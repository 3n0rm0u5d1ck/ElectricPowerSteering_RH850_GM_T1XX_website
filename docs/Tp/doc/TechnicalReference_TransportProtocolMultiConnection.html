---
layout: default
title: TechnicalReference_TransportProtocolMultiConnection
nav_order: 1
parent: Transport Protocol
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>1 / 177 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Transport Protocol ISO15765-2 </b></p>
<p>Technical Reference </p>
<p> </p>
<p>Single/Multiple Connection </p>
<p>Version 3.14.00 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Authors </p>
<p>Oliver </p>
<p>Garnatz, </p>
<p>Andreas </p>
<p>Pick, </p>
<p>Peter </p>
<p>Herrmann, </p>
<p>Thomas Dedler </p>
<p>Status </p>
<p>Released </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>2 / 177 </p>
<p><b>Document Information </b></p>
<p><b>History </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>Rein </p>
<p>1999-06-22 </p>
<p>1.0 </p>
<p>File created </p>
<p>Baeuerle </p>
<p>1999-11-02 </p>
<p>1.42 </p>
<p>Description of connection </p>
<p>specific timing parameters </p>
<p>added </p>
<p>Ebner </p>
<p>2000-07-17 </p>
<p>1.51 </p>
<p>Single connection version </p>
<p>removed; documents only </p>
<p>contains multiple connection </p>
<p>extensions </p>
<p>Garnatz </p>
<p>2000-09-19 </p>
<p>2.03 </p>
<p>Adaptation to new </p>
<p>MultiConnection TP </p>
<p>Garnatz </p>
<p>2001-02-09 </p>
<p>2.07 </p>
<p>Added new functionality  </p>
<p>Garnatz </p>
<p>2001-05-11 </p>
<p>2.10 </p>
<p>Update new Generation Tool </p>
<p>versions </p>
<p>Garnatz </p>
<p>2001-09-14 </p>
<p>2.17 </p>
<p>General improvement;  </p>
<p>Update to version 2.17 of </p>
<p>tpmc.c module  </p>
<p>Garnatz </p>
<p>2002-01.24 </p>
<p>2.27 </p>
<p>SingleConnection version is </p>
<p>added; Protocol-Overview is </p>
<p>added </p>
<p>Garnatz </p>
<p>2002-06-18 </p>
<p>2.33 </p>
<p>Added restrictions for data </p>
<p>consistency </p>
<p>Pick / Garnatz </p>
<p>2002-10-16 </p>
<p>2.36 </p>
<p>Update: CAN Driver in polling </p>
<p>mode </p>
<p>Added: Fast transmission of </p>
<p>ConsecutiveFrames </p>
<p>Update: Usage of TransmitCF </p>
<p>parameter </p>
<p>Garnatz </p>
<p>2002-11-29 </p>
<p>2.37 </p>
<p>General rework  </p>
<p>Garnatz </p>
<p>2003-01-16 </p>
<p>2.39 </p>
<p>Update: </p>
<p>TpTransmit/CopyToCan/Appl</p>
<p>TpCheckTA </p>
<p>Garnatz </p>
<p>2004-01-13 </p>
<p>2.44 </p>
<p>Update: ApplTpCopyToCAN </p>
<p>Pick </p>
<p>2004-03-01 </p>
<p>2.52 </p>
<p>Update: Mixed 29-bit ID </p>
<p>addressing </p>
<p>TpRxGetCanBuffer </p>
<p>TpRxSetBufferOverrun </p>
<p>TpRxGetAddressExtension </p>
<p>TpTxSetAddressExtension </p>
<p>Pick </p>
<p>2004-05-14 </p>
<p>2.60 </p>
<p>Multiple ECUs example </p>
<p>Restriction on </p>
<p>TpTxStateTask/TpRxStateTas</p>
<p>k </p>
<p>Tx/Rx message buffer </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>3 / 177 </p>
<p>consistency clarification </p>
<p>Return value of </p>
<p>ApplTpPreCopyCheck </p>
<p>Mixed 11-bit ID addressing </p>
<p>TpTransmit() return values </p>
<p>Added TpCanChannelInit() </p>
<p>Added TpRxSetTransmitID() </p>
<p>Changed </p>
<p>TpRxSetBufferOverrun </p>
<p>Changed </p>
<p>ApplTpTxCopyToCAN </p>
<p>Changes in chapter ‘How to </p>
<p>serve Different  </p>
<p>               Connections (only </p>
<p>dynamic channels)’. </p>
<p>Pick </p>
<p>2004-12-01 </p>
<p>2.68 </p>
<p>Added description for GENy </p>
<p>configuration tool </p>
<p>(ESCAN00008734).  </p>
<p>Update of API description </p>
<p>(ESCAN00008314). </p>
<p>Feature list added </p>
<p>(ESCAN00008315). </p>
<p>Prototype parameter </p>
<p>corrected (ESCAN00009965) </p>
<p> </p>
<p>Pick </p>
<p>2005-04-07 </p>
<p>2.72.00 </p>
<p>Added description for multiple </p>
<p>addressing systems. </p>
<p>C++ access to TPMC. </p>
<p>Pick </p>
<p>2005-07-14 </p>
<p>2.73.00 </p>
<p>Added description for GENy </p>
<p>configuration </p>
<p>Herrmann </p>
<p>2005-07-19 </p>
<p>2.73.00 </p>
<p>Added new API functions: </p>
<p>TpRxSetWaitCorrectSN, </p>
<p>TpTxSetStrictFlowControlChe</p>
<p>ck </p>
<p>Herrmann </p>
<p>2005-08-11 </p>
<p>2.73.00 </p>
<p>Added new API functions: </p>
<p>TpRxSetTimeoutConfirmation</p>
<p>,  </p>
<p>TpTxSetTimeoutConfirmation, </p>
<p>TpRxSetTimeoutCF, </p>
<p>TpTxSetTimeoutCF   </p>
<p>Garnatz </p>
<p>2006-01-13 </p>
<p>2.80.00 </p>
<p>Added deviation to ISO </p>
<p>15765-2  </p>
<p>Herrmann </p>
<p>2006-02-08 </p>
<p>2.82.00 </p>
<p>ISO 15765-2 deviations </p>
<p>elaborated </p>
<p>Herrmann </p>
<p>2006-03-03 </p>
<p>2.86.00 </p>
<p>Cleanup (ESCAN15514) </p>
<p>Herrmann </p>
<p>2006-03-23 </p>
<p>2.86.00 </p>
<p>ISO 15765-2 deviations </p>
<p>elaborated </p>
<p>Herrmann </p>
<p>2006-04-11 </p>
<p>2.87.00 </p>
<p>General rework after review </p>
<p>Herrmann </p>
<p>2006-07-03 </p>
<p>2.89.00 </p>
<p>Added WaitFrame handling. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>4 / 177 </p>
<p>Herrmann </p>
<p>2007-02-01 </p>
<p>2.90.00 </p>
<p>Added OEM feature </p>
<p>TP_ENABLE_STRICT_DL_C</p>
<p>HECK  </p>
<p>Herrmann </p>
<p>2007-02-23 </p>
<p>2.91.00 </p>
<p>Added feature </p>
<p>TP_DISABLE_MF_RECEPTI</p>
<p>ON </p>
<p>Herrmann </p>
<p>2007-03-14 </p>
<p>2.92.00 </p>
<p>Added ApplFuncTpPrecopy </p>
<p>callback description and </p>
<p>reduced TpRxResetChannel </p>
<p>API usage to indication point </p>
<p>in time or after. </p>
<p>Herrmann </p>
<p>2007-09-20 </p>
<p>2.93.00 </p>
<p>Completed Multiple ECU </p>
<p>description (see chapter </p>
<p>7.3.1). Added TpRxGet-</p>
<p>AddressingFormat / </p>
<p>AssignedDestination </p>
<p>description. </p>
<p>                                                    VERSION 3.xx  </p>
<p>Herrmann </p>
<p>2007-10-15 </p>
<p>3.00.00 </p>
<p>Added description for new </p>
<p>TpClass  </p>
<p>“Dispatched&lt;AddressingType&gt;”  </p>
<p>Herrmann </p>
<p>2007-11-20 </p>
<p>3.01.00 </p>
<p>Cosmetics / Syntax </p>
<p>Herrmann </p>
<p>2008-01-14 </p>
<p>3.02.00 </p>
<p>New API: </p>
<p>TpTxGetTargetAddress </p>
<p>Herrmann </p>
<p>2008-02-12 </p>
<p>3.03.00 </p>
<p>Minor corrections within API </p>
<p>descriptions </p>
<p>(</p>
<p>ApplTpTxErrorIndication, </p>
<p>TpRxGetCanBuffer)</p>
<p> </p>
<p>Herrmann </p>
<p>2008-04-17, </p>
<p> </p>
<p>2008-07-17 </p>
<p>3.04.00 </p>
<p>Added description for </p>
<p>TP_ENBLE_DYN_CHANNEL_TIM</p>
<p>ING. </p>
<p>Added description for the usage </p>
<p>of extended identifiers for </p>
<p>normal addressing as well at </p>
<p>configuration time as also </p>
<p>dynamically at runtime </p>
<p>(TP_USE_EXT_IDS_FOR_NO</p>
<p>RMAL). </p>
<p>Herrmann </p>
<p>2008-12-10 </p>
<p>3.05.00 </p>
<p>Added description for </p>
<p>GenMsgDelay attribute in </p>
<p>chapter 3.4.1 </p>
<p>Herrmann </p>
<p>2009-01-25 </p>
<p>3.07.00 </p>
<p>Adapted version number to </p>
<p>ALM package number (3.06.00 </p>
<p>skipped) </p>
<p>Herrmann </p>
<p>2009-11-25 </p>
<p>3.08.00 </p>
<p>Added description for reception </p>
<p>and transmission without flow </p>
<p>control frames for dyn. </p>
<p>(TpRxWithoutFC, </p>
<p>TpTxWithoutFC) and static </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>5 / 177 </p>
<p>(TpTxFlowControl, </p>
<p>TpRxFlowControl </p>
<p>) Tp classes. </p>
<p>Herrmann </p>
<p>2010-01-12 </p>
<p>3.09.00 </p>
<p>Enhanced description for DLC </p>
<p>checks on the Rx side (see </p>
<p>2.4.2.5). </p>
<p>Added API functions for 29-Bit </p>
<p>ext. Id dynamic handling. </p>
<p>Heil </p>
<p>2010-11-08 </p>
<p>3.10.00 </p>
<p>Added more flexibility for DLC </p>
<p>checks on the Rx side (see </p>
<p>2.4.2.5) </p>
<p>Herrmann </p>
<p>2011-01-19 </p>
<p>3.11.00 </p>
<p>Moved </p>
<p>TP_MEMORY_MODEL_DATA   </p>
<p>from user config file to GENy  </p>
<p>Herrmann </p>
<p>2011-04-05 </p>
<p>3.12 </p>
<p>ESCAN00051019: Added new </p>
<p>(customer specific) pre-compile </p>
<p>switches:  </p>
<p>TP_ENABLE_IGNORE_FC_RE</p>
<p>S_STMIN,  </p>
<p>TP_ENABLE_IGNORE_FC_OV</p>
<p>FL (see 3.2.3). </p>
<p>Herrmann </p>
<p> </p>
<p>Dedler </p>
<p>2011-07-11 </p>
<p> </p>
<p>2011-09-21 </p>
<p>3.13 </p>
<p>ESCAN00051019: Added </p>
<p>support for the dynamic setting </p>
<p>of  29-bit CAN-IDs (see </p>
<p>4.2.2.31, 4.2.2.32, 4.2.3.29, </p>
<p>4.2.3.30). </p>
<p>Added new pre-compile switch:  </p>
<p>TP_USE_UNEXPECTED_FC_</p>
<p>CANCELATION (see 3.2.3). </p>
<p>Dedler </p>
<p>2012-04-10 </p>
<p>3.13.01 </p>
<p>Description of </p>
<p>TpRxGetCanBuffer modified </p>
<p>according to ESCAN00057225 </p>
<p>Dedler </p>
<p>2013-04-30 </p>
<p>3.14.00 </p>
<p>Description for non-standard </p>
<p>flow control handling updated </p>
<p>(3.2.3) </p>
<p><b> </b></p>
<p><b>Reference Documents </b></p>
<p><b>No. </b></p>
<p><b>Title </b></p>
<p>[1] </p>
<p> </p>
<p>/ISO/TF2/:  ISO FDIS 15765-2; Road vehicles — Diagnostics on CAN — Part 2: Network </p>
<p>layer services; </p>
<p>Date 2004-07-16 </p>
<p>[2] </p>
<p> </p>
<p>/OSEK-COM/:  OSEK/VDX Communication Version 2.1, revision 1 17th June 1998 </p>
<p>[3] </p>
<p> </p>
<p>/CANDrv/:  Manual for CAN Driver in used version </p>
<p>[4] </p>
<p> </p>
<p>ISO15765-2:  ISO TC 22/SC 3;  ISO 15765-2:2003(E); Road vehicles — Diagnostics on </p>
<p>controller area network (CAN) — Part 2: Part 2: Network layer services </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>6 / 177 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>We have configured the programs in accordance with your specifications in the </p>
<p>questionnaire. Whereas the programs do support other configurations than the one </p>
<p>specified in your questionnaire, Vector´s release of the programs delivered to your </p>
<p>company is expressly restricted to the configuration you have specified in the </p>
<p>questionnaire. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>7 / 177 </p>
<p><b>Contents</b></p>
<p><b> </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>Introduction .................................................................................................................. 15</b></p>
<p> </p>
<p>1.1</p>
<p> </p>
<p>Relation between general component and shipped version capability .................... 15</p>
<p> </p>
<p>1.2</p>
<p> </p>
<p>Name Conventions ................................................................................................. 16</p>
<p> </p>
<p>1.3</p>
<p> </p>
<p>Abbreviations ......................................................................................................... 17</p>
<p> </p>
<p>1.4</p>
<p> </p>
<p>Channel vs. Connection ......................................................................................... 17</p>
<p> </p>
<p>1.5</p>
<p> </p>
<p>TP classes.............................................................................................................. 18</p>
<p> </p>
<p>1.5.1</p>
<p> </p>
<p>SingleTP classes ........................................................................................... 18</p>
<p> </p>
<p>1.5.2</p>
<p> </p>
<p>Static MultiTP classes ................................................................................... 18</p>
<p> </p>
<p>1.5.3</p>
<p> </p>
<p>Dynamic MultiTP classes .............................................................................. 18</p>
<p> </p>
<p>1.5.4</p>
<p> </p>
<p>Dispatched MultiTP classes .......................................................................... 18</p>
<p> </p>
<p>1.6</p>
<p> </p>
<p>SingleConnection vs. MultipleConnection ............................................................... 19</p>
<p> </p>
<p>1.7</p>
<p> </p>
<p>Features ................................................................................................................. 19</p>
<p> </p>
<p>1.7.1</p>
<p> </p>
<p>Feature List ................................................................................................... 19</p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>Architecture Overview ................................................................................................. 23</b></p>
<p> </p>
<p>2.1</p>
<p> </p>
<p>Requirements ......................................................................................................... 23</p>
<p> </p>
<p>2.1.1</p>
<p> </p>
<p>Protocol-Overview ......................................................................................... 23</p>
<p> </p>
<p>2.1.1.1</p>
<p> </p>
<p>Construction of unsegmented messages ................................................ 23</p>
<p> </p>
<p>2.1.1.2</p>
<p> </p>
<p>Construction of segmented messages .................................................... 23</p>
<p> </p>
<p>2.1.2</p>
<p> </p>
<p>Addressing modes ........................................................................................ 24</p>
<p> </p>
<p>2.1.2.1</p>
<p> </p>
<p>Normal Addressing ................................................................................. 25</p>
<p> </p>
<p>2.1.2.2</p>
<p> </p>
<p>Mixed 11-bit ID Addressing ..................................................................... 25</p>
<p> </p>
<p>2.1.2.3</p>
<p> </p>
<p>Normal Fixed Addressing ....................................................................... 25</p>
<p> </p>
<p>2.1.2.4</p>
<p> </p>
<p>Extended Addressing.............................................................................. 25</p>
<p> </p>
<p>2.1.2.5</p>
<p> </p>
<p>Mixed 29-bit ID Addressing ..................................................................... 26</p>
<p> </p>
<p>2.1.2.6</p>
<p> </p>
<p>Structure of TPCI-Byte ........................................................................... 26</p>
<p> </p>
<p>2.2</p>
<p> </p>
<p>Transmission .......................................................................................................... 28</p>
<p> </p>
<p>2.3</p>
<p> </p>
<p>Reception ............................................................................................................... 29</p>
<p> </p>
<p>2.4</p>
<p> </p>
<p>Working behaviors .................................................................................................. 30</p>
<p> </p>
<p>2.4.1</p>
<p> </p>
<p>Timings ......................................................................................................... 30</p>
<p> </p>
<p>2.4.2</p>
<p> </p>
<p>Error detection............................................................................................... 31</p>
<p> </p>
<p>2.4.2.1</p>
<p> </p>
<p>Reception of a SingleFrame ................................................................... 31</p>
<p> </p>
<p>2.4.2.2</p>
<p> </p>
<p>Reception of a FirstFrame ...................................................................... 31</p>
<p> </p>
<p>2.4.2.3</p>
<p> </p>
<p>Reception of a FlowControl .................................................................... 31</p>
<p> </p>
<p>2.4.2.4</p>
<p> </p>
<p>Reception of a ConsecutiveFrame.......................................................... 32</p>
<p> </p>
<p>2.4.2.5</p>
<p> </p>
<p>Observing CAN frame DLC (Data Length Code) .................................... 32</p>
<p> </p>
<p>2.4.3</p>
<p> </p>
<p>Buffer consistency ......................................................................................... 33</p>
<p> </p>
<p>2.4.4</p>
<p> </p>
<p>Function re-entrancy ..................................................................................... 33</p>
<p> </p>
<p>2.5</p>
<p> </p>
<p>Restriction .............................................................................................................. 34</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>8 / 177 </p>
<p>2.5.1</p>
<p> </p>
<p>Restrictions to ISO/TF2 specification ............................................................. 34</p>
<p> </p>
<p>2.5.2</p>
<p> </p>
<p>Limitations of Transport Protocol Implementation .......................................... 34</p>
<p> </p>
<p>2.5.3</p>
<p> </p>
<p>Deviations to ISO/TF2 specification ............................................................... 37</p>
<p> </p>
<p>2.5.3.1</p>
<p> </p>
<p>Handling of unexpected FlowControl / ConsecutiveFrame frames .......... 37</p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Settings for the MultiTP &amp; SingleTP (multi-based) .................................................... 38</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>General settings with CANgen / DBKOMgen / GENy ............................................. 38</p>
<p> </p>
<p>3.1.1</p>
<p> </p>
<p>Timing ........................................................................................................... 39</p>
<p> </p>
<p>3.1.1.1</p>
<p> </p>
<p>Transmission timing ................................................................................ 39</p>
<p> </p>
<p>3.1.1.2</p>
<p> </p>
<p>Reception timing ..................................................................................... 39</p>
<p> </p>
<p>3.1.1.3</p>
<p> </p>
<p>Common timing ...................................................................................... 40</p>
<p> </p>
<p>3.1.2</p>
<p> </p>
<p>Flow Control .................................................................................................. 40</p>
<p> </p>
<p>3.1.2.1</p>
<p> </p>
<p>Transmission .......................................................................................... 40</p>
<p> </p>
<p>3.1.2.2</p>
<p> </p>
<p>Reception ............................................................................................... 40</p>
<p> </p>
<p>3.1.3</p>
<p> </p>
<p>Misc .............................................................................................................. 41</p>
<p> </p>
<p>3.2</p>
<p> </p>
<p>General settings with Generation Tool GENy .......................................................... 43</p>
<p> </p>
<p>3.2.1</p>
<p> </p>
<p>Configuration of Addressing Information ........................................................ 44</p>
<p> </p>
<p>3.2.2</p>
<p> </p>
<p>Usage of Far RAM buffers ............................................................................. 44</p>
<p> </p>
<p>3.2.3</p>
<p> </p>
<p>Non standard handling of Flow Control frames .............................................. 44</p>
<p> </p>
<p>3.2.3.1</p>
<p> </p>
<p>Reserved STmin Handling ...................................................................... 44</p>
<p> </p>
<p>3.2.3.2</p>
<p> </p>
<p>Ignore Flow Control Overflow ................................................................. 45</p>
<p> </p>
<p>3.2.3.3</p>
<p> </p>
<p>Do not ignore unexpected Flow Control frames ...................................... 45</p>
<p> </p>
<p>3.2.3.4</p>
<p> </p>
<p>Use STmin of FC .................................................................................... 45</p>
<p> </p>
<p>3.2.3.5</p>
<p> </p>
<p>Analyze first FC only .............................................................................. 45</p>
<p> </p>
<p>3.3</p>
<p> </p>
<p>Additional settings via user-configuration file .......................................................... 45</p>
<p> </p>
<p>3.3.1</p>
<p> </p>
<p>Dynamic Timing API ...................................................................................... 45</p>
<p> </p>
<p>3.4</p>
<p> </p>
<p>TP classes: SingleTP (multi-based) ........................................................................ 46</p>
<p> </p>
<p>3.4.1</p>
<p> </p>
<p>Database Attributes ....................................................................................... 46</p>
<p> </p>
<p>3.4.2</p>
<p> </p>
<p>TP class SingleTP (multi-based): Normal Addressing .................................... 47</p>
<p> </p>
<p>3.4.3</p>
<p> </p>
<p>TP class SingleTP (multi-based): Extended Addressing ................................ 47</p>
<p> </p>
<p>3.4.4</p>
<p> </p>
<p>TP class SingleTP (multi-based):Normal Fixed Addressing ........................... 47</p>
<p> </p>
<p>3.4.4.1</p>
<p> </p>
<p>Database Attributes ................................................................................ 47</p>
<p> </p>
<p>3.5</p>
<p> </p>
<p>TP classes Static MultiTP ....................................................................................... 47</p>
<p> </p>
<p>3.5.1</p>
<p> </p>
<p>Database Attributes ....................................................................................... 47</p>
<p> </p>
<p>3.5.2</p>
<p> </p>
<p>TP class specific settings .............................................................................. 48</p>
<p> </p>
<p>3.5.3</p>
<p> </p>
<p>Connection specific timing parameters .......................................................... 48</p>
<p> </p>
<p>3.5.4</p>
<p> </p>
<p>Functions ...................................................................................................... 49</p>
<p> </p>
<p>3.6</p>
<p> </p>
<p>TP classes Dynamic MultiTP .................................................................................. 49</p>
<p> </p>
<p>3.6.1</p>
<p> </p>
<p>Properties ...................................................................................................... 49</p>
<p> </p>
<p>3.6.2</p>
<p> </p>
<p>Hook Functions ............................................................................................. 50</p>
<p> </p>
<p>3.6.3</p>
<p> </p>
<p>Dynamic Objects ........................................................................................... 50</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>9 / 177 </p>
<p>3.6.4</p>
<p> </p>
<p>TP class Dynamic MultiTP: Normal Addressing ............................................. 51</p>
<p> </p>
<p>3.6.4.1</p>
<p> </p>
<p>CANdriver settings ................................................................................. 51</p>
<p> </p>
<p>3.6.5</p>
<p> </p>
<p>TP class Dynamic MultiTP: Extended Addressing ......................................... 51</p>
<p> </p>
<p>3.6.5.1</p>
<p> </p>
<p>TP class specific settings........................................................................ 51</p>
<p> </p>
<p>3.6.5.2</p>
<p> </p>
<p>Database Attributes ................................................................................ 52</p>
<p> </p>
<p>3.6.5.3</p>
<p> </p>
<p>Multiple Base Addresses ........................................................................ 52</p>
<p> </p>
<p>3.6.6</p>
<p> </p>
<p>TP class Dynamic MultiTP: Normal Fixed Addressing ................................... 52</p>
<p> </p>
<p>3.6.6.1</p>
<p> </p>
<p>Database Attributes ................................................................................ 52</p>
<p> </p>
<p>3.6.7</p>
<p> </p>
<p>TP class Dynamic MultiTP: Mixed 29-bit Addressing ..................................... 53</p>
<p> </p>
<p>3.6.8</p>
<p> </p>
<p>TP class Dynamic MultiTP: Multiple Addressing ............................................ 53</p>
<p> </p>
<p>3.6.8.1</p>
<p> </p>
<p>Addressing mode ................................................................................... 53</p>
<p> </p>
<p>3.6.8.2</p>
<p> </p>
<p>CAN Driver settings ................................................................................ 53</p>
<p> </p>
<p>3.7</p>
<p> </p>
<p>TP class Dispatched MultiTP .................................................................................. 55</p>
<p> </p>
<p>3.7.1</p>
<p> </p>
<p>“Dynamic MultiTP” versus “Dispatched MultiTP” – a short analogy ............... 56</p>
<p> </p>
<p>3.7.1.1</p>
<p> </p>
<p>Solution based on “Dynamic MultiTP”: .................................................... 56</p>
<p> </p>
<p>3.7.1.2</p>
<p> </p>
<p>Solution based on “Dispatched MultiTP” ................................................. 57</p>
<p> </p>
<p>3.7.2</p>
<p> </p>
<p>Dispatched MultiTP API ................................................................................. 60</p>
<p> </p>
<p>3.7.2.1</p>
<p> </p>
<p>Reception side........................................................................................ 60</p>
<p> </p>
<p>3.7.2.2</p>
<p> </p>
<p>Transmission side ................................................................................... 61</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>API ................................................................................................................................. 63</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Use of ISO15765-Transport Protocol ...................................................................... 63</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Functions of the Transport Protocol ........................................................................ 63</p>
<p> </p>
<p>4.2.1</p>
<p> </p>
<p>Administrative Functions ............................................................................... 64</p>
<p> </p>
<p>4.2.1.1</p>
<p> </p>
<p>TpInitPowerOn: Initialization ................................................................... 64</p>
<p> </p>
<p>4.2.1.2</p>
<p> </p>
<p>TpInit: Re-initialization ............................................................................ 65</p>
<p> </p>
<p>4.2.1.3</p>
<p> </p>
<p>TpTask:  Observing timing conditions ..................................................... 65</p>
<p> </p>
<p>4.2.1.4</p>
<p> </p>
<p>TpCanChannelInit: CAN channel specifiic re-initialization ....................... 66</p>
<p> </p>
<p>4.2.1.5</p>
<p> </p>
<p>TpRxTask: time base for reception timeouts ........................................... 67</p>
<p> </p>
<p>4.2.1.6</p>
<p> </p>
<p>TpTxTask: time base for timeouts/transmission ...................................... 68</p>
<p> </p>
<p>4.2.1.7</p>
<p> </p>
<p>TpRxStateTask: optional transmission retry ............................................ 69</p>
<p> </p>
<p>4.2.1.8</p>
<p> </p>
<p>TpRxAllStateTask: optional transmission retry ........................................ 69</p>
<p> </p>
<p>4.2.1.9</p>
<p> </p>
<p>TpTxStateTask: optional transmission retry ............................................ 70</p>
<p> </p>
<p>4.2.1.10</p>
<p> </p>
<p>TpTxAllStateTask: optional transmission retry ........................................ 71</p>
<p> </p>
<p>4.2.2</p>
<p> </p>
<p>Receive Functions ......................................................................................... 72</p>
<p> </p>
<p>4.2.2.1</p>
<p> </p>
<p>TpRxSetConnectionNumber: Assign a Connection-Number to a </p>
<p>channel .................................................................................................. 72</p>
<p> </p>
<p>4.2.2.2</p>
<p> </p>
<p>TpRxGetConnectionNumber: Get the Corresponding Connection-</p>
<p>Number .................................................................................................. 72</p>
<p> </p>
<p>4.2.2.3</p>
<p> </p>
<p>TpRxGetAddressingFormat:  Get the current addressing type ................ 73</p>
<p> </p>
<p>4.2.2.4</p>
<p> </p>
<p>TpRxGetAssignedDestination:  Get the currently assigned destination .. 74</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>10 / 177 </p>
<p>4.2.2.5</p>
<p> </p>
<p>TpRxResetChannel: Free Rx-TpChannel ............................................... 75</p>
<p> </p>
<p>4.2.2.6</p>
<p> </p>
<p>TpRxGetStatus: Rx-Channel Status ....................................................... 76</p>
<p> </p>
<p>4.2.2.7</p>
<p> </p>
<p>TpRxSetBS: Setting up BlockSize on Reception Side ............................ 77</p>
<p> </p>
<p>4.2.2.8</p>
<p> </p>
<p>TpRxGetBS: Get BlockSize on Reception Side ...................................... 78</p>
<p> </p>
<p>4.2.2.9</p>
<p> </p>
<p>TpRxSetSTMIN: Setting up STMin time on Reception Side .................... 78</p>
<p> </p>
<p>4.2.2.10</p>
<p> </p>
<p>TpRxGetSTMIN: Get STMin time on Reception Side.............................. 79</p>
<p> </p>
<p>4.2.2.11</p>
<p> </p>
<p>TpRxGetChannelID: Get Received CAN-Id ............................................ 80</p>
<p> </p>
<p>4.2.2.12</p>
<p> </p>
<p>TpRxGetChannelExtID: Get Received Extended CAN-Id ....................... 81</p>
<p> </p>
<p>4.2.2.13</p>
<p> </p>
<p>TpRxGetCanChannel: Get physical CAN channel .................................. 81</p>
<p> </p>
<p>4.2.2.14</p>
<p> </p>
<p>TpRxGetSourceAddress: Get received Source Address ......................... 82</p>
<p> </p>
<p>4.2.2.15</p>
<p> </p>
<p>TpRxGetReceivedTargetAddress: Get received Target Address ............. 83</p>
<p> </p>
<p>4.2.2.16</p>
<p> </p>
<p>TpRxGetEcuNumber: Get ECU Number................................................. 84</p>
<p> </p>
<p>4.2.2.17</p>
<p> </p>
<p>TpRxGetParameterGroupIdentification: Get Identification of PGN .......... 84</p>
<p> </p>
<p>4.2.2.18</p>
<p> </p>
<p>TpRxSetBufferOverrun:   Enable partial acceptance............................... 85</p>
<p> </p>
<p>4.2.2.19</p>
<p> </p>
<p>TpRxSetTransmitID:   Set transmission CAN-Id...................................... 86</p>
<p> </p>
<p>4.2.2.20</p>
<p> </p>
<p>TpRxSetTransmitExtID:   Set transmission Extended CAN-Id................. 87</p>
<p> </p>
<p>4.2.2.21</p>
<p> </p>
<p>TpRxGetChannelIDType:   Get the type of the received CAN-Id ............. 88</p>
<p> </p>
<p>4.2.2.22</p>
<p> </p>
<p>TpRxGetAddressExtension:  Get address extension information ............ 88</p>
<p> </p>
<p>4.2.2.23</p>
<p> </p>
<p>TpRxGetCanBuffer:  Get CAN buffer pointer .......................................... 89</p>
<p> </p>
<p>4.2.2.24</p>
<p> </p>
<p>TpRxSetWaitCorrectSN:  Force to wait for a correct sequence </p>
<p>number ................................................................................................... 90</p>
<p> </p>
<p>4.2.2.25</p>
<p> </p>
<p>TpRxSetTimeoutConfirmation:  Set CAN confirmation timeout ............... 91</p>
<p> </p>
<p>4.2.2.26</p>
<p> </p>
<p>TpRxSetTimeoutCF:  Set Consecutive Frame confirmation timeout ....... 92</p>
<p> </p>
<p>4.2.2.27</p>
<p> </p>
<p>TpRxSetFCStatus:  set up Flow Control on reception side ..................... 92</p>
<p> </p>
<p>4.2.2.28</p>
<p> </p>
<p>TpRxGetFCStatus:  get the Flow Control setup on reception side .......... 93</p>
<p> </p>
<p>4.2.2.29</p>
<p> </p>
<p>TpRxSetClearToSend:  proceed with the transmission after FC wait </p>
<p>frames .................................................................................................... 94</p>
<p> </p>
<p>4.2.2.30</p>
<p> </p>
<p>TpRxWithoutFC:  suppress FC frame usage at the Rx side .................... 95</p>
<p> </p>
<p>4.2.2.31</p>
<p> </p>
<p>TpRxSetPGN: Set Parameter Group Number ........................................ 96</p>
<p> </p>
<p>4.2.2.32</p>
<p> </p>
<p>TpRxSetPriorityBits: Set Priority, Data Page and Reserved bits ............. 97</p>
<p> </p>
<p>4.2.3</p>
<p> </p>
<p>Transmit Functions ........................................................................................ 98</p>
<p> </p>
<p>4.2.3.1</p>
<p> </p>
<p>TpTxGetFreeChannel: Assign Channel to Connection ........................... 98</p>
<p> </p>
<p>4.2.3.2</p>
<p> </p>
<p>TpTxGetConnectionNumber: Get the assigned Connection-Number ...... 99</p>
<p> </p>
<p>4.2.3.3</p>
<p> </p>
<p>TpTxGetConnectionStatus: Get the Connection Status .......................... 99</p>
<p> </p>
<p>4.2.3.4</p>
<p> </p>
<p>TpTxGetTargetAddress:  Get the target address used for transmission 100</p>
<p> </p>
<p>4.2.3.5</p>
<p> </p>
<p>TpTxGetDataBuffer: Get the assigned Data Buffer ............................... 101</p>
<p> </p>
<p>4.2.3.6</p>
<p> </p>
<p>TpTxGetDataIndex: Get the assigned Data Index ................................ 102</p>
<p> </p>
<p>4.2.3.7</p>
<p> </p>
<p>TpTxSetChannelID: Set the CAN Transmit Id ....................................... 102</p>
<p> </p>
<p>4.2.3.8</p>
<p> </p>
<p>TpTxSetChannelExtID: Set the CAN Transmit  Extended Id ................. 103</p>
<p> </p>
<p>4.2.3.9</p>
<p> </p>
<p>TpTxSetCanChannel: Set physical CAN Channel ................................ 104</p>
<p> </p>
<p>4.2.3.10</p>
<p> </p>
<p>TpTxSetTargetAddress: Set Target Address ......................................... 105</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>11 / 177 </p>
<p>4.2.3.11</p>
<p> </p>
<p>TpTxSetEcuNumber: Set ECU Number ................................................ 106</p>
<p> </p>
<p>4.2.3.12</p>
<p> </p>
<p>TpTxSetBaseAddress: Set Base Address............................................. 106</p>
<p> </p>
<p>4.2.3.13</p>
<p> </p>
<p>TpTxSetParameterGroupIdentification: Set Identification of PGN ......... 107</p>
<p> </p>
<p>4.2.3.14</p>
<p> </p>
<p>TpTxSetPriority: Set Priority of the CAN-Frame .................................... 108</p>
<p> </p>
<p>4.2.3.15</p>
<p> </p>
<p>TpTxSetResponse: Assemble a Response ........................................... 109</p>
<p> </p>
<p>4.2.3.16</p>
<p> </p>
<p>TpTransmit: Send a Message ............................................................... 110</p>
<p> </p>
<p>4.2.3.17</p>
<p> </p>
<p>TpTxLockChannel:  Lock Channel ......................................................... 111</p>
<p> </p>
<p>4.2.3.18</p>
<p> </p>
<p>TpTxUnlockChannel:  Unlock TX Channel ............................................. 111</p>
<p> </p>
<p>4.2.3.19</p>
<p> </p>
<p>TpTxResetChannel: Free TX-Channel.................................................. 112</p>
<p> </p>
<p>4.2.3.20</p>
<p> </p>
<p>TpTxSetAddressExtension:  Set Address Extension information .......... 113</p>
<p> </p>
<p>4.2.3.21</p>
<p> </p>
<p>TpTxGetSTminInFrame:   Get STmin from FC frame ........................... 114</p>
<p> </p>
<p>4.2.3.22</p>
<p> </p>
<p>TpTxPrepareSendImmediate:   Prepare CF transmission by </p>
<p>application ............................................................................................ 115</p>
<p> </p>
<p>4.2.3.23</p>
<p> </p>
<p>TpTxSendImmediate:   Start CF transmission by application ................ 115</p>
<p> </p>
<p>4.2.3.24</p>
<p> </p>
<p>TpTxSetAddressingFormat:  Store the current addressing type ............ 116</p>
<p> </p>
<p>4.2.3.25</p>
<p> </p>
<p>TpTxSetStrictFlowControl:  Enable/Disable ISO conformant FC </p>
<p>handling ............................................................................................... 117</p>
<p> </p>
<p>4.2.3.26</p>
<p> </p>
<p>TpTxSetTimeoutConfirmation:  Set the CAN confirmation timeout ........ 118</p>
<p> </p>
<p>4.2.3.27</p>
<p> </p>
<p>TpTxSetTimeoutFC:  Set the FC confirmation timeout .......................... 119</p>
<p> </p>
<p>4.2.3.28</p>
<p> </p>
<p>TpTxWithoutFC:  suppress FC frame usage at the Tx side ................... 120</p>
<p> </p>
<p>4.2.3.29</p>
<p> </p>
<p>TpTxSetPGN: Set Parameter Group Number ....................................... 121</p>
<p> </p>
<p>4.2.3.30</p>
<p> </p>
<p>TpTxSetPriorityBits: Set Priority, Data Page and Reserved bits ............ 122</p>
<p> </p>
<p>4.3</p>
<p> </p>
<p>Dispatched Multi TP class API .............................................................................. 123</p>
<p> </p>
<p>4.3.1</p>
<p> </p>
<p>TpGetConnectionGroup:  Get the connection group identification ............... 123</p>
<p> </p>
<p>4.3.2</p>
<p> </p>
<p>TpGetAddressingType:  Get the addressing type identification .................... 124</p>
<p> </p>
<p>4.3.3</p>
<p> </p>
<p>TpGetCanChannel:  Get the CAN channel .................................................. 125</p>
<p> </p>
<p>4.3.4</p>
<p> </p>
<p>TpGetRxId:  Get the received CAN-Id ......................................................... 126</p>
<p> </p>
<p>4.3.5</p>
<p> </p>
<p>TpGetTxId:  Get the CAN-Id to be used for transmission ............................. 126</p>
<p> </p>
<p>4.3.6</p>
<p> </p>
<p>TpGetBaseAddress:  Get the Base Address ................................................ 127</p>
<p> </p>
<p>4.3.7</p>
<p> </p>
<p>TpGetAddressOffest:  Get the Address Offset ............................................. 128</p>
<p> </p>
<p>4.3.8</p>
<p> </p>
<p>TpGetPriority:  Get the priority info from a 29 bit CAN-Id ............................. 129</p>
<p> </p>
<p>4.3.9</p>
<p> </p>
<p>TpGetPGN:  Get the parameter group identification from a 29 bit CAN-Id ... 129</p>
<p> </p>
<p>4.3.10</p>
<p> </p>
<p>TpGetEcuNumber:  Get the ECU number ................................................... 130</p>
<p> </p>
<p>4.3.11</p>
<p> </p>
<p>TpTransmit .................................................................................................. 131</p>
<p> </p>
<p>4.3.11.1</p>
<p> </p>
<p>TpTransmit connection specific macros ................................................ 131</p>
<p> </p>
<p>4.3.11.2</p>
<p> </p>
<p>TpTransmitNormal:  transmit function for normal addressing ................ 131</p>
<p> </p>
<p>4.3.11.3</p>
<p> </p>
<p>TpTransmitExtended:  transmit function for extended addressing ......... 132</p>
<p> </p>
<p>4.3.11.4</p>
<p> </p>
<p>TpTransmitNormalFixed:  transmit function for NormalFixed </p>
<p>addressing ............................................................................................ 133</p>
<p> </p>
<p>4.3.11.5</p>
<p> </p>
<p>TpTransmitMixed29:  transmit function for Mixed-29 addressing .......... 134</p>
<p> </p>
<p>4.3.11.6</p>
<p> </p>
<p>TpTransmitMixed29:  transmit function for Mixed-29 addressing .......... 135</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>12 / 177 </p>
<p>4.3.11.7</p>
<p> </p>
<p>TpTransmitMixed11:  transmit function for Mixed-11 addressing ........... 136</p>
<p> </p>
<p>4.4</p>
<p> </p>
<p>Application callback functions ............................................................................... 137</p>
<p> </p>
<p>4.4.1</p>
<p> </p>
<p>Reception side ............................................................................................ 137</p>
<p> </p>
<p>4.4.1.1</p>
<p> </p>
<p>ApplTpPrecopyCheck: Reception of TP-Frame .................................... 137</p>
<p> </p>
<p>4.4.1.2</p>
<p> </p>
<p>ApplTpCheckTA:  Check if Target Address is valid (version &lt;= </p>
<p>2.72.00) ................................................................................................ 139</p>
<p> </p>
<p>4.4.1.3</p>
<p> </p>
<p>ApplTpCheckTA:  Check if Target Address is valid (since version </p>
<p>2.73.00) ................................................................................................ 140</p>
<p> </p>
<p>4.4.1.4</p>
<p> </p>
<p>ApplTpRxSF:   Reception of Single Frame ........................................... 141</p>
<p> </p>
<p>4.4.1.5</p>
<p> </p>
<p>ApplTpRxFF:   Reception of First Frame .............................................. 142</p>
<p> </p>
<p>4.4.1.6</p>
<p> </p>
<p>ApplTpRxCF:   Reception of Consecutive Frame ................................. 142</p>
<p> </p>
<p>4.4.1.7</p>
<p> </p>
<p>ApplTpRxCanMessageReceived:   Reception of CAN-Frame .............. 143</p>
<p> </p>
<p>4.4.1.8</p>
<p> </p>
<p>ApplTpRxGetBuffer:   Assign a buffer to a channel ............................... 144</p>
<p> </p>
<p>4.4.1.9</p>
<p> </p>
<p>ApplTpRxCopyFromCAN:   Application Copy Function ......................... 145</p>
<p> </p>
<p>4.4.1.10</p>
<p> </p>
<p>ApplTpRxIndication:   Reception closed  successful ............................. 146</p>
<p> </p>
<p>4.4.1.11</p>
<p> </p>
<p>ApplTpRxErrorIndication:   Reception closed with error ........................ 147</p>
<p> </p>
<p>4.4.1.12</p>
<p> </p>
<p>ApplTpRxGetTxID:  Get CAN Transmit Id ............................................. 148</p>
<p> </p>
<p>4.4.2</p>
<p> </p>
<p>Reception side for functional messages ...................................................... 149</p>
<p> </p>
<p>4.4.2.1</p>
<p> </p>
<p>ApplFuncTpPrecopy:  Check if Target Address is valid ......................... 149</p>
<p> </p>
<p>4.4.3</p>
<p> </p>
<p>Transmission side ....................................................................................... 150</p>
<p> </p>
<p>4.4.3.1</p>
<p> </p>
<p>ApplTpTxFC:   Reception of a Flow Control Frame .............................. 150</p>
<p> </p>
<p>4.4.3.2</p>
<p> </p>
<p>ApplTpTxCanMessageTransmitted:  CAN-Message transmitted .......... 151</p>
<p> </p>
<p>4.4.3.3</p>
<p> </p>
<p>ApplTpTxNotification:   CAN-Frame transmitted ................................... 151</p>
<p> </p>
<p>4.4.3.4</p>
<p> </p>
<p>ApplTpTxCopyToCAN:   Application Copy Function (</p>
<p>16BIT </p>
<p>Controller) ............................................................................................ 152</p>
<p> </p>
<p>4.4.3.5</p>
<p> </p>
<p>ApplTpTxCopyToCAN:   Application Copy Function (8BIT Controller) ... 153</p>
<p> </p>
<p>4.4.3.6</p>
<p> </p>
<p>ApplTpTxConfirmation:  Transmission closed successful ..................... 155</p>
<p> </p>
<p>4.4.3.7</p>
<p> </p>
<p>ApplTpTxErrorIndication:  Transmission closed with error .................... 156</p>
<p> </p>
<p>4.4.4</p>
<p> </p>
<p>Administrative Functions ............................................................................. 157</p>
<p> </p>
<p>4.4.4.1</p>
<p> </p>
<p>ApplTpFatalError: Fatal Error ............................................................... 157</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>Transmission Attributes &amp; Callback functions ......................................................... 159</b></p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b>Integration of CANbedded Components into a Customer Project .......................... 160</b></p>
<p> </p>
<p>6.1</p>
<p> </p>
<p>Requirements to the Customer System Environment ........................................... 160</p>
<p> </p>
<p>6.2</p>
<p> </p>
<p>Component Integration to the Customer Project ................................................... 160</p>
<p> </p>
<p>6.2.1</p>
<p> </p>
<p>Requirements to the Component Initialization in a Customer Project .......... 160</p>
<p> </p>
<p>6.2.2</p>
<p> </p>
<p>Requirements to Component API Usage in a Customer Project .................. 161</p>
<p> </p>
<p>6.2.3</p>
<p> </p>
<p>Requirements to the Customer Project Operating System .......................... 161</p>
<p> </p>
<p>6.2.3.1</p>
<p> </p>
<p>Common Requirements ........................................................................ 161</p>
<p> </p>
<p>6.2.3.2</p>
<p> </p>
<p>Round-Robin-Scheduler and Comparable OS Approaches .................. 162</p>
<p> </p>
<p>6.2.3.3</p>
<p> </p>
<p>Usage of OSEK/OS .............................................................................. 162</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>13 / 177 </p>
<p>6.2.3.4</p>
<p> </p>
<p>Non-Preemptive Operating System ...................................................... 163</p>
<p> </p>
<p>6.2.3.5</p>
<p> </p>
<p>Preemptive Operating System .............................................................. 163</p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>Advanced usage ......................................................................................................... 164</b></p>
<p> </p>
<p>7.1</p>
<p> </p>
<p>Separation of TimerTask and TransmissionTask (StateTask) ................................ 164</p>
<p> </p>
<p>7.2</p>
<p> </p>
<p>Fast transmission of ConsecutiveFrames ............................................................. 164</p>
<p> </p>
<p>7.2.1</p>
<p> </p>
<p>Usage ......................................................................................................... 165</p>
<p> </p>
<p>7.2.2</p>
<p> </p>
<p>Application example .................................................................................... 165</p>
<p> </p>
<p>7.3</p>
<p> </p>
<p>Normal Fixed Addressing ..................................................................................... 166</p>
<p> </p>
<p>7.3.1</p>
<p> </p>
<p>Multiple ECU’s ............................................................................................. 166</p>
<p> </p>
<p>7.3.1.1</p>
<p> </p>
<p>Using the CANgen configuration tool .................................................... 166</p>
<p> </p>
<p>7.3.1.2</p>
<p> </p>
<p>Using the GENy configuration tool ........................................................ 167</p>
<p> </p>
<p>7.4</p>
<p> </p>
<p>Extended- and Normal Fixed Addressing ............................................................. 168</p>
<p> </p>
<p>7.4.1</p>
<p> </p>
<p>Virtual ECU’s / ‘Multiple EcuNumber’ feature ............................................... 168</p>
<p> </p>
<p>7.5</p>
<p> </p>
<p>Using different CAN-Identifiers ............................................................................. 169</p>
<p> </p>
<p>7.5.1</p>
<p> </p>
<p>Statically configured CAN-Ids ...................................................................... 169</p>
<p> </p>
<p>7.5.2</p>
<p> </p>
<p>Dynamically configured CAN-Ids ................................................................. 169</p>
<p> </p>
<p>7.5.3</p>
<p> </p>
<p>Additional API functions ............................................................................... 169</p>
<p> </p>
<p>7.6</p>
<p> </p>
<p>Transmissions without Flow Control frames ......................................................... 170</p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>Example for the user .................................................................................................. 171</b></p>
<p> </p>
<p>8.1</p>
<p> </p>
<p>Administrative usage ............................................................................................ 171</p>
<p> </p>
<p>8.2</p>
<p> </p>
<p>How to Transmit a Tp-Frame? .............................................................................. 171</p>
<p> </p>
<p>8.2.1</p>
<p> </p>
<p>Static Normal Addressing ............................................................................ 171</p>
<p> </p>
<p>8.2.2</p>
<p> </p>
<p>Dynamic Addressing ................................................................................... 171</p>
<p> </p>
<p>8.3</p>
<p> </p>
<p>How to Receive a Tp-Frame ................................................................................. 172</p>
<p> </p>
<p>8.4</p>
<p> </p>
<p>How to Send a Response on a Received Transport-Frame .................................. 172</p>
<p> </p>
<p>8.5</p>
<p> </p>
<p>How to serve Different Connections (only dynamic channels) .............................. 173</p>
<p> </p>
<p>8.5.1</p>
<p> </p>
<p>How to serve the diagnostic connection ...................................................... 173</p>
<p> </p>
<p>8.6</p>
<p> </p>
<p>How to Lock a Tx-Channel and Why? (only dynamic channels) ........................... 175</p>
<p> </p>
<p>8.7</p>
<p> </p>
<p>How to transmit a ConsecutiveFrame as quick as possible .................................. 176</p>
<p> </p>
<p><b>9</b></p>
<p> </p>
<p><b>Contact........................................................................................................................ 177</b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>14 / 177 </p>
<p><b>Illustrations </b></p>
<p>Figure 1-1</p>
<p> </p>
<p>SingleConnection vs. MultipleConnection ................................................. 19</p>
<p> </p>
<p>Figure 2-1</p>
<p> </p>
<p>Example of unsegmented message .......................................................... 23</p>
<p> </p>
<p>Figure 2-2</p>
<p> </p>
<p>Construction of segmented message ........................................................ 24</p>
<p> </p>
<p>Figure 2-3</p>
<p> </p>
<p>Transmission Architecture ......................................................................... 28</p>
<p> </p>
<p>Figure 2-4</p>
<p> </p>
<p>Reception Architecture .............................................................................. 29</p>
<p> </p>
<p>Figure 2-5</p>
<p> </p>
<p>Transmission timings. ............................................................................... 30</p>
<p> </p>
<p>Figure 2-6</p>
<p> </p>
<p>Single Frame TPCI ................................................................................... 31</p>
<p> </p>
<p>Figure 2-7</p>
<p> </p>
<p>First Frame TPCI ...................................................................................... 31</p>
<p> </p>
<p>Figure 2-8</p>
<p> </p>
<p>FlowFrameTPCI ....................................................................................... 31</p>
<p> </p>
<p>Figure 2-9</p>
<p> </p>
<p>Consecutive Frame TPCI .......................................................................... 32</p>
<p> </p>
<p>Figure 2-10</p>
<p> </p>
<p>Accumulation of events during CAN Driver polling .................................... 35</p>
<p> </p>
<p>Figure 3-1</p>
<p> </p>
<p>General settings in Generation Tools ........................................................ 38</p>
<p> </p>
<p>Figure 3-2</p>
<p> </p>
<p>Timing settings in Generation Tools .......................................................... 39</p>
<p> </p>
<p>Figure 3-3</p>
<p> </p>
<p>Flow control settings in Generation Tools .................................................. 40</p>
<p> </p>
<p>Figure 3-4</p>
<p> </p>
<p>Misc. settings in Generation Tools ............................................................ 41</p>
<p> </p>
<p>Figure 3-5</p>
<p> </p>
<p>Main window of component TPMC within configuration tool GENy. ........... 43</p>
<p> </p>
<p>Figure 3-6</p>
<p> </p>
<p>Main window of component TPMC within configuration tool GENy. ........... 44</p>
<p> </p>
<p>Figure 3-7</p>
<p> </p>
<p>Database Attributes for Single/Static TP classes ....................................... 46</p>
<p> </p>
<p>Figure 3-8</p>
<p> </p>
<p>Additional TP settings (Static MultiTP) in Generation Tool......................... 48</p>
<p> </p>
<p>Figure 3-9</p>
<p> </p>
<p>Connection specific timing parameters ..................................................... 48</p>
<p> </p>
<p>Figure 3-10</p>
<p> </p>
<p>Hook-Functions (Static MultiTP) ............................................................... 49</p>
<p> </p>
<p>Figure 3-11</p>
<p> </p>
<p>Mandatory functions for the usage of the CANdesc diagnostic </p>
<p>component ................................................................................................ 50</p>
<p> </p>
<p>Figure 3-12</p>
<p> </p>
<p>Optional functions (example for the usage of the CANdesc diagnostic </p>
<p>component) .............................................................................................. 50</p>
<p> </p>
<p>Figure 3-13</p>
<p> </p>
<p>Misc (Extended Addressing) ..................................................................... 51</p>
<p> </p>
<p>Figure 3-14</p>
<p> </p>
<p>Database attributes for ‘Normal Fixed Addressing’.................................... 52</p>
<p> </p>
<p>Figure 3-15</p>
<p> </p>
<p>Addressing mode (Multiple Addressing) .................................................... 53</p>
<p> </p>
<p>Figure 3-16</p>
<p> </p>
<p>Dedicated call of Precopy functions in TPMC by the driver. ...................... 54</p>
<p> </p>
<p>Figure 3-17</p>
<p> </p>
<p>Dedicated call of application callback functions in TPMC by the internal </p>
<p>dispatcher. ................................................................................................ 55</p>
<p> </p>
<p>Figure 5-1</p>
<p> </p>
<p>Transmission attributes and callback functions ....................................... 159</p>
<p> </p>
<p> </p>
<p><b>Tables </b></p>
<p>Table 1-1</p>
<p> </p>
<p> Name Conventions .................................................................................. 16</p>
<p> </p>
<p>Table 1-2</p>
<p> </p>
<p> Abbreviations ........................................................................................... 17</p>
<p> </p>
<p>Table 1-3</p>
<p> </p>
<p> Feature List ............................................................................................. 22</p>
<p> </p>
<p>Table 2-1</p>
<p> </p>
<p> Addressing Modes ................................................................................... 24</p>
<p> </p>
<p>Table 2-2</p>
<p> </p>
<p> Frame size on normal addressing ............................................................ 25</p>
<p> </p>
<p>Table 2-3</p>
<p> </p>
<p> CAN ID normal fixed addressing .............................................................. 25</p>
<p> </p>
<p>Table 2-4</p>
<p> </p>
<p> Frame size extended addressing ............................................................. 26</p>
<p> </p>
<p>Table 2-5</p>
<p> </p>
<p> Frame size extended addressing ............................................................. 26</p>
<p> </p>
<p>Table 2-6</p>
<p> </p>
<p> Structure of TPCI-bytes ........................................................................... 27</p>
<p> </p>
<p>Table 2-7</p>
<p> </p>
<p> Frames .................................................................................................... 27</p>
<p> </p>
<p>Table 2-8</p>
<p> </p>
<p> Transmission timings ............................................................................... 30</p>
<p> </p>
<p>Table 2-9</p>
<p> </p>
<p> CAN frame DLC ....................................................................................... 32</p>
<p> </p>
<p>Table 3-1</p>
<p> </p>
<p> Usage of TpTxIndex database attribute ................................................... 47</p>
<p> </p>
<p>Table 3-2</p>
<p> </p>
<p> Data Base Attributes ................................................................................ 52</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>15 / 177 </p>
<p><b>1 </b></p>
<p><b>Introduction </b></p>
<p><b>1.1 </b></p>
<p><b>Relation between general component and shipped version capability </b></p>
<p>We </p>
<p>have </p>
<p>configured </p>
<p>the </p>
<p>programs </p>
<p>in </p>
<p>accordance </p>
<p>with </p>
<p>your </p>
<p>specifications </p>
<p>in </p>
<p>the </p>
<p>questionnaire.  Whereas  the  programs  do  support  other  configurations  than  the  one </p>
<p>specified  in </p>
<p>your  questionnaire, </p>
<p>Vector’s  release  of  the  programs  delivered  to  your </p>
<p>company </p>
<p>is </p>
<p>expressly </p>
<p>restricted </p>
<p>to </p>
<p>the </p>
<p>configuration </p>
<p>you </p>
<p>have </p>
<p>specified </p>
<p>in </p>
<p>the </p>
<p>questionnaire. </p>
<p> </p>
<p>This implementation and this user manual are based on the documents, listed above. </p>
<p> </p>
<p><b>It is important to know the documents above-mentioned for a better understanding </b></p>
<p><b>and the use of this manual. </b></p>
<p>/OSEK-COM/ defines different kinds of transmissions. One of them is the USDT (Unack-</p>
<p>nowledged Unsegmented Data Transfer). It is standardized together with ISO/TC22/SC3 </p>
<p>„Diagnostics on CAN“. The result of this standardization is the ISO Spezification15765-2. </p>
<p>The presented Vector-Implementation is based on the harmonized specification between </p>
<p>OSEK-COM and ISO. The implementation is suitable for diagnostic purposes (KWP2000) </p>
<p>as well as for „long“ messages in „normal“ use. </p>
<p>Task of the transport layer is to transmit messages, which might be longer than a CAN-</p>
<p>message.  If  messages  do  not  fit  into  a  CAN-message,  they  will  be  segmented  by  the </p>
<p>transport protocol to be transmitted. </p>
<p>Today  the  ISO/TF2-transport  protocol  is mainly  used  for diagnosis  applications  in  motor </p>
<p>vehicle. Most of all KWP2000 is used as a diagnosis protocol.  </p>
<p>The introduction is followed by a brief overview of the architecture in the third chapter. On </p>
<p>one  side  the  most  important  points  of  the  specification  can  be  seen  there  (see  also </p>
<p>/ISO/TF2  and  /OSEK-COM/)  and  on  the  other  side  this  explains  the  main  ideas  of  this </p>
<p>implementation. </p>
<p>The fourth chapter presents how to set up the transport protocol in the “Generation Tool”. </p>
<p>The fifth chapter contains a description of user interfaces of implementation.  </p>
<p>Transmission attributes and callback functions are presented in a table in chapter 5. </p>
<p>Rules to integrate CANbedded modules in customer projects are content of chapter 5, 6. </p>
<p>Chapter 7 is introducing a more advanced usage of the TP. </p>
<p>The last chapter contains an example for the user. </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>16 / 177 </p>
<p><b>1.2 </b></p>
<p><b>Name Conventions </b></p>
<p>The prefix of a function name determines the module to which it belongs. </p>
<p><b>Prefix </b></p>
<p><b>Remark </b></p>
<p>ApplTp</p>
<p>... </p>
<p> </p>
<p>These functions must be defined within the customer’s application and were called </p>
<p>by the Transport Layer module. The modules, which use functions of the Transport </p>
<p>Layer, are always called application in this manual. </p>
<p>ApplTpRx</p>
<p>… </p>
<p>Hook-Functions which belong to the “reception part” of the TP. </p>
<p>ApplTpTx</p>
<p>… </p>
<p>Hook-Functions which belong to the “transmission part” of the TP. </p>
<p>Can</p>
<p>... </p>
<p>Functions belong to the CAN-Driver. </p>
<p>TpRx</p>
<p>... </p>
<p>Functions belong to the “reception part” of the Transport Layer. </p>
<p>TpTx… </p>
<p>Functions belong to the “transmission part” of the Transport Layer. </p>
<p>Table 1-1 </p>
<p>  Name Conventions </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>17 / 177 </p>
<p><b>1.3 </b></p>
<p><b>Abbreviations </b></p>
<p>List of abbreviations in use: </p>
<p><b>AE </b></p>
<p>Address Extension </p>
<p><b>AI </b></p>
<p>Address Information </p>
<p><b>AK </b></p>
<p>Acknowledge </p>
<p><b>AR </b></p>
<p>Acknowledge Request </p>
<p><b>ASDT  </b></p>
<p>Acknowledged Segmented Data Transfer </p>
<p><b>BS </b></p>
<p>Block Size </p>
<p><b>CF  </b></p>
<p>Consecutive Frame </p>
<p><b>CTS </b></p>
<p>Clear To Send </p>
<p><b>DL </b></p>
<p>Data Length </p>
<p><b>FC </b></p>
<p>Flow Control </p>
<p><b>FF  </b></p>
<p>First Frame </p>
<p><b>FS </b></p>
<p>Flow Status Control </p>
<p><b>ID </b></p>
<p>Identifier </p>
<p><b>SF  </b></p>
<p>Single Frame </p>
<p><b>SN </b></p>
<p>Sequence Number </p>
<p><b>ST </b></p>
<p>Separation Time </p>
<p><b>TA   </b></p>
<p>Target Address </p>
<p><b>TP </b></p>
<p>Transport Protocol </p>
<p><b>TPCI  </b></p>
<p>Transport Protocol Control Information </p>
<p><b>USDT  </b></p>
<p>Unacknowledged Segmented Data Transfer </p>
<p><b>UUDT </b></p>
<p>Unacknowledged Unsegmented Data Transfer </p>
<p><b>WT </b></p>
<p>Wait </p>
<p><b>XDL  </b></p>
<p>extended Data Length </p>
<p>Table 1-2 </p>
<p>  Abbreviations </p>
<p><b>1.4 </b></p>
<p><b>Channel vs. Connection  </b></p>
<p>A (transport) <b>channel </b>is the physical part of the communication link, containing the </p>
<p>reception-/transmission mechanism. It can be understood as an instance of TPMC in an </p>
<p>object oriented meaning. Each channel can handle one connection at one point in time. </p>
<p>A <b>connection </b>describes a logical communication link between two ECU’s. In the </p>
<p>communication matrix it is a fixed assignment between these ECU’s to interchange data </p>
<p>(e.g. the diagnostic request and response message between the Tester and an ECU). </p>
<p>A connection includes all necessary communication parameters for the used addressing </p>
<p>mode (e.g. CAN-channel, CAN-IDs, Source-and Target Addresses, Base-Addresses, etc).  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>18 / 177 </p>
<p><b>1.5 </b></p>
<p><b>TP classes </b></p>
<p><b>1.5.1 </b></p>
<p><b>SingleTP classes </b></p>
<p>In  a  Single  TP  class  only  one  connection  is  possible,  which  is  using  the  only  available </p>
<p>TpChannel. </p>
<p><b>1.5.2 </b></p>
<p><b>Static MultiTP classes </b></p>
<p>While using Static TP classes every connection is fixed assigned to a TpChannel. </p>
<p><b>1.5.3 </b></p>
<p><b>Dynamic MultiTP classes </b></p>
<p>The idea of dynamic TP classes is to use the circumstances that not all connections are </p>
<p>used at the same time. Therefore a connection is necessary allocating a TpChannel at run-</p>
<p>time. </p>
<p><b>1.5.4 </b></p>
<p><b>Dispatched MultiTP classes </b></p>
<p>The  “Dispatched”  MultiTP  class  was  introduced  to  disburden  the  application  from  the </p>
<p>dispatching job. </p>
<p>Using  the  “Dynamic  MultiTP”  classes,  which  support  only  one  single  set  of  callback </p>
<p>functions for all connections together, the dispatching of the actual destination has to be </p>
<p>performed by the application.  </p>
<p>Using  the  “Dispatched  MultiTP”  classes  all  of  the  dispatching  work  is  done  within  the </p>
<p>TPMC.  </p>
<p>“Dispatched MultiTP” is located between static and dynamic TP classes.  </p>
<p><b>Transmission </b></p>
<p>The new allocated TpChannel has included blank communication parameters only, except </p>
<p>for the connection-handle (</p>
<p>tpChannel = TpTxGetFreeChannel(connection)</p>
<p>).  To </p>
<p>establish  the  connection  it  is  necessary  to  assign  the  connection  parameters  to  the </p>
<p>TpChannel. The TpChannel is always used to refer to the connection (like a handle). Every </p>
<p>callback- or API-function has the tpChannel as a parameter.  </p>
<p><b>Reception </b></p>
<p>If a Single- or FirstFrames is received the Transport Protocol is searching internally for a </p>
<p>free TpChannel.  If  a  free TpChannel  is  found  a  data  buffer  will  be  requested  by  calling </p>
<p>ApplTpRxGetBuffer()</p>
<p> from the application. Within this function the application has also </p>
<p>to decide to which connection the received TP frame belongs. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>19 / 177 </p>
<p><b>1.6 </b></p>
<p><b>SingleConnection vs. MultipleConnection </b></p>
<p>The  TPMC  component  has  two  different  operation  modes:  a  SingleConnection  and  a </p>
<p>MultipleConnection  mode.  The  MultipleConnection  mode  has  the  capability  to  handle </p>
<p>different  transmissions  and  receptions  at  the  same  time  like  ECU  1  in  figure  1.  If </p>
<p>SingleConnection mode is used only one transmission and one reception (one full-duplex </p>
<p>connection) can be performed at the same time (ECU 3 and ECU 4). A typical usage for </p>
<p>the SingleConnection mode is a diagnostic connection.  </p>
<p>The </p>
<p>SingleConnection </p>
<p>mode </p>
<p>needs </p>
<p>lower </p>
<p>resources </p>
<p>(ROM </p>
<p>and </p>
<p>runtime), </p>
<p>than </p>
<p>the </p>
<p>MultipleConnection mode.  </p>
<p><b>ECU 1</b></p>
<p><b>ECU 3</b></p>
<p><b>ECU 4</b></p>
<p><b>ECU 2</b></p>
<p>Con 1</p>
<p>Con 4</p>
<p>Con 1</p>
<p>Con 3</p>
<p>Con 2</p>
<p>Con 4</p>
<p> </p>
<p>Figure 1-1 SingleConnection vs. MultipleConnection </p>
<p><b>1.7 </b></p>
<p><b>Features </b></p>
<p>The main focus while the development of the Transport Layer is an easy to handle and </p>
<p>flexible application interface.  </p>
<p><b>&gt; </b></p>
<p>Therefore the buffer handling should be done by the application itself. This is more </p>
<p>flexible than a static buffer handling internally by the Transport Layer. </p>
<p><b>&gt; </b></p>
<p>Each accepted order to the TP will be acknowledged only once – positive or </p>
<p>negative.  </p>
<p><b>&gt; </b></p>
<p>Full-duplex capability - every reception is independent from every transmission and </p>
<p>the other way round. </p>
<p><b>&gt; </b></p>
<p>The static MultipleConnection TP supports connection-specific callback functions. </p>
<p><b>&gt; </b></p>
<p>SingleConnection mode with lower resource demands. </p>
<p><b>&gt; </b></p>
<p>Full ISO compliance </p>
<p><b>&gt; </b></p>
<p>Non-ISO extensions like ‘zero-padding’; ‘connections without FlowControls’ </p>
<p><b>&gt; </b></p>
<p>Multiple addressing mode support (Normal- and Extended Addressing at the same </p>
<p>time in the same ECU) </p>
<p> </p>
<p><b>1.7.1 </b></p>
<p><b>Feature List </b></p>
<p>Not any version of TPMC offers any mentioned feature </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>20 / 177 </p>
<p><b>Feature </b></p>
<p><b>Availability </b></p>
<p><b>Short Description </b></p>
<p><b>Default (on / off ) </b></p>
<p><b>General Features </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>Normal Addressing </p>
<p>Liz </p>
<p>11bit CAN ID Addressing, CAN ID identifies TP </p>
<p>message </p>
<p>- </p>
<p>Extended Addressing </p>
<p>Liz </p>
<p>11bit CAN ID Addressing, Source Address in CAN ID </p>
<p>and Target Address in first data byte  </p>
<p>- </p>
<p>Normal Fixed </p>
<p>Addressing </p>
<p>Liz </p>
<p>29bit CAN ID Addressing, Source and Target Address in </p>
<p>CAN ID </p>
<p>- </p>
<p>Mixed 11bit CAN ID </p>
<p>Addressing </p>
<p>Liz </p>
<p>11bit CAN ID Addressing, CAN ID identifies TP </p>
<p>message, first data byte used for AddressExtension </p>
<p></p>
<p> </p>
<p>Gateway </p>
<p>- </p>
<p>Mixed 29bit CAN ID </p>
<p>Addressing </p>
<p>Liz </p>
<p>29bit CAN ID Addressing, Source and Target Address in </p>
<p>CAN ID, first data byte used for AddressExtension </p>
<p></p>
<p> </p>
<p>Gateway </p>
<p>- </p>
<p>Multiple Addressing </p>
<p>Liz </p>
<p>Combination of former mentioned addressing types </p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Static channel </p>
<p>assignment </p>
<p> </p>
<p>Assignment between channel and connection is fixed at </p>
<p>compile time. </p>
<p>Advantage in opposite to dynamic assignment is better </p>
<p>efficiency (code + runtime) </p>
<p> </p>
<p>Dynamic channel </p>
<p>assignment </p>
<p> </p>
<p>Flexible pool of channels, which can be assigned to </p>
<p>connections at runtime. If no channel is free the request </p>
<p>is rejected. Nr of channels can be &lt;= connections. </p>
<p>(Time division multiplexing) </p>
<p> </p>
<p>C++ access to TPMC </p>
<p> </p>
<p>C++ applications can access TPMC. Header declared </p>
<p>as extern C. </p>
<p> </p>
<p>Additional OBD </p>
<p>reception capability </p>
<p> </p>
<p>Additional receive path to handle OBD requests at any </p>
<p>time, independent to allocated channel resources. </p>
<p> </p>
<p><b>Receiving Features </b></p>
<p> </p>
<p> </p>
<p> </p>
<p>Extended API STmin </p>
<p> </p>
<p>Enables functions to set and get the STmin value for a </p>
<p>TpChannel. </p>
<p>Off </p>
<p>Extended API </p>
<p>BlockSize </p>
<p> </p>
<p>Enables functions to set and get the BS value for a </p>
<p>TpChannel.  </p>
<p>Off </p>
<p>Precopy check / Check </p>
<p>TA function </p>
<p> </p>
<p>Forwards CAN Driver Precopy callback from TPMC to </p>
<p>application. Used for special purposes. </p>
<p>Off </p>
<p>Check Target Address </p>
<p>former called: </p>
<p>Application Precopy </p>
<p>Mixed29, </p>
<p>Normal </p>
<p>Fixed </p>
<p>Forwards CAN Driver Precopy callback from TPMC to </p>
<p>application. Parameter TargetAddress is evaluated by </p>
<p>application. Return value 0xFF rejects reception. </p>
<p>Off </p>
<p>Channel specific timing </p>
<p>Static </p>
<p>TPMC </p>
<p>Assigns individual timing values to each channel. </p>
<p>Off </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>21 / 177 </p>
<p>Custom Rx Memcopy </p>
<p> </p>
<p>TP calls ApplTpRxCopyFromCAN callback function to </p>
<p>enable the application copying the CAN frame data </p>
<p>itself. </p>
<p>Off </p>
<p>Rx Channel without FC </p>
<p>Multi </p>
<p>TPMC </p>
<p>No FC used in transport protocol communication. </p>
<p>Off </p>
<p>Fast Precopy </p>
<p>Extended</p>
<p>, </p>
<p>Mixed29, </p>
<p>Normal </p>
<p>Fixed </p>
<p>Target Address is not evaluated when receiving a TP </p>
<p>frame. </p>
<p>Off </p>
<p>Transmission of FC in </p>
<p>ISR </p>
<p> </p>
<p>The FC is sending in CAN RX IRQ forced from FF and </p>
<p>last CF out of a block. </p>
<p>On </p>
<p>Fix Rx DLC Check </p>
<p> </p>
<p>Check compares actual DLC with expected frame </p>
<p>length (CAN: 8).  </p>
<p>Off </p>
<p>Variable Rx DLC Check </p>
<p> </p>
<p>Check compares actual DLC with minimum expected </p>
<p>frame length. Check is TPMC frame type depending. </p>
<p>On </p>
<p>Functional FC Wait </p>
<p> </p>
<p>Non ISO feature: A functional FC with flow status wait is </p>
<p>supported to reload with functional addressing the </p>
<p>timeout timer awaiting physical FC.  </p>
<p>Off </p>
<p>Strict length check </p>
<p> </p>
<p>If variable Rx Dlc is enabled then the minimum byte </p>
<p>count is checked. If more bytes than announced in the </p>
<p>PCI byte (SF and last CF) are received then the frame </p>
<p>is accepted nevertheless. When the strict length check </p>
<p>feature is enabled </p>
<p>(#define </p>
<p>TP_ENABLE_STRICT_DL_CHECK) then all frames which do </p>
<p>not exactly match the PCI-DL value are ignored.</p>
<p> </p>
<p>Off </p>
<p>Suppress Multi - frame </p>
<p>reception </p>
<p> </p>
<p>For some applications, which use only Single Frames </p>
<p>on the Rx side, the reception of Multi Frames can be </p>
<p>disabled by setting the TP_DISABLE_MF_RECEPTION </p>
<p>switch via a user configuration file.  </p>
<p>The benefit is the smaller resource consumption. The </p>
<p>remaining Single Frame reception is unaffected. </p>
<p>Off </p>
<p><b>Transmission  </b></p>
<p><b>Features </b></p>
<p> </p>
<p> </p>
<p> </p>
<p>Use STmin of FC </p>
<p> </p>
<p>The STmin value is used from the FC.  </p>
<p>See also TxTransmitCF.  </p>
<p>Off </p>
<p>Analyze first FC only </p>
<p> </p>
<p>Only first FC values are analyzed to set STmin and </p>
<p>BlockSize. </p>
<p>Off </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Custom TX Memcopy </p>
<p> </p>
<p>TP calls ApplTpTxCopyToCAN callback function to </p>
<p>enable the application copying the TX data to the CAN </p>
<p>frame. </p>
<p>Off </p>
<p>TX Channel without FC </p>
<p>Multi </p>
<p>TPMC </p>
<p>Transmission without waiting for a FC. In dynamic TP </p>
<p>classes this feature can be activated for each channel. </p>
<p>Off </p>
<p>Fast TX Transmission </p>
<p> </p>
<p>Enables the application to send TP frames in cycle time </p>
<p>faster than TpTxTask() cycle time. </p>
<p>Off </p>
<p>Transmission of FC in </p>
<p>ISR </p>
<p> </p>
<p>Directly response with FC in IRQ context of received FF </p>
<p>or CF. </p>
<p>On </p>
<p>Variable DLC </p>
<p> </p>
<p>The DLC is adapted for SF, FC and last CF as indicated </p>
<p>by addressing type and data amount. </p>
<p>Off </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>22 / 177 </p>
<p>Ignore FC content </p>
<p> </p>
<p>FC is required for proceeding but standard values are </p>
<p>used instead of received ones. </p>
<p>Off </p>
<p>TX Handle Changeable </p>
<p> </p>
<p>The used CAN Driver handle can be changed while </p>
<p>runtime – has to be used with special care </p>
<p>Off </p>
<p>No STmin after FC </p>
<p> </p>
<p>No STmin time is kept after receiving a FC before </p>
<p>sending next CF. </p>
<p>Off </p>
<p>TX min timer </p>
<p> </p>
<p>If the database attribute ‘GenMsgDelayTime’ has a </p>
<p>value unequal to zero, the TP observes this minimum </p>
<p>time between two transmissions. </p>
<p>Off </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Special Features </b></p>
<p> </p>
<p> </p>
<p> </p>
<p>Gateway API </p>
<p> </p>
<p>Extended API to support Gateway requirements (TP </p>
<p>message routing) </p>
<p> </p>
<p>Multiple ECU NR </p>
<p> </p>
<p>Source- and TargetAddress can be modified while </p>
<p>runtime </p>
<p> </p>
<p>Multiple ECU </p>
<p> </p>
<p>Optimized support for physical multiple ECU </p>
<p>configurations. </p>
<p> </p>
<p>Multiple Base Address </p>
<p>Extended </p>
<p>More than one Base Address can be used </p>
<p> </p>
<p>BufferOverrun </p>
<p>Indication </p>
<p> </p>
<p>If the request size exceeds the buffer size, this feature </p>
<p>can be used to receive the request anyway, without </p>
<p>copy the CF data. </p>
<p>off </p>
<p>Queue in ISR </p>
<p>Dynamic </p>
<p>TP-</p>
<p>classes </p>
<p>The next queued element (if available) will be </p>
<p>transmitted within TX-ISR.  </p>
<p>on </p>
<p>ISO Compliancy </p>
<p> </p>
<p>Distinguish between early ISO spec drafts and newer </p>
<p>ones concerning STmin interpretation, DataLength = 0 </p>
<p>behavior and CF sequence error treatment.  </p>
<p>on </p>
<p>Frame Padding </p>
<p> </p>
<p>SF and last CF frame are padded out with a pattern </p>
<p>given in the generation tool. </p>
<p>oem</p>
<p>, off </p>
<p>Priority inversion </p>
<p>protect </p>
<p> </p>
<p>Prevents TPMC to interrupt a multi frame </p>
<p>transmission/reception when transmission and </p>
<p>reception events are in wrong order processed (RX </p>
<p>event with higher priority than Tx event).  </p>
<p>See also “2.5.1”. </p>
<p>on </p>
<p>Runtime checks </p>
<p> </p>
<p>Runtime condition checks </p>
<p>off </p>
<p>Strict message flow </p>
<p>check </p>
<p> </p>
<p>Illegal FlowControl frames will suspend a running </p>
<p>transmission – with same addressing information </p>
<p>on </p>
<p>Diag Functional </p>
<p>channel </p>
<p>CANDes</p>
<p>c (basic) </p>
<p>Capability to handle functional diagnostic requests </p>
<p>within TPMC (only for Vector Diag components e.g.: </p>
<p>CANDesc) </p>
<p>on </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Table 1-3 </p>
<p>  Feature List </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>23 / 177 </p>
<p><b>2 </b></p>
<p><b>Architecture Overview </b></p>
<p>This chapter describes the basic functionality of the Transport Protocol and its main ideas </p>
<p>applying to the Vector implementation of the Transport Protocol. Particular functions of the </p>
<p>Transport Protocol modules, as well as its configuration are described in later chapters. </p>
<p>The  main  idea  of  the Vector implementation  is  to  provide  an  interface,  which  is  easy  in </p>
<p>operation  and </p>
<p>adequate  for  most </p>
<p>applications.  The </p>
<p>implementation </p>
<p>is </p>
<p>quite  efficient </p>
<p>regarding ROM and RAM as well as run-time requirements. </p>
<p><b>2.1 </b></p>
<p><b>Requirements </b></p>
<p>This chapter shows basic requirements of the implementation of the Transport Protocol. </p>
<p><b>2.1.1 </b></p>
<p><b>Protocol-Overview </b></p>
<p>The Task of the transport protocol is to transmit messages, which are generally longer than </p>
<p>a CAN message. If a message is very short, it is transmitted unsegmented within TP. </p>
<p><b>2.1.1.1 </b></p>
<p><b>Construction of unsegmented messages </b></p>
<p> </p>
<p>Figure 2-1 Example of unsegmented message </p>
<p>Unsegmented </p>
<p>messages </p>
<p>are </p>
<p>transmitted </p>
<p>by </p>
<p>a </p>
<p>SingleFrame </p>
<p>message. </p>
<p>SingleFrame </p>
<p>messages  can  have  a  length  of  7  data  bytes  at  a  maximum  (normal  addressing  s.b.) </p>
<p>respectively 6 data bytes (extended addressing, s.b.). There is no Flow-Control (s.b.). </p>
<p><b>2.1.1.2 </b></p>
<p><b>Construction of segmented messages </b></p>
<p>Messages,  which  do  not  fit  into  a  SingleFrame  are  sent  by  a  sequence  of  single  CAN </p>
<p>frames. The receiver is informed of the length of the whole message in the FirstFrame by </p>
<p>the  sender.  ISO/TF2  defines  here  a  maximum  length  of  4095  bytes  for  user  data.  The </p>
<p>receiver </p>
<p>answers </p>
<p>with </p>
<p>a </p>
<p>FlowControl. </p>
<p>The </p>
<p>receiver </p>
<p>gives </p>
<p>the </p>
<p>BlockSize </p>
<p>and </p>
<p>the </p>
<p>SeparationTime  ST</p>
<p>min</p>
<p>  to  the  sender  in  this  FlowControl.  The  BlockSize  controls  the </p>
<p>number of ConsecutiveFrames, which might be sent by the sender before waiting for the </p>
<p>receivers’ FlowControl (status). The minimum value of the SeparationTime ST</p>
<p>min</p>
<p> describes </p>
<p>the minimum sending distance between two ConsecutiveFrames, which can be processed </p>
<p>by the receiver. The sender transmits the maximum BlockSize ConsecutiveFrames after </p>
<p>the reception of the FlowControl. The receiver does not answer it with a FlowControl, if all </p>
<p>data has been transmitted. </p>
<p>SingleFrame(SF)[(PCI.DL=2,xx.. ]</p>
<p>DataLength = 2</p>
<p>DL=$2</p>
<p>Sender</p>
<p>Receiver</p>
<p>DataLength = 2, DL=$2;</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>24 / 177 </p>
<p>First Frame[(PCI.XDL=$0, DL=$24,xx.. ]</p>
<p>DataLength = 36</p>
<p>XDL = $0, DL = $24</p>
<p>DL=$2</p>
<p>Sender</p>
<p>Receiver</p>
<p>Flow Control frame</p>
<p>with impicite</p>
<p>connection set-up</p>
<p>Flow Control[PCI.FS, FC.BSmax=$3,FC,STmin, xx]</p>
<p>Consecutive Frame[PCI.SN=1, xx,xx...]</p>
<p>Consecutive Frame[PCI.SN=2, xx,xx...]</p>
<p>Consecutive Frame[PCI.SN=3, xx,xx...]</p>
<p>Flow Control[PCI.FS, FC.BSmax=$3,FC,STmin, xx]</p>
<p>Multiple</p>
<p>consecutive</p>
<p>frames</p>
<p>Consecutive Frame[PCI.SN=4, xx,xx...]</p>
<p>Consecutive Frame[PCI.SN=5, xx,xx...]</p>
<p>The last</p>
<p>consecutive</p>
<p>frame include</p>
<p>2 valid user</p>
<p>data bytes</p>
<p>Flow Control frame</p>
<p>because</p>
<p>SN=BSmax</p>
<p>End of multiple</p>
<p>frame</p>
<p> </p>
<p>Figure 2-2 Construction of segmented message </p>
<p><b>2.1.2 </b></p>
<p><b>Addressing modes </b></p>
<p>To handle the communication the Transport Protocol is using a Point-to-Point connection. </p>
<p>To establish a Point-to-Point transfer on a broadcast protocol like CAN additional address </p>
<p>information is needed (a source address for the transmit node and a target address for the </p>
<p>receive node). </p>
<p> The ISO/TF2 transport protocol defines four modes of addressing: </p>
<p><b>„Normal“ addressing </b></p>
<p>The CAN ID contains the complete addressing information (to each </p>
<p>source- and target address combination a unique CAN ID is assigned) </p>
<p><b>„Extended“ addressing </b></p>
<p>The CAN ID contains only the source address and the first data byte </p>
<p>contains the target addressing information. </p>
<p><b>“Normal fixed” </b></p>
<p><b>addressing </b></p>
<p>The extended CAN ID contains the complete addressing information </p>
<p>according J1939 </p>
<p><b>“Mixed” addressing </b></p>
<p>Additionally to the extended CAN ID, according J1939, the first data </p>
<p>byte contains a second target address information.  </p>
<p>Since ISO15765-2: 2003 the additional addressing mode mixed </p>
<p>addressing on 11-bit CAN IDs is defined. The address extension is </p>
<p>stored in the first byte followed by the TPCI information. </p>
<p>Table 2-1 </p>
<p>  Addressing Modes </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>25 / 177 </p>
<p>The  Vector  TP  implementation  supports  all  addressing  mode.  The  used  addressing </p>
<p>method is normally determined at compile-time regarding ROM and RAM as well as run-</p>
<p>time </p>
<p>requirements. </p>
<p>For </p>
<p>special </p>
<p>purpose </p>
<p>it </p>
<p>is </p>
<p>also </p>
<p>possible </p>
<p>to </p>
<p>determine </p>
<p>the </p>
<p>used </p>
<p>addressing method at run-time (special version of the TPMC-module is needed). </p>
<p><b>2.1.2.1 </b></p>
<p><b>Normal Addressing </b></p>
<p>The address information is coded in a unique CAN Identifier. </p>
<p>The  Transport  Protocol  uses  the  1st  and  sometimes  2nd  data  byte.  The  data  length  is </p>
<p>coded in 12bits. Therefore the maximum length of a message is limited to 4095 bytes. The </p>
<p>receivers’  control  information  (maximum  block  size  and  minimum  SeparationTime)  is </p>
<p>transmitted to the sender within a FlowControl. </p>
<p> </p>
<p>SingleFrame</p>
<p>TPCI</p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p>FirstFrame</p>
<p>TPCI</p>
<p>DataLength</p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p>Consecutive</p>
<p>Frame</p>
<p>TPCI</p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p>FlowControl</p>
<p>TPCI</p>
<p>BS</p>
<p>max</p>
<p>ST</p>
<p>min</p>
<p><b>Type</b></p>
<p><b>Byte 0</b></p>
<p><b>Byte 1</b></p>
<p><b>Byte 2</b></p>
<p><b>Byte 3</b></p>
<p><b>Byte 4</b></p>
<p><b>Byte 5</b></p>
<p><b>Byte 6</b></p>
<p><b>Byte 7</b></p>
<p>Type</p>
<p>Length</p>
<p>Type</p>
<p>Length</p>
<p>Length</p>
<p>Type</p>
<p>SN</p>
<p>Type</p>
<p>FS</p>
<p> </p>
<p>Table 2-2 </p>
<p>  Frame size on normal addressing </p>
<p><b>2.1.2.2 </b></p>
<p><b>Mixed 11-bit ID Addressing </b></p>
<p>Mixed  11-bit  addressing  is  a  sub-format  of  normal  addressing  (refer  above)  where  the </p>
<p>mapping of the address information is further defined (see ISO 15765-2:2004).  </p>
<p>The target <b>address extension </b>information is placed in the first data byte of the CAN frame </p>
<p>(see ISO 15765-2:2004) followed by the TPCI information in byte two. </p>
<p><b>2.1.2.3 </b></p>
<p><b>Normal Fixed Addressing </b></p>
<p>Normal  fixed  addressing  is  a  sub-format  of  normal  addressing  (refer  above)  where  the </p>
<p>mapping  of  the  address  information  into  the  (extended) CAN-Identifier  is further defined </p>
<p>(see ISO 15765-2). </p>
<p><b>J1939 name</b></p>
<p><b>P</b></p>
<p><b>R/DP</b></p>
<p><b>PF</b></p>
<p><b>PS</b></p>
<p><b>SA</b></p>
<p><b>Data field</b></p>
<p><b>Bits</b></p>
<p>3</p>
<p>2</p>
<p>8</p>
<p>8</p>
<p>8</p>
<p>64</p>
<p><b>Content</b></p>
<p>Priority</p>
<p>Reserved</p>
<p>ProtocolGroup </p>
<p>Identification</p>
<p>Target- </p>
<p>Address</p>
<p>Source-</p>
<p>Address</p>
<p>TPCI/Data</p>
<p><b>CAN Id Bits</b></p>
<p>26-28</p>
<p>24-25</p>
<p>16-23</p>
<p>8-15</p>
<p>0-7</p>
<p>CAN data bytes</p>
<p><b>CAN Field</b></p>
<p>Data</p>
<p>Identifier</p>
<p> </p>
<p>Table 2-3 </p>
<p>  CAN ID normal fixed addressing </p>
<p>For information about the “data field” see 2.1.2.1. </p>
<p><b>2.1.2.4 </b></p>
<p><b>Extended Addressing </b></p>
<p>The source address is coded into the CAN ID by adding the address to  a base CAN ID </p>
<p>(e.g.:  with  a  base  CAN  ID  0x600  and  a  source  address  of  0x10  the  used  CAN  ID  are </p>
<p>0x610) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>26 / 177 </p>
<p>The target address information is placed in the first data byte of the CAN frame (see ISO </p>
<p>15765-2). </p>
<p>TPCI</p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p>TPCI</p>
<p>DataLength</p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p>TPCI</p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p>TPCI</p>
<p>BS</p>
<p>max</p>
<p>ST</p>
<p>min</p>
<p><b>Byte 1</b></p>
<p><b>Byte 2</b></p>
<p><b>Byte 3</b></p>
<p><b>Byte 4</b></p>
<p><b>Byte 5</b></p>
<p><b>Byte 6</b></p>
<p><b>Byte 7</b></p>
<p>Type</p>
<p>Length</p>
<p>Type</p>
<p>Length</p>
<p>Length</p>
<p>Type</p>
<p>SN</p>
<p>Type</p>
<p>FS</p>
<p><b>Byte 0</b></p>
<p><b>ext Addr</b></p>
<p><b>ext Addr</b></p>
<p><b>ext Addr</b></p>
<p><b>ext Addr</b></p>
<p>SingleFrame</p>
<p>FirstFrame</p>
<p>Consecutive</p>
<p>Frame</p>
<p>FlowControl</p>
<p><b>Type</b></p>
<p> </p>
<p>Table 2-4 </p>
<p>  Frame size extended addressing </p>
<p><b>2.1.2.5 </b></p>
<p><b>Mixed 29-bit ID Addressing </b></p>
<p>Mixed 29-bit ID addressing is a sub-format of normal fixed addressing (refer above) where </p>
<p>the  mapping  of  the  address  information  into  the  (extended)  CAN-Identifier  is  further </p>
<p>defined (see ISO 15765-2).  </p>
<p>The target address extension information is placed in the first data byte of the CAN frame </p>
<p>(see ISO 15765-2). </p>
<p>TPCI</p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p>TPCI</p>
<p>DataLength</p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p>TPCI</p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p><b>Data</b></p>
<p>TPCI</p>
<p>BS</p>
<p>max</p>
<p>ST</p>
<p>min</p>
<p><b>Byte 1</b></p>
<p><b>Byte 2</b></p>
<p><b>Byte 3</b></p>
<p><b>Byte 4</b></p>
<p><b>Byte 5</b></p>
<p><b>Byte 6</b></p>
<p><b>Byte 7</b></p>
<p>Type</p>
<p>Length</p>
<p>Type</p>
<p>Length</p>
<p>Length</p>
<p>Type</p>
<p>SN</p>
<p>Type</p>
<p>FS</p>
<p><b>Byte 0</b></p>
<p><b>Address</b></p>
<p><b>Extension</b></p>
<p><b>Address</b></p>
<p><b>Extension</b></p>
<p><b>Address</b></p>
<p><b>Extension</b></p>
<p><b>Address</b></p>
<p><b>Extension</b></p>
<p>SingleFrame</p>
<p>FirstFrame</p>
<p>Consecutive</p>
<p>Frame</p>
<p>FlowControl</p>
<p><b>Type</b></p>
<p> </p>
<p>Table 2-5 </p>
<p>  Frame size extended addressing </p>
<p> </p>
<p><b>2.1.2.6 </b></p>
<p><b>Structure of TPCI-Byte </b></p>
<p>The coding of the TPCI of each frame type is shown in Table 2-6   </p>
<p>Structure </p>
<p>of </p>
<p>TPCI-</p>
<p>bytes. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Encoding of Protocol Control Information (PCI) </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>27 / 177 </p>
<p><b>1. </b></p>
<p><b> </b></p>
<p><b>Network Protocol Control Information (N_PCI) bytes </b></p>
<p><b>2. </b></p>
<p><b> </b></p>
<p><b>Byte #1 </b></p>
<p><b>Byte #2 </b></p>
<p><b>Byte #3 </b></p>
<p><b>N_PDU name </b></p>
<p><b>Bits 7-4 </b></p>
<p><b>Bits 3-0 </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>SingleFrame </p>
<p>N_PCItype = 0 </p>
<p>SF_DL </p>
<p>N/A </p>
<p>N/A </p>
<p>FirstFrame </p>
<p>N_PCItype = 1 </p>
<p>FF_DL </p>
<p>N/A </p>
<p>ConsecutiveFrame </p>
<p>N_PCItype = 2 </p>
<p>SN </p>
<p>N/A </p>
<p>N/A </p>
<p>FlowControl  </p>
<p>N_PCItype = 3 </p>
<p>FS </p>
<p>BS </p>
<p>STmin </p>
<p>Table 2-6 </p>
<p>  Structure of TPCI-bytes </p>
<p><b>Hex value </b></p>
<p><b>Description </b></p>
<p>0 </p>
<p><b>SingleFrame </b></p>
<p> </p>
<p>For unsegmented message, the network layer protocol provides an optimised implementation of the </p>
<p>network protocol with the message length embedded in the PCI byte only. SingleFrame (SF) shall be </p>
<p>used to support the transmission of messages that can fit in a single CAN frame. </p>
<p>1 </p>
<p><b>FirstFrame </b></p>
<p> </p>
<p>A first frame (FF) shall only be used to support the transmission of messages that cannot fit in a single </p>
<p>CAN frame, i.e. segmented message. The first frame of a segmented message is encoded as a </p>
<p>FirstFrame (FF). On receipt of a FirstFrame the receiving network layer entity shall start assembling the </p>
<p>segmented message. </p>
<p>2 </p>
<p><b>ConsecutiveFrame </b></p>
<p> </p>
<p>When sending segmented data, all consecutive frames following the first frame (FF) are encoded as </p>
<p>ConsecutiveFrames (CF). On receipt of a Consecutive Frame (CF) the receiving network layer entity </p>
<p>shall assemble the received data bytes until the whole message is received. The receiving entity shall </p>
<p>pass the assembled message to the adjacent upper protocol layer after the last frame of the message </p>
<p>has been received without error. </p>
<p>3 </p>
<p><b>FlowControl </b></p>
<p> </p>
<p>The purpose of Flow Control is to regulate the rate at which Consecutive Frame network protocol data </p>
<p>unit are sent to the receiver. Three distinct types of Flow Control protocol control information are </p>
<p>specified to support this function. The type is indicated by a field of the protocol control information called </p>
<p>Flow Status (FS) as defined hereafter. </p>
<p>4 - F </p>
<p><b>Reserved </b></p>
<p> </p>
<p>This range of values is reserved by this document.  </p>
<p> </p>
<p><b>SF_DL on SingleFrame </b></p>
<p>Contains the data length of the message (up to 7 bytes with normal </p>
<p>resp. up to 6 bytes with extended addressing). </p>
<p><b>FF_DL on FirstFrame </b></p>
<p>Contains the data length of the message. The most significant 4 bit </p>
<p>of the data length in byte #1, the remaining 8 bits are transmitted in </p>
<p>byte #2. </p>
<p><b>SN on ConsecutiveFrame </b></p>
<p>The Sequence Number is used to discover a doubling or the loss of </p>
<p>a data frame. The SN starts with ‘1’ and is calculated modulo ‘16’ (4 </p>
<p>bit calculation). </p>
<p><b>FS on FlowControlFrame </b></p>
<p>‘0’ means CTS (ClearToSend): sender can continue sending  </p>
<p>’1’ means WT (Wait): sender is not allowed to continue sending, it </p>
<p>has to wait until FC.CTS is received </p>
<p>‘2’ means OVF (Overflow): sender is not allowed to continue </p>
<p>sending, the transfer is stopped. </p>
<p>Table 2-7 </p>
<p>  Frames </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>28 / 177 </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>2.2 </b></p>
<p><b>Transmission </b></p>
<p>  </p>
<p>Only dynamic classes </p>
<p><b>TpTxGetFreeChannel</b>: Associate channel </p>
<p>to connection (only for dynamic classes) </p>
<p>The </p>
<p>application </p>
<p>has </p>
<p>to </p>
<p>allocate </p>
<p>a </p>
<p>free </p>
<p>transport channel.  </p>
<p> </p>
<p><b>TpTxSet...</b>: Adjust transmit state </p>
<p>(only for dynamic classes) </p>
<p>The new allocated TpChannel has only </p>
<p>blank communication parameters included, </p>
<p>which await to be adjusted by the </p>
<p>application. Which parameters have to be </p>
<p>attuned depends on the used TpClass (see </p>
<p>chapter 4.2 Functions of the Transport </p>
<p>Protocol) </p>
<p><b>TpTransmit</b>: Start the transmission </p>
<p><b>ApplTpTxCopyToCan</b>: Copy data to CAN </p>
<p>The </p>
<p>Transport </p>
<p>Layer </p>
<p>supports </p>
<p>two </p>
<p>copy </p>
<p>mechanisms: an internal and an application specific </p>
<p>copy mechanism. </p>
<p>With  the  application  specific  copy  mechanism  the </p>
<p>Transport </p>
<p>Layer </p>
<p>will </p>
<p>call </p>
<p>a </p>
<p>callback </p>
<p>function </p>
<p>to </p>
<p>request data each time data has to be transmitted. </p>
<p><b>ApplTpTxNotification / -CanMessageTransmitted  </b></p>
<p>Each  time  a  transport  frame  (every  frame  or  only </p>
<p>with  pay </p>
<p>load) </p>
<p>will </p>
<p>be  transmitted,  the  Transport </p>
<p>Layer notifies the application.  </p>
<p><b>ApplTpTxConfirmation</b>: Confirm the transmission </p>
<p>After  a  successful  transmission  the  application  will </p>
<p>be  notified.  This  would  be  a  good  point  in  time  to </p>
<p>release unused resources / buffers for example. </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>only dynamic classes</b></p>
<p>IDLE</p>
<p><b>TpTxSet...</b></p>
<p><b>TpTransmit</b></p>
<p>Transmit a CAN-</p>
<p>Frame</p>
<p>Transmission Event</p>
<p>for data segment</p>
<p><b>ApplTpTx-</b></p>
<p><b>CopyToCan</b></p>
<p>Wait for adjusting the</p>
<p>transmit state</p>
<p><b>ApplTpTx-</b></p>
<p><b>Notification</b></p>
<p><b>ApplTpTxCan-</b></p>
<p><b>Message-</b></p>
<p><b>Transmitted</b></p>
<p>Last</p>
<p>Frame?</p>
<p>No</p>
<p><b>ApplTpTx-</b></p>
<p><b>Confirmation</b></p>
<p>Yes</p>
<p><b>ApplTpTxCan-</b></p>
<p><b>Message-</b></p>
<p><b>Transmitted</b></p>
<p>Wait for Transmission</p>
<p>Event</p>
<p>Wait for Transmission</p>
<p><b>TpGetFreeChannel</b></p>
<p>Reserve and block</p>
<p>the channel to this</p>
<p>connection</p>
<p>Adjustable transmit states</p>
<p><i>TpTxSetCanChannel</i></p>
<p><i>TpTxSetChannelID</i></p>
<p><i>TpTxSetTargetAddress</i></p>
<p><i>TpTxSetEcuNumber</i></p>
<p>TpTxTask</p>
<p>CanTransmit</p>
<p><b>Legend</b></p>
<p>Get external event</p>
<p>(TP API call)</p>
<p>Set external event</p>
<p>(Application call)</p>
<p>Set external event</p>
<p>(Application call)</p>
<p><i>only used for special efforts</i></p>
<p>Get internal event</p>
<p>Set internal event</p>
<p>Internal state</p>
<p>Figure 2-3 Transmission Architecture </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>29 / 177 </p>
<p>TpPrecopy</p>
<p><b>ApplTp-</b></p>
<p><b>PrecopyCheck</b></p>
<p>Return Value</p>
<p><b>IDLE</b></p>
<p>Is SF or</p>
<p>FF ?</p>
<p>True '1'</p>
<p><b>Single Frame</b></p>
<p><b>First Frame</b></p>
<p><b>Consecutive</b></p>
<p><b>Frame</b></p>
<p>Is</p>
<p>NULL</p>
<p>?</p>
<p><b>ApplTpRx-</b></p>
<p><b>Indication</b></p>
<p><b>ApplTpRx-</b></p>
<p><b>CopyFrom-</b></p>
<p><b>Can</b></p>
<p>No</p>
<p><b>ApplTpRx-</b></p>
<p><b>GetBuffer</b></p>
<p>Is</p>
<p>NULL</p>
<p>?</p>
<p><b>ApplTpRx-</b></p>
<p><b>CopyFrom-</b></p>
<p><b>Can</b></p>
<p>No</p>
<p><b>ApplTpRx-</b></p>
<p><b>CopyFrom-</b></p>
<p><b>Can</b></p>
<p>Last</p>
<p>CF ?</p>
<p><b>ApplTpRx-</b></p>
<p><b>Indication</b></p>
<p>Yes</p>
<p>CF</p>
<p>SF</p>
<p>FF</p>
<p><b>Wait for next</b></p>
<p><b>CF</b></p>
<p>Yes</p>
<p>Yes</p>
<p>False '0'</p>
<p>No</p>
<p><b>ApplTpRx-</b></p>
<p><b>GetTxID</b></p>
<p><b>(depends on</b></p>
<p><b>configuration)</b></p>
<p><b>ApplTpRx-</b></p>
<p><b>CF</b></p>
<p>ConnectionSearch</p>
<p>DLC-checks</p>
<p>Frame checks</p>
<p>Failed</p>
<p><b>ApplTpRx-</b></p>
<p><b>GetBuffer</b></p>
<p><b>ApplTpRxSF</b></p>
<p><b>ApplTpRxFF</b></p>
<p>CanDriver</p>
<p>TpPrecopy</p>
<p><b>ApplTp-</b></p>
<p><b>PrecopyCheck</b></p>
<p>Return Value</p>
<p>True '1'</p>
<p>False '0'</p>
<p>ConnectionSearch</p>
<p>DLC-checks</p>
<p>Frame checks</p>
<p>Failed</p>
<p>CanDriver</p>
<p><b>2.3 </b></p>
<p><b>Reception  </b></p>
<p>  </p>
<p><b>ApplTpPrecopyCheck</b>: Should receive or not? </p>
<p>The ApplTpPrecopy will be called immediately after the </p>
<p>reception of each TP-Frame. The return value of the function </p>
<p>determines whether or not the TP-Frame is received </p>
<p><b>ApplTpRxGetBuffer</b>: Associate a buffer </p>
<p>The  Transport  Layer  asks  the  application  for  a  buffer.  The </p>
<p>application has to return a valid buffer, in which the received </p>
<p>data will be stored. If the buffer is not valid, the reception will </p>
<p>be abort. </p>
<p><b>ApplTpRxCopyFromCan</b>: Copy data from CAN </p>
<p>The  Transport  Layer  supports  two  copy  mechanisms:  an </p>
<p>internal and an application specific copy mechanism. </p>
<p>The internal copy mechanism can only  be used with a flat-</p>
<p>buffer-model.  </p>
<p>With the application specific copy mechanism the Transport </p>
<p>Layer  will  invoke  a  callback  function  each  time  data  were </p>
<p>received. </p>
<p><b>ApplTpRxGetTxId</b>: Get FlowControl ID </p>
<p>(only with Dynamic Normal Addressing) </p>
<p>A corresponding transmit ID for a FlowControl is needed. </p>
<p><b>ApplTpRxIndication</b>: Indicate a reception  </p>
<p>A complete block of transport frames is received. </p>
<p> </p>
<p><b>Important: </b>The Transport Layer blocks the receive channel </p>
<p>to prevent a double occupancy of this channel. To free the </p>
<p>receive channel the application can call <b>TpRxResetChannel </b></p>
<p><b>()</b>. </p>
<p> </p>
<p>Figure 2-4 Reception Architecture </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>30 / 177 </p>
<p>  </p>
<p><b>2.4 </b></p>
<p><b>Working behaviors  </b></p>
<p><b>2.4.1 </b></p>
<p><b>Timings </b></p>
<p><b>FF</b></p>
<p><b>FC</b></p>
<p><b>CF</b></p>
<p><b>CF</b></p>
<p><b>FC</b></p>
<p><b>CF</b></p>
<p><b>TpTransmit.FF</b></p>
<p><b>ApplTpTxCanMsgTransmitted</b></p>
<p><b>ApplTpTxFC</b></p>
<p><b>ApplTpRxGetBuffer</b></p>
<p><b>ApplTpRxCanMessageTransmitted</b></p>
<p><b>ApplTpRxCF</b></p>
<p><b>ApplTpRxIndication</b></p>
<p><b>N_As</b></p>
<p><b>N_Bs</b></p>
<p><b>N_Bs</b></p>
<p><b>N_Cr</b></p>
<p><b>N_Cr</b></p>
<p><b>N_Cr</b></p>
<p><b>N_Cs</b></p>
<p><b>N_As</b></p>
<p><b>N_Ar</b></p>
<p><b>N_Br</b></p>
<p><b>N_As</b></p>
<p><b>N_Cs</b></p>
<p><b>N_Br</b></p>
<p><b>FC</b></p>
<p><b>N_Ar</b></p>
<p><b>N_Br</b></p>
<p><b>N_Ar</b></p>
<p><b>N_Bs</b></p>
<p><b>N_As</b></p>
<p><b>N_Cs</b></p>
<p><b>ApplTpTxCanMsgTransmitted</b></p>
<p><b>ApplTpTxCanMsgTransmitted</b></p>
<p><b>ApplTpTxFC</b></p>
<p><b>ApplTpTxFC</b></p>
<p><b>ApplTpTxConfirmation</b></p>
<p><b>ApplTpRxCF</b></p>
<p><b>ApplTpRxCanMessageTransmitted</b></p>
<p><b>ApplTpRxCanMessageTransmitted</b></p>
<p> </p>
<p>Figure 2-5 Transmission timings. </p>
<p> </p>
<p>N_As </p>
<p>CAN message confirmation </p>
<p>timeout </p>
<p>N_Ar </p>
<p>CAN message confirmation timeout </p>
<p>N_Bs </p>
<p>Timeout FC </p>
<p>N_Br </p>
<p>Always zero (0) </p>
<p>N_Cs </p>
<p>STmin (from FlowControl) </p>
<p>But not lower than Transmit CF </p>
<p>N_Cr </p>
<p>Timeout CF </p>
<p>Table 2-8 </p>
<p>  Transmission timings </p>
<p>The TP needs the timings normalized to call cycles. Therefore all timings will be rounded </p>
<p>up to an integer multiple of call cycles. </p>
<p>The  timings  have  an  inaccuracy  while  runtime  (based  on  the  technical  concept  where </p>
<p>timers are set on interrupt level and decremented on task level). The jitter is either plus a </p>
<p>call cycle or minus a call cycle.  </p>
<p>In general the ‘Timings’ are calculated with a jitter plus a call cycle – that means the value </p>
<p>of the timing is the first possible time after i.e. a timeout can occur. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>31 / 177 </p>
<p>The TP uses the following algorithm for calculation: </p>
<p><b>&gt; </b></p>
<p>Timings: (STmin-Value + (TpCallCycle-1)) / TpCallCycle  + 1 </p>
<p><b>2.4.2 </b></p>
<p><b>Error detection </b></p>
<p><b>2.4.2.1 </b></p>
<p><b>Reception of a SingleFrame </b></p>
<p><b>1</b></p>
<p><b>7</b></p>
<p><b>6</b></p>
<p><b>5</b></p>
<p><b>4</b></p>
<p><b>3</b></p>
<p><b>2</b></p>
<p><b>0</b></p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>DL</p>
<p>Single Frame</p>
<p>Data Lenth</p>
<p> </p>
<p>Figure 2-6 Single Frame TPCI </p>
<p>A  SingleFrame  will  be  ignored  if  the  DataLength  exceeds  the  maximum  length  of  a </p>
<p>SingleFrame (6 / 7 bytes). </p>
<p><b>2.4.2.2 </b></p>
<p><b>Reception of a FirstFrame </b></p>
<p><b>1</b></p>
<p><b>7</b></p>
<p><b>6</b></p>
<p><b>5</b></p>
<p><b>4</b></p>
<p><b>3</b></p>
<p><b>2</b></p>
<p><b>0</b></p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>0</p>
<p>XDL</p>
<p>First Frame</p>
<p>High Nibble of Data Length</p>
<p> </p>
<p>Figure 2-7 First Frame TPCI </p>
<p>A  FirstFrame  will  be  ignored  (until  version  2.28)  if  the  TPCIlength  is  lower  than  the </p>
<p>maximum length of a SingleFrame (6 / 7 bytes). </p>
<p><b>2.4.2.3 </b></p>
<p><b>Reception of a FlowControl </b></p>
<p>A FlowControl will be ignored if no suitable transmission is running (suitable means: the </p>
<p>Source-  and TargetAddresses  must  fit).  It  will  be  also  ignored  if  the TPCIbyte  misfit  the </p>
<p>valid values. </p>
<p><b>1</b></p>
<p><b>7</b></p>
<p><b>6</b></p>
<p><b>5</b></p>
<p><b>4</b></p>
<p><b>3</b></p>
<p><b>2</b></p>
<p><b>0</b></p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>FS</p>
<p>Flow Control</p>
<p>Flow State</p>
<p>1</p>
<p>0</p>
<p>Continue To Send</p>
<p>1</p>
<p>Wait</p>
<p>2</p>
<p>Overflow </p>
<p>(15765:2003)</p>
<p> </p>
<p>Figure 2-8 FlowFrameTPCI </p>
<p>If  a  suitable </p>
<p>transmission  is  found  the  state  machine  is  checked  for  waiting  for  a </p>
<p>FlowControl (except CAN Driver polling mode is used). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>32 / 177 </p>
<p><b>2.4.2.4 </b></p>
<p><b>Reception of a ConsecutiveFrame </b></p>
<p>A ConsecutiveFrame will be ignored if no suitable reception is running (suitable means: the </p>
<p>Source- and TargetAddresses must fit).  </p>
<p><b>1</b></p>
<p><b>7</b></p>
<p><b>6</b></p>
<p><b>5</b></p>
<p><b>4</b></p>
<p><b>3</b></p>
<p><b>2</b></p>
<p><b>0</b></p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>SN</p>
<p>ConsecutiveFrame</p>
<p>Sequence Number</p>
<p>1</p>
<p> </p>
<p>Figure 2-9 Consecutive Frame TPCI </p>
<p>If </p>
<p>a </p>
<p>suitable </p>
<p>reception </p>
<p>is </p>
<p>found </p>
<p>the </p>
<p>state </p>
<p>machine </p>
<p>is </p>
<p>checked </p>
<p>for </p>
<p>waiting </p>
<p>of </p>
<p>a </p>
<p>ConsecutiveFrame (except CAN Driver polling mode is used). If the estimated Sequence </p>
<p>Number does not fit the current reception will be stopped. </p>
<p> </p>
<p><b>2.4.2.5 </b></p>
<p><b>Observing CAN frame DLC (Data Length Code) </b></p>
<p> </p>
<p>The CAN frame DLC should be set by the sender to a value greater than or equal to the </p>
<p>values indicated in the table below. </p>
<p><b>Frame Type </b></p>
<p><b>Normal (fixed) Addressing </b></p>
<p><b>Extended/Mixed Addressing </b></p>
<p>SingleFrame </p>
<p>SF_DL+1 </p>
<p>SF_DL+2 </p>
<p>FirstFrame </p>
<p>8 </p>
<p>8 </p>
<p>FlowControl </p>
<p>3 </p>
<p>4 </p>
<p>ConsecutiveFrame </p>
<p>(except the last </p>
<p>ConsecutiveFrame) </p>
<p>8 </p>
<p>8 </p>
<p>Last </p>
<p>ConsecutiveFrame </p>
<p>1+ ((FF_DL-6) mod[7]) </p>
<p>2+ ((FF_DL-5) mod[6]) </p>
<p>Table 2-9 </p>
<p>  CAN frame DLC </p>
<p> </p>
<p>The CAN frame DLC check can be configured for the following different ways: </p>
<p>none: </p>
<p> </p>
<p>CAN frames are accepted if they are 8 bytes or less. </p>
<p>The frames are NOT checked against a minimum length. </p>
<p>only DLC 8:  </p>
<p>CAN frames are ONLY accepted if they are exactly 8 bytes long. </p>
<p>variable DLC: </p>
<p>CAN frames are accepted if they are 8 bytes or less. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>33 / 177 </p>
<p>The frames are also checked against the required minimum length. </p>
<p>depend on driver: </p>
<p>CAN frames are accepted if they pass the DLC check configured on driver level. Refer </p>
<p>to [3] on how to set up the DLC check. </p>
<p> </p>
<p><b>2.4.3 </b></p>
<p><b>Buffer consistency </b></p>
<p>The application programmer has to guarantee consistency of transmission and reception </p>
<p>buffers.  </p>
<p><b>Transmission </b></p>
<p>Between </p>
<p>the </p>
<p>call </p>
<p>of </p>
<p>TpTransmit()</p>
<p> </p>
<p>and </p>
<p>ApplTpTxConfirmation()</p>
<p> </p>
<p>or </p>
<p>ApplTpTxErrorIndication()</p>
<p> writing access to the transmission data buffer must be </p>
<p>blocked (except the </p>
<p>ApplTpCopyToCan()</p>
<p> function is used to copy the data). </p>
<p><b>Reception </b></p>
<p>Between </p>
<p>the </p>
<p>call </p>
<p>of </p>
<p>ApplTpRxGetBuffer()</p>
<p> </p>
<p>and </p>
<p>ApplTpRxIndication()</p>
<p> </p>
<p>or </p>
<p>ApplTpRxErrorIndication()</p>
<p>  writing  access  to  the  reception  data  buffer  must  be </p>
<p>blocked (except the </p>
<p>ApplTpCopyFromCan()</p>
<p> function is used to copy the data). </p>
<p> </p>
<p><b>2.4.4 </b></p>
<p><b>Function re-entrancy </b></p>
<p>The TP  re-entrancy  is based on  the  different  tpChannels.  So for static TP  classes,  with </p>
<p>separate  resources  for  each  single  connection,  there  is  no  re-entrancy  problem.  For </p>
<p>dynamic TP classes the re-entrancy is guaranteed too from the viewpoint of TP, as long as </p>
<p>the application handles the connection specific API properly. </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>34 / 177 </p>
<p><b>2.5 </b></p>
<p><b>Restriction </b></p>
<p><b>2.5.1 </b></p>
<p><b>Restrictions to ISO/TF2 specification </b></p>
<p>In  this  chapter  you  will  find  the  restrictions  of  the  current  implementation  relative  to  the </p>
<p>ISO/TF2-specification: </p>
<p> </p>
<p>Timing parameter: </p>
<p><b>&gt; </b></p>
<p>Timing Parameter N_Br is always zero (0) </p>
<p><b>&gt; </b></p>
<p>Timing Parameter N_As and N_Ar can only be defined by a common constant  </p>
<p> </p>
<p>WaitFrame support: </p>
<p>For versions until version 2.73.00: </p>
<p><b>&gt; </b></p>
<p>The reception of WaitFrames is supported. The transmission of WaitFrames is not </p>
<p>supported, N_WFTmax is always zero (0).  </p>
<p>For versions until version 2.88.00: </p>
<p><b>&gt; </b></p>
<p>Commencing with version 2.73.00 the transmission of WaitFrames is supported but </p>
<p>N_WFTmax is not considered. The periodical transmission must be stopped by the </p>
<p>application and does not stop by itself. </p>
<p>From version 2.89.00: </p>
<p><b>&gt; </b></p>
<p>Commencing with version 2.89.00 the maximal number of WaitFrames to be </p>
<p>transmitted (N_WFTmax) is supported and the transmission of WaitFrames stops </p>
<p>automatically when this limit is exceeded. </p>
<p>From version 3.01.00: </p>
<p><b>&gt; </b></p>
<p>Commencing with version 3.01.00 the maximal number of WaitFrames to be received </p>
<p>(N_TxWFTmax) is supported and the reception of WaitFrames stops automatically </p>
<p>when this limit is exceeded. </p>
<p> </p>
<p><b>2.5.2 </b></p>
<p><b>Limitations of Transport Protocol Implementation </b></p>
<p>The Transport Protocol is a complex state machine, which is triggered by external events </p>
<p>like requests by the application, receive indications and transmit confirmations by the CAN </p>
<p>driver. </p>
<p>The state machine expects those events in the order they appear in the “real world” to </p>
<p>decide the next step to be performed. The state machine performs one event after the </p>
<p>other and each decision is based on the current state. </p>
<p> </p>
<p>Under some very specific conditions, events may be given to the Transport Protocol state </p>
<p>machine in the incorrect order what can cause wrong decisions. </p>
<p> </p>
<p>One requirement to the TP is that unexpected frames are to be ignored. Therefore it is </p>
<p>important to discard e.g. received FlowControl frames before the FirstFrame or </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>35 / 177 </p>
<p>ConsecutiveFrame has been sent. It may now happen that the transmit confirmation and </p>
<p>the receive indication event occur “at the same time”. In such a situation the concrete </p>
<p>behaviour depends on the sequence the underlying CAN driver handles such events. </p>
<p>Unfortunately this sequence depends on the hardware implementation of the CAN </p>
<p>controller and the interrupt concept of the µC. Usually RX handling is done first to prevent </p>
<p>loss of incoming data whereas TX handling has a lower priority. Most CAN controllers do </p>
<p>not support means to handle such events in the “real world order” later, if an immediate </p>
<p>handling is not possible due to e.g. an long lasting ISR lock or the CAN driver polling is </p>
<p>executed too slow. </p>
<p> </p>
<p>Example:  </p>
<p>The TP transmits its FirstFrame successfully to the bus and the tester answers very fast </p>
<p>with the FlowControl and the notification of the FirstFrame transmit event is delayed due to </p>
<p>(a) an ISR lock or (b) a too slow polling sequence, both events are valid at the same time. </p>
<p>Now it is up to the CAN driver how the notification sequence is performed. </p>
<p>If TX is handled first, TP is in a state to accept the FlowControl and everything went well. If </p>
<p>RX is handled first, TP is not aware that the FirstFrame has been already sent and will </p>
<p>ignore the incoming FlowControl. In that case, the TP runs in a timeout due to the partner </p>
<p>has sent its frame correctly but it was assigned to the wrong event sequence and was </p>
<p>therefore ignored. </p>
<p> </p>
<p><b>CAN RX task</b>:</p>
<p>     FC received.</p>
<p>     Error: Awaited FF</p>
<p>              ackowledge.</p>
<p>     Reject FC.</p>
<p>TX</p>
<p>RX</p>
<p>Flow Control</p>
<p>First Frame</p>
<p>Acknowledge</p>
<p>Ack</p>
<p>Consecutive Frame</p>
<p>Consecutive Frame</p>
<p>Consecutive Frame</p>
<p>CAN driver polling</p>
<p>CAN driver polling</p>
<p><b>TX </b>event: acknowledge</p>
<p><b>RX </b>event: FC received</p>
<p><b>CAN TX task</b>:</p>
<p>    Acknowledge on FF</p>
<p>    Regulare proceeding</p>
<p>    (set timer, change</p>
<p>     state)</p>
<p><b>TP task</b>:</p>
<p>     Timeout on FC.</p>
<p>     Free TP channel.</p>
<p>Flow Control</p>
<p>Ack</p>
<p>Ack</p>
<p>Ack</p>
<p>Ack</p>
<p> </p>
<p>Figure 2-10 Accumulation of events during CAN Driver polling </p>
<p> </p>
<p>Implemented solution 1: </p>
<p>The TP can be configured to handle the event sequence always in the way it is notified by </p>
<p>the underlying driver. In that case it is fully compliant to the requirement that (timely) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>36 / 177 </p>
<p>incorrect frames are rejected. Unfortunately, the rejection can happen in a short time </p>
<p>period also for correct transmitted frames. The time period where this can happen is equal </p>
<p>to the runtime of the e.g. FlowControl frame on the bus (e.g. for DLC=8 and 500kBd this is </p>
<p>approx. 200µs for an interrupt driven CAN driver or the CAN driver polling rate). Timely </p>
<p>incorrect received frames outside of this time window are correctly handled/rejected. </p>
<p> </p>
<p>As a result, the correctly transmitted TP sequence might be aborted by a timeout on the </p>
<p>sender side and the tester has to repeat its request. </p>
<p> </p>
<p>The configuration switch TP_HIGH_RX_LOW_TX_PRIORITY has to be kTpOff to select </p>
<p>the implementation 1. </p>
<p> </p>
<p> </p>
<p>Implemented solution 2: </p>
<p>The TP can be configured to accept FlowControl frames also in the time window after the </p>
<p>successful ECU internal FirstFrame transmit request till the frame is really on the bus. In </p>
<p>that case it is not fully compliant to the requirement that (timely) incorrect frames are </p>
<p>rejected. The length of the time period depends on the baudrate (message runtimes), the </p>
<p>busload and if the CAN driver is used in ISR or polling mode. The shortest time range is </p>
<p>some few 10µs up to a multiple of the CAN driver polling rate. Timely incorrect received </p>
<p>frames outside of this time window are correctly handled/rejected. </p>
<p> </p>
<p>As a result of this behaviour, a too early (timely incorrect) received FlowControl frame will </p>
<p>be accepted by the TP and the transport layer continues to transmit its data.  </p>
<p>Because this scenario does usually not or only rarely happen in the field but the </p>
<p>performance of the whole diagnostic process is higher, the selection of that configuration is </p>
<p>highly recommended.  </p>
<p> </p>
<p>The configuration switch TP_HIGH_RX_LOW_TX_PRIORITY has to be kTpOn to select </p>
<p>the implementation 2. </p>
<p> </p>
<p> </p>
<p><b>Info</b> </p>
<p>Please note that the content of the received frame is always analyzed and illegal frames </p>
<p>are discarded as required. All above discussed issues are only valid if the frame is timely </p>
<p>incorrect but all other facts are correct concerning the current TP status. </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>Implementation solution 2 is automatically activated since version 2.36 of TPMC </p>
<p>component while the CAN Driver is used in polling mode. It is activated as default for </p>
<p>interrupt driven systems since version 2.63.. </p>
<p>  </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>37 / 177 </p>
<p><b>2.5.3 </b></p>
<p><b>Deviations to ISO/TF2 specification </b></p>
<p>In this chapter you will find the deviations of the current implementation compared to the </p>
<p>ISO/TF2-specification. </p>
<p><b>2.5.3.1 </b></p>
<p><b>Handling of unexpected FlowControl / ConsecutiveFrame frames </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>This deviation is only in effect if the TP_HIGH_RX_LOW_TX_PRIORITY feature is </p>
<p>kTpOn.  </p>
<p>The normal operation assumes that a transmit is followed first by its confirmation </p>
<p>interrupt and after that the next receive interrupt appears. </p>
<p>With a tester reacting very fast and simultaneously a controller that has a higher priority </p>
<p>for Rx interrupts than for Tx interrupts the Rx interrupt may be detected before the Tx  </p>
<p>confirmation interrupt: </p>
<p> </p>
<p>Without the HighRx-LowTx feature the transmission stops at this point. </p>
<p> </p>
<p>With the activation of the HighRx-LowTx feature the TP implementation tries to </p>
<p>clear this unexpected sequence and to proceed with the transmission. </p>
<p>Nevertheless there are still some special situations left (see the description </p>
<p>above) that can not be cleared by the TP and so the transmission might be </p>
<p>stopped anyway. </p>
<p><b>Conclusion</b>: </p>
<p>The HighRx-LowTx feature is activated by default to get a minimum of transmissions </p>
<p>being stopped. </p>
<p>You can deactivate the feature e.g. if your configuration does not require the feature or if </p>
<p>you prefer that the tester explicitly repeats requests after stopped transmissions. </p>
<p> </p>
<p>Please see the description below to get an idea in which special situations some </p>
<p>malfunction is still possible. </p>
<p>See also chapter 2.5.2 ‘Limitations of Transport Protocol ’ for further details. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>38 / 177 </p>
<p><b>3 </b></p>
<p><b>Settings for the MultiTP &amp; SingleTP (multi-based) </b></p>
<p>To  use  the  MultiConnection  or  the  SingleConnection  (multi-based)  TP  with  the  GENy </p>
<p>CANGen or the DBKOMGen tool the “Manufacture” attribute in the database has to be set. </p>
<p>Additionally  a  License  File  for  GENy  and  CANGen  tool  is  needed,  which  includes  a </p>
<p>clearing for the MultiConnection Tp. </p>
<p><b>3.1 </b></p>
<p><b>General settings with CANgen / DBKOMgen / GENy </b></p>
<p>In the following descriptions examples from the CANGen / DBKOMGen generation tool </p>
<p>GUI  are used. </p>
<p>  </p>
<p> </p>
<p>Figure 3-1 General settings in Generation Tools </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>39 / 177 </p>
<p><b>3.1.1 </b></p>
<p><b>Timing  </b></p>
<p>  </p>
<p> </p>
<p>Figure 3-2 Timing settings in Generation Tools </p>
<p><b>3.1.1.1 </b></p>
<p><b>Transmission timing </b></p>
<p><b>Tx call cycle </b></p>
<p>Together  with  this  period,  the  function  TpTxTask()  has  to  be  called  periodically  by  the </p>
<p>application </p>
<p><b>TxTimeoutFC</b></p>
<p><b> </b></p>
<p>In the Timeout FC edit field, the FlowControl timeout value is specified. Within this time, </p>
<p>the expected FC frame has to be received by the transmitting ECU.</p>
<p> </p>
<p><b>TxTransmitCF</b></p>
<p><b> </b></p>
<p>The  Transmit  CF  time  is  the  interval  for  the  transmission  of  ConsecutiveFrames.  This </p>
<p>value  is  used  as  a  constant  in  ECUs  that  don’t  use  the  STmin  value  from  FlowControl </p>
<p>frame.  </p>
<p>If this time should be defined as a constant at compile time the configuration switch “Use </p>
<p>ST</p>
<p>Min </p>
<p>from flow control frame” should be set to Off.  </p>
<p>If  the  time  ST</p>
<p>Min</p>
<p>  from  the  FlowControl  message  should  be  calculated,  the  configuration </p>
<p>switch  “Use  ST</p>
<p>Min </p>
<p>from  flow  control  frame”  has  to  be  selected.  Due  to  the  problem  to </p>
<p>handle  a  non-linear  buffer  (e.g.  ring-buffer  mechanism)  in  the  application  (usage  of </p>
<p>ApplTpCopyToCAN or Vector Diagnostic Layer) the Transmit CF parameter set the fastest </p>
<p>possible transmission.  </p>
<p>Transmit CF set the lowest possible separation time. </p>
<p>Example: The Diagnostic Tester set the STmin value to zero. Which will mean to the ECU </p>
<p>to transmit as fast as possible. If the application uses in this case a ring-buffer mechanism </p>
<p>it has to fill the ring-buffer in the same fast way as the TP transmits the data. To prevent in </p>
<p>such a case a buffer under-run it is possible to limit the TP, by setting the lowest possible </p>
<p>separation time value, so that the calculated STmin cannot be smaller than the Transmit </p>
<p>CF value. </p>
<p><b>3.1.1.2 </b></p>
<p><b>Reception timing </b></p>
<p><b>Rx call cycle </b></p>
<p>Together  with  this  period,  the  function  TpRxTask()  has  to  be  called  periodically  by  the </p>
<p>application </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>40 / 177 </p>
<p><b>RxTimeoutCF </b></p>
<p>After the Timeout CF time expires, a time-out occurs with the transport layer between the </p>
<p>receptions of two ConsecutiveFrames. </p>
<p><b>3.1.1.3 </b></p>
<p><b>Common timing </b></p>
<p><b>CAN message confirmation timeout</b></p>
<p><b> </b></p>
<p>Maximum time between a transmission request and the confirmation interrupt, indicating </p>
<p>that the frame is sent successfully (it is at least accepted by one net node). </p>
<p> </p>
<p> </p>
<p><b>3.1.2 </b></p>
<p><b>Flow Control </b></p>
<p>  </p>
<p> </p>
<p>Figure 3-3 Flow control settings in Generation Tools </p>
<p><b>3.1.2.1 </b></p>
<p><b>Transmission </b></p>
<p><b>Use ST</b></p>
<p><b>Min </b></p>
<p><b>from flow control frame </b></p>
<p>If  the  “Flow  control”  time  ST</p>
<p>Min</p>
<p>  was  defined  as  constant  at  compile  time  for  the  whole </p>
<p>system,  it  won’t  be  necessary  to  calculate  it  at  runtime.  Setting  the  configuration  switch </p>
<p>„Use STMin from FlowControl frame“ to Off can parameterize this. </p>
<p>If  the  time  ST</p>
<p>Min</p>
<p>  from  the  FlowControl  message  should  be  calculated,  the  configuration </p>
<p>switch “Use ST</p>
<p>Min </p>
<p>from FlowControl frame” has to be selected. </p>
<p><b>3.1.2.2 </b></p>
<p><b>Reception </b></p>
<p><b>STMin</b></p>
<p><b> </b></p>
<p>The  STmin  edit  field  contains  the  minimum  separation  time  between  two  consecutive </p>
<p>frames. The separation time will be at least as long as configured or longer. The value in </p>
<p>this  edit  field  will  be  transmitted  to  the  sender  ECU  in  the  FlowControl  frame  from  the </p>
<p>current  ECU.  The  STmin  value  can  either  be  defined  at  compile  time  or  changed  at </p>
<p>runtime (see also 3.1.3 Extended API STmin). </p>
<p><b>BlockSize requested </b></p>
<p>The BlockSize specifies the number of ConsecutiveFrames until a FlowControl is needed. </p>
<p>The receiver defines the BlockSize. The sender always uses the BlockSize of the receiver. </p>
<p>The BlockSize value can either be defined at compile time or changed at runtime (see also </p>
<p>3.1.3 Extended API BlockSize). </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>41 / 177 </p>
<p><b>3.1.3 </b></p>
<p><b>Misc </b></p>
<p>  </p>
<p> </p>
<p>Figure 3-4 Misc. settings in Generation Tools </p>
<p><b>Extended API (variable BlockSize) </b></p>
<p>API extension, which can adjust the BlockSize value. </p>
<p>If  the  feature  is  enabled  the  BlockSize  can  be  set  at  run-time  by  using  the  functions </p>
<p>TpRxSetBS()  and TpRxGetBS(). </p>
<p>Default value after initializations:  “BlockSize requested”</p>
<p> </p>
<p>(Section ‘Flow Control’) </p>
<p><b>Extended API(variable STmin) </b></p>
<p>API extension, which can adjust the STmin value. </p>
<p>If  the feature  is  enabled  the  STmin  value  can  be  set  at  run-time by  using  the  functions </p>
<p>TpRxSetSTMIN()  and TpRxGetSTMIN(). </p>
<p>Default value after initializations: “STmin” (Section ‘Flow Control’) </p>
<p><b>Use fast RAM </b></p>
<p>The  RAM  demand  and  run-time  can  be  reduced  on  some  implementations,  if  some </p>
<p>frequently used variables of the Transport Protocol are put into the „near“ memory. </p>
<p>If  the  feature  is  enabled  (default)  the  less  used  variables  are  also  set  into  the  „near“-</p>
<p>memory. The code is smaller and faster.  </p>
<p>Otherwise less used variables are not set into the „near“-memory. The code is a little bit </p>
<p>bigger and slower. </p>
<p><b>Use Gateway API </b></p>
<p>API extension, which was implemented for Gateway purpose, but it is also possible to use </p>
<p>it in other fields of applications. </p>
<p>If  the  feature  is  enabled  the  API  of  ‘ApplTpRxGetBuffer’  and  ‘ApplTpRxCheckTA’  is </p>
<p>extended  with  the  CanRxInfoStructPtr  from  the  CAN  Driver  Precopy  functions API  (see </p>
<p>/CANDrv/ manual).  </p>
<p>Within  this  CanRxInfoSturctPtr  parameter  the  CAN  ID,  pointer  to  the  CAN  data,  etc.  is </p>
<p>included. </p>
<p><b>Assertions  </b></p>
<p>To detect some incorrect internal conditions of the Transport Protocol during development, </p>
<p>integration </p>
<p>and </p>
<p>software </p>
<p>test, </p>
<p>there </p>
<p>are </p>
<p>different </p>
<p>categories </p>
<p>of </p>
<p>so </p>
<p>called </p>
<p>assertions </p>
<p>configurable:  </p>
<p>1. </p>
<p>User interface (for example input parameters, reentrance if not allowed)  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>42 / 177 </p>
<p>2. </p>
<p>Generated data  </p>
<p>3. </p>
<p>Internal software errors (for example inconsistent internal states)  </p>
<p>Each type of assertion can be configured independently.  </p>
<p>These  assertions  will  help  in  different  development  phases  to  deal  with  unexpected </p>
<p>problems, which cannot be handled by the Transport-Protocol internally. In such case the </p>
<p>following callback function will be called by the Transport-Protocol:  </p>
<p> </p>
<p>void <b>ApplTpFatalError</b>( vuint8 errorNumber ); </p>
<p> </p>
<p>This  callback  function  has  to  be  provided  by  the  Application.  The  function  parameter </p>
<p>errorNumber  gives  more  detailed  information  about  the  kind  of  error,  which  is  occurred </p>
<p>(see also 4.4.4.1 ApplTpFatalError: Fatal Error for the different error-codes).  </p>
<p>Generally,  the  error  number  has  to  be  checked  to  solve  the  underlying  problem.  The </p>
<p>recovery strategy is application dependent, but mostly there is a complete reset necessary </p>
<p>to set up the software correctly again.  </p>
<p> </p>
<p><b>Caution </b></p>
<p>This callback function must not return to the Transport-Protocol afterwards. </p>
<p><b>assert user </b></p>
<p>User assertion will be activated.  </p>
<p>Should be used while development of Application software  </p>
<p><b>assert internal </b></p>
<p>Internal assertions will be activated. </p>
<p>Should be used for tests of software changes in the Transport-Protocol </p>
<p>(Vector internal) </p>
<p> </p>
<p><b> assert generated </b></p>
<p>Internal assertions will be activated. </p>
<p>Should be used if a new version of the Generation Tool is used  </p>
<p><b>runtime checks </b></p>
<p>Runtime checks will be activated.  </p>
<p>In contrast to the assertions the ‘runtime checks’ can also be used after the development </p>
<p>phase  and  should  guarantee  a  more  reliable  run.  Checks  for  parameter  plausibility, </p>
<p>overwriting of memory like beyond access of tables, etc.. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>43 / 177 </p>
<p><b>3.2 </b></p>
<p><b>General settings with Generation Tool GENy </b></p>
<p>General  settings  can  be  done  under  the  TPMC  tree  element.  Most  important  is  the </p>
<p>selection of TpClass in the upper right window. Some online help is provided for the most </p>
<p>settings  in  the  OnScreenHelp  window.  Section  “Advanced  Configuration”  is  providing </p>
<p>special  features  like  Gateway  APIs  or  padding  of  TP  frames.  Some  features  might  be </p>
<p>greyed </p>
<p>which </p>
<p>means </p>
<p>that </p>
<p>this </p>
<p>features </p>
<p>are </p>
<p>preconfigured </p>
<p>based </p>
<p>on </p>
<p>OEM </p>
<p>or </p>
<p>other </p>
<p>constraints.  It  is  necessary  to  configure  for  each  Tp  class  at  least  one  “TP  Connection </p>
<p>Group” object. Some static configured TP classes like “Static Normal Multi TP” require one </p>
<p>Connection  Group  object  for  each  TP  connection  whereas  dynamic  TP  classes  have </p>
<p>always only one object. A Connection Group object represents a set of call back functions  </p>
<p>for the application to notify successful transmission or reception. </p>
<p> </p>
<p>Figure 3-5 Main window of component TPMC within configuration tool GENy.  </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>44 / 177 </p>
<p><b>3.2.1 </b></p>
<p><b>Configuration of Addressing Information </b></p>
<p>The  addressing  information  is  configured  for  each  channel.  The  provided  addressing </p>
<p>elements like TpTxMessage (for NormalAddressing) depend on the selected TP class. It is </p>
<p>required to assign a TpConnectionGroupObj for each Addressing information. In Dynamic </p>
<p>Multiple Addressing Tp  Classes  any Addressing  Information  is  assigned  to  only  one TP </p>
<p>Connection Group Object. </p>
<p> </p>
<p> </p>
<p>Figure 3-6 Main window of component TPMC within configuration tool GENy.  </p>
<p> </p>
<p><b>3.2.2 </b></p>
<p><b>Usage of Far RAM buffers </b></p>
<p>Due to reasons of RAM resource availability it may be necessary to locate the receive and </p>
<p>transmit  buffers  handed  to  the  TP  in  a  far  memory  location.  All  message  buffer  related </p>
<p>types and callbacks will then use far pointers. </p>
<p>To enable this option the “Use far RAM buffers” option within the “Advanced Configuration” </p>
<p>tab must be enabled. </p>
<p>If that option does not suffice for your integration the “Memory Model Override” option can </p>
<p>be  used  alternatively  supporting  the  usage  of  a  special  qualification  string  that  can  be </p>
<p>entered as plain text (e.g.: @page @far).  </p>
<p> </p>
<p><b>3.2.3 </b></p>
<p><b>Non standard handling of Flow Control frames </b></p>
<p><b>3.2.3.1 </b></p>
<p><b>Reserved STmin Handling </b></p>
<p>According to ISO 15765-2 the STmin values 0x80-0xF0 and 0xFA-0xFF are reserved.  </p>
<p>If a received FC.CTS frame  nevertheless uses one of these  reserved values, it shall be </p>
<p>interpreted from the TP as the maximum STmin time (0x7F) which is defined. </p>
<p>The TP supports two additional possibilities to handle reserved STmin values: </p>
<p><b>&gt; </b></p>
<p>If the switch ‘TP_ENABLE_IGNORE_FC_RES_STMIN’ is defined, then a FC frame </p>
<p>with a reserved STmin value is silently ignored. </p>
<p><b>&gt; </b></p>
<p>If the switch ‘TP_ENABLE_CANCEL_FC_RES_STMIN is defined, then a FC frame </p>
<p>with a reserved STmin value will lead to the cancellation of the Tx connection. </p>
<p>Note that each switch has only an effect if the STmin is evaluated at all. For cases where </p>
<p>STmin might not be evaluated, please refer to 3.2.3.4 and 3.2.3.5. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>45 / 177 </p>
<p><b>3.2.3.2 </b></p>
<p><b>Ignore Flow Control Overflow </b></p>
<p>According </p>
<p>to </p>
<p>ISO </p>
<p>15765-2 </p>
<p>a </p>
<p>received </p>
<p>FC.OVFLW </p>
<p>(0x32) </p>
<p>will </p>
<p>abort </p>
<p>the </p>
<p>ongoing </p>
<p>transmission due to the lack of reception buffer at the receiver side. </p>
<p>If  the  switch  ‘TP_ENABLE_IGNORE_FC_OVFL’  is  defined  then  a  FC.OVFLW  frame  is </p>
<p>silently ignored instead. </p>
<p> </p>
<p><b>3.2.3.3 </b></p>
<p><b>Do not ignore unexpected Flow Control frames </b></p>
<p>According to ISO 15765-2 any unexpected FC frame shall be ignored.  </p>
<p>If the switch TP_USE_UNEXPECTED_FC_CANCELATION is set to kTp_On, this behavior </p>
<p>is changed. Then every unexpected FC frame will cancel the current transmission. </p>
<p> </p>
<p><b>3.2.3.4 </b></p>
<p><b>Use STmin of FC </b></p>
<p>According to ISO 15765-2, the STmin from an FC.CTS shall be used as separation time </p>
<p>between two consecutive frames.  </p>
<p>If the switch TP_USE_STMIN_OF_FC is set to kTp_Off, the STmin of the FC is ignored. </p>
<p>Instead, the configured N_Cs timeout (TxTransmitCF parameter, see 3.1.1.1) is used as </p>
<p>STmin. </p>
<p> </p>
<p><b>3.2.3.5 </b></p>
<p><b>Analyze first FC only </b></p>
<p>According to ISO 15765-2, the contents of each expected and received FC.CTS shall be </p>
<p>evaluated by a transmitter in order to adjust its BS and STmin values. </p>
<p>If the switch TP_USE_ONLY_FIRST_FC is set to kTp_On, only the BS and the STmin of </p>
<p>the  first  received  FC.CTS  are  evaluated.  These  values  are  then  used  for  the  complete </p>
<p>transmission. Further received FC.CTS are only used for synchronization and not to adjust </p>
<p>BS and STmin. </p>
<p> </p>
<p><b>3.3 </b></p>
<p><b>Additional settings via user-configuration file </b></p>
<p><b>3.3.1 </b></p>
<p><b>Dynamic Timing API </b></p>
<p>Using this feature the application can dynamically change connection specific timing </p>
<p>values for: </p>
<p><b>&gt; </b></p>
<p>CAN confirmation timeout (N_Ar, N_As) </p>
<p><b>&gt; </b></p>
<p>Consecutive Frame timeout (N_Cr) </p>
<p><b>&gt; </b></p>
<p>Flow Control timeout (N_Bs). </p>
<p>The dynamic channel timing feature can be enabled via a user configuration file.  If the </p>
<p>pre-processor switch “</p>
<p>TP_ENABLE_DYN_CHANNEL_TIMING”</p>
<p> is included in this way then </p>
<p>the TP takes the timing values from the following application provided variables: </p>
<p>tTpEngineTimer tpRxConfirmationTimeout [kTpRxChannelCount]; </p>
<p>tTpEngineTimer tpTxConfirmationTimeout [kTpTxChannelCount]; </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>46 / 177 </p>
<p>tTpEngineTimer tpRxTimeoutCF                 [kTpRxChannelCount]; </p>
<p>tTpEngineTimer tpTxTimeoutFC                 [kTpTxChannelCount]; </p>
<p> </p>
<p>tTpEngineTimer  is  usually  of  type  canuint16,  for  8-bit  CPUs  it  might  also  be  defined  as </p>
<p>canuint8. </p>
<p>These  variables  are  initialized  internally  from  the  TP  with  the  constant  values  that  are </p>
<p>configured  in  the  generation  tool.  So  all  connection  specific  timing  are  equal  after  TP </p>
<p>initialization.  </p>
<p> </p>
<p>Please note that the TP expects these variables, containing the connection </p>
<p>specific timing values, to be supplied by the application.  </p>
<p> </p>
<p>For the further dynamic adaptation and differentiation of these connection specific values </p>
<p>the following API functions are available in addition: </p>
<p><b>&gt; </b></p>
<p>TpRxSetTimeoutConfirmation (see 4.2.2.25 ) </p>
<p><b>&gt; </b></p>
<p>TpTxSetTimeoutConfirmation (see 4.2.3.26)</p>
<p> </p>
<p><b>&gt; </b></p>
<p>TpRxSetTimeoutCF ( see 4.2.2.26 ) </p>
<p><b>&gt; </b></p>
<p>TpTxSetTimeoutFC (see 4.2.3.27) </p>
<p>With these functions the belonging timeout values of the TP can be changed dynamically </p>
<p>during runtime.  </p>
<p> </p>
<p><b>3.4 </b></p>
<p><b>TP classes: SingleTP (multi-based) </b></p>
<p>These TP classes are based on the MultiTP core but running only with one connection and </p>
<p>are optimized to consume a minimum of resources. </p>
<p><b>3.4.1 </b></p>
<p><b>Database Attributes </b></p>
<p>Following Database attributes are needed: </p>
<p>  </p>
<p>  </p>
<p> </p>
<p>Figure 3-7 Database Attributes for Single/Static TP classes </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>47 / 177 </p>
<p>        </p>
<p><b>DiagRequest / DiagResponse</b>:  Used for diagnostic request messages to make special </p>
<p>pre-settings for the Vector diagnosis’s layers.  </p>
<p>(Only available for some car-manufactures) </p>
<p> </p>
<p><b> </b></p>
<p><b>TpTxIndex</b>:  </p>
<p> </p>
<p>   </p>
<p> </p>
<p>Used for application TP messages. </p>
<p>TP connections with FlowControl: bi-directional transmissions according to ISO 15765 </p>
<p>standard </p>
<p>TP-connections without FlowControl: unidirectional transmissions nonconformance to the </p>
<p>ISO 15765 standard </p>
<p> </p>
<p>bidirectional with FC (standard)</p>
<p>The TX-Node and the RX-Node includes each a TX-TP-message </p>
<p>with the same TpTxIndex value {Broadcast not possible}.</p>
<p>bidirectional without FC</p>
<p>not supported</p>
<p>unidirectional with FC</p>
<p>not supported</p>
<p>unidirectional without FC</p>
<p>(not supported in SingleTP </p>
<p>classes)</p>
<p>The RX-Node do not include a TX-TP-message with a same </p>
<p>TpTxIndex as the TX-TP-msg. of the TX-Node {Broadcast is </p>
<p>possible - TX-msg. can have more than one receiver}.</p>
<p><b>conventions to read a connection out of the database</b></p>
<p> </p>
<p>Table 3-1 </p>
<p>  Usage of TpTxIndex database attribute </p>
<p><b> </b></p>
<p><b>GenMsgDelayTime: </b></p>
<p>If the database attribute ‘GenMsgDelayTime’ has a value unequal to zero, then the TP </p>
<p>observes this time between two transmissions as a minimum time distance. </p>
<p> </p>
<p><b>3.4.2 </b></p>
<p><b>TP class SingleTP (multi-based): Normal Addressing  </b></p>
<p>No special settings needed </p>
<p><b>3.4.3 </b></p>
<p><b>TP class SingleTP (multi-based): Extended Addressing  </b></p>
<p>No special settings needed </p>
<p> </p>
<p><b>3.4.4 </b></p>
<p><b>TP class SingleTP (multi-based):Normal Fixed Addressing  </b></p>
<p><b>3.4.4.1 </b></p>
<p><b>Database Attributes </b></p>
<p>Refer to chapter 3.6.6.1 Database Attributes </p>
<p> </p>
<p><b>3.5 </b></p>
<p><b>TP classes Static MultiTP </b></p>
<p>For each TP-communication between two ECUs static defined connections are available.  </p>
<p><b>3.5.1 </b></p>
<p><b>Database Attributes </b></p>
<p>Refer to chapter 3.4.1 Database Attributes </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>48 / 177 </p>
<p><b>3.5.2 </b></p>
<p><b>TP class specific settings </b></p>
<p> </p>
<p> </p>
<p>Figure 3-8 Additional TP settings (Static MultiTP) in Generation Tool </p>
<p><b>Connection specific timing parameters </b></p>
<p>If  ‘Connection  specific  timing  parameters’  are  activated  the  timing  parameters  of  each </p>
<p>connection can override the global timing values for this connection. </p>
<p><b>TpPreCopyCheck </b></p>
<p>Just enter a function name to use this hook function. </p>
<p> </p>
<p><b>3.5.3 </b></p>
<p><b>Connection specific timing parameters </b></p>
<p>  </p>
<p> </p>
<p>Figure 3-9 Connection specific timing parameters </p>
<p> </p>
<p>The following parameters can be configured individually for each connection: </p>
<p><b>Timings </b></p>
<p><b>&gt; </b></p>
<p>TxTimeoutFC </p>
<p><b>&gt; </b></p>
<p>TxTimeoutCF </p>
<p><b>&gt; </b></p>
<p>RxTransmitCF </p>
<p><b>FlowControl </b></p>
<p><b>&gt; </b></p>
<p>STMin </p>
<p><b>&gt; </b></p>
<p>Requested BlockSize </p>
<p>For detailed descriptions refer chapter 3.1.1 Timing and the following </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>49 / 177 </p>
<p><b>3.5.4 </b></p>
<p><b>Functions </b></p>
<p>  </p>
<p> </p>
<p>Figure 3-10 Hook-Functions (Static MultiTP) </p>
<p>Just enter a suitable function name to use the hook function in your application.  </p>
<p>For a detailed description of each function refer chapter 4.4. </p>
<p> </p>
<p><b>3.6 </b></p>
<p><b>TP classes Dynamic MultiTP </b></p>
<p>In opposite to the static MultiTP there are no fix connections available. All connections are </p>
<p>built-on during runtime and released after the transmission is complete. So the  resources </p>
<p>used per connection can be reused by other applications. </p>
<p> </p>
<p><b>3.6.1 </b></p>
<p><b>Properties </b></p>
<p><b>Tx channel count </b></p>
<p>Maximum possible number of parallel used TpChannel(s) for transmissions. </p>
<p><b>Rx channel count </b></p>
<p>Maximum possible number of parallel used TpChannel(s) for receptions. </p>
<p><b>Use Tx channels without FC </b></p>
<p>Enable the feature to use the non-ISO implementation ‘without FC’ for transmission. </p>
<p><b>Use Rx channels without FC </b></p>
<p>Enable the feature to use the non-ISO implementation ‘without FC’ for reception.  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>50 / 177 </p>
<p><b>3.6.2 </b></p>
<p><b>Hook Functions </b></p>
<p>In  opposite  to  the  static  MultiTP,  where  all  hook  functions  are  available  once  for  each </p>
<p>statically configured connection, here this set of hook functions is available only once for </p>
<p>all connections.  This means that all messages have to be dispatched to  the belonging </p>
<p>destination by the application for each connection. </p>
<p> </p>
<p>These hook functions we recommend to use. </p>
<p> </p>
<p>Figure 3-11 Mandatory functions for the usage of the CANdesc diagnostic component </p>
<p>Just enter a suitable function name to use the hook function in your application.  </p>
<p>For a detailed description of each function refer to chapter 4.4. </p>
<p> </p>
<p>These hook functions are optional. </p>
<p> </p>
<p>Figure 3-12 Optional functions (example for the usage of the CANdesc diagnostic component)  </p>
<p> </p>
<p><b>Be careful </b></p>
<p>while using a Vector Diagnostic Layer it is necessary to hand over only the function calls </p>
<p>to the Diagnostic Layer, which belong to the diagnostic connection(s). An application </p>
<p>example is present, see chapter 8.5.1. </p>
<p> </p>
<p> </p>
<p><b>3.6.3 </b></p>
<p><b>Dynamic Objects </b></p>
<p>The MultiConnection Tp uses the “dynamic TxID” functionality </p>
<p>(Dynamic TxID </p>
<p></p>
<p> On) </p>
<p>of the CAN-</p>
<p>Driver. However, you can specify additional dynamic objects for your application. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>51 / 177 </p>
<p> </p>
<p> </p>
<p><b>Important </b></p>
<p>If you want to add dynamic objects for your application you have just to enter your count </p>
<p>of dynamic objects. The Generation Tool adds the usage of dynamic objects for the </p>
<p>MultiConnection Tp automatically. </p>
<p> </p>
<p><b>3.6.4 </b></p>
<p><b>TP class Dynamic MultiTP: Normal Addressing  </b></p>
<p><b>3.6.4.1 </b></p>
<p><b>CANdriver settings </b></p>
<p> </p>
<p> </p>
<p><b>Important </b></p>
<p>Actually the Generation Tool will not setup the reception messages automatically. The </p>
<p>user itself has to insert for each message, which should be processed by the TP (or for </p>
<p>a range of messages) a ‘TpPrecopy’-function. Please refer the CAN-driver manual </p>
<p>/CANdrv/ how to insert a Precopy-function. </p>
<p> </p>
<p> </p>
<p><b>3.6.5 </b></p>
<p><b>TP class Dynamic MultiTP: Extended Addressing  </b></p>
<p><b>3.6.5.1 </b></p>
<p><b>TP class specific settings </b></p>
<p>  </p>
<p> </p>
<p>Figure 3-13 Misc (Extended Addressing) </p>
<p><b>Own ECU number </b></p>
<p>It will be read out from the database attribute ‘TpOwnSystemEcuNumber’. </p>
<p><b>Lowest functional address </b></p>
<p>The </p>
<p>value </p>
<p>should </p>
<p>define </p>
<p>the </p>
<p>lowest </p>
<p>value </p>
<p>of </p>
<p>an </p>
<p>additional </p>
<p>range </p>
<p>of </p>
<p>receivable </p>
<p>TargetAddresses. </p>
<p>Not supported – use instead the hook function </p>
<p>ApplTpCheckTA()</p>
<p> </p>
<p><b>Highest functional address </b></p>
<p>The </p>
<p>value </p>
<p>should </p>
<p>define </p>
<p>the </p>
<p>highest </p>
<p>value </p>
<p>of </p>
<p>an </p>
<p>additional </p>
<p>range </p>
<p>of </p>
<p>receivable </p>
<p>TargetAddresses. </p>
<p>Not supported – use instead the hook function </p>
<p>ApplTpCheckTA()</p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>52 / 177 </p>
<p><b>3.6.5.2 </b></p>
<p><b>Database Attributes </b></p>
<p> </p>
<p><b>Name </b></p>
<p><b>Default </b></p>
<p><b>No TP used </b></p>
<p><b>Normal </b></p>
<p><b>Extended </b></p>
<p><b>(example) </b></p>
<p>TpNodeBaseAddress </p>
<p>FFFF </p>
<p>Default </p>
<p>Default </p>
<p>0x600 </p>
<p>TpOwnSystemEcuNumber </p>
<p>FF </p>
<p>Default </p>
<p>Default </p>
<p>0x01 </p>
<p>TpNodeMesageCount </p>
<p>FF </p>
<p>Default </p>
<p>Default </p>
<p>0xff </p>
<p>Table 3-2 </p>
<p>  Data Base Attributes </p>
<p><b>TpNodeBaseAddress </b></p>
<p>The not valid value FFFF indicates, that there is no base address necessary. </p>
<p> </p>
<p><b>TpOwnSystemEcuNumber </b></p>
<p>This value provides the own ECU Number, necessary for setting up the transmit identifier. </p>
<p> </p>
<p><b>TpNodeMessageCount </b></p>
<p>This value determines how many messages are assigned to the ‘range’ together with the </p>
<p>base address. This is necessary for the TP to calculate to which base the received CAN ID </p>
<p>is assigned. </p>
<p>The values for extended addressing are just an example: </p>
<p>The CAN ID for this node is 0x600 + 0x01 = 0x601. </p>
<p><b>3.6.5.3 </b></p>
<p><b>Multiple Base Addresses </b></p>
<p>For each connection a dedicated base address including an address offset and a message  </p>
<p>count can be specified.   </p>
<p><b>3.6.6 </b></p>
<p><b>TP class Dynamic MultiTP: Normal Fixed Addressing </b></p>
<p><b>3.6.6.1 </b></p>
<p><b>Database Attributes </b></p>
<p> </p>
<p>    </p>
<p> </p>
<p>Figure 3-14 Database attributes for ‘Normal Fixed Addressing’  </p>
<p><b>TpOwnSystemEcuNumber </b></p>
<p>Each ECU is represented in the network by an address / EcuNumber. If the  EcuNumber </p>
<p>0xff is used the TP activates the ‘Multiple EcuNumber’ feature (refer 7.4.1 Virtual ECU’s). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>53 / 177 </p>
<p><b>TpNodeBaseAddress </b></p>
<p>This attribute includes the upper 13 bits (like priority, PGN) of the CAN-ID.  </p>
<p><b>3.6.7 </b></p>
<p><b>TP class Dynamic MultiTP: Mixed 29-bit Addressing </b></p>
<p>Currently open – support is only for generation tool GENy requested  </p>
<p><b>3.6.8 </b></p>
<p><b>TP class Dynamic MultiTP: Multiple Addressing  </b></p>
<p>In this TP class it is possible to change the addressing mode in run-time. </p>
<p><b>3.6.8.1 </b></p>
<p><b>Addressing mode </b></p>
<p>  </p>
<p> </p>
<p>Figure 3-15 Addressing mode (Multiple Addressing) </p>
<p>Only the checked addressing modes will be supported. </p>
<p><b>3.6.8.2 </b></p>
<p><b>CAN Driver settings </b></p>
<p>To  distinguish  the  addressing  mode  while  the  reception  different  Precopy-functions  will </p>
<p>exist for each mode. It is possible to insert the Precopy-function for a message or for a </p>
<p>range of messages (CAN-Driver Ranges). </p>
<p><b>&gt; </b></p>
<p><b>NormalAddressing</b>:   </p>
<p> </p>
<p> </p>
<p> </p>
<p>TpPrecopyNormal&lt;DESTINATION&gt; </p>
<p><b>&gt; </b></p>
<p><b>NormalFixedAddressing</b>:  TpPrecopyNormalFixed&lt;DESTINATION&gt; </p>
<p><b>&gt; </b></p>
<p><b>ExtendedAddressing</b>:   </p>
<p> </p>
<p> </p>
<p>TpPrecopyExtended&lt;DESTINATION&gt; </p>
<p><b>&gt; </b></p>
<p><b>Mixed29Addressing</b>:  </p>
<p> </p>
<p> </p>
<p> </p>
<p>TpPrecopyMixed29&lt;DESTINATION&gt; </p>
<p><b>&gt; </b></p>
<p><b>Mixed11Addressing</b>:  </p>
<p> </p>
<p> </p>
<p> </p>
<p>TpPrecopyMixed11&lt;DESTINATION&gt; </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>Actually the Generation Tool will not setup the reception messages automatically. </p>
<p> </p>
<p>&lt;DESTINATION&gt; is replaced by on of the following strings: </p>
<p><b>&gt; </b></p>
<p>Appl  </p>
<p><b>&gt; </b></p>
<p>DiagFunc </p>
<p><b>&gt; </b></p>
<p>DiagPhys </p>
<p> </p>
<p>These  destinations  identify  the  purpose  of  a  given  connection.  DiagFunc  will  identify  a </p>
<p>functional  Diagnostic  message  (1:n).  DiagPhys  is  representing  the  standard  physical </p>
<p>diagnostic  message  (1:1)  and  Appl  a  standard  TPMC  connection  used  for  application </p>
<p>purpose (1:1). </p>
<p>E.g.: NormalFixedAddressing range 18DA0500 with mask 0xFF which is specified by the </p>
<p>ISO standard as physical range would be configured in the CAN Driver as: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>54 / 177 </p>
<p>TpPrecopyNormalFixedDiagPhys </p>
<p> </p>
<p>Using a dispatcher in combination with two macro functions it is possible to distinguish </p>
<p>inside the TPMC callback function set between a diagnostic or applicational request </p>
<p>message and direct it to the correct component like CANdesc.  </p>
<p> </p>
<p>TpRxGetAddressingFormat(tpChannel)</p>
<p>         </p>
<p>can be used to check against  </p>
<p>#define kTpNormalAddressing </p>
<p>#define kTpExtendedAddressing </p>
<p>#define kTpNormalFixedAddressing </p>
<p>#define kTpMixed29Addressing </p>
<p>#define kTpMixed11Addressing </p>
<p>TpRxGetAssignedDestination( tpChannel)</p>
<p>     </p>
<p>can be used to check against</p>
<p> </p>
<p>#define kTpRequestAppl </p>
<p>#define kTpRequestDiagFunctional </p>
<p>#define kTpRequestDiagPhysical  </p>
<p> </p>
<p> </p>
<p> </p>
<p>Figure 3-16 Dedicated call of Precopy functions in TPMC by the driver. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>55 / 177 </p>
<p><b>3.7 </b></p>
<p><b>TP class Dispatched MultiTP </b></p>
<p>With the release version 3.00.00 of TPMC the “Dispatched” MultiTP class was introduced </p>
<p>to disburden the application from the dispatching job. </p>
<p>Using  the  “Dynamic  MultiTP”  classes,  which  support  only  one  single  set  of  callback </p>
<p>functions for all connections together, the dispatching of the actual destination has to be </p>
<p>performed by the application.  </p>
<p>Using  the  “Dispatched  MultiTP”  classes  all  of  the  dispatching  work  is  done  within  the </p>
<p>TPMC. </p>
<p>“Dispatched MultiTP” is located between static and dynamic TP classes. As well as Static </p>
<p>TP </p>
<p>it </p>
<p>supports </p>
<p>connection </p>
<p>specific </p>
<p>sets </p>
<p>of </p>
<p>callback </p>
<p>functions </p>
<p>and </p>
<p>dispatches </p>
<p>all </p>
<p>connections, regarding the Address Information (AI),  to these callback functions. Just as </p>
<p>Dynamic TP resources are shared among the connections. </p>
<p> </p>
<p>Figure 3-17 Dedicated call of application callback functions in TPMC by the internal dispatcher. </p>
<p> </p>
<p> </p>
<p><b>Info</b> </p>
<p>Please note that all existing applications are unaffected unless the new class is actually </p>
<p>selected in the generation tool. </p>
<p> </p>
<p> </p>
<p>     Dispatched       TPMC </p>
<p>Diag </p>
<p>Appl_1 </p>
<p>Appl_n </p>
<p> </p>
<p>Can Driver </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN 1 </p>
<p>CAN 2 </p>
<p>AI_0 </p>
<p>AI_1 </p>
<p>AI_2 </p>
<p>The configured address information (AI) is  </p>
<p>linked (via a TPMC internal Precopy function) </p>
<p>directly to the destination application. </p>
<p>All connection specific attributes like timeouts, </p>
<p>max. tpChannels, callback function set, etc. are </p>
<p>kept internally in the TPMC. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>56 / 177 </p>
<p><b>3.7.1 </b></p>
<p><b> “Dynamic MultiTP” versus “Dispatched MultiTP” – a short analogy </b></p>
<p><b>3.7.1.1 </b></p>
<p><b>Solution based on “Dynamic MultiTP”: </b></p>
<p>Here  all  dynamic  TpChannels  are  provided  as  a  global  resource  and  shared  by  all </p>
<p>connections.  So,  if  no  Rx  channel  is  currently  available  then  the  incoming  message  is </p>
<p>simply  discarded  by  the  TPMC,  no  reception  will  occur  and  the  application  will  not  be </p>
<p>notified. </p>
<p>Otherwise </p>
<p>the </p>
<p>primal </p>
<p>callback </p>
<p>function </p>
<p>to </p>
<p>map </p>
<p>an </p>
<p>incoming </p>
<p>request </p>
<p>to </p>
<p>a </p>
<p>connection,  the  ‘ApplTpRxGetBuffer’  function,  is  called.  The  addressing  data  statically </p>
<p>configured in GENy is not present for the dispatching application. There is no consistency </p>
<p>provided by the TPMC. </p>
<p>To  perform  this  mapping  the  addressing  information  statically  configured  has  to  be </p>
<p>compared </p>
<p>to </p>
<p>the </p>
<p>currently </p>
<p>received </p>
<p>CAN </p>
<p>message. </p>
<p>The </p>
<p>scope </p>
<p>of </p>
<p>the </p>
<p>addressing </p>
<p>information to be compared can be different and depends on the used addressing type. </p>
<p>If a valid connection is found within the ‘ApplTpRxGetBuffer’ function then a valid pointer to </p>
<p>the  application  buffer  is  handed  to  the  TPMC,  the  FC  status  can  be  set  and  the  FC </p>
<p>addressing  information  must  be  set  for  usage  by  the  TPMC.  The  identified  reception  is </p>
<p>marked while using the ‘TpRxSetConnectionNumber’ API function with a unique number </p>
<p>defined </p>
<p>by </p>
<p>the </p>
<p>application. </p>
<p>To </p>
<p>distinguish </p>
<p>the </p>
<p>connections </p>
<p>in </p>
<p>later </p>
<p>callbacks </p>
<p>(e.g. </p>
<p>ApplTpRxIndication(tpChannel)), the API TpRxGetConnectionNumber(tpChannel) must be </p>
<p>used to get an application relevant handle. The tpChannel handle can and will be different </p>
<p>for each reception. </p>
<p> </p>
<p>Receive Example: (see also chapter 8.5) </p>
<p>  /* get CAN-Id */ </p>
<p>  requestId = TpRxGetChannelID(channel); </p>
<p>  if(requestId == MY_RECEIVE_ID) { </p>
<p>    /* store connection number */ </p>
<p>    TpRxSetConnectionNumber(channel, kMyConnectionNo); </p>
<p>    /* set CAN-Id for response */ </p>
<p>    TpRxSetTransmitID(channel, MY_TRANSMIT_ID); </p>
<p>    pBuf = myTpGetRxBuffer(channel, dataLength); </p>
<p>    /* handle FC status properly */ </p>
<p>    if(pBuf == V_NULL) { </p>
<p>      TpRxSetFCStatus(channel, kTpFCStatusOverflow); </p>
<p>    } </p>
<p>    else { </p>
<p>      TpRxSetFCStatus(channel, kTpFCClearToSend); </p>
<p>    } </p>
<p>  } </p>
<p> </p>
<p>For  the  transmission a Tx  channel  has  to be  allocated, a  connection  number has  to be </p>
<p>assigned and the connection parameters have to be set according to the addressing type </p>
<p>before the transmission can be started. </p>
<p> </p>
<p>Transmit Example: (see also chapter 8.5) </p>
<p>  /* acquire a tx channel */ </p>
<p>vuint8 channel = TpTxGetFreeChannel(kMyConnection0); </p>
<p>if(channel != </p>
<p>kTpNoChannel</p>
<p> ) { </p>
<p>  /* set CAN channel */ </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>57 / 177 </p>
<p>  TpTxSetCanChannel(channel, kMyCanNo); </p>
<p>  /* set CAN identifiers */ </p>
<p>  TpTxSetChannelID(channel, myTxCANId, myRxCANId); /* precalculated CAN Ids */ </p>
<p>  TpTxSetTargetAddress(channel, target_address);    /* extended addressing   */ </p>
<p>  /* trigger the transmission */ </p>
<p>  TpTransmit(channel, data, length); </p>
<p>} </p>
<p> </p>
<p>For all this topics several API functions must be used in a correct manner what may result </p>
<p>in a pretty complex dispatcher to be handled by the application. </p>
<p> </p>
<p><b>3.7.1.2 </b></p>
<p><b>Solution based on “Dispatched MultiTP” </b></p>
<p>Each  connection  group  has  a  configurable  number of TpChannels  reserved  for  its  own. </p>
<p>This offers an improved availability for concurrent receptions with no interference to other </p>
<p>TpChannel resources availability. </p>
<p>All Tp callbacks are dispatched internally in the TPMC. In addition to the passing of a raw </p>
<p>tpChannel a connection handle ‘addrInfoHandle’ is handed to the application. Behind this </p>
<p>‘addrInfoHandle’  all  address  information  is  available  based  on  the  static  configuration </p>
<p>information.  Only  dynamic  runtime  address  information  (e.g.  target  address  in  case  of </p>
<p>Extended- or NormalFixed- addressing) has to be handled extra. </p>
<p> </p>
<p> </p>
<p><b>Info</b> </p>
<p>Please  note  that  all  application  callback  functions  do  not  change  their  API. </p>
<p>Additional  API  functions  are  provided  to  get  the  ‘addressInfoHandle’  from  the </p>
<p>corresponding tpChannel : </p>
<p> </p>
<p>TpRxGetAddressInfoHandle(tpChannel)</p>
<p>: within reception callbacks</p>
<p> </p>
<p> </p>
<p>TpTxGetAddressInfoHandle(tpChannel)</p>
<p>: within transmission callbacks </p>
<p> </p>
<p>A connection specific precopy function is introduced which is called when the dispatching </p>
<p>is already completed and resulted in exactly the call of this connection specific function. To </p>
<p>identify  the  connection  later  on  just  the  ‘addressInfoHandle’  has  to  be  stored  by  the </p>
<p>application. </p>
<p>The  handles  are  provided  in  the  form  “kTp&lt;Addressing  Info  Name&gt;”  in  the  generated </p>
<p>code.  So  the  application  can  easily  differentiate </p>
<p>within  the  callback  functions  which </p>
<p>connection </p>
<p>is </p>
<p>present </p>
<p>just </p>
<p>by </p>
<p>checking </p>
<p>the </p>
<p>‘addressInfoHandle’ </p>
<p>using </p>
<p>the </p>
<p>API </p>
<p>‘TpRxGetAddressInfoHandle()’. </p>
<p>Please </p>
<p>note </p>
<p>that </p>
<p>the </p>
<p>differentiation </p>
<p>in </p>
<p>the </p>
<p>callback </p>
<p>functions is only necessary if more than one AI is configured for one connection or if the </p>
<p>same  callback  functions  are  configured  for  more  than  one  connection.  Otherwise  the </p>
<p>corresponding callback function is dedicated unambiguously to one connection.  </p>
<p>Of  course  also  here  free  TpChannels  must  be  available  (per  connection  group)  or  the </p>
<p>reception (transmission) will fail. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>58 / 177 </p>
<p>Example:  </p>
<p>The following example shows a “Dispatched Multiple Addressing Multi TP” configuration </p>
<p>containing 3 connections (TpConnection000/001/002). </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>One AI is configured per connection and each connection uses a different addressing type </p>
<p>(Normal-, Extended-, NormalFixed- addressing). </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>59 / 177 </p>
<p>Each connection has an appropriate </p>
<p>connection specific set of callback </p>
<p>functions beneath some other </p>
<p>connection specific attributes. </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>In the generated code the following constants are available for usage by the application. </p>
<p>The connections groups: </p>
<p>#define kTpGroupTpConnection000              0 </p>
<p>#define kTpGroupTpConnection001              1 </p>
<p>#define kTpGroupTpConnection002              2 </p>
<p> </p>
<p>The connection handles: </p>
<p>#define kTpConn0_AI1                         0 </p>
<p>#define kTpConn1_AI2                         1 </p>
<p>#define kTpConn2_AI3                         2 </p>
<p> </p>
<p>The connection specific transmit macros: </p>
<p>#define TpTransmit_Conn0_AI1( data ,length)          \ </p>
<p>TpTransmitNormal(     kTpConn0_AI1, data, length) </p>
<p>#define TpTransmit_Conn1_AI2( TA ,data ,length)      \  </p>
<p>TpTransmitExtended(   kTpConn1_AI2, TA, data, length) </p>
<p>#define TpTransmit_Conn2_AI3( TA ,data ,length)      \ </p>
<p>TpTransmitNormalFixed(kTpConn2_AI3, TA, data, length) </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>60 / 177 </p>
<p> </p>
<p>Now the application can easily differentiate within the connection specific callback </p>
<p>functions and decide how to proceed: </p>
<p> </p>
<p>if(TpRxGetAddressInfoHandle(tpChan) == kTpConn1_AI2) {  </p>
<p>  ...  </p>
<p> </p>
<p>TpTransmit_Conn1_AI2( TA ,data ,length); </p>
<p>  ... </p>
<p>} </p>
<p> </p>
<p> </p>
<p><b>3.7.2 </b></p>
<p><b>Dispatched MultiTP API </b></p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>To avoid collisions it is prohibited to use API-functions from the application site that are </p>
<p>used internally by the TPMC dispatcher.  </p>
<p>This means that all API functions marked as “done internally by TP” in the tables below </p>
<p>are neither necessary nor available anymore! </p>
<p>  </p>
<p><b>3.7.2.1 </b></p>
<p><b>Reception side  </b></p>
<p> </p>
<p><b>Dynamic MultiTP class  </b></p>
<p><b> </b></p>
<p><b>Dispatched MultiTP class </b></p>
<p><b>Since version 3.00.00 </b></p>
<p> TpRxSetConnectionNumber </p>
<p> done internally by TP </p>
<p> TpRxGetConnectionNumber </p>
<p> done internally by TP </p>
<p> TpRxGetAddressingFormat</p>
<p> </p>
<p> TpRxGetAssignedDestination</p>
<p> </p>
<p> done internally by TP </p>
<p> </p>
<p> </p>
<p> TpRxResetChannel </p>
<p> available for application usage </p>
<p> TpRxSetTransmitID </p>
<p> TpRxGetStatus </p>
<p> TpRxSetBS </p>
<p> TpRxGetBS </p>
<p> TpRxSetSTMIN </p>
<p> TpRxGetSTMIN </p>
<p> TpRxGetChannelID </p>
<p> TpRxGetCanChannel </p>
<p> TpRxGetSourceAddress </p>
<p> TpRxGetReceivedTargetAddress </p>
<p> TpRxGetEcuNumber </p>
<p> TpRxSetBufferOverrun </p>
<p> TpRxGetAddressExtension </p>
<p> TpRxGetCanbuffer </p>
<p> TpRxSetWaitCorrectSN </p>
<p> TpRxSetTimeoutConfirmation </p>
<p> TpRxSetTimeoutCF </p>
<p> TpRxSetFCStatus </p>
<p> TpRxGetFCStatus </p>
<p> TpRxSetClearToSend </p>
<p> </p>
<p> </p>
<p> </p>
<p>New API functions for Dispatched classes: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>61 / 177 </p>
<p>Please find a more detailed description in chapter 4. </p>
<p> </p>
<p> TpGetConnectionGroup(AI_handle) </p>
<p> Get the connection group   </p>
<p> (kTpGroup&lt;ConnectionName&gt;) </p>
<p> TpGetAddressingType (AI_handle) </p>
<p> Get the addressing type info (only for multiple  </p>
<p> addressing class): </p>
<p>  kTpNormalAddressing,  </p>
<p>  kTpExtendedAddressing,  </p>
<p>  kTpNormalFixedAddressing, </p>
<p>  kTpMixed11Addressing,  </p>
<p>  kTpMixed29Addressing </p>
<p> TpGetCanChannel(AI_handle) </p>
<p> Get the pertaining CAN channel (only for multiple </p>
<p> CAN channels) </p>
<p> TpGetRxId(          AI_handle) </p>
<p> Get the Rx CAN-Identifier (only for normal  </p>
<p> addressing) </p>
<p> TpGetTxId(          AI_handle) </p>
<p> Get the Tx CAN-Identifier (only for normal  </p>
<p> addressing) </p>
<p> TpGetBaseAddress(   AI_handle) </p>
<p> Get the base address (only for extended   </p>
<p> addressing) </p>
<p> TpGetAddressOffset( AI_handle) </p>
<p> Get the address offset pertaining to a base  </p>
<p> address (only for extended addressing) </p>
<p> TpGetPriority(      AI_handle) </p>
<p> Get the priority info from a 29-bit CAN  </p>
<p> identifier (only for NormalFixed or Mixed29    </p>
<p> addressing) </p>
<p> TpGetPGN(           AI_handle) </p>
<p> Get the parameter group identification from a  </p>
<p> 29-bit CAN identifier (only for NormalFixed or  </p>
<p> Mixed29  addressing) </p>
<p> TpGetEcuNumber(     AI_handle) </p>
<p> Get the ECU address (only for NormalFixed or  </p>
<p> Mixed29  addressing) </p>
<p> </p>
<p> </p>
<p><b>3.7.2.2 </b></p>
<p><b>Transmission side </b></p>
<p> </p>
<p> </p>
<p><b>Info</b> </p>
<p>Please note that the TpTransmit function is the only API that has to be adapted in the </p>
<p>application code. </p>
<p> </p>
<p> </p>
<p><b>Dynamic MultiTP class  </b></p>
<p><b> </b></p>
<p><b>Dispatched MultiTP class </b></p>
<p><b>Since version 3.00.00 </b></p>
<p>TpTxSetChannelID </p>
<p>done internally by TP </p>
<p>TpTxSetCanChannel </p>
<p>done internally by TP </p>
<p>TpTxSetTargetAddress </p>
<p>done internally by TP </p>
<p>TpTxSetEcuNumber </p>
<p>done internally by TP </p>
<p>TpTxSetBaseAddress </p>
<p>done internally by TP </p>
<p>TpTxGetFreeChannel </p>
<p>done internally by TP </p>
<p>TpTxSetAddressingFormat </p>
<p>done internally by TP </p>
<p>TpTxGetConnectionNumber </p>
<p>done internally by TP </p>
<p>TpTxGetConnectionStatus </p>
<p>done internally by TP </p>
<p>TpTxSetAddressExtension </p>
<p>done internally by TP </p>
<p>TpTxSetResponse </p>
<p>done internally by TP </p>
<p>TpTxLockChannel </p>
<p>done internally by TP  </p>
<p>(see note </p>
<p>1.)</p>
<p> below) </p>
<p>TpTxUnlockChannel </p>
<p>TpTransmit </p>
<p>Either you can use the generated connection </p>
<p>specific macros: </p>
<p>TpTransmit_&lt;ConnectionName&gt;(data,len),  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>62 / 177 </p>
<p>TpTransmit_&lt;ConnectionName&gt;(TA,data,len),  </p>
<p>TpTransmit_&lt;ConnectionName&gt;(AE,data,len),  </p>
<p>TpTransmit_&lt;ConnectionName&gt;(TA,AE,data,len), </p>
<p> </p>
<p>or directly the referenced functions:  </p>
<p>TpTransmitNormal     (AI, data, len), </p>
<p>TpTransmitExtended   (AI, TA, data, len), </p>
<p>TpTransmitNormalFixed(AI, TA, data, len), </p>
<p>TpTransmitMixed11    (AI, AE, data, len), </p>
<p>TpTransmitMixed29    (AI, TA, AE, data, len). </p>
<p> </p>
<p>Please refer to the API description in </p>
<p>chapter 4. </p>
<p> </p>
<p> </p>
<p>TpTxGetDataBuffer </p>
<p>available for application usage </p>
<p>TpTxGetDataIndex </p>
<p>TpTxResetChannel </p>
<p>TpTxGetSTminInFrame </p>
<p>TpTxPrepareSendImmediate </p>
<p>TpTxSendImmediate </p>
<p>TpRxSetStrictFlowControl </p>
<p>1.) </p>
<p>Note: The Locking and Unlocking of tpChannels is no longer necessary. Due to the possibility to configure </p>
<p>a connection with a dedicated exclusive tpChannel the tpChannel resource is ‘locked’ implicitly. </p>
<p> </p>
<p> </p>
<p>New API functions for Dispatched classes: </p>
<p>Please find a more detailed description in chapter 4. </p>
<p> </p>
<p> </p>
<p>TpTransmitNormal</p>
<p>(       AI_handle,data,len) </p>
<p>Instead of using the addressing type </p>
<p>specific transmit functions we recommend </p>
<p>to use the connection specific macros </p>
<p>which are generated. </p>
<p> </p>
<p>TpTransmitExtended</p>
<p>(     AI_handle,data,len) </p>
<p> </p>
<p>TpTransmitNormalFixed( </p>
<p>AI_handle,data,len) </p>
<p> </p>
<p>TpTransmitMixed11(     </p>
<p>AI_handle,data,len </p>
<p> </p>
<p>TpTransmitMixed29(     </p>
<p>AI_handle,data,len </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>63 / 177 </p>
<p><b>4 </b></p>
<p><b>API </b></p>
<p><b>4.1 </b></p>
<p><b>Use of ISO15765-Transport Protocol </b></p>
<p>Please use the services of the ISO15765 Transport Protocol in your application according </p>
<p>to the instructions in this manual. </p>
<p>Please  include  the  tpmc.h  definition  file  in  all  modules  requiring  Transport  Protocol </p>
<p>Services. All  available  services,  the  types  for  the  interface,  and  symbolic  constants  are </p>
<p>defined in this file.  </p>
<p>After a power on reset and before any other call of the Transport Protocol the function void </p>
<p>TpInitPowerOn(void)</p>
<p>  has  to  be  called. The main program  of the Transport  Protocol </p>
<p>TpTxTask()</p>
<p> and </p>
<p>TpRxTask()</p>
<p><b> </b>has to be called periodically by the application.  </p>
<p>All other services of the Transport Protocol are called on those points in your application </p>
<p>where services are required. </p>
<p> </p>
<p><b>4.2 </b></p>
<p><b>Functions of the Transport Protocol </b></p>
<p>Field description of the following tables </p>
<p><b>Name of the function  </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>Function prototype for SingleConnectionTP </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>Function prototype for MultipleConnectionTP </p>
<p><b>Parameter </b></p>
<p>Name of the parameter </p>
<p>Description of the parameter </p>
<p><b>Return code </b></p>
<p>name  </p>
<p>Meaning of the return code </p>
<p><b>Availability </b></p>
<p>The API is included in all versions, except a restriction is given here </p>
<p><b>Description </b></p>
<p>Explanation of the functionality </p>
<p><b>Pre-condition(s) </b></p>
<p>Required preconditions before the function can be used.  </p>
<p><b>Post-condition(s) </b></p>
<p>If a state change was done, it will be described here </p>
<p><b>Call context </b></p>
<p>The restrictions from where the function can be used are described here.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>64 / 177 </p>
<p><b>Please note </b></p>
<p>Some additional notes </p>
<p><b>Examples </b></p>
<p>A short code example is given </p>
<p> </p>
<p><b>4.2.1 </b></p>
<p><b>Administrative Functions </b></p>
<p><b>4.2.1.1 </b></p>
<p><b>TpInitPowerOn: Initialization </b></p>
<p><b>TpInitPowerOn  </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpInitPowerOn  </b>( void ) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpInitPowerOn  </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Availability </b></p>
<p>No restrictions  </p>
<p><b>Description </b></p>
<p>Power On Initialization of the TP. This function has to be called before all other functions of the Transport </p>
<p>Protocol once after Power On. </p>
<p><b>Pre-condition(s) </b></p>
<p>Global interrupts are disabled and CAN-driver with function </p>
<p>CanInitPowerOn()</p>
<p> and are initialized </p>
<p>correctly. </p>
<p><b>Post-condition(s) </b></p>
<p>The Transport Layer is ready for reception after calling </p>
<p>TpInitPowerOn()</p>
<p>. </p>
<p><b>Call context </b></p>
<p>Background-loop level with global disabled interrupts </p>
<p><b>Please note </b></p>
<p>Call the </p>
<p>TpInitPowerOn()</p>
<p> before the application wants to reserve own dynamic transmission objects. </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>65 / 177 </p>
<p><b>4.2.1.2 </b></p>
<p><b>TpInit: Re-initialization </b></p>
<p><b>TpInit  </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpInit  </b>( void ) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpInit </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Availability </b></p>
<p>No restrictions  </p>
<p><b>Description </b></p>
<p>The Transport Layer is re-initialized after calling </p>
<p>TpInit()</p>
<p><b>. </b></p>
<p><b>Pre-condition(s) </b></p>
<p>TpInitPowerOn()</p>
<p><b> </b>was called before. No TP functionality is used at this time. </p>
<p><b>Post-condition(s) </b></p>
<p>The Transport Layer is re-initialized after calling </p>
<p>TpInit().</p>
<p> </p>
<p><b>Call context </b></p>
<p>Background-loop level with global disabled interrupts </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p><b>4.2.1.3 </b></p>
<p><b>TpTask:  Observing timing conditions </b></p>
<p><b>TpTask  </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void TP_API_CALL_TYPE <b>TpTask</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE <b>TpTask</b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>66 / 177 </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Availability </b></p>
<p>No restrictions  </p>
<p><b>Description </b></p>
<p>Function calls both TpRxTask and TpTxTask in correct order. </p>
<p><b>Pre-condition(s) </b></p>
<p>TpInitPowerOn() </p>
<p>was called before. </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Cyclic task base. </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p><b>4.2.1.4 </b></p>
<p><b>TpCanChannelInit: CAN channel specifiic re-initialization </b></p>
<p><b>TpCanChannelInit </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void TP_API_CALL_TYPE <b>TpCanChannelInit</b>(canuint8 </p>
<p>canChannel) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE <b>TpCanChannelInit</b>(canuint8 </p>
<p>canChannel) </p>
<p><b>Parameter </b></p>
<p>canChannel</p>
<p> </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Availability </b></p>
<p>Since TPMC version 2.41</p>
<p> </p>
<p><b>Description </b></p>
<p>Any reception / transmission on this CAN channel will be stopped. If a connection was running the </p>
<p>application will be informed by calling the function </p>
<p>ApplTpXxErrorIndication().</p>
<p> </p>
<p><b>Pre-condition(s) </b></p>
<p>TpInitPowerOn() was called before. No TP functionality is used at this time. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>67 / 177 </p>
<p><b>Post-condition(s) </b></p>
<p>All running TP channels on this CAN channel are re-initialized. </p>
<p><b>Call context </b></p>
<p>Background-loop level with global disabled interrupts </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p><b>4.2.1.5 </b></p>
<p><b>TpRxTask: time base for reception timeouts </b></p>
<p><b>TpRxTask </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpRxTask</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpRxTask</b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Availability </b></p>
<p>No restrictions</p>
<p> </p>
<p><b>Description </b></p>
<p>The function </p>
<p>TpRxTask() </p>
<p>has to be called periodically (cycle time T</p>
<p>TpRxCallCycle</p>
<p>) by the application. This </p>
<p>function performs all Rx-Tasks of the Transport Layer and monitors the timings. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Background-loop level or OSEK-osTask with low priority. </p>
<p><b>Important note: </b>This function <b>must not </b>be called in interrupt context! </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>68 / 177 </p>
<p><b>4.2.1.6 </b></p>
<p><b>TpTxTask: time base for timeouts/transmission </b></p>
<p><b>TpTxTask </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpTxTask</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpTxTask</b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Availability </b></p>
<p>No restrictions</p>
<p> </p>
<p><b>Description </b></p>
<p>The function </p>
<p>TpTxTask()</p>
<p> has to be called periodically (cycle time T</p>
<p>TpTxCallCycle</p>
<p>) by the application. This </p>
<p>function performs all Tx-Tasks of the Transport Layer and monitors the timings. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with </p>
<p>TpInitPowerOn()</p>
<p>. </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Background-loop level or OSEK-OSTask with low priority. </p>
<p><b>Important note: </b>This function <b>must not </b>be called in interrupt context! </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>69 / 177 </p>
<p><b>4.2.1.7 </b></p>
<p><b>TpRxStateTask: optional transmission retry </b></p>
<p><b>TpRxStateTask </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpRxStateTask</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpRxStateTask</b>(vuint8 tpChannel) </p>
<p><b>Parameter </b></p>
<p>tpChannel</p>
<p> </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Availability </b></p>
<p>Since TPMC version 2.35</p>
<p> </p>
<p><b>Description </b></p>
<p>The function </p>
<p>TpRxStateTask()</p>
<p> can be called optionally by the application. This function performs the link </p>
<p>from the Transport Layer to the CAN-Driver. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with </p>
<p>TpInitPowerOn()</p>
<p>. </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b> </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>R </p>
<p> </p>
<p><b>4.2.1.8 </b></p>
<p><b>TpRxAllStateTask: optional transmission retry </b></p>
<p><b>TpRxAllStateTask </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpRxAllStateTask </b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpRxAllStateTask </b>(void) </p>
<p><b>Parameter </b></p>
<p>-</p>
<p> </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>70 / 177 </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Availability </b></p>
<p>Since TPMC version 2.35</p>
<p> </p>
<p><b>Description </b></p>
<p>The function </p>
<p>TpRxAllStateTask()</p>
<p> can be called optionally by the application. This function performs the </p>
<p>link from the Transport Layer to the CAN-Driver for all running Rx-connections. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>  </p>
<p> </p>
<p><b>4.2.1.9 </b></p>
<p><b>TpTxStateTask: optional transmission retry </b></p>
<p><b>TpTxStateTask </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpTxStateTask </b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpTxStateTask </b>(vuint8 tpChannel) </p>
<p><b>Parameter </b></p>
<p>tpChannel</p>
<p> </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Availability </b></p>
<p>Since TPMC version 2.35</p>
<p> </p>
<p><b>Description </b></p>
<p>The function </p>
<p>TpTxStateTask()</p>
<p> can be called optionally by the application. This function performs the link </p>
<p>from the Transport Layer to the CAN-Driver. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with </p>
<p>TpInitPowerOn ()</p>
<p>. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>71 / 177 </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>It is prohibited to call TpTxStateTask () nested. </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p><b>4.2.1.10 </b></p>
<p><b>TpTxAllStateTask: optional transmission retry </b></p>
<p><b>TpTxAllStateTask </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpTxAllStateTask </b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpTxAllStateTask </b>(void) </p>
<p><b>Parameter </b></p>
<p>tpChannel</p>
<p> </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Availability </b></p>
<p>Since TPMC version 2.35</p>
<p> </p>
<p><b>Description </b></p>
<p>The function </p>
<p>TpTxAllStateTask()</p>
<p> can be called optionally by the application. This function performs the </p>
<p>link from the Transport Layer to the CAN-Driver for all running Tx-connections. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with </p>
<p>TpInitPowerOn ()</p>
<p>. </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>72 / 177 </p>
<p><b>4.2.2 </b></p>
<p><b>Receive Functions </b></p>
<p><b>4.2.2.1 </b></p>
<p><b>TpRxSetConnectionNumber: Assign a Connection-Number to a channel </b></p>
<p><b>TpRxSetConnectionNumber </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>-</p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpRxSetConnectionNumber</b>(vuint8 tpChannel,  </p>
<p>void connection) </p>
<p><b>Parameter </b></p>
<p>tpChannel</p>
<p> </p>
<p>Underlying tpChannel used for this connection. </p>
<p>connection </p>
<p>Connection number that shall be assigned to this tpChannel. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP classes</p>
<p> </p>
<p><b>Description </b></p>
<p>This function assigns an application specific connection-number to this tpChannel. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Use this function only inside the callback function </p>
<p><b>ApplTpRxGetBuffer()</b></p>
<p> ! </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>  </p>
<p> </p>
<p><b>4.2.2.2 </b></p>
<p><b>TpRxGetConnectionNumber: Get the Corresponding Connection-Number </b></p>
<p><b>TpRxGetConnectionNumber </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>-</p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>TpRxGetConnectionNumber</b>(vuint8 tpChannel) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>73 / 177 </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p>- </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP classes</p>
<p> </p>
<p><b>Description </b></p>
<p>This function returns the connection-number, which is assigned to this </p>
<p>tpChannel</p>
<p>. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with </p>
<p>TpInitPowerOn()</p>
<p>. </p>
<p>This </p>
<p>tpChannel</p>
<p> is not reset and a connection-number was previously assigned to it by the application. </p>
<p>(See TpRxSetConnectionNumber()) </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>A correct value will only be returned, if a connection number was set previously in the callback function </p>
<p>ApplTpRxGetBuffer() </p>
<p>with </p>
<p>TpRxSetConnectionNumber()</p>
<p>. </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p><b>4.2.2.3 </b></p>
<p><b>TpRxGetAddressingFormat:  Get the current addressing type  </b></p>
<p><b>TpRxGetAddressingFormat </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>- </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>canbittype <b>TpRxGetAddressingFormat</b>(canuint8 </p>
<p>tpChannel) </p>
<p><b>Parameter </b></p>
<p>tpChannel</p>
<p> </p>
<p>Underlying TP channel </p>
<p><b>Return code </b></p>
<p> </p>
<p>One of the following constants (canbittype:3): </p>
<p>#define kTpNormalAddressing        </p>
<p>#define kTpExtendedAddressing      </p>
<p>#define kTpNormalFixedAddressing   </p>
<p>#define kTpMixed29Addressing       </p>
<p>#define kTpMixed11Addressing       </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>74 / 177 </p>
<p><b>Availability </b></p>
<p>Only for Multiple Addressing TP</p>
<p> </p>
<p><b>Description </b></p>
<p>This macro is used to retrieve the required addressing information in a multiple addressing environment.  </p>
<p>Using a dispatcher in combination with the macro function it is possible to distinguish inside the TPMC </p>
<p>callback function set between the different addressing types and handle additional pertaining information. </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Pre-condition(s) </b></p>
<p>A TP Channel is successful allocated. </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p><b>4.2.2.4 </b></p>
<p><b>TpRxGetAssignedDestination:  Get the currently assigned destination  </b></p>
<p><b>TpRxGetAssignedDestination </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>- </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>canbittype <b>TpRxGetAssignedDestination</b>(canuint8 </p>
<p>tpChannel) </p>
<p><b>Parameter </b></p>
<p>tpChannel</p>
<p> </p>
<p>Underlying tp channel </p>
<p><b>Return code </b></p>
<p> </p>
<p>One of the following constants (canbittype:3): </p>
<p>#define kTpRequestAppl            // Application </p>
<p>#define kTpRequestDiagFunctional  // Functional Diag. </p>
<p>#define kTpRequestDiagPhysical    // Physical Diag. </p>
<p>is delivered to differentiate between application, functional or physical diagnostic </p>
<p>requests. </p>
<p><b>Availability </b></p>
<p>Only for Multiple Addressing TP</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>75 / 177 </p>
<p><b>Description </b></p>
<p>This macro is used to retrieve the required destination information in a multiple addressing environment.  </p>
<p>Using a dispatcher in combination with the macro function it is possible to distinguish inside the TPMC </p>
<p>callback function set between the different destinations and handle the correct dispatching of the message </p>
<p>to the pertaining destination. </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Pre-condition(s) </b></p>
<p>A tpChannel is successful allocated. </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.2.2.5 </b></p>
<p><b>TpRxResetChannel: Free Rx-TpChannel </b></p>
<p><b>TpRxResetChannel </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void TP_API_CALL_TYPE <b>TpRxResetChannel</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE <b>TpRxResetChannel</b>(canuint8 </p>
<p>tpChannel) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>-</p>
<p> </p>
<p>- </p>
<p><b>Availability </b></p>
<p>No restriction</p>
<p> </p>
<p><b>Description </b></p>
<p>Each time a transport-frame was received the used channel is blocked. To receive another transport-frame </p>
<p>on this channel the application has to free this channel. </p>
<p>This is, in case of an erroneous reception, not required for the TpRxErrorIndication() callback. </p>
<p>The function is called within or after the Rx-Indication - callback.  </p>
<p>If the application calls the reset-function then the application itself is also responsible to handle the reset </p>
<p>values inside the application in further processing steps.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>76 / 177 </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Background-loop level or OSEK-OSTask with lower or same priority as TpTasks.  </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.2.2.6 </b></p>
<p><b>TpRxGetStatus: Rx-Channel Status </b></p>
<p><b>TpRxGetStatus </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>vuint8 <b>TpRxGetStatus</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>TpRxGetStatus</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p>kTpChannelInUse = 0x01 </p>
<p>kTpChannelNotInUse =0x00</p>
<p> </p>
<p><b>Availability </b></p>
<p>No restriction</p>
<p> </p>
<p><b>Description </b></p>
<p>This function returns the actual status of the Rx-Channel. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>The returned status can have more than two values!  </p>
<p>The InUse-Flag is always coded in the lowest bit (0x01) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>77 / 177 </p>
<p><b>Examples </b></p>
<p>Because it is a status-field there are two possibilities for checking if the channel is InUse: </p>
<p> </p>
<p>if ( TpRxGetStatus(user_channel) != kTpChannelNotInUse ) </p>
<p>{ </p>
<p>... </p>
<p>or: </p>
<p>if ( TpRxGetStatus(user_channel) &amp; kTpChannelInUse ) </p>
<p>{ </p>
<p>...</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.2.2.7 </b></p>
<p><b>TpRxSetBS: Setting up BlockSize on Reception Side  </b></p>
<p><b>TpRxSetBS </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpRxSetBS</b>(vuint8 newBlockSize) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpRxSetBS</b>(vuint8 channel, vuint8 </p>
<p>newBlockSize) </p>
<p><b>Parameter </b></p>
<p>newBlockSize </p>
<p>- </p>
<p>channel </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Extended API-BS must be activated</p>
<p> </p>
<p><b>Description </b></p>
<p>The BlockSize-Value within the FlowControl can be adjusted by this function. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>78 / 177 </p>
<p><b>4.2.2.8 </b></p>
<p><b>TpRxGetBS: Get BlockSize on Reception Side  </b></p>
<p><b>TpRxGetBS </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>vuint8 <b>TpRxGetBS</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>TpRxGetBS</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Extended API-BS must be activated</p>
<p> </p>
<p><b>Description </b></p>
<p>The BlockSize-Value within the FlowControl can be read by this function. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>  </p>
<p> </p>
<p><b>4.2.2.9 </b></p>
<p><b>TpRxSetSTMIN: Setting up STMin time on Reception Side  </b></p>
<p><b>TpRxSetSTMIN </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpRxSetSTMIN</b>(vuint8 newSTMinSize) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpRxSetSTMIN</b>(vuint8 channel, vuint8 </p>
<p>newSTMinSize) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>79 / 177 </p>
<p>newSTMinSize </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Extended API-STMIN must be activated</p>
<p> </p>
<p><b>Description </b></p>
<p>The STmin-Value within the FlowControl can be adjusted by this function. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.2.2.10 </b></p>
<p><b>TpRxGetSTMIN: Get STMin time on Reception Side  </b></p>
<p><b>TpRxGetSTMIN </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>vuint8 <b>TpRxGetSTMIN</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>TpRxGetSTMIN</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Extended API-STMIN must be activated</p>
<p> </p>
<p><b>Description </b></p>
<p>The STmin-Value within the FlowControl can be read by this function. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>80 / 177 </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.2.2.11 </b></p>
<p><b>TpRxGetChannelID: Get Received CAN-Id </b></p>
<p><b>TpRxGetChannelID </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>- </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint16 <b>TpRxGetChannelID</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>- </p>
<p><b>Return code </b></p>
<p> </p>
<p>CAN-ID </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP class: Normal Addressing.</p>
<p> </p>
<p><b>Description </b></p>
<p>This function returns the CAN-Identifier, of the last transport-frame </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>81 / 177 </p>
<p><b>4.2.2.12 </b></p>
<p><b>TpRxGetChannelExtID: Get Received Extended CAN-Id </b></p>
<p><b>TpRxGetChannelExtID </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>- </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint32 <b>TpRxGetChannelExtID</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>- </p>
<p><b>Return code </b></p>
<p> </p>
<p>Extended CAN-ID </p>
<p><b>Availability </b></p>
<p>For  </p>
<p>- Dynamic TP class Normal Addressing and  </p>
<p>- Dispatched Normal Multi TP</p>
<p> </p>
<p><b>Description </b></p>
<p>This function returns the extended CAN-Identifier, of the last transport-frame </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.2.2.13 </b></p>
<p><b>TpRxGetCanChannel: Get physical CAN channel </b></p>
<p><b>TpRxGetCanChannel </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>- </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>TpRxGetCanChannel</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>82 / 177 </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only multiple CAN-channel  systems</p>
<p> </p>
<p><b>Description </b></p>
<p>This function returns the (physical) CAN-channel, through which the last transport-frame has been received. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.2.2.14 </b></p>
<p><b>TpRxGetSourceAddress: Get received Source Address </b></p>
<p><b>TpRxGetSourceAddress </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>vuint8 <b>TpRxGetSourceAddress</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>TpRxGetSourceAddress</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP classes: Extended- and Normal Fixed Addressing</p>
<p> </p>
<p><b>Description </b></p>
<p>This function returns the destination address, which has been received in the last transport-frame. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn() </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>83 / 177 </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>  </p>
<p> </p>
<p><b>4.2.2.15 </b></p>
<p><b>TpRxGetReceivedTargetAddress: Get received Target Address </b></p>
<p><b>TpRxGetReceivedTargetAddress </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>vuint8 <b>TpRxGetReceivedTargetAddress</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>TpRxGetReceivedTargetAddress</b>(vuint8 </p>
<p>channel) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p> </p>
<p><b>Return code </b></p>
<p>TargetAddress </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for TP classes: Extended-, Normal Fixed-, and Mixed addressing with the extended gateway API </p>
<p>enabled. </p>
<p><b>Description </b></p>
<p>This function returns the destination address, which has been received in the last transport-frame. Normally </p>
<p>it is only used for gateway applications. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>   </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>84 / 177 </p>
<p><b>4.2.2.16 </b></p>
<p><b>TpRxGetEcuNumber: Get ECU Number </b></p>
<p><b>TpRxGetEcuNumber </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>vuint8 <b>TpRxGetEcuNumber</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>TpRxGetEcuNumber</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Multiple EcuNumber feature must be activated</p>
<p> </p>
<p><b>Description </b></p>
<p>This function returns the ECU Number, which has been received in the last transport-frame. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>  </p>
<p> </p>
<p><b>4.2.2.17 </b></p>
<p><b>TpRxGetParameterGroupIdentification: Get Identification of PGN </b></p>
<p><b>TpRxGetParameterGroupIdentification </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>vuint8 <b>TpRxGetParameterGroupIdentification</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 </p>
<p><b>TpRxGetParameterGroupIdentification</b>(vuint8 </p>
<p>channel) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>85 / 177 </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>Currently not available. </p>
<p>Only for dynamic TP class: Normal Fixed Addressing with extended API </p>
<p> </p>
<p><b>Description </b></p>
<p>This function returns the Identification of the Parameter Group, which has been received in the last </p>
<p>transport-frame. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p>  </p>
<p> </p>
<p> </p>
<p><b>4.2.2.18 </b></p>
<p><b>TpRxSetBufferOverrun:   Enable partial acceptance </b></p>
<p><b>TpRxSetBufferOverrun </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void TP_API_CALL_TYPE <b>TpRxSetBufferOverrun</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE </p>
<p><b>TpRxSetBufferOverrun</b>(canuint8 tpChannel) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Since TPMC version 2.41.00. The buffer overrun feature must be enabled</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>86 / 177 </p>
<p><b>Description </b></p>
<p>A reception can be received without copying the received data. This could be useful if the reception buffer is </p>
<p>too small, but the request must be received to reject it by a special response. The data of a Single- or </p>
<p>FirstFrame are copied, but no data are copied for ConsecutiveFrames. Due to this a buffer must be provided </p>
<p>with at least the maximum length of Single- or FirstFrame. </p>
<p><b>Pre-condition(s) </b></p>
<p>Only useful if a FF has been received </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Within function </p>
<p>ApplTpRxGetBuffer()</p>
<p> </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p>  </p>
<p> </p>
<p><b>4.2.2.19 </b></p>
<p><b>TpRxSetTransmitID:   Set transmission CAN-Id </b></p>
<p><b>TpRxSetTransmitID </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>-</p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE <b>TpRxSetTransmitID </b></p>
<p>(canuint8 tpChannel, canuint16 transmitID) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p>- </p>
<p>transmitID </p>
<p>CAN-ID  </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only TP-class ‘Dynamic NormalAddressing MultiTP’</p>
<p> </p>
<p><b>Description </b></p>
<p>While receiving a multiple frame request the TP needs the CAN-ID for the transmission of the FlowControl </p>
<p>message. Additionally the Diagnostic/TP will need it to calculate the response transmission </p>
<p>(</p>
<p>TpTxSetResponse()</p>
<p>), why it is necessary to set it each time </p>
<p>ApplTpRxGetBuffer()</p>
<p> gets called. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>Response can be calculated automatically by the Function </p>
<p>TpTxSetResponse().</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>87 / 177 </p>
<p><b>Call context </b></p>
<p>Within function </p>
<p>ApplTpRxGetBuffer()</p>
<p> </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p><b>4.2.2.20 </b></p>
<p><b>TpRxSetTransmitExtID:   Set transmission Extended CAN-Id </b></p>
<p><b>TpRxSetTransmitExtID </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>-</p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE <b>TpRxSetTransmitExtID </b></p>
<p>(canuint8 tpChannel, canuint32 transmitID) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p>- </p>
<p>transmitID </p>
<p>Extended CAN-ID (29 bits) </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only TP-class ‘Dynamic NormalAddressing MultiTP’ and </p>
<p>        TP-class ‘Dispatched NormalAddressing MultiTP’</p>
<p> </p>
<p><b>Description </b></p>
<p>While receiving a multiple frame request the TP needs the CAN-ID for the transmission of the FlowControl </p>
<p>message. Additionally the Diagnostic/TP will need it to calculate the response transmission </p>
<p>(</p>
<p>TpTxSetResponse()</p>
<p>), why it is necessary to set it each time </p>
<p>ApplTpRxGetBuffer()</p>
<p> gets called. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>Response can be calculated automatically by the Function </p>
<p>TpTxSetResponse().</p>
<p> </p>
<p><b>Call context </b></p>
<p>Within function </p>
<p>ApplTpRxGetBuffer()</p>
<p> </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>88 / 177 </p>
<p><b>4.2.2.21 </b></p>
<p><b>TpRxGetChannelIDType:   Get the type of the received CAN-Id </b></p>
<p><b>TpRxGetChannelIDType </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>-</p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>canuint8 TP_API_CALL_TYPE <b>TpRxGetChannelIDType </b></p>
<p>(canuint8 tpChannel) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>canuint8  </p>
<p>Either kTpCanIdTypeStd (11-Bit) or kTpCanIdTypeExt (29-Bit). </p>
<p><b>Availability </b></p>
<p>Only TP-class ‘Dynamic NormalAddressing MultiTP’.</p>
<p> </p>
<p><b>Description </b></p>
<p>If mixed CAN-IDs, as well 11-Bit identifiers as also 29-Bit identifiers are used during runtime then this API </p>
<p>can be used to get the type of the identifier.  </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>Response can be calculated automatically by the Function </p>
<p>TpTxSetResponse().</p>
<p> </p>
<p><b>Call context </b></p>
<p>Within function </p>
<p>ApplTpRxGetBuffer()</p>
<p> </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p><b>4.2.2.22 </b></p>
<p><b>TpRxGetAddressExtension:  Get address extension information </b></p>
<p><b>TpRxGetAddressExtension </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>canuint8 TP_API_CALL_TYPE </p>
<p><b>TpRxGetAddressExtension</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>canuint8 TP_API_CALL_TYPE </p>
<p><b>TpRxGetAddressExtension</b>(canuint8 tpChannel) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>89 / 177 </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p> </p>
<p><b>Availability </b></p>
<p>For mixed 29-bit ID and 11-bit ID addressing</p>
<p> </p>
<p><b>Description </b></p>
<p>This function returns the address extension information from the first byte. </p>
<p><b>Pre-condition(s) </b></p>
<p>Running reception. Valid after callback function ApplTpRxGetBuffer(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.2.2.23 </b></p>
<p><b>TpRxGetCanBuffer:  Get CAN buffer pointer </b></p>
<p><b>TpRxGetCanBuffer </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>CanChipDataPtrTP_API_CALL_TYPE </p>
<p><b>TpRxGetCanBuffer</b>(void); </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>CanChipDataPtr TP_API_CALL_TYPE </p>
<p><b>TpRxGetCanbuffer</b>(canuint8 tpChannel); </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Since TPMC version 2.41.00</p>
<p> </p>
<p><b>Description </b></p>
<p>Returns a pointer to the first payload byte of the last received CAN frame in the hardware data buffer </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>90 / 177 </p>
<p><b>Pre-condition(s) </b></p>
<p>Reception must be in progress </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p>  </p>
<p><b> </b></p>
<p><b>4.2.2.24 </b></p>
<p><b>TpRxSetWaitCorrectSN:  Force to wait for a correct sequence number </b></p>
<p><b>TpRxSetWaitCorrectSN </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void TP_API_CALL_TYPE <b>TpRxSetWaitCorrectSN </b></p>
<p>(tpBool wait); </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE <b>TpRxSetWaitCorrectSN </b></p>
<p>(canuint8 tpChannel, tpBool wait); </p>
<p><b>Parameter </b></p>
<p>tpChannel  </p>
<p>wait </p>
<p>- </p>
<p>kTpTrue, kTpFalse </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Since TPMC version 2.73.00.  </p>
<p>Only for Dynamic TP. </p>
<p>The following constant must be defined via a user-config file</p>
<p>:  </p>
<p>   #define TP_ENABLE_DYN_AWAIT_CORRECT_SN </p>
<p><b>Description </b></p>
<p>The behaviour of the TPMC component in case of a wrong or missing sequence number can be changed: </p>
<p>By default (wait = kTpFalse) the TPMC behaviour is like described in ISO 15765-2.  </p>
<p>By setting the ‘wait’ parameter to  ‘kTpTrue’  the behaviour can be changed  in the way that TPMC does not </p>
<p>re-init the connection, but ignores the current frame and continues waiting  for the correct sequence number. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>91 / 177 </p>
<p><b>Call context </b></p>
<p>Within function </p>
<p>ApplTpRxGetBuffer().</p>
<p> </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p><b>4.2.2.25 </b></p>
<p><b>TpRxSetTimeoutConfirmation:  Set CAN confirmation timeout </b></p>
<p><b>TpRxSetTimeoutConfirmation </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE </p>
<p><i><b>TpRxSetTimeoutConfirmation</b></i>(canuint8 tpChannel, </p>
<p>tTpEngineTimer time); </p>
<p><b>Parameter </b></p>
<p>tpChannel  </p>
<p>time </p>
<p>- </p>
<p>In timer ticks. The TpTask cycle time is equivalent to one timer tick. </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Since TPMC version 2.73.00.  </p>
<p>Only for Dynamic Multi TP. </p>
<p>The following constant must be defined via a user-config file</p>
<p>:  </p>
<p>   #define TP_ENABLE_DYN_CHANNEL_TIMING. </p>
<p><b>Description </b></p>
<p>The CAN message confirmation timeout  value (N_Ar) can be changed dynamical. </p>
<p><b>Pre-condition(s) </b></p>
<p>A tpChannel is successful allocated. </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Within function </p>
<p>ApplTpRxGetBuffer().</p>
<p> </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>92 / 177 </p>
<p> </p>
<p><b>4.2.2.26 </b></p>
<p><b>TpRxSetTimeoutCF:  Set Consecutive Frame confirmation timeout </b></p>
<p><b>TpRxSetTimeoutCF </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE <i><b>TpRxSetTimeoutCF</b></i>(canuint8 </p>
<p>tpChannel, tTpEngineTimer time); </p>
<p><b>Parameter </b></p>
<p>tpChannel  </p>
<p>time </p>
<p>- </p>
<p>In timer ticks. The TpTask cycle time is equivalent to one timer tick. </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Since TPMC version 2.73.00.  </p>
<p>Only for Dynamic Multi TP. </p>
<p>The following constant must be defined via a user-config file</p>
<p>:  </p>
<p>   #define TP_ENABLE_DYN_CHANNEL_TIMING. </p>
<p><b>Description </b></p>
<p>The CF timeout  value (N_Cr) can be changed dynamical. </p>
<p><b>Pre-condition(s) </b></p>
<p>A tpChannel is successful allocated. </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Within function </p>
<p>ApplTpRxGetBuffer().</p>
<p> </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p><b>4.2.2.27 </b></p>
<p><b>TpRxSetFCStatus:  set up Flow Control on reception side </b></p>
<p><b>TpRxSetFCStatus</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void TpRxSetFCStatus(canuint8 FCStatus) </p>
<p>MultipeConnectionTP </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>93 / 177 </p>
<p> </p>
<p>void TpRxSetFCStatus(canuint8 tpChannel, </p>
<p>canuint8 FCStatus) </p>
<p><b>Parameter </b></p>
<p>FCStatus </p>
<p>KTpFCClearToSend </p>
<p>kTpFCStatusWait </p>
<p>kTpFCSupressFrame </p>
<p>kTpFCStatusOverflow </p>
<p>tpChannel </p>
<p> </p>
<p><b>Return code </b></p>
<p> </p>
<p>None </p>
<p><b>Availability </b></p>
<p>Only available with at least one of the following switches defined: </p>
<p>#define TP_ENABLE_FC_WAIT </p>
<p>#define TP_ENABLE_FC_SUPRESS </p>
<p>#define TP_ENABLE_FC_OVERFLOW </p>
<p>Each of these defines corresponds to the belonging status. </p>
<p><b>Description </b></p>
<p>The Flow Control content and also the further behaviour can be adjusted by this function.  </p>
<p>By default the FC status is set to ‘kTpFCClearToSend’. </p>
<p>In case of ‘kTpFCStatusWait’ WaitFrames are sent until an explicit clear to send is initiated with the </p>
<p>corresponding API function ‘</p>
<p>TpRxSetClearToSend()’</p>
<p>. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May only be used within the application callback ‘</p>
<p>ApplTpRxGetBuffer()’.</p>
<p> </p>
<p><b>Please note </b></p>
<p>- </p>
<p> </p>
<p><b>4.2.2.28 </b></p>
<p><b>TpRxGetFCStatus:  get the Flow Control setup on reception side </b></p>
<p><b>TpRxGetFCStatus</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>canuint8 TpRxGetFCStatus(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>canuint8 TpRxGetFCStatus(canuint8 tpChannel) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>94 / 177 </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>One of the possible status constants:  </p>
<p>o</p>
<p> </p>
<p>kTpFCClearToSend,  </p>
<p>o</p>
<p> </p>
<p>kTpFCStatusWait, </p>
<p>o</p>
<p> </p>
<p>kTpFCSupressFrame, </p>
<p>o</p>
<p> </p>
<p>kTpFCStatusOverflow</p>
<p> </p>
<p><b>Availability </b></p>
<p>Only available with at least one of the following switches defined: </p>
<p>#define TP_ENABLE_FC_WAIT </p>
<p>#define TP_ENABLE_FC_SUPRESS </p>
<p>#define TP_ENABLE_FC_OVERFLOW </p>
<p>Each of these defines corresponds to the belonging status. </p>
<p><b>Description </b></p>
<p>The Flow Control content and also the further behaviour of the TP component depends on the FC status.  </p>
<p>With this function the effective FC status can be questioned. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context. </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p><b> </b></p>
<p><b>4.2.2.29 </b></p>
<p><b>TpRxSetClearToSend:  proceed with the transmission after FC wait frames </b></p>
<p><b>TpRxSetClearToSend</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void TpRxSetClearToSend(canuint8 *pBuffer) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TpRxSetClearToSend(canuint8 tpChannel, </p>
<p>canuint8 *pBuffer) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p> </p>
<p><b>Return code </b></p>
<p> </p>
<p>None</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>95 / 177 </p>
<p><b>Availability </b></p>
<p>Only available with the following switch defined: </p>
<p>#define TP_ENABLE_FC_WAIT </p>
<p><b>Description </b></p>
<p>When a request that was delayed previously by sending WaitFrames is now ready for reception, then the </p>
<p>reception can be started with this function.  </p>
<p>The already received data is handed to the application buffer passed as parameter and the transmission of </p>
<p>a FC(CTS) is initiated. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p>An activation of the WaitFames with a previous call of ‘TpRxSetFCStatus(kTpFCStatusWait)’ must have be </p>
<p>done and must still be active (the effective FC status delivered by TpRxGetFCStatus() is  </p>
<p>‘kTpFCStatusWait’.), otherwise this function has no effect. </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context. </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p><b> </b></p>
<p><b>4.2.2.30 </b></p>
<p><b>TpRxWithoutFC:  suppress FC frame usage at the Rx side </b></p>
<p><b>TpRxWithoutFC</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE TpRxWithoutFC(canuint8 tpChannel)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p> </p>
<p><b>Return code </b></p>
<p> </p>
<p>None</p>
<p> </p>
<p><b>Availability </b></p>
<p>Only available for dynamic Tp classes and with the following switch set to kTpOn: </p>
<p>#define TP_USE_RX_CHANNEL_WITHOUT_FC  kTpOn </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>96 / 177 </p>
<p><b>Description </b></p>
<p>If the usage of Flow Control frames on the Rx side shall be avoided then the enabling of this feature can be </p>
<p>used to suppress all further FC frames within a distinct reception. </p>
<p>In this case the suppression of FC frames must be disabled for each new reception by calling this API </p>
<p>function for the belonging tpChannel within the  ApplTpRxGetBuffer() callback function.  </p>
<p>For the reception of Single Frames this aspect is irrelevant.  </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Use this function only inside the callback function </p>
<p><b>ApplTpRxGetBuffer()</b></p>
<p> ! </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>-  </p>
<p> </p>
<p> </p>
<p><b>4.2.2.31 </b></p>
<p><b>TpRxSetPGN: Set Parameter Group Number </b></p>
<p><b>TpRxSetPGN </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpRxSetPGN</b>(vuint8 pgn) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpRxSetPGN</b>(vuint8 tpChannel, vuint8 pgn) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p>- </p>
<p>pgn </p>
<p>Parameter Group Number to be used </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP class Normal Fixed or Mixed-29 addressing.</p>
<p> </p>
<p><b>Description </b></p>
<p>This function sets the Parameter Group Number (bit no. 16 - 23) within an extended 29 bit CAN-Identifer to </p>
<p>be used for the re-transmission of Flow Control frames for the current reception channel in case of a multi </p>
<p>frame reception. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>97 / 177 </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p>   </p>
<p> </p>
<p> </p>
<p><b>4.2.2.32 </b></p>
<p><b>TpRxSetPriorityBits: Set Priority, Data Page and Reserved bits </b></p>
<p><b>TpRxSetPriorityBits </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpRxSetPriorityBits</b>(vuint8 prio,  </p>
<p>                         vuint8 res,  </p>
<p>                         vuint8 dataPage) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpRxSetPriorityBits</b>(vuint8 tpChannel,  </p>
<p>                         vuint8 prio,  </p>
<p>                         vuint8 res,  </p>
<p>                         vuint8 dataPage) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p>- </p>
<p>prio </p>
<p>Priority bits to be used (3 bits from bit position 26-28)  </p>
<p>res </p>
<p>Reserved bit to be used (1 bit on bit position 25)  </p>
<p>dataPage </p>
<p>Data Page bit to be used (1 bit on bit position 24)  </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP class Normal Fixed or Mixed-29 addressing.</p>
<p> </p>
<p><b>Description </b></p>
<p>This function sets beside the Priority Bits (bit no. 26,27,28) also the bits for the ‘Reserved’ bit position (no. </p>
<p>25) and the ‘Data Page’ bit position (no. 24)  within an extended 29 bit CAN-Identifer to be used for the </p>
<p>retransmission of Flow Control frames for the current reception channel in case of a multi frame reception. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>98 / 177 </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>   </p>
<p> </p>
<p><b>4.2.3 </b></p>
<p><b>Transmit Functions </b></p>
<p><b>4.2.3.1 </b></p>
<p><b>TpTxGetFreeChannel: Assign Channel to Connection </b></p>
<p><b>TpTxGetFreeChannel </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>- </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>TpTxGetFreeChannel</b>(vuint8 connection) </p>
<p><b>Parameter </b></p>
<p>connection </p>
<p>- </p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP classes.</p>
<p> </p>
<p><b>Description </b></p>
<p>This function returns a free channel handle, if possible. If no channel was free the return value will be </p>
<p>kTpNoChannel</p>
<p>. The Transport Layer assigns the connection-number to the channel. </p>
<p>The application has got the possibility to get the connection-number by using the function </p>
<p>TpTxGetConnectionNumber(channel)</p>
<p><b>. </b></p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Within function </p>
<p>ApplTpRxGetBuffer().</p>
<p> </p>
<p><b>Please note </b></p>
<p>The connection-numbers starting at </p>
<p><b>0xf0 </b></p>
<p>are reserved for internal usage. </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>99 / 177 </p>
<p><b>4.2.3.2 </b></p>
<p><b>TpTxGetConnectionNumber: Get the assigned Connection-Number </b></p>
<p><b>TpTxGetConnectionNumber </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>- </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>TpTxGetConnectionNumber</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP classes.</p>
<p> </p>
<p><b>Description </b></p>
<p>This function returns the connection-number which is assigned to this channel.  </p>
<p>The application has got the possibility to assign the connection-number by using the function </p>
<p>TpTxGetFreeChannel(connectionNumber)</p>
<p><b>. </b></p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>  </p>
<p> </p>
<p><b>4.2.3.3 </b></p>
<p><b>TpTxGetConnectionStatus: Get the Connection Status </b></p>
<p><b>TpTxGetConnectionStatus </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>- </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>TpTxGetConnectionStatus</b>(vuint8 </p>
<p>connection) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>100 / 177 </p>
<p><b>Parameter </b></p>
<p>connection </p>
<p>- </p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP classes.</p>
<p> </p>
<p><b>Description </b></p>
<p>This function returns the corresponding channel-number if it exits. If no channel is assigned to this </p>
<p>connection the return value is </p>
<p>kTpNoChannel</p>
<p>. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p><b>4.2.3.4 </b></p>
<p><b>TpTxGetTargetAddress:  Get the target address used for transmission  </b></p>
<p><b>TpTxGetTargetAddress</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpTxGetTargetAddress(canuint8 tpChannel) </p>
<p><b>Parameter </b></p>
<p>tpChannel</p>
<p> </p>
<p> </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>Target address.</p>
<p> </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes and NormalFixed-, Extended- or Mixed- Addressing type. </p>
<p>One of the following switches must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_NORMAL_FIXED_ADDRESSING </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_EXTENDED_ADDRESSING </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_MIXED_29_ADDRESSING </p>
<p><b>Description </b></p>
<p>This API function enables the application to appoint confirmations to previously issued transmissions. </p>
<p>Without this API the appointment of confirmations with parallel transmissions and Normal Fixed, Mixed or </p>
<p>Extended addressing is not possible with “Dispatched Multi TP”. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>101 / 177 </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p>Typically used in the application callback functions. </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.2.3.5 </b></p>
<p><b>TpTxGetDataBuffer: Get the assigned Data Buffer </b></p>
<p><b>TpTxGetDataBuffer </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>vuint8 <b>TpTxGetDataBuffer </b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>TpTxGetDataBuffer </b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP classes.</p>
<p> </p>
<p><b>Description </b></p>
<p>This function returns the pointer to the buffer which is assigned to this channel. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>102 / 177 </p>
<p> </p>
<p><b>4.2.3.6 </b></p>
<p><b>TpTxGetDataIndex: Get the assigned Data Index </b></p>
<p><b>TpTxGetDataIndex </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>vuint8 <b>TpTxGetDataIndex </b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>TpTxGetDataIndex </b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p> </p>
<p><b>Availability </b></p>
<p>No restrictions</p>
<p> </p>
<p><b>Description </b></p>
<p>This function returns the current offset into the buffer which is assigned to this channel. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.2.3.7 </b></p>
<p><b>TpTxSetChannelID: Set the CAN Transmit Id </b></p>
<p><b>TpTxSetChannelID </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>-</p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpTxSetChannelID</b>(vuint8 channel,  </p>
<p>                      vuint16 transmitID,  </p>
<p>                      vuint16 receiveID) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>103 / 177 </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>- </p>
<p>transmitID </p>
<p> </p>
<p>receivedID </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP class: Normal Addressing</p>
<p> </p>
<p><b>Description </b></p>
<p>This function sets the transmit CAN-Identifier for the next call of </p>
<p>TpTransmit()</p>
<p>. Also the receive CAN-</p>
<p>Identifier (must be unique) to the corresponding FlowControl is set. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p><b>4.2.3.8 </b></p>
<p><b>TpTxSetChannelExtID: Set the CAN Transmit  Extended Id </b></p>
<p><b>TpTxSetChannelExtID </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>-</p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpTxSetChannelExtID</b>(vuint8 channel,  </p>
<p>                         vuint32 transmitID,  </p>
<p>                         vuint32 receiveID) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>- </p>
<p>transmitID </p>
<p> </p>
<p>receivedID </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>104 / 177 </p>
<p><b>Availability </b></p>
<p>For  </p>
<p>- Dynamic TP class Normal Addressing and  </p>
<p>- Dispatched Normal Multi TP </p>
<p><b>Description </b></p>
<p>This function sets the transmit extended CAN-Identifier (29 bits) for the next call of </p>
<p>TpTransmit()</p>
<p>. Also </p>
<p>the receive extended CAN-Identifier (must be unique) to the corresponding FlowControl is set. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>  </p>
<p> </p>
<p><b>4.2.3.9 </b></p>
<p><b>TpTxSetCanChannel: Set physical CAN Channel </b></p>
<p><b>TpTxSetCanChannel </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpTxSetCanChannel</b>( vuint8 canChannel) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpTxSetCanChannel</b>(vuint8 channel, </p>
<p>                       vuint8 canChannel) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>canChannel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for multiple CAN-channel systems and dynamic TP class.</p>
<p> </p>
<p><b>Description </b></p>
<p>This function sets the (physical) CAN-channel for the next call of </p>
<p>TpTransmit()</p>
<p>. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>105 / 177 </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p>  </p>
<p> </p>
<p><b>4.2.3.10 </b></p>
<p><b>TpTxSetTargetAddress: Set Target Address </b></p>
<p><b>TpTxSetTargetAddress </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpTxSetTargetAddress</b>(vuint8 targetaddress) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpTxSetTargetAddress</b>(vuint8 channel,  </p>
<p>                          vuint8 targetaddress) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>targetaddress </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP classes: Extended- and Normal Fixed Addressing</p>
<p> </p>
<p><b>Description </b></p>
<p>This function sets the destination address for the next call of </p>
<p>TpTransmit()</p>
<p>. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>106 / 177 </p>
<p><b>4.2.3.11 </b></p>
<p><b>TpTxSetEcuNumber: Set ECU Number </b></p>
<p><b>TpTxSetEcuNumber </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpTxSetEcuNumber</b>(vuint8 ecuNr) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpTxSetEcuNumber</b>(vuint8 channel, </p>
<p>                      vuint8 ecuNr) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>- </p>
<p>ecuNr </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP classes: Extended- and Normal Fixed Addressing </p>
<p>‘Multiple EcuNumber’ feature must be activated</p>
<p> </p>
<p><b>Description </b></p>
<p>This function sets the ECU Number for the next call of </p>
<p>TpTransmit().</p>
<p> </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p>  </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.2.3.12 </b></p>
<p><b>TpTxSetBaseAddress: Set Base Address </b></p>
<p><b>TpTxSetEcuNumber </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpTxSetBaseAddress</b>(vuint8 channel, </p>
<p>                        vuint8 baseAddress) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>107 / 177 </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>- </p>
<p>baseAddress </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP classes: Extended  Addressing </p>
<p>‘Multiple EcuNumber’ feature must be activated.</p>
<p> </p>
<p><b>Description </b></p>
<p>This function sets the base address for the next call of </p>
<p>TpTransmit().</p>
<p> </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p>  </p>
<p> </p>
<p><b>4.2.3.13 </b></p>
<p><b>TpTxSetParameterGroupIdentification: Set Identification of PGN </b></p>
<p><b>TpTxSetParameterGroupIdentification </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>-</p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpTxSetParameterGroupIdentification</b>(vuint8 </p>
<p>channel, </p>
<p>                                         vuint8 </p>
<p>identification) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>- </p>
<p>identification </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>108 / 177 </p>
<p><b>Availability </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>Currently not available. </p>
<p>Only for dynamic TP class: Normal Fixed Addressing with extended API </p>
<p> </p>
<p><b>Description </b></p>
<p>This function sets the Identification of the ParameterGroup for the next call of </p>
<p><b>TpTransmit().</b></p>
<p> </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p>   </p>
<p> </p>
<p><b>4.2.3.14 </b></p>
<p><b>TpTxSetPriority: Set Priority of the CAN-Frame </b></p>
<p><b>TpTxSetPriority </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>-</p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpTxSetPriority</b>(vuint8 channel, </p>
<p>                     vuint8 priority) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>- </p>
<p>priority </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>Currently not available. </p>
<p>Only for dynamic TP class: Normal Fixed Addressing with extended API </p>
<p> </p>
<p><b>Description </b></p>
<p>This function sets the Priority of the CAN-Frame for the next call of </p>
<p>TpTransmit().</p>
<p> </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>109 / 177 </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p><b>4.2.3.15 </b></p>
<p><b>TpTxSetResponse: Assemble a Response </b></p>
<p><b>TpTxSetResponse </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>-</p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpTxSetResponse</b>(vuint8 rxChannel,  </p>
<p>                     vuint8 txChannel) </p>
<p><b>Parameter </b></p>
<p>rxChannel </p>
<p>- </p>
<p>txChanel </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP classes.</p>
<p> </p>
<p><b>Description </b></p>
<p>This function assembles a Response based on a received transport-frame for the next call of </p>
<p>TpTransmit().</p>
<p> </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>110 / 177 </p>
<p><b>4.2.3.16 </b></p>
<p><b>TpTransmit: Send a Message </b></p>
<p><b>TpTransmit </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>vuint8 <b>TpTransmit</b>(vuint8* data,  </p>
<p>                  vuint16 count) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>TpTransmit </b>(vuint8  tpChannel,  </p>
<p>                   vuint8* data,  </p>
<p>                   vuint16 count) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p> </p>
<p>Data </p>
<p>Pointer to the data buffer that shall be transmitted. </p>
<p>count </p>
<p>Number of bytes to be transmitted. </p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p>kTpSuccess: No transmission in progress (ready to send) </p>
<p>kTpBusy:    Transmission in progress </p>
<p>kTpFailed:  If the data length is zero or the tpChannel is not allocated.</p>
<p> </p>
<p><b>Availability </b></p>
<p>No restrictions</p>
<p> </p>
<p><b>Description </b></p>
<p>Send a message.  </p>
<p>The Transport Layer decides which transmission protocol (SingleFrame with up to 6/7 data bytes depending </p>
<p>on the addressing type) is used by checking the given count.</p>
<p> </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>After a transmission the channel is released, except the channel is explicitly locked.  </p>
<p>Since version 2.35 the transmission request will be only queued within the context of TpTransmit. The </p>
<p>transmission to the bus starts within the TpTxStateTask (TpTxTask) calls. </p>
<p><b>kTpFailed</b>: In previous versions (2.34.xx and earlier) it is possible that TpTransmit returns ‘kTpFailed’, </p>
<p>because the CANdriver (CanTransmit returns failed) is busy. Starting with version 2.35.00 only dynamic TP-</p>
<p>classes return this value in case of wrong attributes/parameters. </p>
<p><b>kTpBusy</b>: A transmission is already running or GenMsgDelayTime is not kept.  </p>
<p><b>kTpSuccess</b>: Successful queued message that will be transmitted with the next task cycle. </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>111 / 177 </p>
<p><b>4.2.3.17 </b></p>
<p><b>TpTxLockChannel:  Lock Channel  </b></p>
<p><b>TpTxLockChannel </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>-</p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpTxLockChannel</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP classes.</p>
<p> </p>
<p><b>Description </b></p>
<p>If a channel is locked, it will not be released after a transmission. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.2.3.18 </b></p>
<p><b>TpTxUnlockChannel:  Unlock TX Channel </b></p>
<p><b>TpTxUnlockChannel </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>-</p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpTxUnlockChannel</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>112 / 177 </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP classes.</p>
<p> </p>
<p><b>Description </b></p>
<p>Unlock the lock of the channel. The channel will be released with the next call of </p>
<p>TpTxResetChannel()</p>
<p> or </p>
<p>TpTransmit().</p>
<p> </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.2.3.19 </b></p>
<p><b>TpTxResetChannel: Free TX-Channel </b></p>
<p><b>TpTxResetChannel </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void TP_API_CALL_TYPE <b>TpTxResetChannel</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE <b>TpTxResetChannel</b>(canuint8 </p>
<p>tpChannel) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>No rectrictions</p>
<p> </p>
<p><b>Description </b></p>
<p>The channel will be released by the Transport Layer. At the next call of </p>
<p>TpTxGetFreeChannel()</p>
<p> it can be </p>
<p>assigned to another connection. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with </p>
<p>TpInitPowerOn().</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>113 / 177 </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Background-loop level or OSEK-OSTask with lower priority as TpTasks. </p>
<p><b>Please note </b></p>
<p>The tpChannel will be released in any case and immediately.  </p>
<p>If a transmission is in progress the application will be informed by calling the function </p>
<p>ApplTpTxErrorIndication().</p>
<p><b> </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.2.3.20 </b></p>
<p><b>TpTxSetAddressExtension:  Set Address Extension information </b></p>
<p><b>TpTxSetAddressExtension </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void TP_API_CALL_TYPE </p>
<p><b>TpTxSetAddressExtension</b>(canuint8 </p>
<p>addressExtension); </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE </p>
<p><b>TpTxSetAddressExtension</b>(canuint8 tpChannel, </p>
<p>canuint8 addressExtension); </p>
<p><b>Parameter </b></p>
<p>adressExtension </p>
<p>- </p>
<p>tpChannel </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>For mixed 29-bit ID and mixed 11-bit ID addressing</p>
<p> </p>
<p><b>Description </b></p>
<p>This function is used to set the address extension information. </p>
<p><b>Pre-condition(s) </b></p>
<p>This function must be called in advance of calling TpTransmit(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>114 / 177 </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>  </p>
<p> </p>
<p><b>4.2.3.21 </b></p>
<p><b>TpTxGetSTminInFrame:   Get STmin from FC frame </b></p>
<p><b>TpTxGetSTminInFrame </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>canuint8 TP_API_CALL_TYPE </p>
<p><b>TpTxGetSTminInFrame</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>canuint8 TP_API_CALL_TYPE </p>
<p><b>TpTxGetSTminInFrame</b>(canuint8 tpChannel) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>STmin value </p>
<p><b>Availability </b></p>
<p>The STmin value must be taken out of the received FC frames </p>
<p>(TP_USE_STMIN_OF_FC == kTpOn)</p>
<p> and </p>
<p>the fast transmission feature </p>
<p>(TP_USE_FAST_TX_TRANSMISSION == kTpOn) </p>
<p>must be activated.</p>
<p> </p>
<p> </p>
<p><b>Description </b></p>
<p>Function is returning the STmin value of the last FC frame. </p>
<p><b>Pre-condition(s) </b></p>
<p>This function must be called in advance of calling TpTransmit(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>115 / 177 </p>
<p><b>4.2.3.22 </b></p>
<p><b>TpTxPrepareSendImmediate:   Prepare CF transmission by application </b></p>
<p><b>TpTxPrepareSendImmediate </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>TP_EXTERNAL_INLINE canuint8 TP_API_CALL_TYPE </p>
<p><b>TpTxPrepareSendImmediate</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>TP_EXTERNAL_INLINE canuint8 TP_API_CALL_TYPE </p>
<p><b>TpTxPrepareSendImmediate</b>(canuint8 tpChannel) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p>- </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>kTpSuccess, kTpFailed </p>
<p><b>Availability </b></p>
<p>The fast transmission feature </p>
<p>(TP_USE_FAST_TX_TRANSMISSION) </p>
<p>must be set to kTpOn.</p>
<p> </p>
<p><b>Description </b></p>
<p>If the TP is not in the state for preparing a new CF-Frame (i.e. it is waiting for a FC) the function will return a </p>
<p>‘kTpFailed’. Otherwise if the preparation is successful it will return a ‘kTpSuccess’.  </p>
<p><b>Note</b>:   In the case of ‘kTpSuccess’ the application is responsible for the transmission of the next </p>
<p>ConsecutiveFrame. If the application does not call TpTxSendImmediate() the TP stays blocked. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>The call of this function is only allowed in the context of the TpTxCanMessageTransmitted() / ApplTpTxFC() </p>
<p>Hook-function. </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p><b>4.2.3.23 </b></p>
<p><b>TpTxSendImmediate:   Start CF transmission by application </b></p>
<p><b>TpTxSendImmediate </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>TP_EXTERNAL_INLINE void TP_API_CALL_TYPE </p>
<p><b>TpTxSendImmediate</b>(void) </p>
<p>MultipeConnectionTP </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>116 / 177 </p>
<p> </p>
<p>TP_EXTERNAL_INLINE void TP_API_CALL_TYPE </p>
<p><b>TpTxSendImmediate</b>(canuint8 tpChannel) </p>
<p><b>Parameter </b></p>
<p> </p>
<p>- </p>
<p><b>Return code </b></p>
<p> </p>
<p> </p>
<p><b>Availability </b></p>
<p>The fast transmission feature </p>
<p>(TP_USE_FAST_TX_TRANSMISSION) </p>
<p>must be set to kTpOn.</p>
<p> </p>
<p><b>Description </b></p>
<p>Prepares the ConsecutiveFrame and calls the TpTxStateTask() to transmit the frame. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p><b>4.2.3.24 </b></p>
<p><b>TpTxSetAddressingFormat:  Store the current addressing type  </b></p>
<p><b>TpTxSetAddressingFormat </b></p>
<p><b>Prototype </b></p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE </p>
<p><b>TpTxSetAddressingFormat</b>(canuint8 tpChannel, </p>
<p>SupportInfoStruct supportInfo) </p>
<p><b>Parameter </b></p>
<p>tpChannel</p>
<p> </p>
<p>- </p>
<p>supportInfo </p>
<p> </p>
<p><b>Return code </b></p>
<p> </p>
<p>- </p>
<p><b>Availability </b></p>
<p>Multiple Addressing TP</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>117 / 177 </p>
<p><b>Description </b></p>
<p>This function is used to prepare the required addressing information in a multiple addressing environment </p>
<p>and internally to assign a given connection to the right component.</p>
<p>  </p>
<p>#define kTpNormalAddressing        </p>
<p>#define kTpExtendedAddressing      </p>
<p>#define kTpNormalFixedAddressing   </p>
<p>#define kTpMixed29Addressing       </p>
<p>#define kTpMixed11Addressing       </p>
<p>#define kTpRequestAppl            // Application connection </p>
<p>#define kTpRequestDiagFunctional  // Functional Diag connect. </p>
<p>#define kTpRequestDiagPhysical    // Physical Diag connection </p>
<p>SupportInfoStruct supportInfo; </p>
<p>supportInfo.addressingFormat     = kTpNormalAddressing; </p>
<p>supportInfo.assignedDestination  = kTpRequestDiagPhysical; </p>
<p>TpTxSetAddressingFormat(DiagPhysChannel, supportInfo);</p>
<p> </p>
<p><b>Pre-condition(s) </b></p>
<p>A tpChannel is successful allocated. </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p><b>4.2.3.25 </b></p>
<p><b>TpTxSetStrictFlowControl:  Enable/Disable ISO conformant FC handling </b></p>
<p><b>TpTxSetStrictFlowControl </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void TP_API_CALL_TYPE <b>TpTxSetStrictFlowControl </b></p>
<p>(tpBool strict) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE <b>TpRxSetStrictFlowControl </b></p>
<p>(canuint8 tpChannel, tpBool strict) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p> </p>
<p>- </p>
<p>strict </p>
<p>kTpTrue, kTpFalse </p>
<p><b>Return code </b></p>
<p> </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>118 / 177 </p>
<p><b>Availability </b></p>
<p>Since TPMC version 2.73.00.  </p>
<p>Only for Dynamic TP. </p>
<p>The following constant must be defined via a user-config file</p>
<p>:  </p>
<p>   #define TP_ENABLE_FC_MSG_FLOW_DYN_CHECK. </p>
<p><b>Description </b></p>
<p>The behaviour of the TPMC component in case of a missing FC frame can be changed: </p>
<p>By default (strict = kTpTrue) the TPMC behaviour is like described in ISO 15765-2.  </p>
<p>By setting the ‘strict’ parameter to  ‘kTpFalse’  the behaviour can be changed in the way  that TPMC does </p>
<p>not re-init the connection, but ignores the current frame in case of a missing FC. </p>
<p><b>Pre-condition(s) </b></p>
<p>A tpChannel is successful allocated. </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Call before </p>
<p>TpTransmit()</p>
<p> </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p><b>4.2.3.26 </b></p>
<p><b>TpTxSetTimeoutConfirmation:  Set the CAN confirmation timeout </b></p>
<p><b>TpTxSetTimeoutConfirmation </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE </p>
<p><i><b>TpTxSetTimeoutConfirmation</b></i>(canuint8 tpChannel, </p>
<p>tTpEngineTimer time) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p> </p>
<p>- </p>
<p>Time </p>
<p>In timer ticks. The TpTask cycle time is equivalent to one timer tick.  </p>
<p><b>Return code </b></p>
<p> </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>119 / 177 </p>
<p><b>Availability </b></p>
<p>Since TPMC version 2.73.00.  </p>
<p>Only for Dynamic Multi TP. </p>
<p>The following constant must be defined via a user-config file</p>
<p>:  </p>
<p>   #define TP_ENABLE_DYN_CHANNEL_TIMING. </p>
<p><b>Description </b></p>
<p>The CAN message confirmation timeout (N_As) value can be changed dynamical. </p>
<p><b>Pre-condition(s) </b></p>
<p>A tpChannel is successful allocated. </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Call before TpTransmit(). </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p><b>4.2.3.27 </b></p>
<p><b>TpTxSetTimeoutFC:  Set the FC confirmation timeout </b></p>
<p><b>TpTxSetTimeoutFC </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE <i><b>TpTxSetTimeoutFC</b></i>(canuint8 </p>
<p>tpChannel, tTpEngineTimer time) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p> </p>
<p>- </p>
<p>Time </p>
<p>In timer ticks. The TpTask cycle time is equivalent to one timer tick.  </p>
<p><b>Return code </b></p>
<p> </p>
<p>- </p>
<p><b>Availability </b></p>
<p>Since TPMC version 2.73.00.  </p>
<p>Only for Dynamic Multi TP. </p>
<p>The following constant must be defined via a user-config file</p>
<p>:  </p>
<p>   #define TP_ENABLE_DYN_CHANNEL_TIMING. </p>
<p><b>Description </b></p>
<p>The FC timeout value (N_Bs) can be changed dynamical per channel. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>120 / 177 </p>
<p><b>Pre-condition(s) </b></p>
<p>A tpChannel is successful allocated. </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Call before TpTransmit(). </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>  </p>
<p><b>4.2.3.28 </b></p>
<p><b>TpTxWithoutFC:  suppress FC frame usage at the Tx side </b></p>
<p><b>TpTxWithoutFC</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void TP_API_CALL_TYPE TpTxWithoutFC(canuint8 tpChannel)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p> </p>
<p><b>Return code </b></p>
<p> </p>
<p>None</p>
<p> </p>
<p><b>Availability </b></p>
<p>Only available for dynamic Tp classes and with the following switch set to kTpOn: </p>
<p>#define TP_USE_TX_CHANNEL_WITHOUT_FC  kTpOn </p>
<p><b>Description </b></p>
<p>If the usage of Flow Control frames on the Tx side shall be avoided then the enabling of this feature can be </p>
<p>used to suppress all further FC frames within a distinct transmission. </p>
<p>In this case the suppression of FC frames must be disabled for each new transmission by calling this API </p>
<p>function for the belonging tpChannel before calling TpTransmit.  </p>
<p>For the transmission of Single Frames this aspect is irrelevant.  </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Call from task context before calling TpTransmit. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>121 / 177 </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>-  </p>
<p> </p>
<p><b>4.2.3.29 </b></p>
<p><b>TpTxSetPGN: Set Parameter Group Number </b></p>
<p><b>TpTxSetPGN </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpTxSetPGN</b>(vuint8 pgn) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpTxSetPGN</b>(vuint8 tpChannel, vuint8 pgn) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p>- </p>
<p>pgn </p>
<p>Parameter Group Number to be used </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP class Normal Fixed or Mixed-29 addressing.</p>
<p> </p>
<p><b>Description </b></p>
<p>This function sets the parameter group number (bit no. 16 - 23) within an extended 29 bit CAN-Identifer for </p>
<p>the next call of </p>
<p><b>TpTransmit().</b></p>
<p> </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>122 / 177 </p>
<p>   </p>
<p><b>4.2.3.30 </b></p>
<p><b>TpTxSetPriorityBits: Set Priority, Data Page and Reserved bits </b></p>
<p><b>TpTxSetPriorityBits </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>TpTxSetPriorityBits</b>(vuint8 prio,  </p>
<p>                         vuint8 res,  </p>
<p>                         vuint8 dataPage) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>TpTxSetPriorityBits</b>(vuint8 tpChannel,  </p>
<p>                         vuint8 prio,  </p>
<p>                         vuint8 res,  </p>
<p>                         vuint8 dataPage) </p>
<p><b>Parameter </b></p>
<p>tpChannel </p>
<p>- </p>
<p>prio </p>
<p>Priority bits to be used (3 bits from bit position 26-28)  </p>
<p>res </p>
<p>Reserved bit to be used (1 bit on bit position 25)  </p>
<p>dataPage </p>
<p>Data Page bit to be used (1 bit on bit position 24)  </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP class Normal Fixed or Mixed-29 addressing.</p>
<p> </p>
<p><b>Description </b></p>
<p>This function sets beside the Priority Bits (bit no. 26,27,28) also the bits for the ‘Reserved’ bit position (no. </p>
<p>25) and the ‘Data Page’ bit position (no. 24) within an extended 29 bit CAN-Identifer for the next call of </p>
<p><b>TpTransmit().</b></p>
<p> </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>   </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>123 / 177 </p>
<p><b>4.3 </b></p>
<p><b>Dispatched Multi TP class API </b></p>
<p> </p>
<p><b>4.3.1 </b></p>
<p><b>TpGetConnectionGroup:  Get the connection group identification </b></p>
<p><b>TpGetConnectionGroup</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpGetConnectionGroup(canuint8 addressInfoHandle) </p>
<p><b>Parameter </b></p>
<p>addressInfoHandle</p>
<p> </p>
<p> </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>kTpGroup&lt;ConnectionName&gt; constant </p>
<p> </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes. </p>
<p>One of the following switches must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_NORMAL_ADDRESSING </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_EXTENDED_ADDRESSING </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_NORMAL_FIXED_ADDRESSING </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_MIXED_29_ADDRESSING </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_MULTIPLE_ADDRESSING </p>
<p><b>Description </b></p>
<p>Deliver the appropriate connection group identification as a constant. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p>Typically used in the application callback functions. </p>
<p><b>Please note </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>124 / 177 </p>
<p><b>4.3.2 </b></p>
<p><b>TpGetAddressingType:  Get the addressing type identification </b></p>
<p><b>TpGetAddressingType</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpGetAddressingType(canuint8 addressInfoHandle) </p>
<p><b>Parameter </b></p>
<p>addressInfoHandle</p>
<p> </p>
<p> </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>One of the possible status constants:  </p>
<p> kTpNormalAddressing,  </p>
<p> kTpExtendedAddressing,  </p>
<p> kTpNormalFixedAddressing, </p>
<p> kTpMixed29Addressing</p>
<p> </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes and “Multiple Addressing” type. </p>
<p>The following switch must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_MULTIPLE_ADDRESSING </p>
<p><b>Description </b></p>
<p>Deliver the appropriate addressing type as a constant. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p>Typically used in the application callback functions. </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>125 / 177 </p>
<p><b>4.3.3 </b></p>
<p><b>TpGetCanChannel:  Get the CAN channel </b></p>
<p><b>TpGetCanChannel</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpGetCanChannel(canuint8 addressInfoHandle) </p>
<p><b>Parameter </b></p>
<p>addressInfoHandle</p>
<p> </p>
<p> </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>Number of the CAN channel.</p>
<p> </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes and multiple CAN channels configured. </p>
<p>One of the following switches must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_NORMAL_ADDRESSING </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_EXTENDED_ADDRESSING </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_NORMAL_FIXED_ADDRESSING </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_MIXED_29_ADDRESSING </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_MULTIPLE_ADDRESSING </p>
<p> </p>
<p><b>Description </b></p>
<p>Deliver the appropriate CAN channel. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p>Typically used in the application callback functions. </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>126 / 177 </p>
<p><b>4.3.4 </b></p>
<p><b>TpGetRxId:  Get the received CAN-Id  </b></p>
<p><b>TpGetRxId</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpGetRxId(canuint8 addressInfoHandle) </p>
<p><b>Parameter </b></p>
<p>addressInfoHandle</p>
<p> </p>
<p> </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>CAN identifier.</p>
<p> </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes and “Normal Addressing” type. </p>
<p>The following switches must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_NORMAL_ADDRESSING </p>
<p><b>Description </b></p>
<p>Deliver the appropriate Rx CAN identifier. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p>Typically used in the application callback functions. </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.3.5 </b></p>
<p><b>TpGetTxId:  Get the CAN-Id to be used for transmission  </b></p>
<p><b>TpGetTxId</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpGetTxId(canuint8 addressInfoHandle) </p>
<p><b>Parameter </b></p>
<p>addressInfoHandle</p>
<p> </p>
<p> </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>CAN identifier.</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>127 / 177 </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes and “Normal Addressing” type. </p>
<p>The following switches must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_NORMAL_ADDRESSING </p>
<p><b>Description </b></p>
<p>Deliver the appropriate Tx CAN identifier. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p>Typically used in the application callback functions. </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p><b>4.3.6 </b></p>
<p><b>TpGetBaseAddress:  Get the Base Address   </b></p>
<p><b>TpGetBaseAddress</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpGetBaseAddress(canuint8 addressInfoHandle) </p>
<p><b>Parameter </b></p>
<p>addressInfoHandle</p>
<p> </p>
<p> </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>Base address.</p>
<p> </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes and “Extended Addressing” type. </p>
<p>The following switches must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_EXTENDED_ADDRESSING </p>
<p><b>Description </b></p>
<p>Deliver the appropriate base address. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>128 / 177 </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p>Typically used in the application callback functions. </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p><b>4.3.7 </b></p>
<p><b>TpGetAddressOffest:  Get the Address Offset   </b></p>
<p><b>TpGetAddressOffset</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpGetAddressOffset(canuint8 addressInfoHandle) </p>
<p><b>Parameter </b></p>
<p>addressInfoHandle</p>
<p> </p>
<p> </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>Address offset.</p>
<p> </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes and “Extended Addressing” type. </p>
<p>The following switches must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_EXTENDED_ADDRESSING </p>
<p><b>Description </b></p>
<p>Deliver the appropriate address offset. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p>Typically used in the application callback functions. </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>The address 0x06F0 is separated in 2 parts:  </p>
<p>- base address  0x0600 and </p>
<p>- address offset 0x00F0 </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>129 / 177 </p>
<p><b>4.3.8 </b></p>
<p><b>TpGetPriority:  Get the priority info from a 29 bit CAN-Id   </b></p>
<p><b>TpGetPriority</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpGetPriority(canuint8 addressInfoHandle) </p>
<p><b>Parameter </b></p>
<p>addressInfoHandle</p>
<p> </p>
<p> </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>Priority value (0..7)</p>
<p> </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes and “NormalFixed Addressing” or “Mixed29” addressing  </p>
<p>type. </p>
<p>The following switches must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_NORMAL_FIXED_ADDRESSING </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_MIXED_29_ADDRESSING </p>
<p><b>Description </b></p>
<p>Deliver the appropriate address offset. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p>Typically used in the application callback functions. </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>-  </p>
<p> </p>
<p> </p>
<p><b>4.3.9 </b></p>
<p><b>TpGetPGN:  Get the parameter group identification from a 29 bit CAN-Id   </b></p>
<p><b>TpGetPGN</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpGetPGN(canuint8 addressInfoHandle) </p>
<p><b>Parameter </b></p>
<p>addressInfoHandle</p>
<p> </p>
<p> </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>PGN value.</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>130 / 177 </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes and “NormalFixed Addressing” or “Mixed29” addressing  </p>
<p>type. </p>
<p>The following switches must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_NORMAL_FIXED_ADDRESSING </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_MIXED_29_ADDRESSING </p>
<p><b>Description </b></p>
<p>Deliver the appropriate address offset. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p>Typically used in the application callback functions. </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>-  </p>
<p> </p>
<p> </p>
<p><b>4.3.10 </b></p>
<p><b>TpGetEcuNumber:  Get the ECU number   </b></p>
<p><b>TpGetEcuNumber</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpGetEcuNumber(canuint8 addressInfoHandle) </p>
<p><b>Parameter </b></p>
<p>addressInfoHandle</p>
<p> </p>
<p> </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>ECU number.</p>
<p> </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes and “NormalFixed Addressing” or “Mixed29” addressing  </p>
<p>type. </p>
<p>The following switches must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_NORMAL_FIXED_ADDRESSING </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_MIXED_29_ADDRESSING </p>
<p><b>Description </b></p>
<p>Deliver the appropriate ECU number. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>131 / 177 </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p>Typically used in the application callback functions. </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>-  </p>
<p> </p>
<p><b>4.3.11 </b></p>
<p><b>TpTransmit </b></p>
<p> </p>
<p>There are two alternatives available to transmit data. Either you use the generated </p>
<p>connection specific  TpTransmit macros or you use the addressing type specific functions </p>
<p>behind the macros. </p>
<p> </p>
<p><b>4.3.11.1 </b></p>
<p><b>TpTransmit connection specific macros </b></p>
<p>The data pointer (type canuint8) and the data length (type canuint16) are always </p>
<p>necessary. Depending on the addressing type additional information like the Target </p>
<p>Address (TA) for Extended / NormalFixed addressing  or the Address Extension (AE) for </p>
<p>Mixed addressing is necessary. </p>
<p> </p>
<p><b>Addressing </b></p>
<p><b>Type </b></p>
<p><b>Macro name </b></p>
<p>Normal  </p>
<p>TpTransmit_&lt;ConnectionName&gt;(canuint8  data,  </p>
<p>                            canuint16 len) </p>
<p>Extended  </p>
<p>TpTransmit_&lt;ConnectionName&gt;(canuint8  TA, </p>
<p>                            canuint8  data, </p>
<p>                            canuint16 len) </p>
<p>NormalFixed </p>
<p>Mixed29 </p>
<p>TpTransmit_&lt;ConnectionName&gt;(canuint8  TA, </p>
<p>                            canuint8  AE, </p>
<p>                            canuint8  data, </p>
<p>                            canuint8  len) </p>
<p> </p>
<p> </p>
<p><b>4.3.11.2 </b></p>
<p><b>TpTransmitNormal:  transmit function for normal addressing    </b></p>
<p><b>TpTransmitNormal</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpTransmitNormal(canuint8  addressInfoHandle,  </p>
<p>                 canuint8  data,  </p>
<p>                 canuint16 length) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>132 / 177 </p>
<p><b>Parameter </b></p>
<p>addressInfoHandle</p>
<p> </p>
<p> </p>
<p>data </p>
<p>Pointer to the transmit data. </p>
<p>length </p>
<p>Length of the transmit data (in bytes). </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>kTpSuccess:  </p>
<p>No transmission in progress (ready to send) </p>
<p>kTpBusy:     </p>
<p> </p>
<p>Transmission in progress </p>
<p>kTpFailed:   </p>
<p> </p>
<p>Data length is zero </p>
<p>kTpNoChannel: No TP channel available</p>
<p> </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes. </p>
<p>The following switch must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_NORMAL_ADDRESSING </p>
<p><b>Description </b></p>
<p>Send the data with the given length to the CAN bus. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>-  </p>
<p> </p>
<p> </p>
<p><b>4.3.11.3 </b></p>
<p><b>TpTransmitExtended:  transmit function for extended addressing    </b></p>
<p><b>TpTransmitExtended</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpTransmitExtended(canuint8  addressInfoHandle,  </p>
<p>                   canuint8  TA,  </p>
<p>                   canuint8  data,  </p>
<p>                   canuint16 length) </p>
<p><b>Parameter </b></p>
<p>addressInfoHandle</p>
<p> </p>
<p> </p>
<p>TA </p>
<p>Target Address. </p>
<p>data </p>
<p>Pointer to the transmit data. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>133 / 177 </p>
<p>length </p>
<p>Length of the transmit data (in bytes). </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>kTpSuccess:  </p>
<p>No transmission in progress (ready to send), </p>
<p>kTpBusy:     </p>
<p> </p>
<p>Transmission in progress, </p>
<p>kTpFailed:   </p>
<p> </p>
<p>Data length is zero, </p>
<p>kTpNoChannel: No TP channel available.</p>
<p> </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes. </p>
<p>The following switch must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_EXTENDED_ADDRESSING </p>
<p><b>Description </b></p>
<p>Send the data with the given length to the CAN bus. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>-  </p>
<p> </p>
<p> </p>
<p><b>4.3.11.4 </b></p>
<p><b>TpTransmitNormalFixed:  transmit function for NormalFixed addressing    </b></p>
<p><b>TpTransmitNormalFixed</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpTransmitNormalFixed(canuint8  addressInfoHandle,  </p>
<p>                      canuint8  TA,  </p>
<p>                      canuint8  data,  </p>
<p>                      canuint16 length)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>addressInfoHandle</p>
<p> </p>
<p> </p>
<p>TA </p>
<p>Target Address. </p>
<p>data </p>
<p>Pointer to the transmit data. </p>
<p>length </p>
<p>Length of the transmit data (in bytes). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>134 / 177 </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>kTpSuccess:  No transmission in progress (ready to send) </p>
<p>kTpBusy:      </p>
<p>Transmission in progress </p>
<p>kTpFailed:    </p>
<p>Data length is zero </p>
<p>kTpNoChannel: No tpChannel available </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes. </p>
<p>The following switch must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_NORMAL_FIXED_ADDRESSING </p>
<p><b>Description </b></p>
<p>Send the data with the given length to the CAN bus. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>-  </p>
<p> </p>
<p> </p>
<p><b>4.3.11.5 </b></p>
<p><b>TpTransmitMixed29:  transmit function for Mixed-29 addressing    </b></p>
<p><b>TpTransmitMixed29</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpTransmitMixed29(canuint8  addressInfoHandle,  </p>
<p>                  canuint8  TA,  </p>
<p>                  canuint8  AE,  </p>
<p>                  canuint8  data,  </p>
<p>                  canuint16 length) </p>
<p><b>Parameter </b></p>
<p>addressInfoHandle</p>
<p> </p>
<p> </p>
<p>TA </p>
<p>Target Address. </p>
<p>AE </p>
<p>Address Extension. </p>
<p>data </p>
<p>Pointer to the transmit data. </p>
<p>length </p>
<p>Length of the transmit data (in bytes). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>135 / 177 </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>kTpSuccess:   </p>
<p>No transmission in progress (ready to send), </p>
<p>kTpBusy:      </p>
<p> </p>
<p>Transmission in progress, </p>
<p>kTpFailed:    </p>
<p> </p>
<p>Data length is zero, </p>
<p>kTpNoChannel: No TP channel available. </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes. </p>
<p>The following switch must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_MIXED_29_ADDRESSING </p>
<p><b>Description </b></p>
<p>Send the data with the given length to the CAN bus. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>-  </p>
<p> </p>
<p><b>4.3.11.6 </b></p>
<p><b>TpTransmitMixed29:  transmit function for Mixed-29 addressing    </b></p>
<p><b>TpTransmitMixed29</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpTransmitMixed29(canuint8  addressInfoHandle,  </p>
<p>                  canuint8  TA,  </p>
<p>                  canuint8  AE,  </p>
<p>                  canuint8  data,  </p>
<p>                  canuint16 length) </p>
<p><b>Parameter </b></p>
<p>addressInfoHandle</p>
<p> </p>
<p> </p>
<p>TA </p>
<p>Target Address. </p>
<p>AE </p>
<p>Address Extension. </p>
<p>data </p>
<p>Pointer to the transmit data. </p>
<p>length </p>
<p>Length of the transmit data (in bytes). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>136 / 177 </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>kTpSuccess:   </p>
<p>No transmission in progress (ready to send), </p>
<p>kTpBusy:      </p>
<p> </p>
<p>Transmission in progress, </p>
<p>kTpFailed:    </p>
<p> </p>
<p>Data length is zero, </p>
<p>kTpNoChannel: No TP channel available. </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes. </p>
<p>The following switch must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_MIXED_29_ADDRESSING </p>
<p><b>Description </b></p>
<p>Send the data with the given length to the CAN bus. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>-  </p>
<p>  </p>
<p> </p>
<p><b>4.3.11.7 </b></p>
<p><b>TpTransmitMixed11:  transmit function for Mixed-11 addressing    </b></p>
<p><b>TpTransmitMixed29</b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p> </p>
<p>TpTransmitMixed11(canuint8  addressInfoHandle,  </p>
<p>                  canuint8  AE,  </p>
<p>                  canuint8  data,  </p>
<p>                  canuint16 length) </p>
<p><b>Parameter </b></p>
<p>addressInfoHandle</p>
<p> </p>
<p> </p>
<p>AE </p>
<p>Address Extension. </p>
<p>data </p>
<p>Pointer to the transmit data. </p>
<p>length </p>
<p>Length of the transmit data (in bytes). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>137 / 177 </p>
<p><b>Return code </b></p>
<p>canuint8 </p>
<p>kTpSuccess:   </p>
<p>No transmission in progress (ready to send) </p>
<p>kTpBusy:      </p>
<p> </p>
<p>Transmission in progress </p>
<p>kTpFailed:    </p>
<p> </p>
<p>Data length is zero </p>
<p>kTpNoChannel: No TP channel available </p>
<p><b>Availability </b></p>
<p>Only available for “Dispatched Multi TP” classes and at least one AI with mixed-11 as addressing type </p>
<p>The following switch must be defined: </p>
<p>#define TP_TYPE_MULTI_DISPATCHED_MULTIPLE_ADDRESSING </p>
<p><b>Description </b></p>
<p>Send the data with the given length to the CAN bus. </p>
<p><b>Pre-condition(s) </b></p>
<p>The TP is initialized with TpInitPowerOn(). </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>May be used in application context.  </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>-  </p>
<p> </p>
<p><b>4.4 </b></p>
<p><b>Application callback functions </b></p>
<p>In the Generation Tool the user can define which callback functions he would like to use </p>
<p>from the Transport Protocol. The names can be adjusted by the user. E.g. the prefix <b>User </b></p>
<p>can be used instead of <b>Appl. </b>These functions will only be provided, if they were configured </p>
<p>in the Generation Tool what can be done by entering a function name. </p>
<p><b>4.4.1 </b></p>
<p><b>Reception side </b></p>
<p><b>4.4.1.1 </b></p>
<p><b>ApplTpPrecopyCheck: Reception of TP-Frame </b></p>
<p><b>ApplTpPrecopyCheck </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>canuint8 </p>
<p><b>ApplTpPrecopyCheck </b></p>
<p>( CanRxInfoStructPtr rxStruct ) </p>
<p>Single Receive Buffer </p>
<p>canuint8 </p>
<p><b>ApplTpPrecopyCheck </b></p>
<p>( CanReceiveHandle rxObject ) </p>
<p>Multiple Receive Buffer </p>
<p>canuint8 </p>
<p><b>ApplTpPrecopyCheck </b></p>
<p>( CanChipDataPtr rxRegPtr ) </p>
<p>Multi Channel </p>
<p>Indexed (MRC) </p>
<p>canuint8 <b>ApplTpPrecopyCheck </b>( CanRxInfoStructPtr rxStruct </p>
<p>) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>138 / 177 </p>
<p>Code replicated (SRB) </p>
<p>canuint8 <b>ApplTpPrecopyCheck </b>( CanReceiveHandle rxObject ) </p>
<p>Code replicated (MRB) </p>
<p>canuint8 <b>ApplTpPrecopyCheck </b>( CanChipDataPtr rxRegPtr ) </p>
<p><b>Parameter </b></p>
<p>rxObject </p>
<p>Handle of received object </p>
<p>rxRegPtr </p>
<p>Pointer to the received data in the CAN Controller receive register </p>
<p>rxStruct </p>
<p>Pointer to the receive structure </p>
<p><b>Return code </b></p>
<p>kCanCopyData </p>
<p>Received data will be copied using the CAN Driver 's internal copy mechanism </p>
<p>kCanNoCopyData</p>
<p> </p>
<p>CAN Driver doesn’t copy data and doesn’t perform indication </p>
<p><b>Availability </b></p>
<p>since versions: TPMC: 2.35.00 | CANgen: 3.88.02 | DBKOMgen: 2.37.01</p>
<p> </p>
<p><b>Description </b></p>
<p>Special functions for the application, which is immediately called after the reception of a TP-CAN-message. </p>
<p>If e.g. several CAN-Ids are defined in an ECU for the TP (gateway or multiple ECU) it has to be decided, </p>
<p>before the TP is able to make use of the CAN-message, whether the current CAN-message should be </p>
<p>processed or not depending on the CAN-ID. This user- check function can be used for it, which is called by </p>
<p>the TP on each data reception. </p>
<p>If this function returns „1“, the CAN-message is processed by the TP. </p>
<p>If this function returns „0“, the CAN- message is dismissed by the TP and the process is finished. </p>
<p>The name of this callback-function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>139 / 177 </p>
<p><b>4.4.1.2 </b></p>
<p><b>ApplTpCheckTA:  Check if Target Address is valid (version &lt;= 2.72.00) </b></p>
<p><b>ApplTpCheckTA </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>vuint8 </p>
<p><b>ApplTpCheckTA</b></p>
<p> (vuint8 tpCurrentTargetAddress)</p>
<p> </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 </p>
<p><b>ApplTpCheckTA</b></p>
<p> (vuint8 tpCurrentTargetAddress)</p>
<p> </p>
<p>SingleConnectionTp GATEWAY API </p>
<p> </p>
<p>vuint8 </p>
<p><b>ApplTpCheckTA</b></p>
<p> (vuint8 tpCurrentTargetAddress,  </p>
<p>                      CanRxInfoStructPtr infoStruct)</p>
<p> </p>
<p>MultipeConnectionTP GATEWAY API </p>
<p> </p>
<p>vuint8 </p>
<p><b>ApplTpCheckTA</b></p>
<p> (vuint8 tpCurrentTargetAddress, </p>
<p>                      CanRxInfoStructPtr infoStruct)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>tpCurrentTargetAddress </p>
<p>- </p>
<p>infoStruct </p>
<p> </p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p>- </p>
<p><b>Availability </b></p>
<p>Only for TP versions less than or equal to 2.72.00. See also chapter  4.4.1.3 for the changed API description </p>
<p>available since version 2.73.00. </p>
<p>Only for dynamic TP classes: Extended- and Normal Fixed Addressing</p>
<p> </p>
<p><b>Description </b></p>
<p>This function will be called for every reception of a TP-CAN-message. Within this function the application has </p>
<p>to decide, if the TargetAddress in the received CAN-frame is valid. If the TargetAddress is not valid and </p>
<p>should not be received the return value must be ‘kTpNoChannel’. If it should be received the TargetAddress </p>
<p>should be returned. See also chapter 7.4.1 Virtual ECU’s / ‘Multiple EcuNumber’ feature. </p>
<p>The name of this callback-function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>Until versions: TPMC: 2.35.00 | CANgen: 3.88.02 | DBKOMgen: 2.37.01the function name was called </p>
<p>ApplTpPrecopy()</p>
<p><b> </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>140 / 177 </p>
<p><b>4.4.1.3 </b></p>
<p><b> </b></p>
<p><b>ApplTpCheckTA:  Check if Target Address is valid (since version 2.73.00) </b></p>
<p><b>ApplTpCheckTA </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>t_ta_type <b>ApplTpCheckTA </b>(vuint8 tpCurrentTargetAddress) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>t_ta_type <b>ApplTpCheckTA </b>(vuint8 tpCurrentTargetAddress) </p>
<p>SingleConnectionTp GATEWAY API </p>
<p> </p>
<p>t_ta_type <b>ApplTpCheckTA </b>(vuint8 tpCurrentTargetAddress,  </p>
<p>                         CanRxInfoStructPtr infoStruct) </p>
<p>MultipeConnectionTP GATEWAY API </p>
<p> </p>
<p>t_ta_type <b>ApplTpCheckTA </b>(vuint8 tpCurrentTargetAddress, </p>
<p>                         CanRxInfoStructPtr infoStruct) </p>
<p><b>Parameter </b></p>
<p>tpCurrentTargetAddress </p>
<p>- </p>
<p>infoStruct </p>
<p> </p>
<p><b>Return code </b></p>
<p>t_ta_type</p>
<p> </p>
<p>typedef enum  </p>
<p>{ </p>
<p>  kTpNone = 0, </p>
<p>  kTpPhysical = 1, </p>
<p>  kTpFunctional = 2 </p>
<p>} t_ta_type;</p>
<p> </p>
<p><b>Availability </b></p>
<p>Only for TP versions greater than or equal to 2.73.00. See also the former API description in chapter  4.4.1.2 </p>
<p>Only for dynamic TP classes: Extended- and Normal Fixed Addressing</p>
<p> </p>
<p><b>Description </b></p>
<p>This function will be called for every reception of a TP-CAN-message. Within this function the application has </p>
<p>to decide, if the TargetAddress in the received CAN-frame is valid and if it is a physical or functional identifer..  </p>
<p>If the TargetAddress is not valid and should not be received the return value must be ‘kTpNone’.  </p>
<p>If the TargetAddress is identified as a physical identifier then ‘kTpPhysical’ should be returned.  </p>
<p>If the TargetAddress is identified as a functional identifier then ‘kTpFunctional’ should be returned.  </p>
<p>See also chapter 7.4.1 Virtual ECU’s / ‘Multiple EcuNumber’ feature. </p>
<p>The name of this callback-function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>141 / 177 </p>
<p><b>Please note </b></p>
<p>Until versions: TPMC: 2.35.00 | CANgen: 3.88.02 | DBKOMgen: 2.37.01the function name was called </p>
<p>ApplTpPrecopy()</p>
<p><b> </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p><b>4.4.1.4 </b></p>
<p><b>ApplTpRxSF:   Reception of Single Frame </b></p>
<p><b>ApplTpRxSF </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>ApplTpRxSF</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>ApplTpRxSF</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>- </p>
<p><b>Return code </b></p>
<p> </p>
<p>- </p>
<p><b>Availability </b></p>
<p>No restriction</p>
<p> </p>
<p><b>Description </b></p>
<p>This function is called after the reception of a single-frame. ApplTpRxGetBuffer() will be called before. </p>
<p>The name of this callback-function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>142 / 177 </p>
<p><b>4.4.1.5 </b></p>
<p><b>ApplTpRxFF:   Reception of First Frame </b></p>
<p><b>ApplTpRxFF </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>ApplTpRxFF </b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>ApplTpRxFF</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>- </p>
<p><b>Return code </b></p>
<p> </p>
<p>- </p>
<p><b>Availability </b></p>
<p>No restriction</p>
<p> </p>
<p><b>Description </b></p>
<p>This function is called after the reception of a first-frame. ApplTpRxGetBuffer() will be called before. </p>
<p>The name of this callback function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.4.1.6 </b></p>
<p><b>ApplTpRxCF:   Reception of Consecutive Frame </b></p>
<p><b>ApplTpRxCF </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>ApplTpRxCF</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>ApplTpRxCF</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>143 / 177 </p>
<p><b>Return code </b></p>
<p> </p>
<p>- </p>
<p><b>Availability </b></p>
<p>No restriction</p>
<p> </p>
<p><b>Description </b></p>
<p>This function is called after the reception of a consecutive-frame. </p>
<p>The name of this callback function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.4.1.7 </b></p>
<p><b>ApplTpRxCanMessageReceived:   Reception of CAN-Frame </b></p>
<p><b>ApplTpRxCanMessageReceived </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>ApplTpRxCanMessageReceived</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>ApplTpRxCanMessageReceived</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>- </p>
<p><b>Return code </b></p>
<p> </p>
<p>- </p>
<p><b>Availability </b></p>
<p>until versions: TPMC: 2.35.00 CANgen: 3.88.02 DBKOMgen: 2.37.01 </p>
<p>Will be not supported in the future.</p>
<p> </p>
<p><b>Description </b></p>
<p>This function  is called after the reception of a CAN-frame and is normally used only in gateways. </p>
<p>The name of this callback function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>144 / 177 </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>  </p>
<p> </p>
<p><b>4.4.1.8 </b></p>
<p><b>ApplTpRxGetBuffer:   Assign a buffer to a channel </b></p>
<p><b>TpTxSetStrictFlowControl </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>unsigned char* <b>ApplTpRxGetBuffer</b>(vuint16 dataLength) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>unsigned char* <b>ApplTpRxGetBuffer</b>(vuint8 channel, </p>
<p>                                 vuint16 dataLength) </p>
<p>SingleConnectionTp GATEWAY API </p>
<p> </p>
<p>unsigned char* <b>ApplTpRxGetBuffer</b>(vuint16 dataLength </p>
<p>                             CanRxInfoStructPtr rxStruct) </p>
<p>MultipeConnectionTP GATEWAY API </p>
<p> </p>
<p>unsigned char* <b>ApplTpRxGetBuffer</b>(vuint8 channel, </p>
<p>                             vuint16 dataLength </p>
<p>                             CanRxInfoStructPtr rxStruct) </p>
<p><b>Parameter </b></p>
<p>dataLength </p>
<p>- </p>
<p>channel  </p>
<p> </p>
<p>rxStruct </p>
<p> </p>
<p><b>Return code </b></p>
<p>usigned char </p>
<p>- </p>
<p><b>Availability </b></p>
<p>No restriction</p>
<p> </p>
<p><b>Description </b></p>
<p>This function is called after reception of the first data to get a buffer with a minimum length of </p>
<p>dataLength</p>
<p> </p>
<p>from the application. The application has to return a pointer to this buffer. If the returned pointer is </p>
<p>NULL</p>
<p>, the </p>
<p>transport-message will not be received anymore. </p>
<p>The name of this callback function can be adjusted as desired in the Generation Tool. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>145 / 177 </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p><b>4.4.1.9 </b></p>
<p><b>ApplTpRxCopyFromCAN:   Application Copy Function </b></p>
<p><b>ApplTpRxCopyFromCAN </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>ApplTpRxCopyFromCan</b>(vuint8 * source, </p>
<p>                         vuint16 count) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>ApplTpRxCopyFromCan</b>(vuint8 channel, </p>
<p>                         vuint8 * source, </p>
<p>                         vuint16 count) </p>
<p><b>Parameter </b></p>
<p>Source </p>
<p>- </p>
<p>Count </p>
<p> </p>
<p>channel </p>
<p> </p>
<p><b>Return code </b></p>
<p> </p>
<p>- </p>
<p><b>Availability </b></p>
<p>No restriction</p>
<p> </p>
<p><b>Description </b></p>
<p>The buffer management is done by the application. This function is always called by the Transport Protocol </p>
<p>while receiving a TP-CAN-message. </p>
<p>The argument <b>source </b>points to the receive buffer of the CAN-controller; the argument <b>count </b>determines </p>
<p>number of data, which has to be copied by the application function. </p>
<p>The name of this callback-function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>146 / 177 </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>void ApplTpRxCopyFromCan(vuint8 channel, vuint8 * source, vuint16 count) </p>
<p>{ </p>
<p>  (void)memcpy(&amp;(TpRxGetDataBuffer(channel)[TpRxGetDataIndex(channel)]),  </p>
<p>               source, count); </p>
<p>}</p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.4.1.10 </b></p>
<p><b>ApplTpRxIndication:   Reception closed  successful </b></p>
<p><b>ApplTpRxIndication </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>ApplTpRxIndication</b>(vuint16 dataLength) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>ApplTpRxIndication</b>(vuint8 channel,  </p>
<p>                        vuint16 dataLength) </p>
<p><b>Parameter </b></p>
<p>dataLength </p>
<p>- </p>
<p>channel </p>
<p> </p>
<p><b>Return code </b></p>
<p> </p>
<p>- </p>
<p><b>Availability </b></p>
<p>No restriction</p>
<p> </p>
<p><b>Description </b></p>
<p>This function is called after the completely reception of a single frame message or a multiple frame </p>
<p>message. </p>
<p>dataLength </p>
<p>is the number of received bytes in the reception buffer.  </p>
<p>The name of this callback function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>147 / 177 </p>
<p><b>4.4.1.11 </b></p>
<p><b>ApplTpRxErrorIndication:   Reception closed with error </b></p>
<p><b>ApplTpRxErrorIndication </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>ApplTpRxErrorIndication</b>(vuint8 errorCode) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>ApplTpRxErrorIndication</b>(vuint8 channel, </p>
<p>                             vuint8 errorCode) </p>
<p><b>Parameter </b></p>
<p>errorCode  </p>
<p><b>&gt; </b></p>
<p>kTpRxErrFF_SfreceivedAgain: While a reception is in progress a </p>
<p>new  </p>
<p><b>&gt; </b></p>
<p>Single- or FirstFrame is received, because the running reception will </p>
<p>be canceled and set up new. </p>
<p><b>&gt; </b></p>
<p>KTpRxErrWrongSNreceived:    A ConsecutiveFrame with a wrong </p>
<p>SequenceNumber is received, because of the current reception will </p>
<p>be canceled. </p>
<p><b>&gt; </b></p>
<p>KTpRxErrCFTimeout:               An awaited ConsecutiveFrame is not </p>
<p>received in the right time and a timeout occurs. </p>
<p><b>&gt; </b></p>
<p>KTpRxErrConfIntTimeout:         The FlowControl could not </p>
<p>transmitted within the necessary time and a (confirmation) timeout </p>
<p>occurs. </p>
<p>channel </p>
<p> </p>
<p><b>Return code </b></p>
<p> </p>
<p>- </p>
<p><b>Availability </b></p>
<p>No restriction</p>
<p> </p>
<p><b>Description </b></p>
<p>This function will be called if an error occurs on the channel. The channel will be reinitialized afterwards. </p>
<p>The name of this callback function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>148 / 177 </p>
<p><b>4.4.1.12 </b></p>
<p><b>ApplTpRxGetTxID:  Get CAN Transmit Id </b></p>
<p><b>ApplTpRxGetTxID </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>- </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint16 <b>ApplTpRxGetTxID</b>(vuint16 receiveId) </p>
<p><b>Parameter </b></p>
<p>receiveId  </p>
<p> </p>
<p><b>Return code </b></p>
<p> </p>
<p>- </p>
<p><b>Availability </b></p>
<p>Only for dynamic TP classes: Normal Addressing </p>
<p>Insert:</p>
<p> </p>
<p>#define TP_USE_TX_ID_APPL_CHECK kTpOn  </p>
<p>in a user-config file to use this feature. </p>
<p>!!! Attention: Only until TPMC version 2.60.00</p>
<p> </p>
<p><b>Description </b></p>
<p>This function is called after reception of a First-Frame, to get the Transmit-ID for the FlowControl. </p>
<p>The name of this callback function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>149 / 177 </p>
<p><b>4.4.2 </b></p>
<p><b>Reception side for functional messages </b></p>
<p>Only available if a functional connection group exists. </p>
<p> </p>
<p><b>4.4.2.1 </b></p>
<p><b>ApplFuncTpPrecopy:  Check if Target Address is valid </b></p>
<p><b>ApplFuncTpPrecopy </b></p>
<p><b>Prototype </b></p>
<p>Normal Fixed addressing, Extended addressing: </p>
<p> </p>
<p>vuint8 <b>ApplFuncTpPrecopy </b>(vuint8 tpCurrentTargetAddress) </p>
<p>Normal Fixed addressing, Extended addressing with GATEWAY - API: </p>
<p> </p>
<p>vuint8 <b>ApplFuncTpPrecopy </b>(vuint8 tpCurrentTargetAddress,  </p>
<p>                          CanRxInfoStructPtr infoStruct) </p>
<p>Mixed addressing: </p>
<p> </p>
<p>vuint8 <b>ApplFuncTpPrecopy </b>(vuint8 tpCurrentTargetAddress, </p>
<p>                       vuint8 tpCurrentAddressExtension) </p>
<p>Mixed addressing with GATEWAY - API: </p>
<p> </p>
<p>vuint8 <b>ApplFuncTpPrecopy </b>(vuint8 tpCurrentTargetAddress,  </p>
<p>                       vuint8 tpCurrentAddressExtension, </p>
<p>                       CanRxInfoStructPtr infoStruct) </p>
<p><b>Parameter </b></p>
<p>tpCurrentTargetAddress </p>
<p>Contains the N_TA byte of the received message. </p>
<p>tpCurrentAddressExtension </p>
<p>Contains the N_AE byte of the received message. </p>
<p>infoStruct </p>
<p>Pointer to a data structure containing more information concerning the </p>
<p>received message (e.g. Raw Id, DLC). </p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p>- </p>
<p><b>Availability </b></p>
<p>For TP classes: Extended-, Normal Fixed- and Mixed- Addressing. </p>
<p>If a functional connection groups exists and a callback name is configured. The default callback name used </p>
<p>is “TpFuncCheckTA”.</p>
<p> </p>
<p><b>Description </b></p>
<p>This function will be called for every reception of a functional TP-CAN-message. Within this function the </p>
<p>application has to decide, if the TargetAddress / AddressExtension in the received CAN-frame is valid.  </p>
<p>If the TargetAddress/AddressExtension is not valid and should not be received the return value must be </p>
<p>‘kTpNoChannel’.  If it should be received the TargetAddress should be returned.  </p>
<p>If the Multiple EcuNumber feature is used, then the concerning EcuNumber must be returned. </p>
<p>The name of this callback-function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>150 / 177 </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b> </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.4.3 </b></p>
<p><b>Transmission side </b></p>
<p><b>4.4.3.1 </b></p>
<p><b>ApplTpTxFC:   Reception of a Flow Control Frame </b></p>
<p><b>ApplTpTxFC </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>ApplTpTxFC</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>ApplTpTxFC</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>receiveId  </p>
<p> </p>
<p><b>Return code </b></p>
<p> </p>
<p>- </p>
<p><b>Availability </b></p>
<p>since versions: TPMC: 2.35.00 CANgen: 3.88.02 DBKOMgen: 2.37.01</p>
<p> </p>
<p><b>Description </b></p>
<p>This function is called after the reception of a FlowControl-frame. </p>
<p>The name of this callback-function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p>  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>151 / 177 </p>
<p><b>4.4.3.2 </b></p>
<p><b>ApplTpTxCanMessageTransmitted:  CAN-Message transmitted </b></p>
<p><b>ApplTpTxCanMessageTransmitted </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>ApplTpTxCanMessageTransmitted</b>(void) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>ApplTpTxCanMessageTransmitted</b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>channel  </p>
<p> </p>
<p><b>Return code </b></p>
<p> </p>
<p>- </p>
<p><b>Availability </b></p>
<p>No description</p>
<p> </p>
<p><b>Description </b></p>
<p>This function is called each time after a successful transmission of an CAN-message / frame (only for TX </p>
<p>connections - .this will mean for SF; FF; CF and not for FC messages) </p>
<p>The name of this callback function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.4.3.3 </b></p>
<p><b>ApplTpTxNotification:   CAN-Frame transmitted </b></p>
<p><b>ApplTpTxNotification </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>ApplTpTxNotification</b>(vuint8 count) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>ApplTpTxNotification</b>(vuint8 channel,  </p>
<p>                          vuint8 count) </p>
<p><b>Parameter </b></p>
<p>channel  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>152 / 177 </p>
<p>count </p>
<p> </p>
<p><b>Return code </b></p>
<p> </p>
<p>- </p>
<p><b>Availability </b></p>
<p>No restriction</p>
<p> </p>
<p><b>Description </b></p>
<p>This function is called each time after sending Tp-Frames except “Single-Frames” and the “last </p>
<p>Consecutive-Frame”. </p>
<p>Count</p>
<p><b> </b>is the number of transmitted data. </p>
<p>The name of this callback function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p><b>- </b></p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.4.3.4 </b></p>
<p><b>ApplTpTxCopyToCAN:   Application Copy Function (</b></p>
<p><b>16BIT Controller)  </b></p>
<p><b>ApplTpTxCopyToCAN </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>vuint8 <b>ApplTpTxCopyToCAN</b>(TpCopyToCanInfoStructPtr infoStruct) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>ApplTpTxCopyToCAN</b>(TpCopyToCanInfoStructPtr infoStruct) </p>
<p><b>Parameter </b></p>
<p>infoStruct</p>
<p> </p>
<p> </p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p>If everything is fine return ‘</p>
<p>kTpSucces</p>
<p><b>’ </b>otherwise <b>‘</b></p>
<p>kTpFailed’</p>
<p><b>.</b></p>
<p> </p>
<p><b>Availability </b></p>
<p>No restriction</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>153 / 177 </p>
<p><b>Description </b></p>
<p>The buffer management is done by the application. This function is always called by the Transport Protocol </p>
<p>before sending a TP-CAN-message. </p>
<p>The parameter is a pointer to the following structure:</p>
<p> </p>
<p>struct tTpCopyToCanInfoStruct_s </p>
<p>{ </p>
<p>  canuint8   Channel;      /* TP Channel*/ </p>
<p>  canuint8*  pDestination; /* Pointer to destination buffer */ </p>
<p>  canuint8*  pSource;      /*Pointer to linear source buffer*/ </p>
<p>  canuint16  Length;       /* The maximum length to copy */ </p>
<p>};</p>
<p> </p>
<p>The name of this callback-function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>Since version 2.35 the TPMC component tries to call </p>
<p>ApplTpCopyToCAN()</p>
<p> again and again until </p>
<p>kTpSuccess</p>
<p> </p>
<p>is returned or ‘CAN message confirmation timeout’ occurs. </p>
<p><b>Examples </b></p>
<p>vuint8 ApplTpCopyToCan(TpCopyToCanInfoStructPtr infoStruct) </p>
<p>{ </p>
<p>  (void)memcpy( infoStruct-&gt;pDestination, infoStruct-&gt;pSource,  </p>
<p>  infoStruct-&gt;Length); </p>
<p>  return kTpSuccess; </p>
<p>} </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.4.3.5 </b></p>
<p><b>ApplTpTxCopyToCAN:   Application Copy Function (8BIT Controller)  </b></p>
<p><b>ApplTpTxCopyToCAN </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>vuint8 <b>ApplTpTxCopyToCAN</b>(vuint8 offset,    </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>      vuint8 count) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>ApplTpTxCopyToCAN</b>(vuint8 channel,   </p>
<p>                         vuint8 offset,    </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>      vuint8 count) </p>
<p><b>Parameter </b></p>
<p>Offset </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>154 / 177 </p>
<p>Count </p>
<p> </p>
<p>channel </p>
<p> </p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p>If everything is fine return </p>
<p>kTpSuccess</p>
<p><b> </b>otherwise </p>
<p>kTpFailed</p>
<p><b>. </b></p>
<p><b>Availability </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>Only until TPMC version 2.49.00. </p>
<p> </p>
<p>Since TPMC version 2.50.00 the API described in 4.4.3.4 “ApplTpTxCopyToCAN:   Application Copy </p>
<p>Function (</p>
<p>16BIT Controller)” is used instead.</p>
<p> </p>
<p><b>Description </b></p>
<p>The buffer management is done by the application. This function is always called by the Transport Protocol </p>
<p>before sending a TP-CAN-message. </p>
<p>The argument </p>
<p>offset</p>
<p> determines the offset into the sending buffer of CAN Driver (Offset=0..7); the </p>
<p>argument “count” determines number of data, which has to be copied by the application function. </p>
<p>The name of this callback function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>Since version 2.35 the TPMC component tries to call </p>
<p>ApplTpCopyToCAN()</p>
<p> again and again until </p>
<p>kTpSuccess</p>
<p> </p>
<p>is returned or ‘CAN message confirmation timeout’ occurs. </p>
<p>TpTxData(channel)</p>
<p><b> </b>can be used to access the transmit buffer of the CAN-driver. </p>
<p> </p>
<p><b>Caution </b></p>
<p>Do not access the transmit buffer of the CAN-driver elsewhere </p>
<p> </p>
<p><b>Examples </b></p>
<p>vuint8 ApplTpCopyToCan(vuint8 channel,  </p>
<p>                       vuint8 offset,  </p>
<p>                       vuint8 length) </p>
<p>{ </p>
<p>  (void)memcpy( &amp;TpTxData(channel)[ offset ], </p>
<p>                &amp;TpTxGetDataBuffer(channel)[TpTxGetDataIndex(channel)],  </p>
<p>                length);     </p>
<p>  return kTpSuccess; </p>
<p>}</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>155 / 177 </p>
<p><b>4.4.3.6 </b></p>
<p><b>ApplTpTxConfirmation:  Transmission closed successful </b></p>
<p><b>ApplTpTxConfirmation </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>ApplTpTxConfirmation</b>(vuint8 state) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>ApplTpTxConfirmation</b>(vuint8 channel, </p>
<p>                          vuint8 state) </p>
<p><b>Parameter </b></p>
<p>State</p>
<p> </p>
<p> </p>
<p>cannel </p>
<p> </p>
<p><b>Return code </b></p>
<p> </p>
<p>-</p>
<p> </p>
<p><b>Availability </b></p>
<p>No description</p>
<p> </p>
<p><b>Description </b></p>
<p>This function is called after a single- or a multiple-frame message is transmitted completely.  </p>
<p>The </p>
<p>state</p>
<p> condition is given as a parameter and can be analyzed by the application. Please note that this </p>
<p>is intended for further usage, currently the delivered state is always kTpSuccess. </p>
<p>The name of this callback-function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>Currently the ‘state’ parameter is not used. So the default of this parameter is ‘kTpSuccess’. </p>
<p><b>Examples </b></p>
<p>vuint8 ApplTpCopyToCan(TpCopyToCanInfoStructPtr infoStruct) </p>
<p>{ </p>
<p>  (void)memcpy( infoStruct-&gt;pDestination, infoStruct-&gt;pSource,  </p>
<p>  infoStruct-&gt;Length); </p>
<p>  return kTpSuccess; </p>
<p>} </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>156 / 177 </p>
<p><b>4.4.3.7 </b></p>
<p><b>ApplTpTxErrorIndication:  Transmission closed with error  </b></p>
<p><b>ApplTpTxErrorIndication </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>vuint8 <b>ApplTpTxErrorIndication</b>(vuint8 errorCode) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>vuint8 <b>ApplTpTxErrorIndication</b>(vuint8 channel, </p>
<p>                               vuint8 errorCode) </p>
<p><b>Parameter </b></p>
<p>errorCode </p>
<p><b>&gt; </b></p>
<p>kTpTxErrFCTimeout: An awaited FlowControl timed out  </p>
<p><b>&gt; </b></p>
<p>kTpTxErrConfIntTimeout: A TP-CAN-massage could not transmitted </p>
<p>within the necessary time and a (confirmation) timeout occurs. </p>
<p><b>&gt; </b></p>
<p>kTpTxErrFCWrongFlowStatus: An invalid FlowControl-frame is </p>
<p>received.                            Only with activated strict message flow </p>
<p>checking (TP_USE_STRICT_MSG_FLOW_CHECKING must be set </p>
<p>to kTpOn in a user-config file to activate this feature). </p>
<p><b>&gt; </b></p>
<p>kTpTxErrWFTmaxOverrun: WFTmax wait frames are received now </p>
<p>(only for MCAN, if TP_ENABLE_MCAN is defined) </p>
<p><b>&gt; </b></p>
<p>kTpTxErrFCOverrun: the receiver reported an Overrun, channel is </p>
<p>terminated </p>
<p> </p>
<p>Old error codes Old error codes since TPMC version 2.35 </p>
<p><b>&gt; </b></p>
<p>kTpTxErrBufferUnderrun: Within the ApplTpCopyToCAN function a </p>
<p>buffer-underrun occurs. </p>
<p>cannel </p>
<p> </p>
<p><b>Return code </b></p>
<p> </p>
<p>Hold the channel:                        kTpHoldChannel   </p>
<p>Reinitializing / free the channel:  kTpFreeChannel </p>
<p><b>Availability </b></p>
<p>No description</p>
<p> </p>
<p><b>Description </b></p>
<p>This function will be called if an error occurs on the channel. The application has now to decide if the </p>
<p>channel should be reinitialized or hold for reusing it (only for dynamic TP classes necessary). </p>
<p>The name of this callback-function can be adjusted as desired in the Generation Tool. </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>157 / 177 </p>
<p><b>Please note </b></p>
<p>Currently the ‘state’ parameter is not used. So the default of this parameter is ‘kTpSuccess’. </p>
<p><b>Examples </b></p>
<p>vuint8 ApplTpCopyToCan(TpCopyToCanInfoStructPtr infoStruct) </p>
<p>{ </p>
<p>  (void)memcpy( infoStruct-&gt;pDestination, infoStruct-&gt;pSource,  </p>
<p>  infoStruct-&gt;Length); </p>
<p>  return kTpSuccess; </p>
<p>} </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.4.4 </b></p>
<p><b>Administrative Functions </b></p>
<p><b>4.4.4.1 </b></p>
<p><b>ApplTpFatalError: Fatal Error </b></p>
<p> </p>
<p><b>ApplTpFatalError </b></p>
<p><b>Prototype </b></p>
<p>SingleConnectionTp </p>
<p> </p>
<p>void <b>ApplTpFatalError</b>(vuint8 errorCode) </p>
<p>MultipeConnectionTP </p>
<p> </p>
<p>void <b>ApplTpFatalError</b>(vuint8 errorCode) </p>
<p><b>Parameter </b></p>
<p>errorCode </p>
<p>User assertions: </p>
<p><b>&gt; </b></p>
<p>KTpErrNoDynObjAtTpInit: Within TpInitPowerOn() it is not possible </p>
<p>to allocate the necessary transmit-objects from CAN-driver – please </p>
<p>check initialization order </p>
<p><b>&gt; </b></p>
<p>KTpErrChannelNrTooHigh: Possible access of a invalid tpChannel – </p>
<p>please check your application calls of the TP-API. </p>
<p><b>&gt; </b></p>
<p>KTpRxErrFcCanIdIsMissing: The CAN-ID of the FlowControl was </p>
<p>not set within the ApplTpRxGetBuffer() function for dynamic </p>
<p>NormalAddressing – please check your application. </p>
<p><b>&gt; </b></p>
<p>KtpTxErrDatalengthTooHigh: The application tried to transmit more </p>
<p>than 4095 bytes of data – please check your application. </p>
<p><b>&gt; </b></p>
<p>KTpTxErrWrongFrameAtPretransmitSpecified: Internal state-</p>
<p>machine check – please get in contact with us. </p>
<p><b>&gt; </b></p>
<p>KTpTxErrNoStateSpecified: Internal state-machine check – please </p>
<p>get in contact with us. </p>
<p><b>&gt; </b></p>
<p>kTpRxErrNoStateSpecified: Internal state-machine check – please </p>
<p>get in contact with us. </p>
<p><b>&gt; </b></p>
<p>kTpErrChannelNotInPreTransmitState: The application tried to </p>
<p>configure a not assigned tpChannel in a dynamic TP class – please </p>
<p>check your application. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>158 / 177 </p>
<p><b>&gt; </b></p>
<p>KTpErrWrongAddressingFormat: The application tried to configure a </p>
<p>tpChannel for a wrong AddressingMode (e.g. </p>
<p>TpTxSetTargetAddress for NormalAddressing configured </p>
<p>tpChannel) in a dynamic TP class – please check your application - </p>
<p>please check your application. </p>
<p><b>&gt; </b></p>
<p>KTpRxErrSetResponseWithoutFc: The function TpTxSetResponse() </p>
<p>is called for without-FC configured tpChannel - please check your </p>
<p>application. </p>
<p><b>&gt; </b></p>
<p>KTpTxErrSetResponseWithoutFc: The function TpTxSetResponse() </p>
<p>is called for without-FC configured tpChannel - please check your </p>
<p>application. </p>
<p><b>&gt; </b></p>
<p>KTpErrChannelNotInUse: The application tried to get information </p>
<p>about an unused tpChannel – please check your application. </p>
<p> Internal assertions: </p>
<p><b>&gt; </b></p>
<p>KTpErrChannelNrTooHigh: Possible access of a invalid tpChannel – </p>
<p>please check the stack-usage. </p>
<p><b>&gt; </b></p>
<p>KTpRxErrNotInWaitCFState: Internal state-machine check – please </p>
<p>get in contact with us. </p>
<p><b>&gt; </b></p>
<p>KTpErrChannelNotInUse: Internal state-machine check – please get </p>
<p>in contact with us. </p>
<p><b>&gt; </b></p>
<p>KTpErrNoCanChannelFound: The CAN-driver confirmation function </p>
<p>is called with a wrong Handle, because it is not possible to calculate </p>
<p>the corresponding CAN-channel – please get in contact with us. </p>
<p><b>Return code </b></p>
<p> </p>
<p>- </p>
<p><b>Availability </b></p>
<p>Until versions CANgen: 3.88.02 DBKOMgen: 2.37.01 TP-assertions are activated if the “Debug level” in </p>
<p>CAN-Driver includes “User”/”Internal”</p>
<p> </p>
<p><b>Description </b></p>
<p>This function will be called if a fatal error occurs.  </p>
<p>The name of this callback function is not changeable </p>
<p><b>Pre-condition(s) </b></p>
<p>- </p>
<p><b>Post-condition(s) </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Please note </b></p>
<p>- </p>
<p><b>Examples </b></p>
<p>- </p>
<p> </p>
<p><b>   </b></p>
<p> </p>
<p>  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>159 / 177 </p>
<p><b>5 </b></p>
<p><b>Transmission Attributes &amp; Callback functions </b></p>
<p> </p>
<p>Figure 5-1 Transmission attributes and callback functions </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>160 / 177 </p>
<p><b>6 </b></p>
<p><b>Integration of CANbedded Components into a Customer Project </b></p>
<p><b>6.1 </b></p>
<p><b>Requirements to the Customer System Environment </b></p>
<p>A  customer  system  environment  from  the  CANbedded  component  point  of  view  is  the </p>
<p>environment (system architecture) where the component together with other CANbedded </p>
<p>components, </p>
<p>an </p>
<p>operation </p>
<p>system, </p>
<p>startup </p>
<p>code, </p>
<p>system </p>
<p>control </p>
<p>software </p>
<p>and </p>
<p>the </p>
<p>application is running. </p>
<p>To  full  fill  the  different  requirements  to  the  component  architecture  like  small  ROM  and </p>
<p>RAM </p>
<p>footprint, </p>
<p>short </p>
<p>API </p>
<p>runtime </p>
<p>and </p>
<p>short </p>
<p>interrupt </p>
<p>lock </p>
<p>times </p>
<p>(global </p>
<p>and </p>
<p>only </p>
<p>CAN/LIN/others  bus  interrupts)  during  the  API  execution,  some  requirements  to  the </p>
<p>customer’s system environment and the component usage in that system has to be given </p>
<p>to and kept by the user. </p>
<p>The  requirements  and  needs  to  use  CANbedded  components  in  a  customer  specific </p>
<p>project are listed in this chapter. It is necessary to check the requirements, preconditions </p>
<p>and needs carefully to guaranteed the correct and consistent usage of the software in the </p>
<p>resulting  system  and  to  prevent  malfunction  and  data  consistency  problems  during  the </p>
<p>system execution (in the vehicle in the field).  </p>
<p><b>6.2 </b></p>
<p><b>Component Integration to the Customer Project </b></p>
<p><b>6.2.1 </b></p>
<p><b>Requirements to the Component Initialization in a Customer Project </b></p>
<p>The correct sequence for all CANbedded component initialization calls (e.g. CAN Driver, </p>
<p>network management, interaction layer …) depends on the needs for the whole, vehicle </p>
<p>manufacturer specific integration package. Therefore the correct call location in the context </p>
<p>to the other (CANbedded) power up initialization calls for this component is just a example.  </p>
<p>The following rules are valid for each use case of a CANbedded component in a customer </p>
<p>project and must be guaranteed to prevent faulty situations: </p>
<p>1)  The  component  must  be  initialized  after  the  primary  CAN  Driver  initialization  via </p>
<p>CanInitPowerOn(). </p>
<p>2)  The component must be initialized during the global interrupt is locked, to prevent </p>
<p>any  interrupt  occurrences  during  the  initialization  sequence  of  this  and ALL  other </p>
<p>CANbedded </p>
<p>modules.  Therefore </p>
<p>the </p>
<p>requirement </p>
<p>is </p>
<p>to </p>
<p>make </p>
<p>sure </p>
<p>the </p>
<p>global </p>
<p>interrupt  is  disabled  during  the  whole  initialization  sequence  of  all  CANbedded </p>
<p>components (driver, IL, NM, TP, diagnostics …). </p>
<p>3)  Please  note,  that  the  usage  of  CanDisableInterrupt  and  CanRestoreInterrupt  is </p>
<p>incorrect to lock the global interrupt during the CANbedded initialization sequence. </p>
<p>A customer project specific global interrupt lock and unlock is necessary. </p>
<p>4)  The customer system architecture must guarantee that all CANbedded modules are </p>
<p>initialized  before  the  first  usage  of  any API  or  variable  access  in  the  customer’s </p>
<p>application software is performed. </p>
<p>5)  The  call  to  the  component  initialization  function  TpInitPowerOn()  will  reset  the </p>
<p>component state to the initial state. Therefore it is NOT recommended to call the </p>
<p>component </p>
<p>initialization </p>
<p>function </p>
<p>during </p>
<p>the </p>
<p>system </p>
<p>runtime </p>
<p>to </p>
<p>e.g. </p>
<p>terminate </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>161 / 177 </p>
<p>something. Please check carefully, if the call to this API is valid (and helpful) in the </p>
<p>planned application context. </p>
<p>6)  Please  note,  that  the  call  to  the  component  initialization  function  may  be  runtime </p>
<p>consuming, </p>
<p>especially </p>
<p>if </p>
<p>there </p>
<p>are </p>
<p>additional </p>
<p>callbacks </p>
<p>to </p>
<p>the </p>
<p>application </p>
<p>are </p>
<p>performed and that the global interrupts are locked during that time, too. </p>
<p>7)  If an OSEK/OS is used, the basic initialization sequence has to be performed in the </p>
<p>startup-hook or, alternatively in an task used to initialized the whole system. Please </p>
<p>check, that the global interrupt is locked during the startup hook execution to ensure </p>
<p>the  required  data  consistency.  This  is  true  for  all  osCAN  OSEK  but  not  for  each </p>
<p>OSEK/OS  on  the  market.  If  the  initialization  is  performed  in  a  task,  the  interrupt </p>
<p>must be locked by the user for each OSEK/OS implementation. </p>
<p> </p>
<p><b>6.2.2 </b></p>
<p><b>Requirements to Component API Usage in a Customer Project </b></p>
<p>1)  The CANbedded component needs a first initialization of all internal variables and </p>
<p>states via the call of the initialization API function TpInitPowerOn(). It is not allowed </p>
<p>to use any API or data structure of the component before the primary initialization </p>
<p>has </p>
<p>been </p>
<p>performed. </p>
<p>See </p>
<p>chapter </p>
<p>6.2.1 </p>
<p>Requirements </p>
<p>to </p>
<p>the </p>
<p>Component </p>
<p>Initialization in a Customer Project for details to the component needs according to </p>
<p>the initialization sequence. </p>
<p>2)  The  cyclic  function(s)  (e.g.  TpRxTask()/TpTxTask())  of  a  component  must  not  be </p>
<p>called  on  interrupt  level  (e.g.  the  timer  interrupt).  It  is  strictly  forbidden,  that  the </p>
<p>cyclic called component API interrupts the component’s API functions running in the </p>
<p>(CAN/LIN)  interrupt  context  or  an  other  component  API’s.  See  chapter  6.2.3.1 </p>
<p>Common Requirements for details. </p>
<p>3)  It is not allowed to call any CANbedded API function in the context of an interrupt, if </p>
<p>this is not explicitly allowed or required in this documentation. </p>
<p>4)  Please  refer  to  chapter  6.2.3  Requirements  to  the  Customer  Project  Operating </p>
<p>System for the component requirements to the operating system. </p>
<p> </p>
<p><b>6.2.3 </b></p>
<p><b>Requirements to the Customer Project Operating System </b></p>
<p>The operating system used in the customer project has to fulfill the rules listed in chapter </p>
<p>6.2.3.1 Common Requirements to guarantee data consistency of the internal and external </p>
<p>component states and values. </p>
<p><b>6.2.3.1 </b></p>
<p><b>Common Requirements </b></p>
<p>The  component  offers  different  API  functions  and  global  variable/state  access  to  the </p>
<p>application  program.  Some  of  these  API  functions  are  necessary  to  fulfill  the  basic </p>
<p>functionality of the component. This is e.g. the initialization and the cyclic called function to </p>
<p>realize the internal time base and the state handling.  </p>
<p>The cyclic called API function TpRxTask()/TpTxTask() is also called TASK in the context of </p>
<p>this  chapter.  Due  to  the  need for fast  (1  - 10ms)  cyclic  calls,  this  tasks are  often  called </p>
<p>erroneously  by  calling  this API  function  in  an  timer  interrupt  context.  This  is  STRICTLY </p>
<p>forbidden. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>162 / 177 </p>
<p>The list below describes the common rules for all component API calls. The documentation </p>
<p>of the API functions and the component callback functions describes the deviations from </p>
<p>this rules if, e.g. the API is allowed to be called during the TASK is running. </p>
<p><b>Please check carefully, if this restrictions are valid in your system: </b></p>
<p><b>&gt; </b></p>
<p>API functions must not interrupt the (CAN/LIN) RX/TX interrupt service functions </p>
<p><b>&gt; </b></p>
<p>API functions must not interrupt the TASK functions </p>
<p><b>&gt; </b></p>
<p>API functions must not interrupt other API functions of the same component  </p>
<p><b>&gt; </b></p>
<p>TASK functions must not interrupt API functions of the same component  </p>
<p><b>&gt; </b></p>
<p>If there are multiple TASK functions for a component: TASK function must not interrupt </p>
<p>other TASK functions of the same component  </p>
<p><b>&gt; </b></p>
<p>TASK functions must not interrupt the (CAN/LIN) RX/TX interrupt service functions </p>
<p> </p>
<p> </p>
<p><b>Info </b></p>
<p><b>&gt; </b></p>
<p>API and TASK functions are protected against interruption by the (CAN/LIN) RX/TX </p>
<p>interrupt service functions </p>
<p><b>&gt; </b></p>
<p>There are no limitations for interruptions of the component API’s with other, </p>
<p>independent interrupt service functions (e.g. A/D converter, SIO lines, ...) </p>
<p> </p>
<p> </p>
<p><b>6.2.3.2 </b></p>
<p><b>Round-Robin-Scheduler and Comparable OS Approaches </b></p>
<p>If the used operating system works like a round-robin scheduler or comparable and there </p>
<p>is only one common call level for application and CANbedded APIs with additional, small </p>
<p>interrupt handlers, the preconditions as described in chapter 6.2.3.4 should be valid. </p>
<p> </p>
<p><b>6.2.3.3 </b></p>
<p><b>Usage of OSEK/OS </b></p>
<p>The  component  can  be  used together with  an  OSEK  operating  system. The  component </p>
<p>itself  is  operating  system  independent  and  can  therefore  be  used  together  with  an </p>
<p>OSEK/OS, if the rules listed in chapter 6.2.3.1 are fulfilled. </p>
<p>OSEK/OS  can  be  configured  to  4  different  setups  (BCC1  to  ECC2).  Depending  on  the </p>
<p>selected setup, OSEK/OS is non-preemptive or (full-)preemptive. The preemptive setups </p>
<p>are able to run non-preemptive and preemptive tasks. Please refer to the chapters 6.2.3.4 </p>
<p>and 6.2.3.5 for further details. </p>
<p>If  an  OSEK/OS  is  used,  the  basic  initialization  sequence  has  to  be  performed  in  the </p>
<p>startup-hook or, alternatively in an task used to initialized the whole system. Please check, </p>
<p>that the global interrupt is locked during the startup hook execution to ensure the required </p>
<p>data  consistency.  This  is  true  for  all  osCAN  OSEK  but  not  for  each  OSEK/OS  on  the </p>
<p>market. If the initialization is performed in a task, the interrupt must be locked by the user </p>
<p>for each OSEK/OS implementation. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>163 / 177 </p>
<p><b>6.2.3.4 </b></p>
<p><b>Non-Preemptive Operating System </b></p>
<p>If  an  non-preemptive  OS  is  used,  there  are  no  limitations  to  the  usage  of  CANbedded </p>
<p>component API’s on task/main level due to an task change is started by an OS-API call or </p>
<p>by exiting a function called directly by the OS scheduler. Due to this there is no situation </p>
<p>with possible dangerous interruptions of component API executions in this environment.  </p>
<p>Non-preemptive approaches are using also interrupt handlers for e.g. CAN, LIN, A/D and </p>
<p>D/A  conversion  and  other  things.  Until  the  requirements  listed  in  chapter  6.2.3.1  are </p>
<p>fulfilled, no critical situation according to data consistency and the CANbedded component </p>
<p>usage occurs. The CANbedded component itself is able to cope with the interruption via </p>
<p>the internal connection to the CAN/LIN driver. </p>
<p> </p>
<p><b>6.2.3.5 </b></p>
<p><b>Preemptive Operating System </b></p>
<p>If  the  CANbedded  component  has  to  be  used  in  a  full-preemptive  environment,  some </p>
<p>additional restrictions have to be kept in mind. If this is not explicitly allowed, please check </p>
<p>carefully, that the restrictions listed in chapter 6.2.3.1 are fulfilled by the system setup.  </p>
<p>Possible  solutions  for  a  save  usage  of  the  CANbedded  component  may  be  calling  the </p>
<p>cyclic  functions  and  API’s  in  non-preemptive  tasks  or  to  lock  task  changes  during  the </p>
<p>execution of the cyclic function calls and the component APIs. </p>
<p>It  is  not  recommended  to  solve  the  restrictions  via  a  special  task  priority  setup  due  to </p>
<p>possible  maintenance  issues  when  changing  and  extending  the  software  system  in  the </p>
<p>future. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>164 / 177 </p>
<p><b>7 </b></p>
<p><b>Advanced usage  </b></p>
<p><b>7.1 </b></p>
<p><b>Separation of TimerTask and TransmissionTask (StateTask) </b></p>
<p>Until TPMC version 2.35 there is a combination of a timer observation and the handling of </p>
<p>transmission requests in one task function. By the demand of faster TP transmission the </p>
<p>most popular possibility is to separate the transmission mechanism from the timer task. </p>
<p>Since TPMC version 2.35 TimerTask and TransmissionTask are separated. </p>
<p>The ‘TimerTask’ includes the time observation. The ‘StateTask’ includes the transmission </p>
<p>handling of the CAN-frames. Especially the retry of the transmission while CanTransmit() </p>
<p>cannot accept the message, because the (all) TX registers are currently in use. </p>
<p>Like the former ‘Task’ function (TpXxTask()) the current ‘Task’ function (TpXxTask()) </p>
<p>includes the call of both tasks to have a full compatibility. So it must be called further on </p>
<p>periodically. The ‘StateTask’ can be called out of a fixed time periods in addition. </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>It is not necessary to call the ‘StateTask’, if the CAN Driver queue is enabled. </p>
<p> </p>
<p> </p>
<p><b>void TpTxTask(void) </b></p>
<p><b>&gt; </b></p>
<p> static void TpTxTimerTask(void) (not visible for the application)</p>
<p> </p>
<p><b>&gt; </b></p>
<p> void TpTxStateTaskAllChannels(void) </p>
<p> </p>
<p><b>void TpRxTask(void) </b></p>
<p><b>&gt; </b></p>
<p> void TpRxTimerTask(void) (not visible for the application) </p>
<p><b>&gt; </b></p>
<p> void TpRxStateTaskAllChannels(void) </p>
<p> </p>
<p>The ‘StateTaskAllChannels’ iterates over all tpChannels. To speed up only one connection. </p>
<p>a ‘StateTask’ is provided, which is handles the transmission of this connection. </p>
<p><b>void TpTxStateTask(vuint8 tpChannel) </b></p>
<p><b>void TpRxStateTask(vuint8 tpChannel) </b></p>
<p><b> </b></p>
<p><b>7.2 </b></p>
<p><b>Fast transmission of ConsecutiveFrames </b></p>
<p>Available since TPMC version 2.35. </p>
<p>The TP-layer calculates the STmin time based on the CallCycle of the TpTimerTask().To </p>
<p>guarantee  that  a  under  run  of  the  STmin  is  not  possible,  one  CallCycle  is  added.  This </p>
<p>conservative way of calculation do not fit the demand of a fast transmission. </p>
<p>The added feature includes a possibility to transmit a TP-frame as quick as possible. </p>
<p>Typically this feature can be used for a fast re-programming of ECU’s through Gateways or </p>
<p>Testers.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>165 / 177 </p>
<p>The  feature  can’t  be  enabled  through  the  GenTools. A  user-config  file  has  to  be  used, </p>
<p>including following define: </p>
<p>#define TP_USE_FAST_TX_TRANSMISSION kTpOn </p>
<p><b>7.2.1 </b></p>
<p><b>Usage </b></p>
<p>The TP provides a special API function which assembles and transmits the next CF-frame </p>
<p>by skipping the internal timer for the minimum sending distance (STmin). This means the </p>
<p>application has the possibility to transmit the next CF frame faster than the calculated </p>
<p>minimum sending distance of the TP module allows.  </p>
<p>Normally the timer will be reloaded with the value of the minimum sending distance and is </p>
<p>observed in the TpTxTimerTask(). By calling the function TpTxPrepareSendImmediate() </p>
<p>the timer of the TP is stopped. If the preparation returns a ‘kTpSuccess’ the application </p>
<p>gets the responsibility of transmitting the next ConsecutiveFrame. The application can </p>
<p>reload an (application) alarm-timer with the STmin value of the FlowControl-frame by </p>
<p>calling the function TpTxGetSTminInFrame(). If the alarm occurs (timer is decremented to </p>
<p>zero) the application can transmit the ConsecutiveFrame by calling the function </p>
<p>TpTxSendImmediate(), which prepares the CF-frame and calls the TpTxStateTask() to </p>
<p>transmit the frame immediately. </p>
<p><b>7.2.2 </b></p>
<p><b>Application example </b></p>
<p><b>For non-zero STmins: </b></p>
<p>void ApplTpTxFC(canuint8 channel) </p>
<p>{ </p>
<p>  if(kTpSuccess == TpTxPrepareSendImmediate(channel)) </p>
<p>  { </p>
<p>    TpTxSendImmediate(channel); </p>
<p>  } </p>
<p>} </p>
<p>void ApplTpTxCanMessageTransmitted(canuint8 channel) </p>
<p>{ </p>
<p>  canuint8 stminTime; </p>
<p> </p>
<p>  if(kTpSuccess == TpTxPrepareSendImmediate(channel)) </p>
<p>  { </p>
<p>   stminTime = TpTxGetSTminInFrame(channel); </p>
<p> </p>
<p>    /* load an OSEK-OS alarm (in ms) */ </p>
<p>    SetRelAlarm(TpSepAlarm, MSEC(stminTime),0); </p>
<p> </p>
<p>    /* after alarm time expires: TpTxSendImmediate(channel); */ </p>
<p>  } </p>
<p>} </p>
<p> </p>
<p><b>For zero STmins (fast as possible): </b></p>
<p>Attention:  Due to the current priority rules it could be possible that no real parallel </p>
<p>transmission is possible. All other channels are not handled anymore while </p>
<p>another transmission is running. </p>
<p> </p>
<p>void ApplTpTxFC(canuint8 channel) </p>
<p>{ </p>
<p>  if(kTpSuccess == TpTxPrepareSendImmediate(channel)) </p>
<p>  { </p>
<p>    TpTxSendImmediate(channel); </p>
<p>  } </p>
<p>} </p>
<p>void ApplTpTxCanMessageTransmitted(canuint8 channel) </p>
<p>{ </p>
<p>  if(kTpSuccess == TpTxPrepareSendImmediate(channel)) </p>
<p>  { </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>166 / 177 </p>
<p>    TpTxSendImmediate(channel); </p>
<p>  } </p>
<p>} </p>
<p> </p>
<p><b>7.3 </b></p>
<p><b>Normal Fixed Addressing </b></p>
<p><b>7.3.1 </b></p>
<p><b>Multiple ECU’s  </b></p>
<p>Multiple  ECU’  s  are  control  units  which  are  assembled  several  times  within  the  CAN </p>
<p>network with the same software (example: seat in the front on the left hand side and on the </p>
<p>right  hand  side).  In  this  case,  the  application  has  to  decide  at  run-time,  which  ECU  is </p>
<p>actually installed and has to set-up these parameters dynamically.  </p>
<p><b>7.3.1.1 </b></p>
<p><b>Using the CANgen configuration tool </b></p>
<p>The  configuration  tool  does  not  apply  the  ECU  information  but  it  provides  all  possible </p>
<p>values for the application as constants in the generated code.   </p>
<p> </p>
<p>E.g.: In the generated tp_cfg.h file you will find constants for all existing ECU numbers:  </p>
<p>#define kTpEcuNumber0   </p>
<p> </p>
<p> </p>
<p>0x10 </p>
<p>#define kTpEcuNumber1   </p>
<p> </p>
<p> </p>
<p>0x11 </p>
<p>#define kTpEcuNumber2   </p>
<p> </p>
<p> </p>
<p>0x12 </p>
<p>#define kTpEcuNumber3   </p>
<p> </p>
<p> </p>
<p>0x13 </p>
<p>… </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>167 / 177 </p>
<p>In case of using the CANgen configuration tool the application must accomplish  two things </p>
<p>now at Power On time: </p>
<p>a) </p>
<p>The actual ECU number must be set using the ComSetCurrentECU() API. </p>
<p>b) </p>
<p>The actual ECU number must be provided to the TPMC.  </p>
<p> </p>
<p>Code example: </p>
<p>extern canuint8 tpEcuNumber; </p>
<p>canuint8 tpEcuNumber; </p>
<p> </p>
<p>void main(void) </p>
<p>{ </p>
<p>  CanInitPowerOn(); </p>
<p>  <b>ComSetCurrentECU(currentECU); </b></p>
<p>  ... </p>
<p>  if ( FirstECUis selected) { </p>
<p>    <b>tpEcuNumber = kTpEcuNumber0; </b></p>
<p>  }  </p>
<p>  else if (SecondECU is selcted) { </p>
<p>    <b>tpEcuNumber = kTpEcuNumber1; </b></p>
<p>     } </p>
<p>  TpInitPowerOn();  /* For some configuration it could be also         </p>
<p>    DiagInitPowerOn()  with implicit TPMC initialization       */ </p>
<p>  ... </p>
<p>  &lt;EnableCAN_ISR&gt; </p>
<p>} </p>
<p> </p>
<p><b>7.3.1.2 </b></p>
<p><b>Using the GENy configuration tool </b></p>
<p>The configuration tool does not apply the ECU information  completely but it provides all </p>
<p>possible values for the application as constants in the generated code.   </p>
<p> </p>
<p>E.g.: In the generated tp_par.c file a kTpEcuNumber_field[] is provided for all existing ECU </p>
<p>numbers: </p>
<p> </p>
<p>vuint8 kTpEcuNumber_field [4] = { </p>
<p> </p>
<p> </p>
<p>0x10, </p>
<p> </p>
<p> </p>
<p>0x11, </p>
<p> </p>
<p> </p>
<p>0x12, </p>
<p> </p>
<p> </p>
<p>0x13 </p>
<p> </p>
<p>} </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>168 / 177 </p>
<p>In case of using the GENy configuration tool  there is left one thing now the application </p>
<p>must accomplish at Power On time: </p>
<p>a) The actual ECU number must be set using the ComSetCurrentECU() API. </p>
<p> </p>
<p>Code example: </p>
<p> </p>
<p>void main(void) </p>
<p>{ </p>
<p>  CanInitPowerOn(); </p>
<p>  <b>ComSetCurrentECU(currentECU); </b></p>
<p>  ... </p>
<p>  TpInitPowerOn();  /* For some configuration it could be also         </p>
<p>    DiagInitPowerOn()  with implicit TPMC initialization       */ </p>
<p>  ... </p>
<p>  &lt;EnableCAN_ISR&gt; </p>
<p>} </p>
<p> </p>
<p><b>7.4 </b></p>
<p><b>Extended- and Normal Fixed Addressing </b></p>
<p><b>7.4.1 </b></p>
<p><b>Virtual ECU’s / ‘Multiple EcuNumber’ feature </b></p>
<p>‘Virtual  ECU’s’  are  control  units  which  include  the  logic  of  more  than  one  ECU.  In  the </p>
<p>network they have to react for more than one ECU number. The application has to decide </p>
<p>which ECU number should be received and which not.  </p>
<p>For versions &lt; 2.73.00: </p>
<p>All TargetAddresses (except the functional TargetAddress 0xFF ) will be received through </p>
<p>the  Transport  Layer.  Following  the  reception  of  a  TP-frame  the  application  callback </p>
<p>ApplTpPrecopy()  is called  by  the Transport Layer.  In  this function  the  application  has to </p>
<p>decide  which  TargetAddress  should  be  received  and  which  not.  In  this  function  the  </p>
<p>application gets the received TargetAddress and has to return the TargetAddress itself to </p>
<p>receive TransportFrames. To not receive the following TransportFrames the return value </p>
<p>has to be ‘kTpNoChannel’ (0xff).  </p>
<p>If  the  received  TargetAddress  e.g.  is  a  part  of  a  functional  range,  the  application  can </p>
<p>modify </p>
<p>the </p>
<p>received </p>
<p>TargetAddress </p>
<p>by </p>
<p>returning </p>
<p>another </p>
<p>TargetAddress </p>
<p>in </p>
<p>the </p>
<p>ApplTpPrecopy  function.  If  the  returned  value  is  unequal  to  the  received  the  Transport </p>
<p>Layer will receive the TransportFrames with this TargetAddress and not with the received </p>
<p>(the responded FlowControl is also modified). </p>
<p> </p>
<p>canuint8 ApplTpCheckTA(vuint8 targetAddress) </p>
<p>{ </p>
<p>  vuint8 result; </p>
<p>  switch(targetAddress) </p>
<p>  { </p>
<p>    case TargetAddress_0: </p>
<p>    case TargetAddress_1: </p>
<p>    </p>
<p>... </p>
<p>    case TargetAddress_n: </p>
<p>      result = targetAddress; </p>
<p>      break; </p>
<p>    default: </p>
<p>      result = kTpNoChannel; </p>
<p>  } </p>
<p>  return result; </p>
<p>} </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>169 / 177 </p>
<p>For versions &gt;= 2.73.00: </p>
<p>All TargetAddresses are received through the Transport Layer. Following the reception of a </p>
<p>TP-frame the application callback ApplTpPrecopy() is called by the Transport Layer. In this </p>
<p>function the application has to decide which TargetAddress should be received and which </p>
<p>not. </p>
<p>The </p>
<p> </p>
<p>application </p>
<p>gets </p>
<p>the </p>
<p>received </p>
<p>TargetAddress </p>
<p>and </p>
<p>has </p>
<p>to </p>
<p>return </p>
<p>either </p>
<p>‘kTpPhysical’ </p>
<p>or </p>
<p>‘kTpFunctional’. </p>
<p>To </p>
<p>not </p>
<p>receive </p>
<p>any </p>
<p>subsequent </p>
<p>TP </p>
<p>Frames </p>
<p>the  </p>
<p>application returns ‘kTpNone’.  </p>
<p> </p>
<p> </p>
<p>t_ta_type ApplTpCheckTA(vuint8 targetAddress) </p>
<p>{ </p>
<p>  t_ta_type result; </p>
<p>  if(targetAddress == MY_ECU_NUMBER) </p>
<p> </p>
<p> </p>
<p>{ </p>
<p>    result = kTpPhysical; </p>
<p>  } </p>
<p>  else if((targetAddress &gt;= TP_LOWEST_FUNCTIONAL_ADDRESS ) &amp;&amp; </p>
<p>          (targetAddress &lt;= TP_HIGHEST_FUNCTIONAL_ADDRESS)) </p>
<p>    result = kTpFunctional; </p>
<p>  } </p>
<p>  else </p>
<p>  { </p>
<p>    result = kTpNone; </p>
<p>  } </p>
<p>  return result; </p>
<p>} </p>
<p> </p>
<p><b>7.5 </b></p>
<p><b>Using different CAN-Identifiers  </b></p>
<p>For  some  purposes  different  CAN-Ids,  as  well  11-Bit  standard  as  also  29-Bit  extended </p>
<p>identifiers  shall  be  used  for  the  Normal Addressing  type.  If  so,  the  TPMC  provides  two </p>
<p>configuration opportunities to handle this requirement either statically at configuration time </p>
<p>or dynamically at runtime. </p>
<p><b>7.5.1 </b></p>
<p><b>Statically configured CAN-Ids </b></p>
<p>By default 11-Bit standard Ids are used with Normal Addressing. If 29-Bit extended Ids are </p>
<p>requested  by  the  user  and  thus  also  entered  as  Addressing  Information  in  the  GENy </p>
<p>generation tool, then the preprocessor switch </p>
<p>TP_USE_EXT_IDS_FOR_NORMAL</p>
<p> is generated </p>
<p>with the value kTpOn. The code is now applicable to be used with 29-Bit CAN-Ids. </p>
<p><b>7.5.2 </b></p>
<p><b>Dynamically configured CAN-Ids </b></p>
<p>If the user has the necessity to handle both kinds of CAN-Ids during runtime, then in the </p>
<p>GENy </p>
<p>generation </p>
<p>tool </p>
<p>different </p>
<p>CAN-Ids </p>
<p>can </p>
<p>be </p>
<p>entered </p>
<p>for </p>
<p>different </p>
<p>Addressing </p>
<p>Informations. Now the preprocessor switch </p>
<p>TP_USE_MIXED_IDS_FOR_NORMAL</p>
<p> is generated </p>
<p>with the value kTpOn in addition and the code is now applicable to be used simultaneously </p>
<p>with 11- and 29- Bit CAN-Ids.  </p>
<p><b>7.5.3 </b></p>
<p><b>Additional API functions </b></p>
<p>If both kinds of CAN-Ids are used then the additional API function              </p>
<p>canuint8  TpRxGetChannelIDType(canuint8 tpChannel)</p>
<p> is provided.   </p>
<p>This  function  either  returns  kTpCanIdTypeStd  for  11-Bit  or  kTpCanIdTypeExt  for  29-Bit </p>
<p>identifiers. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>170 / 177 </p>
<p><b>7.6 </b></p>
<p><b>Transmissions without Flow Control frames  </b></p>
<p>For some purposes the usage of FC frames might be omitted. Please note that this feature </p>
<p>is not supported for single connection TP. </p>
<p>If  using  a  dynamic  Tp  Class  then  the  provided  API  functions  TpRxWithoutFC  resp. </p>
<p>TpTxWithoutFC can be used (see 0, 4.2.3.28) to control the FC usage. </p>
<p> </p>
<p>If using a static Tp Class then a channel specific FC control information must be provided </p>
<p>at compile time for the TP containing the information if FC frames shall be used or not for a </p>
<p>specific channel either on the Rx- and/or on the Tx- side.  </p>
<p>The definition and usage of the FC control array must be as described below:  </p>
<p>vuint8 TpRxFlowControl[kTpRxChannelCount]; </p>
<p>vuint8 TpTxFlowControl[kTpTxChannelCount]; </p>
<p> </p>
<p>In the default case, if the usage of FC frames is required, then the FC control array </p>
<p>contains a value of “1” for the belonging Rx- or Tx- channel. If FC frames shall be </p>
<p>suppressed, then the FC control array contains a value of “0” for the belonging Rx- or Tx- </p>
<p>channel. </p>
<p>  </p>
<p>Example: </p>
<p>vuint8 TpRxFlowControl[3] =  </p>
<p>{ 1,    // use FC frames </p>
<p>  1,    // use FC frames </p>
<p>  0     // use no FC frames </p>
<p>};  // </p>
<p>vuint8 TpTxFlowControl[3] =  </p>
<p>{ 1,    // use FC frames </p>
<p>  1,    // use FC frames </p>
<p>  0     // use no FC frames </p>
<p>}; </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>171 / 177 </p>
<p><b>8 </b></p>
<p><b>Example for the user </b></p>
<p><b>8.1 </b></p>
<p><b>Administrative usage </b></p>
<p>The  Transport  Protocol  has  to  be  initialized  before  all  other  functions  were  called.  This </p>
<p>initialization has to be done after initializing the CAN-driver (<b>CanInitPowerOn()</b>), possibly </p>
<p>if  the  interrupts  are  still  locked.  The  Transport  Layer  is  ready  for  reception  after  calling </p>
<p><b>TpInitPowerOn(). </b></p>
<p>To perform the state machine the functions <b>TpRxTask() </b>and <b>TpTxTask() </b>have to be called </p>
<p>periodically. </p>
<p>If the application wants to have access to the API of the TPMC-component it has to include </p>
<p>the “tpmc.h” file after including of the “can_inc.h” file. </p>
<p><b>8.2 </b></p>
<p><b>How to Transmit a Tp-Frame?  </b></p>
<p><b>8.2.1 </b></p>
<p><b>Static Normal Addressing </b></p>
<p>First  you  need  an  own  buffer  with  your  data  which  should  be  transmitted.  To  start  the </p>
<p>transmission simply call <b>TpTransmit().  </b></p>
<p>if (TpTransmit(tpChannel, appl-buffer, appl-data-length) != kTpSuccess) </p>
<p>{ </p>
<p>  /* Error case – transmission was not successful */ </p>
<p>} </p>
<p> </p>
<p>A confirmation function is called after the complete transmission. It can be used to release </p>
<p>buffers...</p>
<p> </p>
<p>void ApplTpTxConfirmation(vuint8 tpChannel, vuint8 state) </p>
<p>{ </p>
<p> </p>
<p>If you want an own copy mechanism to move the data from your buffer into CAN buffer you </p>
<p>have </p>
<p>to </p>
<p>use </p>
<p>the </p>
<p>function </p>
<p><b>ApplTpTxCopyToCan() </b></p>
<p>(This </p>
<p>can </p>
<p>be </p>
<p>configured </p>
<p>in </p>
<p>the </p>
<p>Generation Tool). </p>
<p><b>8.2.2 </b></p>
<p><b>Dynamic Addressing </b></p>
<p>(Normal- / Normal Fixed- / Extended- / Multiple-Addressing)</p>
<p> </p>
<p>Before the application can call <b>TpTransmit() </b>(refer 8.2 How to Transmit a Tp-Frame?) a </p>
<p>transport  channel  has  to  be  requested.  The  function <b> TpTxGetFreeChannel() </b> returns  a </p>
<p>free  transport  channel  or  –  if  no  channel  is  available  at  the  moment  – <b> kTpNoChannel</b>. </p>
<p>After a channel is assigned, the channel has to parameterized by the application. In the </p>
<p>example below, the application will set the Transmit ID and Receive ID (Dynamic Normal </p>
<p>Addressing) before sending the data. </p>
<p>Important: replace the cursive words by your own </p>
<p>tpChannel = TpTxGetFreeChannel(connection-number); </p>
<p>if(tpChannel != kTpNoChannel) </p>
<p>{ </p>
<p>    /* normal addressing */ </p>
<p>    TpTxSetChannelID(tpChannel, TransmitID, ReceiveID); </p>
<p> </p>
<p>    if (TpTransmit(tpChannel, appl-buffer, appl-data-length) != kTpSuccess) </p>
<p>    { </p>
<p>      /* Error case – transmission was not successful */ </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>172 / 177 </p>
<p>    } </p>
<p>} </p>
<p> </p>
<p>The callback functions provide only the tpChannel as a parameter. To get the unique </p>
<p>connection-number out of this tpChannel the function </p>
<p><b>TpTxGetConnectionNumber(tpChannel) </b>is provided </p>
<p>void ApplTpTxConfirmation(vuint8 tpChannel, vuint8 state) </p>
<p>{ </p>
<p>  switch(TpTxGetConnectionNumber(tpChannel)) </p>
<p>   . </p>
<p>   . </p>
<p><b>8.3 </b></p>
<p><b>How to Receive a Tp-Frame </b></p>
<p>It  is only  possible  to  get  an  Indication  by  a  function  callback. The  reception  progress  is </p>
<p>completed by the Transport Layer. </p>
<p><b>Important: </b>The Transport Layer blocks the receive tpChannel as long as the application </p>
<p>desires. To free the receive channel call <b>TpRxResetChannel()</b>.  </p>
<p>void ApplTpRxIndication ( vuint8 tpChannel, vuint16 dataLength) </p>
<p>{ </p>
<p>   ... </p>
<p>   ... </p>
<p>   TpRxResetChannel(tpChannel); </p>
<p>   ... </p>
<p>   ... </p>
<p>} </p>
<p>The Transport Layer supports only buffer-management by the application. If data will be </p>
<p>received, it is important to the Transport Layer to get a buffer into which the data can be </p>
<p>moved. </p>
<p>vuint8 * ApplTpRxGetBuffer (vuint8 tpChannel, vuint16 length) </p>
<p>{ </p>
<p>  if (Is_ReceiveDataBuffer_free)  </p>
<p>  { </p>
<p>    Set_ReceiveDataBuffer_Used; </p>
<p> </p>
<p>    if (length &lt;= MaxLength) </p>
<p>    { </p>
<p> </p>
<p>   /* return a valid data buffer */ </p>
<p>      return ReceiveDataBuffer; </p>
<p>    } else { </p>
<p> </p>
<p>  /* length is too big for the ReceiveDataBuffer – do not receive the data */ </p>
<p>      return NULL; </p>
<p>  } else { </p>
<p> </p>
<p>  /* ReceiveDataBuffer is not free – do not receive the data */ </p>
<p>     return NULL; </p>
<p>  } </p>
<p> </p>
<p>} </p>
<p><b>8.4 </b></p>
<p><b>How to Send a Response on a Received Transport-Frame </b></p>
<p>Normally </p>
<p>the </p>
<p>application </p>
<p>has </p>
<p>to </p>
<p>set </p>
<p>transmission </p>
<p>attributes </p>
<p>like </p>
<p>TargetAddress, </p>
<p>TargetIdentifier </p>
<p>or </p>
<p>physical </p>
<p>CanChannel </p>
<p>(depending </p>
<p>on </p>
<p>the </p>
<p>addressing </p>
<p>mode </p>
<p>and </p>
<p>configuration). So if the application want to send a response to the sender of a received </p>
<p>transport-frame it has to set these transmission attributes. For this case it can do it easily </p>
<p>by  using  the function TpTxSetResponse(). The Preconditions  are only  the  Rx-Channel  - </p>
<p>which is still blocked - from the sender and a free Tx-Channel for the transmission.  </p>
<p>if ( (txTpChannel = TpTxGetFreeChannel(user_connection)) != kTpNoChannel ) </p>
<p>{ </p>
<p>  TpTxSetResponse(rxTpChannel, txTpChannel); </p>
<p>  TpRxResetChannel(rxTpChannel); </p>
<p>  TpTransmit(txTpChannel, ...); </p>
<p>} </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>173 / 177 </p>
<p><b>8.5 </b></p>
<p><b>How to serve Different Connections (only dynamic channels) </b></p>
<p>The dynamic TP classes does not support connection specific callback functions. </p>
<p>Therefore the application needs an easy handling between the different connections with </p>
<p>less resource requirements. Especially the diagnostic-layer must be handled  </p>
<p><b>8.5.1 </b></p>
<p><b>How to serve the diagnostic connection   </b></p>
<p>This is also an example to serve different connections in your own application! I.e. you can </p>
<p>derive from the diagnosis example to your own. </p>
<p><b>Reception part: </b></p>
<p>Within the ‘ApplTpRxGetBuffer()’ the application is responsible to distinguish between the </p>
<p>different connections. If the right connection is found a connection-number can be set to </p>
<p>have in the later callbacks a faster decision. </p>
<p>(Dynamic  Normal Addressing) The  received  CAN-ID  (for  the  diagnosis)  is  unique  (get  it </p>
<p>with: TpRxGetChannelID(tpChannel)) </p>
<p><b>Transmission part: </b></p>
<p>At the transmission the connection-number is unique. The diagnosis uses the connection-</p>
<p>numbers “kDiagConnection” and “kDiagAddConnection”.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>174 / 177 </p>
<p>unsigned char* ApplTpRxGetBuffer(vuint8 tpChannel, vuint16 tpRxDataLength)  </p>
<p>{ </p>
<p>  switch(TpRxGetChannelID(tpChannel)) </p>
<p>  { </p>
<p>  case DIAG_RECEIVE_ID: </p>
<p>    TpRxSetConnectionNumber(tpChannel, kDiagConnection); </p>
<p>    return DiagTpGetRxBuffer(tpChannel, tpRxDataLength); </p>
<p>  case APPL_RECEIVE_ID: </p>
<p>    TpRxSetConnectionNumber(tpChannel, CONNECTION_0); </p>
<p>    /* Check for an valid application buffer */ </p>
<p>    return APPLICATION_BUFFER; </p>
<p>  default: </p>
<p>    return NULL; </p>
<p>    break; </p>
<p>  } </p>
<p>} </p>
<p> </p>
<p>void ApplTpRxIndication(vuint8 tpChannel, vuint16 tpRxDataLength) </p>
<p>{ </p>
<p>  switch(TpRxGetConnectionNumber(tpChannel)) </p>
<p>  { </p>
<p>  case kDiagConnection: </p>
<p>    DiagPhysReception(tpChannel, tpRxDataLength); </p>
<p>    break; </p>
<p>  case CONNECTION_0: </p>
<p>    UserTpRxIndication(tpRxDataLength); </p>
<p>    break; </p>
<p>  default: </p>
<p>    break; </p>
<p>  } </p>
<p>} </p>
<p> </p>
<p>void ApplTpRxErrorIndication(vuint8 tpChannel, vuint8 status) </p>
<p>{ </p>
<p>  switch(TpRxGetConnectionNumber(tpChannel)) </p>
<p>  { </p>
<p>  case kDiagConnection: </p>
<p>    DiagRxErrorIndication(tpChannel, status); </p>
<p>  case CONNECTION_0: </p>
<p>    UserTpRxErrorIndication(status); </p>
<p>  default: </p>
<p>    break; </p>
<p>  } </p>
<p>} </p>
<p> </p>
<p>void ApplTpRxFF(vuint8 tpChannel) </p>
<p>{ </p>
<p>  if (TpRxGetConnectionNumber( tpChannel ) == kDiagConnection ) </p>
<p>  { </p>
<p>    DiagRestartS1TimerInternal( tpChannel ); </p>
<p>  } </p>
<p>} </p>
<p> </p>
<p>void ApplTpRxCF(vuint8 tpChannel) </p>
<p>{ </p>
<p>  if (TpRxGetConnectionNumber( tpChannel ) == kDiagConnection ) </p>
<p>  { </p>
<p>    DiagRestartS1TimerInternal( tpChannel ); </p>
<p>  } </p>
<p>} </p>
<p> </p>
<p> </p>
<p>void ApplTpTxConfirmation(vuint8 tpChannel, vuint8 state) </p>
<p>{ </p>
<p>  switch(TpTxGetConnectionNumber(tpChannel)) </p>
<p>  { </p>
<p>  case kDiagConnection: </p>
<p>    DiagConfirmation( tpChannel, state); </p>
<p>  case CONNECTION_0: </p>
<p>    UserTpConfirmation(status); </p>
<p>  default: </p>
<p>    break; </p>
<p>  } </p>
<p>} </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>175 / 177 </p>
<p>vuint8 ApplTxErrorIndication(vuint8 tpChannel, vuint8 status) </p>
<p>{ </p>
<p>  switch(TpTxGetConnectionNumber(tpChannel)) </p>
<p>  { </p>
<p>  case kDiagConnection: </p>
<p>    return DiagTxErrorIndication(tpChannel, status); </p>
<p>  case CONNECTION_0: </p>
<p>    UserTpTxErrorIndication(status); </p>
<p>  default: </p>
<p>    return kTpFreeChannel; </p>
<p>  } </p>
<p>} </p>
<p> </p>
<p>vuint8 ApplCopyToCAN(TpCopyToCanInfoStructPtr infoStruct) </p>
<p>{ </p>
<p>  switch(TpTxGetConnectionNumber(infoStruct-&gt;Channel)) </p>
<p>  { </p>
<p>  case kDiagConnection: </p>
<p>    return DiagCopyToCAN(infoStruct-&gt;Channel, kSFDataPos, tpTxDataLength); </p>
<p>  default: </p>
<p>    (void)memcpy( infoStruct-&gt;pDestination, infoStruct-&gt;pSource, infoStruct-&gt;Length); </p>
<p>    break; </p>
<p>  } </p>
<p>  return 0; </p>
<p>} </p>
<p> </p>
<p>void ApplTpTxNotification(vuint8 tpChannel, vuint8 DataLength) </p>
<p>{ </p>
<p>  switch(TpTxGetConnectionNumber(tpChannel)) </p>
<p>  { </p>
<p>  case kDiagConnection: </p>
<p>    DiagTpMsgTxReady(tpChannel, DataLength); </p>
<p>    break; </p>
<p>  default: </p>
<p>    break; </p>
<p>  } </p>
<p>} </p>
<p><b>8.6 </b></p>
<p><b>How to Lock a Tx-Channel and Why? (only dynamic channels) </b></p>
<p>Normally the application get a resource – use the resource – and release the resource. In </p>
<p>the  current  version  the  resource  Transmit-tpChannel  will  be  released  by  the  Transport </p>
<p>Layer automatically after a transmission (for code optimization). If an application will use </p>
<p>the same channel more than one time (i.e. a periodically transmission) it has to lock the </p>
<p>channel.  </p>
<p>... </p>
<p>... </p>
<p>TpTxLockChannel(channel); </p>
<p>TpTransmit(...) </p>
<p>... </p>
<p>TpTransmit(...) </p>
<p> </p>
<p>... </p>
<p>TpTransmit(...) </p>
<p> </p>
<p>The application has two possibilities to release the channel: </p>
<p><b>&gt; </b></p>
<p>unlock the channel using ‘<b>TpTxUnlockChannel ()</b>’: i.e. only one transmission without </p>
<p>a release should be done... </p>
<p>TpTxLockChannel(user_channel); </p>
<p>TpTransmit(user_channel, ...) </p>
<p>... </p>
<p>&gt;wait until confirmation occured&lt; </p>
<p>TpTxUnlockChannel(user_channel); </p>
<p>TpTransmit(user_channel, ...) </p>
<p>/* After this transmission the channel will be released */ </p>
<p>... </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>176 / 177 </p>
<p> </p>
<p><b>&gt; </b></p>
<p>release the channel using ‘<b>TpTxResetChannel()</b>’: Lock the resource for many </p>
<p>transfers as long as used  </p>
<p>... </p>
<p>... </p>
<p>TpTxLockChannel(channel); </p>
<p>TpTransmit(...) </p>
<p>... </p>
<p>TpTransmit(...) </p>
<p>... </p>
<p>TpTxResetChannel(channel); </p>
<p>... </p>
<p><b>8.7 </b></p>
<p><b>How to transmit a ConsecutiveFrame as quick as possible  </b></p>
<p>Typically this requirement is used for a fast re-programming of ECU’s through Gateways or </p>
<p>Testers.  </p>
<p>How to do that, please refer to chapter 7.2 Fast transmission of ConsecutiveFrames. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Transport Protocol ISO15765-2 </p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.14.00 </p>
<p>based on template version 5.1.0 </p>
<p>177 / 177 </p>
<p><b>9 </b></p>
<p><b>Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p><b>&gt; </b> News </p>
<p><b>&gt; </b> Products </p>
<p><b>&gt; </b> Demo software </p>
<p><b>&gt; </b> Support </p>
<p><b>&gt; </b> Training data </p>
<p><b>&gt; </b> Addresses </p>
<p> </p>
<p><b>www.vector.com </b></p>
</body>
</html>
{% endraw %}