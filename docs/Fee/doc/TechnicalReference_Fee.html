---
layout: default
title: TechnicalReference_Fee
nav_order: 3
parent: Flash EEPROM Emulation
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p> </p>
<p> </p>
<p>  </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>MICROSAR FEE </b></p>
<p>Technical Reference </p>
<p> </p>
<p>  </p>
<p>Version 8.02.02 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Authors </p>
<p>Christian Kaiser </p>
<p>Status </p>
<p>Released </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>2 </p>
<p>based on template version 3.1 </p>
<p><b>Document Information </b></p>
<p><b>History </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>Christian Kaiser </p>
<p>2012-06-26 </p>
<p>8.00.00 </p>
<p>- </p>
<p>Removed revision history entries, due to </p>
<p>major changes in component. </p>
<p>- </p>
<p>Removed all references to Fee30Inst2</p>
<p> </p>
<p>- </p>
<p>Added Ch. 2.4.2 “Partitions”, </p>
<p>- </p>
<p>Added Ch. 4.3.2 “Fee_InitEx”, updated Ch. </p>
<p>4.3.1 </p>
<p>- </p>
<p>Reworked Ch. 2.3, Ch. 2.6, Ch. 2.10, Ch. </p>
<p>3.1.1, 4.4.1, Ch. 5  </p>
<p>- </p>
<p>Changes throughout the document: </p>
<p>introduction of partitions </p>
<p>- </p>
<p>Added Ch. 6.3.4 </p>
<p>- </p>
<p>Added Ch. 2.4.3.1</p>
<p> </p>
<p>Christian Kaiser </p>
<p>2012-09-20 </p>
<p>8.00.01 </p>
<p>- </p>
<p>Minor editorial changes in Ch. 5 </p>
<p>- </p>
<p>Added Ch. 5.2.1 </p>
<p>Christian Kaiser </p>
<p>2013-03-05 </p>
<p>8.00.02 </p>
<p>- </p>
<p>Ch. 1:  AUTOSAR version(s) </p>
<p>- </p>
<p>Ch. 6.3.1: maximum number of Partitions </p>
<p>Christian Kaiser </p>
<p>2014-03-11 </p>
<p>8.00.03 </p>
<p>- </p>
<p>Editorial changes (rework of review </p>
<p>findings) </p>
<p>- </p>
<p>Ch. 5.1.5.5: corrected description of </p>
<p>“Suspend Long” </p>
<p>- </p>
<p>Ch. 3.5: Critical Section description </p>
<p>- </p>
<p>Ch. 1.1 – updated figure, added notes. </p>
<p>Claudia Mausz </p>
<p>2015-02-13 </p>
<p>8.01.00 </p>
<p>- </p>
<p>Add new chapter: </p>
<p> 2.12 Fee_MainFunction Triggering </p>
<p>Christian Kaiser </p>
<p>2016-01-13 </p>
<p>8.02.00 </p>
<p>- </p>
<p>Ch. 5.1.5.3: Corrected requirements on </p>
<p>“Internal Buffer Size” configuration </p>
<p>- </p>
<p>Ch. 2.6.1.1: Updated “parameter checks” </p>
<p>table </p>
<p>- </p>
<p>Ch.: 3.1.1: Updated deliverables table  </p>
<p>- </p>
<p>Ch.: 4.3.2, 4.3.3, 4.3.11: Updated </p>
<p>descriptions. </p>
<p>- </p>
<p>Ch. 5.1.5.1: Updated list of “Error detection </p>
<p>switches” </p>
<p>Christian Kaiser </p>
<p>2016-07-27 </p>
<p>8.02.01 </p>
<p>- </p>
<p>Ch. 6.3.16: Behavior of </p>
<p>Fee_ForceSectorSwitch </p>
<p>Christian Kaiser </p>
<p>2016-08-31 </p>
<p>8.02.02 </p>
<p>- </p>
<p>Ch. 4.3.6: internal behavior of Fee_Cancel </p>
<p><b>Reference Documents </b></p>
<p><b>No. </b></p>
<p><b>Title </b></p>
<p><b>Version </b></p>
<p>[1] </p>
<p>AUTOSAR_SWS_Flash_EEPROM_Emulation.pdf </p>
<p>-- </p>
<p>[2] </p>
<p>AUTOSAR_SWS_DET.pdf </p>
<p>V2.2.1 </p>
<p>[3] </p>
<p>AUTOSAR_BasicSoftwareModules.pdf </p>
<p>V1.3.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>3 </p>
<p>based on template version 3.1 </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Please note </b></p>
<p>We have configured the programs in accordance with your specifications in the </p>
<p>questionnaire. Whereas the programs do support other configurations than the one </p>
<p>specified in your questionnaire, Vector´s release of the programs delivered to your </p>
<p>company is expressly restricted to the configuration you have specified in the </p>
<p>questionnaire. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>4 </p>
<p>based on template version 3.1 </p>
<p><b>Contents </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>Introduction................................................................................................................. 10</b></p>
<p> </p>
<p>1.1</p>
<p> </p>
<p>Architecture Overview ...................................................................................... 11</p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>Functional Description ............................................................................................... 13</b></p>
<p> </p>
<p>2.1</p>
<p> </p>
<p>Features .......................................................................................................... 13</p>
<p> </p>
<p>2.2</p>
<p> </p>
<p>Initialization ...................................................................................................... 14</p>
<p> </p>
<p>2.3</p>
<p> </p>
<p>States .............................................................................................................. 15</p>
<p> </p>
<p>2.3.1</p>
<p> </p>
<p>Module States .................................................................................. 15</p>
<p> </p>
<p>2.3.2</p>
<p> </p>
<p>Job States/Results ........................................................................... 17</p>
<p> </p>
<p>2.4</p>
<p> </p>
<p>Flash organization ............................................................................................ 18</p>
<p> </p>
<p>2.4.1</p>
<p> </p>
<p>Block Handling ................................................................................. 19</p>
<p> </p>
<p>2.4.1.1</p>
<p> </p>
<p>Block Chunks ................................................................. 19</p>
<p> </p>
<p>2.4.1.2</p>
<p> </p>
<p>Block Search.................................................................. 19</p>
<p> </p>
<p>2.4.2</p>
<p> </p>
<p>Partitions .......................................................................................... 19</p>
<p> </p>
<p>2.4.3</p>
<p> </p>
<p>Logical Sectors ................................................................................ 20</p>
<p> </p>
<p>2.5</p>
<p> </p>
<p>Processing ....................................................................................................... 21</p>
<p> </p>
<p>2.5.1.1</p>
<p> </p>
<p>Initial processing ............................................................ 21</p>
<p> </p>
<p>2.5.1.2</p>
<p> </p>
<p>Processing of Read Job ................................................. 22</p>
<p> </p>
<p>2.5.1.3</p>
<p> </p>
<p>Processing of Write Job ................................................. 22</p>
<p> </p>
<p>2.5.1.4</p>
<p> </p>
<p>Processing of InvalidateBlock Job .................................. 22</p>
<p> </p>
<p>2.5.1.5</p>
<p> </p>
<p>Processing of EraseImmediateBlock Job ....................... 22</p>
<p> </p>
<p>2.5.1.6</p>
<p> </p>
<p>Processing of GetEraseCycle Job .................................. 22</p>
<p> </p>
<p>2.5.1.7</p>
<p> </p>
<p>Processing of GetWriteCycle Job ................................... 23</p>
<p> </p>
<p>2.6</p>
<p> </p>
<p>Error Handling .................................................................................................. 23</p>
<p> </p>
<p>2.6.1</p>
<p> </p>
<p>Development Error Reporting ........................................................... 23</p>
<p> </p>
<p>2.6.1.1</p>
<p> </p>
<p>Parameter Checking ...................................................... 25</p>
<p> </p>
<p>2.6.2</p>
<p> </p>
<p>Production Code Error Reporting ..................................................... 26</p>
<p> </p>
<p>2.6.3</p>
<p> </p>
<p>Error notification ............................................................................... 26</p>
<p> </p>
<p>2.7</p>
<p> </p>
<p>Sector Switch ................................................................................................... 27</p>
<p> </p>
<p>2.7.1</p>
<p> </p>
<p>Background Sector Switch (BSS) ..................................................... 27</p>
<p> </p>
<p>2.7.2</p>
<p> </p>
<p>Foreground Sector Switch (FSS)...................................................... 27</p>
<p> </p>
<p>2.7.3</p>
<p> </p>
<p>Sector Overflow ............................................................................... 28</p>
<p> </p>
<p>2.7.4</p>
<p> </p>
<p>Sector switch reserves and thresholds ............................................. 28</p>
<p> </p>
<p>2.7.5</p>
<p> </p>
<p>Background Sector Switch Reserve/Threshold ................................ 29</p>
<p> </p>
<p>2.7.6</p>
<p> </p>
<p>Foreground Sector Switch/Threshold ............................................... 29</p>
<p> </p>
<p>2.8</p>
<p> </p>
<p>Data Conversion .............................................................................................. 30</p>
<p> </p>
<p>2.9</p>
<p> </p>
<p>Flash Page Size impacts .................................................................................. 31</p>
<p> </p>
<p>2.10</p>
<p> </p>
<p>Services for handling under-voltage situations ................................................. 31</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>5 </p>
<p>based on template version 3.1 </p>
<p>2.11</p>
<p> </p>
<p>Critical Data Blocks .......................................................................................... 32</p>
<p> </p>
<p>2.12</p>
<p> </p>
<p>Fee_MainFunction Triggering .......................................................................... 34</p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Integration ................................................................................................................... 35</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>Scope of Delivery ............................................................................................. 35</p>
<p> </p>
<p>3.1.1</p>
<p> </p>
<p>Static Files ....................................................................................... 35</p>
<p> </p>
<p>3.1.2</p>
<p> </p>
<p>Dynamic Files .................................................................................. 36</p>
<p> </p>
<p>3.2</p>
<p> </p>
<p>Compiler Abstraction and Memory Mapping ..................................................... 36</p>
<p> </p>
<p>3.3</p>
<p> </p>
<p>Dependencies on SW Modules ........................................................................ 38</p>
<p> </p>
<p>3.3.1</p>
<p> </p>
<p>OSEK/AUTOSAR OS ....................................................................... 38</p>
<p> </p>
<p>3.3.2</p>
<p> </p>
<p>Module SchM ................................................................................... 38</p>
<p> </p>
<p>3.3.3</p>
<p> </p>
<p>Module Det ...................................................................................... 38</p>
<p> </p>
<p>3.3.4</p>
<p> </p>
<p>Module Fls ....................................................................................... 38</p>
<p> </p>
<p>3.3.5</p>
<p> </p>
<p>Callback Functions ........................................................................... 39</p>
<p> </p>
<p>3.3.5.1</p>
<p> </p>
<p>Lower layer interaction ................................................... 39</p>
<p> </p>
<p>3.3.5.2</p>
<p> </p>
<p>Upper layer interaction ................................................... 39</p>
<p> </p>
<p>3.3.5.3</p>
<p> </p>
<p>User Error Callback........................................................ 40</p>
<p> </p>
<p>3.4</p>
<p> </p>
<p>Dependencies on HW modules ........................................................................ 41</p>
<p> </p>
<p>3.5</p>
<p> </p>
<p>Critical Sections ............................................................................................... 41</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>API Description ........................................................................................................... 42</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Interfaces Overview ......................................................................................... 42</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Type Definitions ............................................................................................... 42</p>
<p> </p>
<p>4.2.1</p>
<p> </p>
<p>Fee_SectorSwitchStatusType .......................................................... 42</p>
<p> </p>
<p>4.2.2</p>
<p> </p>
<p>Fee_SectorErrorType ....................................................................... 42</p>
<p> </p>
<p>4.3</p>
<p> </p>
<p>Services provided by FEE ................................................................................ 44</p>
<p> </p>
<p>4.3.1</p>
<p> </p>
<p>Fee_Init ............................................................................................ 44</p>
<p> </p>
<p>4.3.2</p>
<p> </p>
<p>Fee_InitEx ........................................................................................ 45</p>
<p> </p>
<p>4.3.3</p>
<p> </p>
<p>Fee_SetMode .................................................................................. 45</p>
<p> </p>
<p>4.3.4</p>
<p> </p>
<p>Fee_Read ........................................................................................ 47</p>
<p> </p>
<p>4.3.5</p>
<p> </p>
<p>Fee_Write ........................................................................................ 48</p>
<p> </p>
<p>4.3.6</p>
<p> </p>
<p>Fee_Cancel ..................................................................................... 49</p>
<p> </p>
<p>4.3.7</p>
<p> </p>
<p>Fee_GetStatus ................................................................................. 50</p>
<p> </p>
<p>4.3.8</p>
<p> </p>
<p>Fee_GetJobResult ........................................................................... 50</p>
<p> </p>
<p>4.3.9</p>
<p> </p>
<p>Fee_InvalidateBlock ......................................................................... 51</p>
<p> </p>
<p>4.3.10</p>
<p> </p>
<p>Fee_GetVersionInfo ......................................................................... 52</p>
<p> </p>
<p>4.3.11</p>
<p> </p>
<p>Fee_EraseImmediateBlock .............................................................. 52</p>
<p> </p>
<p>4.3.12</p>
<p> </p>
<p>Fee_MainFunction ........................................................................... 53</p>
<p> </p>
<p>4.3.13</p>
<p> </p>
<p>Fee_GetEraseCycle ......................................................................... 54</p>
<p> </p>
<p>4.3.14</p>
<p> </p>
<p>Fee_GetWriteCycle .......................................................................... 55</p>
<p> </p>
<p>4.3.15</p>
<p> </p>
<p>Fee_GetSectorSwitchStatus ............................................................ 56</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>6 </p>
<p>based on template version 3.1 </p>
<p>4.3.17</p>
<p> </p>
<p>Fee_ForceSectorSwitch ................................................................... 58</p>
<p> </p>
<p>4.3.18</p>
<p> </p>
<p>Fee_ConvertBlockConfig ................................................................. 59</p>
<p> </p>
<p>4.3.19</p>
<p> </p>
<p>Fee_SuspendWrites ......................................................................... 61</p>
<p> </p>
<p>4.3.20</p>
<p> </p>
<p>Fee_ResumeWrites ......................................................................... 61</p>
<p> </p>
<p>4.3.21</p>
<p> </p>
<p>Fee_DisableFss ............................................................................... 62</p>
<p> </p>
<p>4.3.22</p>
<p> </p>
<p>Fee_EnableFss ................................................................................ 63</p>
<p> </p>
<p>4.4</p>
<p> </p>
<p>Services used by FEE ...................................................................................... 63</p>
<p> </p>
<p>4.4.1</p>
<p> </p>
<p>Data Conversion Callback ................................................................ 64</p>
<p> </p>
<p>4.5</p>
<p> </p>
<p>Callback Functions ........................................................................................... 65</p>
<p> </p>
<p>4.5.1</p>
<p> </p>
<p>Fee_JobEndNotification ................................................................... 65</p>
<p> </p>
<p>4.5.2</p>
<p> </p>
<p>Fee_JobErrorNotification ................................................................. 65</p>
<p> </p>
<p>4.6</p>
<p> </p>
<p>Configurable Interfaces .................................................................................... 66</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>Configuration .............................................................................................................. 67</b></p>
<p> </p>
<p>5.1</p>
<p> </p>
<p>Configuration with DaVinci Configurator ........................................................... 67</p>
<p> </p>
<p>5.1.1</p>
<p> </p>
<p>Start configuration of the FEE .......................................................... 67</p>
<p> </p>
<p>5.1.2</p>
<p> </p>
<p>Useful Chunk-Sizes (instance counts) .............................................. 67</p>
<p> </p>
<p>5.1.3</p>
<p> </p>
<p>Update of block configuration ........................................................... 69</p>
<p> </p>
<p>5.1.4</p>
<p> </p>
<p>FEE Configuration tab ...................................................................... 69</p>
<p> </p>
<p>5.1.5</p>
<p> </p>
<p>General Settings tab ........................................................................ 73</p>
<p> </p>
<p>5.1.5.1</p>
<p> </p>
<p>Error Detection – Development Mode ............................ 73</p>
<p> </p>
<p>5.1.5.2</p>
<p> </p>
<p>Area “Error Callback” ..................................................... 73</p>
<p> </p>
<p>5.1.5.3</p>
<p> </p>
<p>Area Buffer..................................................................... 74</p>
<p> </p>
<p>5.1.5.4</p>
<p> </p>
<p>Area “Upper Layer” ........................................................ 74</p>
<p> </p>
<p>5.1.5.5</p>
<p> </p>
<p>Area “Critical Section Handling” ..................................... 74</p>
<p> </p>
<p>5.1.6</p>
<p> </p>
<p>Partitions .......................................................................................... 75</p>
<p> </p>
<p>5.1.6.1</p>
<p> </p>
<p>Area “Management” ....................................................... 77</p>
<p> </p>
<p>5.1.6.2</p>
<p> </p>
<p>Area “Lower Layer” ........................................................ 77</p>
<p> </p>
<p>5.1.7</p>
<p> </p>
<p>Module API tab ................................................................................. 78</p>
<p> </p>
<p>5.1.7.1</p>
<p> </p>
<p>API Configuration ........................................................... 78</p>
<p> </p>
<p>5.1.7.2</p>
<p> </p>
<p>Provided API .................................................................. 79</p>
<p> </p>
<p>5.2</p>
<p> </p>
<p>Configuration Parameters only visible in GCE .................................................. 79</p>
<p> </p>
<p>5.2.1</p>
<p> </p>
<p>Fls API deviating from AUTOSAR naming convention ...................... 79</p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b>AUTOSAR Standard Compliance............................................................................... 81</b></p>
<p> </p>
<p>6.1</p>
<p> </p>
<p>Deviations ........................................................................................................ 81</p>
<p> </p>
<p>6.1.1</p>
<p> </p>
<p>Maximum Blocking Time .................................................................. 81</p>
<p> </p>
<p>6.2</p>
<p> </p>
<p>Additions/ Extensions ....................................................................................... 81</p>
<p> </p>
<p>6.2.1</p>
<p> </p>
<p>Parameter Checking ........................................................................ 81</p>
<p> </p>
<p>6.2.2</p>
<p> </p>
<p>Fee_InitEx ........................................................................................ 81</p>
<p> </p>
<p>6.2.3</p>
<p> </p>
<p>GetEraseCycle ................................................................................. 81</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>7 </p>
<p>based on template version 3.1 </p>
<p>6.2.4</p>
<p> </p>
<p>GetWriteCycle .................................................................................. 81</p>
<p> </p>
<p>6.2.5</p>
<p> </p>
<p>GetSectorSwitchStatus .................................................................... 81</p>
<p> </p>
<p>6.2.6</p>
<p> </p>
<p>ForceSectorSwitch ........................................................................... 81</p>
<p> </p>
<p>6.2.7</p>
<p> </p>
<p>Fee_ConvertBlockConfig ................................................................. 81</p>
<p> </p>
<p>6.2.8</p>
<p> </p>
<p>Fee_SuspendWrites / Fee_ResumeWrites ....................................... 81</p>
<p> </p>
<p>6.2.9</p>
<p> </p>
<p>Fee_EnableFss / Fee_DisableFss ................................................... 81</p>
<p> </p>
<p>6.3</p>
<p> </p>
<p>Limitations........................................................................................................ 81</p>
<p> </p>
<p>6.3.1</p>
<p> </p>
<p>Partitions .......................................................................................... 81</p>
<p> </p>
<p>6.3.2</p>
<p> </p>
<p>Flash Usage ..................................................................................... 82</p>
<p> </p>
<p>6.3.3</p>
<p> </p>
<p>Performance .................................................................................... 82</p>
<p> </p>
<p>6.3.4</p>
<p> </p>
<p>Aborts/Resets .................................................................................. 82</p>
<p> </p>
<p>6.3.5</p>
<p> </p>
<p>Write Cycle and Erase Cycle Counters ............................................ 83</p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>Glossary and Abbreviations ...................................................................................... 84</b></p>
<p> </p>
<p>7.1</p>
<p> </p>
<p>Glossary .......................................................................................................... 84</p>
<p> </p>
<p>7.2</p>
<p> </p>
<p>Abbreviations ................................................................................................... 84</p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>Contact ........................................................................................................................ 86</b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>8 </p>
<p>based on template version 3.1 </p>
<p><b>Illustrations </b></p>
<p>1-1</p>
<p> </p>
<p>AUTOSAR architecture ............................................................................. 11</p>
<p> </p>
<p>Figure 1-2</p>
<p> </p>
<p>FEE in a typical (AUTOSAR) SW architecture .......................................... 12</p>
<p> </p>
<p>Figure 2-1 FEE Module States ............................................................................................. 16</p>
<p> </p>
<p>Figure 2-2 From User Blocks to Flash Sectors ..................................................................... 18</p>
<p> </p>
<p><b> </b></p>
<p><b>Tables </b></p>
<p>Table 2-1 </p>
<p> </p>
<p>Supported SWS features .......................................................................... 13</p>
<p> </p>
<p>Table 2-2 </p>
<p> </p>
<p>Not supported SWS features .................................................................... 13</p>
<p> </p>
<p>Table 2-3 </p>
<p> </p>
<p>Module states ........................................................................................... 15</p>
<p> </p>
<p>Table 2-4 </p>
<p> </p>
<p>Job results ................................................................................................ 17</p>
<p> </p>
<p>Table 2-5 </p>
<p> </p>
<p>Mapping of service IDs to services ........................................................... 24</p>
<p> </p>
<p>Table 2-6 </p>
<p> </p>
<p>Errors reported to DET ............................................................................. 24</p>
<p> </p>
<p>Table 2-7 </p>
<p> </p>
<p>Development Error detection: Assignment of checks to services .............. 26</p>
<p> </p>
<p>Table 2-8 </p>
<p> </p>
<p>Det_ReportError ....................................................................................... 27</p>
<p> </p>
<p>Table 3-1 </p>
<p> </p>
<p>Static files ................................................................................................. 35</p>
<p> </p>
<p>Table 3-2 </p>
<p> </p>
<p>Generated files ......................................................................................... 36</p>
<p> </p>
<p>Table 3-3 </p>
<p> </p>
<p>Compiler abstraction and memory mapping .............................................. 36</p>
<p> </p>
<p>Table 3-4 </p>
<p> </p>
<p>Error Codes and FEE’s default behavior ................................................... 41</p>
<p> </p>
<p>Table 4-1 </p>
<p> </p>
<p>Fee_SectorSwitchStatusType ................................................................... 42</p>
<p> </p>
<p>Table 4-2 </p>
<p> </p>
<p>Fee_SectorError Type .............................................................................. 43</p>
<p> </p>
<p>Table 4-3 </p>
<p> </p>
<p>Fee_Init .................................................................................................... 44</p>
<p> </p>
<p>Table 4-4 </p>
<p> </p>
<p>Fee_InitEx ................................................................................................ 45</p>
<p> </p>
<p>Table 4-5 </p>
<p> </p>
<p>Fee_SetMode ........................................................................................... 46</p>
<p> </p>
<p>Table 4-6 </p>
<p> </p>
<p>Fee_Read ................................................................................................. 47</p>
<p> </p>
<p>Table 4-7 </p>
<p> </p>
<p>Fee_Write ................................................................................................. 48</p>
<p> </p>
<p>Table 4-8 </p>
<p> </p>
<p>Fee_Cancel .............................................................................................. 49</p>
<p> </p>
<p>Table 4-9 </p>
<p> </p>
<p>Fee_GetStatus ......................................................................................... 50</p>
<p> </p>
<p>Table 4-10 </p>
<p> </p>
<p>Fee_GetJobResult .................................................................................... 51</p>
<p> </p>
<p>Table 4-11 </p>
<p> </p>
<p>Fee_InvalidateBlock ................................................................................. 51</p>
<p> </p>
<p>Table 4-12 </p>
<p> </p>
<p>Fee_GetVersionInfo .................................................................................. 52</p>
<p> </p>
<p>Table 4-13 </p>
<p> </p>
<p>Fee_EraseImmediateBlock ....................................................................... 53</p>
<p> </p>
<p>Table 4-14 </p>
<p> </p>
<p>Fee_MainFunction .................................................................................... 54</p>
<p> </p>
<p>Table 4-15 </p>
<p> </p>
<p>Fee_GetEraseCycle ................................................................................. 55</p>
<p> </p>
<p>Table 4-16 </p>
<p> </p>
<p>Fee_GetWriteCycle .................................................................................. 56</p>
<p> </p>
<p>Table 4-17 </p>
<p> </p>
<p>Fee_GetSectorSwitchStatus ..................................................................... 57</p>
<p> </p>
<p>Table 4-18 </p>
<p> </p>
<p>Fee_ForceSectorSwitch ........................................................................... 59</p>
<p> </p>
<p>Table 4-19 </p>
<p> </p>
<p>Fee_ConvertBlockConfig .......................................................................... 61</p>
<p> </p>
<p>Table 4-20 </p>
<p> </p>
<p>Fee_SuspendWrites ................................................................................. 61</p>
<p> </p>
<p>Table 4-21 </p>
<p> </p>
<p>Fee_ResumeWrites .................................................................................. 62</p>
<p> </p>
<p>Table 4-22 </p>
<p> </p>
<p>Fee_DisableFss ........................................................................................ 62</p>
<p> </p>
<p>Table 4-23 </p>
<p> </p>
<p>Fee_EnableFss ........................................................................................ 63</p>
<p> </p>
<p>Table 4-24 </p>
<p> </p>
<p>Services used by the FEE......................................................................... 64</p>
<p> </p>
<p>Table 4-25 </p>
<p> </p>
<p>User defined conversion callback ............................................................. 65</p>
<p> </p>
<p>Table 4-26 </p>
<p> </p>
<p>Fee_JobEndNotification ............................................................................ 65</p>
<p> </p>
<p>Table 4-27 </p>
<p> </p>
<p>Fee_JobErrorNotification .......................................................................... 66</p>
<p> </p>
<p>Table 4-28 </p>
<p> </p>
<p>Configurable interfaces ............................................................................. 66</p>
<p> </p>
<p>Table 5-1 </p>
<p> </p>
<p>Fee configuration ...................................................................................... 72</p>
<p> </p>
<p>Table 5-2 </p>
<p> </p>
<p>Error Detection – Development Mode ....................................................... 73</p>
<p> </p>
<p>Table 5-3 </p>
<p> </p>
<p>Error Callback ........................................................................................... 74</p>
<p> </p>
<p>Table 5-4 </p>
<p> </p>
<p>Upper Layer .............................................................................................. 74</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>9 </p>
<p>based on template version 3.1 </p>
<p>Table 5-5 </p>
<p> </p>
<p>Critical Section Services ........................................................................... 75</p>
<p> </p>
<p>Table 5-6 </p>
<p> </p>
<p>Lower Layer .............................................................................................. 76</p>
<p> </p>
<p>Table 5-7 </p>
<p> </p>
<p>sector switch reserve ................................................................................ 77</p>
<p> </p>
<p>Table 5-8 </p>
<p> </p>
<p>Lower Layer .............................................................................................. 77</p>
<p> </p>
<p>Table 5-9 </p>
<p> </p>
<p>API Configuration ..................................................................................... 78</p>
<p> </p>
<p>Table 5-10 </p>
<p> </p>
<p>Provided API ............................................................................................. 79</p>
<p> </p>
<p>Table 5-11 </p>
<p> </p>
<p>Parameters only visible in GCE view. ....................................................... 79</p>
<p> </p>
<p>Table 7-1 </p>
<p> </p>
<p>Glossary ................................................................................................... 84</p>
<p> </p>
<p>Table 7-2 </p>
<p> </p>
<p>Abbreviations ............................................................................................ 85</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>10 </p>
<p>based on template version 3.1 </p>
<p><b>1 </b></p>
<p><b>Introduction </b></p>
<p>This document describes the functionality, API and configuration of the AUTOSAR BSW </p>
<p>module FEE as specified in [1].  </p>
<p> </p>
<p><b>Supported AUTOSAR Release*: </b></p>
<p>3 and 4 </p>
<p><b>Supported Configuration Variants: </b></p>
<p>link-time with AUTOSAR 3 </p>
<p>pre-compile with AUTOSAR 4 </p>
<p><b> </b></p>
<p> </p>
<p><b>Vendor ID: </b></p>
<p>FEE_VENDOR_ID </p>
<p>30 decimal </p>
<p>(= Vector-Informatik, </p>
<p>according to HIS) </p>
<p><b>Module ID: </b></p>
<p>FEE_MODULE_ID   </p>
<p>21 decimal </p>
<p>(according to ref. [3]) </p>
<p>* For the precise AUTOSAR Release please see the release specific documentation.  </p>
<p> </p>
<p>The FEE enables you to access a dedicated flash area for storing data persistently. It is </p>
<p>intended to be used exclusively either by the NVRAM Manager or on SW instance within a </p>
<p>Flash-Boot-Loader in the Boot-Loader mode. </p>
<p>Further on, the module depends on some other modules, like DET for error handling, the </p>
<p>underlying Flash driver for hardware access and the MEMIF for consistent types. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>11 </p>
<p>based on template version 3.1 </p>
<p><b>1.1 </b></p>
<p><b>Architecture Overview </b></p>
<p>The following figure shows where the FEE is located in the AUTOSAR architecture. </p>
<p> </p>
<p>1-1 </p>
<p>AUTOSAR architecture </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>12 </p>
<p>based on template version 3.1 </p>
<p> </p>
<p>The following figure shows the FEE and its relationship to other modules. </p>
<p> </p>
<p>Figure 1-2 </p>
<p>FEE in a typical (AUTOSAR) SW architecture </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Figure 1-2 shows the normal case. In general FEE does not depend on who actually </p>
<p>uses it, and who provides required services. E.g. it does not matter who provides </p>
<p>mechanisms to synchronize access to critical sections (chapter 3.5), or who actually </p>
<p>calls </p>
<p>Fee_MainFunction</p>
<p>. It also doesn’t matter whether callbacks (Fls to FEE, FEE </p>
<p>to NvM) are directly called as depicted in the figure, or whether they are “intercepted” </p>
<p>by someone.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>FEE assumes exclusive usage of Fls. Allowing other components to use Fls’s services </p>
<p>results in synchronization issues, which are hard to solve. Hence this shall be avoided. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b> class Sandbox</b></p>
<p><b>Fee</b></p>
<p><b>MemIf</b></p>
<p><b>Det</b></p>
<p><b>Fls</b></p>
<p><b>Nv M</b></p>
<p><b>SchM</b></p>
<p><b>EcuM</b></p>
<p>«use»</p>
<p>«include»</p>
<p>«use»</p>
<p>«use»</p>
<p>«optional»</p>
<p>«optional»</p>
<p>«optional»</p>
<p>«use»</p>
<p>«initialize»</p>
<p>«triggers»</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>13 </p>
<p>based on template version 3.1 </p>
<p><b>2 </b></p>
<p><b>Functional Description </b></p>
<p><b>2.1 </b></p>
<p><b>Features </b></p>
<p>The features listed in this chapter cover the complete functionality specified in [1]. </p>
<p>The &quot;supported&quot;  and &quot;not  supported&quot; features  are presented  in  the following  two  tables. </p>
<p>For further information of not supported features also see chapter 6. </p>
<p> </p>
<p>The following features described in [1] are supported: </p>
<p><b>Feature </b></p>
<p>The module operates on blocks provided by the NVRAM Manager. Read accesses to blocks are </p>
<p>handled byte-wise. </p>
<p>Hardware restrictions like erase cycles or sector sizes are abstracted and not visible for the </p>
<p>upper layer. </p>
<p>Incomplete writes (e.g. due to reset) are detected. </p>
<p>The virtual sectors use a wrap-around concept with backup of the most recent data blocks. </p>
<p>Possibility to retrieve the number of erase cycles of a logical sector (done via the API service </p>
<p>Fee_GetEraseCycle()</p>
<p>). This feature is an add-on to the AUTOSAR standard. </p>
<p>Possibility to retrieve the number of write cycles of a block (done via the API service </p>
<p>Fee_GetWriteCycle()</p>
<p>).This feature is an add-on to the AUTOSAR standard. </p>
<p>Possibility to force sector switches (done via the API service </p>
<p>Fee_ForceSectorSwitch()</p>
<p>).This feature is an add-on to the AUTOSAR standard. </p>
<p>API to perform data conversion after configuration update i.e. blocks whose payload has </p>
<p>changed may be converted according to new configuration without data-loss. This feature is an </p>
<p>add-on to the AUTOSAR standard. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>This feature is optional, i.e. it has to be ordered explicitly. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Fee supports Flash Address Spaces (provided by Fls) of up to 2GBytes, i.e. Sectors to be used </p>
<p>by FEE may resist in range </p>
<p>0x00000000 </p>
<p>to </p>
<p>0x7FFFFFFF</p>
<p> </p>
<p>Fee_MainFunction</p>
<p> Triggering: Possibility to call the </p>
<p>Fee_MainFunction</p>
<p> in a cyclic task or in </p>
<p>a background task. </p>
<p>Table 2-1  </p>
<p>Supported SWS features </p>
<p>The following features described in [1] are not supported: </p>
<p><b>Feature </b></p>
<p>The </p>
<p>MAXIMUM_BLOCK_TIME</p>
<p> is not supported by the FEE, because no time reference is provided </p>
<p>to the FEE. </p>
<p>Table 2-2  </p>
<p>Not supported SWS features </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>14 </p>
<p>based on template version 3.1 </p>
<p><b>2.2 </b></p>
<p><b>Initialization </b></p>
<p>The  FEE  is  initialized  and  operational  after </p>
<p>Fee_Init()</p>
<p>  or </p>
<p>Fee_InitEx()</p>
<p>  has  been </p>
<p>called.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The FEE is driven asynchronously, i.e. jobs are requested via dedicated API, and they </p>
<p>are processed by calling </p>
<p>Fee_MainFunction()</p>
<p>. </p>
<p><b> </b></p>
<p> </p>
<p>Initialization  just  prepares  FEE  to  accept  and  process  requests.  Initialization  of  sectors </p>
<p>(checking  their  headers  and  determining  new/old  one)  is  deferred  until  first  request  is </p>
<p>being started on a partition. </p>
<p> </p>
<p>Additionally after initialization, any sector switch processing is disabled: </p>
<p><b>&gt; </b></p>
<p>Sector Switch Processing in Background (see 2.7.1) can be enabled by </p>
<p>Fee_SetMode(MEMIF_MODE_SLOW)</p>
<p>. </p>
<p><b>&gt; </b></p>
<p>Depending on “FSS Control API” (see Ch. 5.1.7.1) they can only be enabled by: </p>
<p><b>&gt; </b></p>
<p>Fee_EnableFss()</p>
<p>, if “FSS Control  API” was enabled. In that case write requests </p>
<p>beyond Foreground Sector Switch Threshold are disabled; refer to chapter 2.10. </p>
<p><b>&gt; </b></p>
<p>Fee_Write()</p>
<p> / </p>
<p>Fee_InvalidateBlock()</p>
<p> / </p>
<p>Fee_EraseImmediateBlock()</p>
<p>, </p>
<p>otherwise. </p>
<p>These implicit defaults help to ensure that FEE does not perform any write, or even erase </p>
<p>operations during ECU start-up, unless explicitly requested by user. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>It is not recommended to use any of the mentioned services during ECU’s start-up </p>
<p>phase. Special care needs to be taken about write requests: Proper initialization (order) </p>
<p>of application software is important to prevent from too early write accesses to NV </p>
<p>memory. </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>15 </p>
<p>based on template version 3.1 </p>
<p><b>2.3 </b></p>
<p><b>States </b></p>
<p><b>2.3.1 </b></p>
<p><b>Module States </b></p>
<p><b>Point in Time </b></p>
<p><b>Module State </b></p>
<p>After Reset, before Fee_Init was called </p>
<p>MEMIF_UNINIT </p>
<p>When Fee_Init() returns </p>
<p>MEMIF_ BUSY_INTERNAL </p>
<p>When accepting a job request. </p>
<p>MEMIF_BUSY </p>
<p>If rejecting a job request. </p>
<p>No change. </p>
<p>Upon completing a job (including returning from </p>
<p>Fee_SetMode()</p>
<p>) </p>
<p>MEMIF_BUSY_INTERNAL </p>
<p>Pending internal operations (while no user job is pending) </p>
<p>MEMIF_BUSY_INTERNAL </p>
<p>Not even an internal job is pending </p>
<p>MEMIF_IDLE </p>
<p>Table 2-3  </p>
<p>Module states </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>State MEMIF_UNINIT can only be delivered after reset, if start-up code was executed, </p>
<p>and section </p>
<p>FEE_START_SEC_VAR_INIT_UNSPECIFIED</p>
<p> was mapped to an </p>
<p>appropriate section, being initialized by startup code. See also: chapter 3.2 </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Normally (unless Fee_Cancel was called) FEE_IDLE state can only be entered via </p>
<p>FEE_BUSY_INTERNAL. </p>
<p>Whenever FEE leaves MEMIF_BUSY_STATE due to job completion it asynchronously </p>
<p>checks all partitions for their fill levels, and the necessity of sector switch. Therefore, </p>
<p>even if no sector switch is necessary or allowed, it takes few </p>
<p>Fee_MainFunction</p>
<p> </p>
<p>cycles to finally become (and report) IDLE  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>16 </p>
<p>based on template version 3.1 </p>
<p> </p>
<p>Figure 2-1 FEE Module States </p>
<p> </p>
<p> </p>
<p><b>stm GlobalFsm</b></p>
<p><b>initialized</b></p>
<p>PowerOff</p>
<p><b>MEMIF_UNINIT</b></p>
<p><b>MEMIF_IDLE</b></p>
<p><b>MEMIF_BUSY</b></p>
<p><b>MEMIF_BUSY_INTERNAL</b></p>
<p>PowerOff</p>
<p>Power-On Reset</p>
<p>Reset</p>
<p>Fee_Init</p>
<p>Fee_EraseImmediateBlock,</p>
<p>Fee_Invalidate, Fee_Read, Fee_Write,</p>
<p>Fee_ConvertBlockConfig</p>
<p>/jobResult = MEMIF_JOB_PENDING</p>
<p>Fee_Cancel</p>
<p>/jobResult = MEMIF_JOB_CANCELLED</p>
<p>power-off</p>
<p>Fee_Read, Fee_Write, Fee_Invalidate,</p>
<p>Fee_EraseImmediateBlock,</p>
<p>Fee_ConvertBlockConfig</p>
<p>/jobResult = MEMIF_JOB_PENDING</p>
<p>Fee_Cancel</p>
<p>Fee_ForceSectorSwitch,</p>
<p>Fee_SetMode</p>
<p>Fee_ForceSectorSwitch</p>
<p>jobCompleted</p>
<p>/jobResult = [MEMIF_JOB_OK,</p>
<p>MEMIF_JOB_FAILED,</p>
<p>MEMIF_BLOCK_INVALID,</p>
<p>MEMIF_BLOCK_INCONSISTENT]</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>17 </p>
<p>based on template version 3.1 </p>
<p><b>2.3.2 </b></p>
<p><b>Job States/Results </b></p>
<p> </p>
<p><b>Point in Time </b></p>
<p><b>Job State </b></p>
<p>After successfully finished job </p>
<p>MEMIF_JOB_OK </p>
<p>After a job has been accepted </p>
<p>MEMIF_JOB_PENDING </p>
<p>After </p>
<p>Fee_Cancel()</p>
<p> </p>
<p>MEMIF_JOB_CANCELLED </p>
<p>After a read job has been finished and an invalidated block </p>
<p>was found, or the requested block was never successfully </p>
<p>written before. </p>
<p>MEMIF_BLOCK_INVALID </p>
<p>After a block is read which has not been written successfully </p>
<p>before.  </p>
<p>MEMIF_BLOCK_INCONSISTENT </p>
<p>After a job has been finished and retrieving data (independent </p>
<p>from management information of payload data) from the Flash </p>
<p>failed </p>
<p>MEMIF_JOB_FAILED </p>
<p>Table 2-4  </p>
<p>Job results </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>18 </p>
<p>based on template version 3.1 </p>
<p><b>2.4 </b></p>
<p><b>Flash organization </b></p>
<p>Figure 2-2 gives an overview of how FEE organizes flash memory, and how FEE’s three </p>
<p>main concepts – (User) Blocks, Partitions and Logical Sectors – are related. </p>
<p> </p>
<p>Figure 2-2 From User Blocks to Flash Sectors </p>
<p><b>pkg Ov erall Flash management concepts</b></p>
<p><b>(Data)Flash</b></p>
<p><b>FEE</b></p>
<p><b>FEE::Partition</b></p>
<p>{1..*}</p>
<p><b>FEE::Logical Sector</b></p>
<p><b>(Data)Flash::Physical Sector</b></p>
<p>{2..*}</p>
<p><b>FEE::UserBlocks</b></p>
<p>{1..*}</p>
<p><b>Nv M</b></p>
<p><b>NVM::User Blocks</b></p>
<p>{1..*}</p>
<p>2</p>
<p>0..1</p>
<p>1..*</p>
<p>0..1</p>
<p>1</p>
<p>0..1</p>
<p>0..1</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>19 </p>
<p>based on template version 3.1 </p>
<p><b>2.4.1 </b></p>
<p><b>Block Handling </b></p>
<p><b>2.4.1.1 </b></p>
<p><b>Block Chunks </b></p>
<p>Block chunks are the smallest entities the FEE can allocate dynamically in Flash. A chunk </p>
<p>allocation reserves space for a configurable number (refer to chapter 5.1.4) of versions of </p>
<p>the associated block. FEE continues writing new versions (aka instances) of this block into </p>
<p>its most recent chunk, until it’s full. Writing the next instance requires allocation of a new </p>
<p>chunk.  Each  block’s  chunks  build  up  a  linked  list  in  flash:  each  chunk  points  to  its </p>
<p>successor. </p>
<p><b>2.4.1.2 </b></p>
<p><b>Block Search </b></p>
<p>A  requested  block  is searched  by following  the  links  provided  by  the  block  chunks. The </p>
<p>start  point  is  the  default  area  of  the  block.  If  the  chunk  link  is  erased  the  search  is </p>
<p>continued within the current chunk using a binary search algorithm. </p>
<p>The search concept provides fast access to every block as only the needed block chunks </p>
<p>are accessed. </p>
<p><b>2.4.2 </b></p>
<p><b>Partitions </b></p>
<p>FEE employs a concept of partitions. A partition can be thought of an emulation space that </p>
<p>is managed separately from other ones: </p>
<p><b>&gt; </b></p>
<p>Errors in one partition do not affect data in other ones </p>
<p><b>&gt; </b></p>
<p>Error states (e.g. Read-Only Mode) are local to a single partition. </p>
<p><b>&gt; </b></p>
<p>Job processing in one partition does (almost) not depend on sector switch processing </p>
<p>(chapter 2.7) in other partitions. </p>
<p>However,  compared  to  two  FEEs operating  on two  different flash  devices,  partitions  still </p>
<p>require synchronization: </p>
<p><b>&gt; </b></p>
<p>FEE is still restricted to use one single flash driver. </p>
<p><b>&gt; </b></p>
<p>According to AUTOSAR, FEE is still limited to one pending user request. </p>
<p><b>&gt; </b></p>
<p>Only one partition can perform a sector switch at a time </p>
<p><b>&gt; </b></p>
<p>Sector switch processing can only be interrupted when processing a block completed. </p>
<p>Each partition consists of two logical sectors, which in turn are mapped to physical flash </p>
<p>sectors. </p>
<p>During configuration, each logical block must be assigned to a partition. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>FEE configurations for FBL and Application do not need to share all partitions. E.g. a </p>
<p>partition containing only application data may remain unknown to the FBL. However, </p>
<p>shared partitions must refer to identical Fls configurations (FlsConfigSet container), and </p>
<p>they must match in address and size, as well as in alignment settings. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>20 </p>
<p>based on template version 3.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>Most typical as well as most recommended use case for partitions is the physical </p>
<p>separation of frequently and infrequently written data. Such a separation reduces </p>
<p>sector switch efforts, because a whole partition would be infrequently updated. </p>
<p>Therefore, separation also increases availability data. However, it may increase </p>
<p>number of flash’s erase cycles over life-time, because frequently written data will </p>
<p>usually (it depends on actual amounts) be spread over less flash memory. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>2.4.3 </b></p>
<p><b>Logical Sectors </b></p>
<p>The  FEE  divides  the  physical  flash  assigned  to  a  partition  in  two  parts,  called  logical </p>
<p>sectors. Each logical sector must be mapped to one or more continuous physical Flash </p>
<p>sectors. Logical sectors do not need to be aligned on physical sector boundaries, i.e. they </p>
<p>may  start  and/or  end  within  physical  sectors.  However,  start  and  end  addresses  must </p>
<p>adhere to the configured address alignment. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The mapping of logical to physical sectors is mutual exclusive, i.e. physical sectors </p>
<p>may not be shared between logical sectors. </p>
<p>It results in a minimum number of physical sectors that must be available to define </p>
<p>(additional) partitions: Per partition, two physical sectors must be provided by HW (and </p>
<p>Fls). </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Unused flash space within a physical sector must not be used (neither read nor write) </p>
<p>by other software. It should be assumed to be erased, because FEE does never write </p>
<p>it, but it will be erased, too, with each sector erase triggered by FEE. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>Besides the lower logical sector must be located at a smaller address than the upper one, </p>
<p>both sectors may be located anywhere within the flash space provided by the underlying </p>
<p>driver  (considering  restrictions  imposed  by  hardware  or  the  driver,  of  course),  i.e.  there </p>
<p>may be a gap between them. </p>
<p> </p>
<p>Furthermore, the two logical sectors must be erasable independently from each other, i.e. </p>
<p>they must be mapped to distinctive physical sectors.  </p>
<p>The size of the smaller logical sector defines the maximal number of blocks that can be </p>
<p>handled by the FEE. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>Within AUTOSAR specification logical sectors are called virtual sectors. </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>21 </p>
<p>based on template version 3.1 </p>
<p><b>2.5 </b></p>
<p><b>Processing </b></p>
<p>All </p>
<p>jobs </p>
<p>(Read, </p>
<p>Write, </p>
<p>InvalidateBlock, </p>
<p>EraseImmediateBlock, </p>
<p>GetWriteCycle, </p>
<p>GetEraseCycle, ForceSectorSwitch) will be executed asynchronously with the help of a job </p>
<p>state machine. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The FEE must be initialized before the services are called. </p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Only one job can be accepted at a time. Hence, it is not allowed to request an </p>
<p>asynchronous job to the FEE as long as the currently pending job has not been </p>
<p>completed. </p>
<p><b> </b></p>
<p> </p>
<p>While </p>
<p>internal </p>
<p>operations </p>
<p>are </p>
<p>performed </p>
<p>(current </p>
<p>status </p>
<p>is </p>
<p>equal </p>
<p>to </p>
<p>MEMIF_BUSY_INTERNAL</p>
<p>) a job can be accepted, but actual processing may be deferred </p>
<p>due to sector switch handling (see chapter 2.7 for more details).  </p>
<p><b>2.5.1.1 </b></p>
<p><b>Initial processing </b></p>
<p>In order to become able to process a request, FEE has to determine both logical sectors’ </p>
<p>states, i.e. whether they are usable at all, and which one contains most recent data. Once </p>
<p>FEE determined these states, it maintains them in RAM. </p>
<p>Since a request is always associated with a partition, FEE performs this initialization step </p>
<p>at beginning of normal job processing. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>FEE attempts to read both sector headers, i.e. the first 8 bytes in each logical sector. </p>
<p>This processing takes at least 3 cycles (from initial job request to start of actual job </p>
<p>processing), assuming FEE does not have to wait for Fls, i.e. Fls_Read processing </p>
<p>completes between two Fee_MainFunction calls. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>If one of both Fee sector headers is erased or corrupted, and the other one is ok, FEE </p>
<p>tries to use the valid sector; erasing the other one will be done either when necessary, </p>
<p>or when no user jobs are pending (see also chapter 2.7) </p>
<p>If both sector headers are erased, FEE behaves as if flash is nearly full (see also </p>
<p>2.7.2): It will erase one logical sector and write its header, as part of first write class </p>
<p>job’s processing. </p>
<p>If both sector headers are corrupted or one header is corrupted and the other is </p>
<p>erased, FEE calls the user error callback function, if configured. Refer to chapter </p>
<p>3.3.5.3 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>22 </p>
<p>based on template version 3.1 </p>
<p><b>2.5.1.2 </b></p>
<p><b>Processing of Read Job </b></p>
<p>The  FEE  provides  the  service </p>
<p>Fee_Read()</p>
<p>  for  reading  a  block. This  service  reads  the </p>
<p>data of the block which has been most recently written.  </p>
<p>This asynchronous job is initiated with the API function </p>
<p>Fee_Read()</p>
<p> and is processed by </p>
<p>subsequent calls of </p>
<p>Fee_MainFunction() </p>
<p>(see also chapter 2.3). </p>
<p><b>2.5.1.3 </b></p>
<p><b>Processing of Write Job </b></p>
<p>To write the current block content to flash memory the API function </p>
<p>Fee_Write()</p>
<p> is used. </p>
<p>FEE searches the next free position in the most recent block chunk to write block’s new </p>
<p>instance to. </p>
<p>This asynchronous job is initiated with the API function </p>
<p>Fee_Write()</p>
<p> and is processed by </p>
<p>subsequent calls of </p>
<p>Fee_MainFunction() </p>
<p>(see also chapter 2.3). </p>
<p><b>2.5.1.4 </b></p>
<p><b>Processing of InvalidateBlock Job </b></p>
<p>To </p>
<p>invalidate </p>
<p>the </p>
<p>block </p>
<p>content </p>
<p>in </p>
<p>flash </p>
<p>memory </p>
<p>the </p>
<p>API </p>
<p>function </p>
<p>Fee_InvalidateBlock()</p>
<p>  is  used.  The  FEE  component  marks  the  block  as  invalid; </p>
<p>upon success, subsequent read attempts report </p>
<p>MEMIF_BLOCK_INVALID</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>Block Invalidation is very similar to Block Write, as it also creates a new instance, i.e. it </p>
<p>consumes flash memory. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>This asynchronous job is initiated with the API function </p>
<p>Fee_InvalidateBlock()</p>
<p> and is </p>
<p>processed by subsequent calls of </p>
<p>Fee_MainFunction() </p>
<p>(see also chapter 2.3). </p>
<p><b>2.5.1.5 </b></p>
<p><b>Processing of EraseImmediateBlock Job </b></p>
<p>Immediate data is data of a block which should be written with a higher priority than the </p>
<p>other blocks. </p>
<p>To mark an immediate block as erased the API function </p>
<p>Fee_EraseImmediateBlock()</p>
<p> </p>
<p>is  used.  As  the  FEE  component  can’t  erase  the  corresponding  block  it  writes  invalid </p>
<p>information for the block to the flash memory. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>FEE processes EraseImmediateBlock jobs identically to InvalidateBlock jobs. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>This asynchronous job is initiated with the API function </p>
<p>Fee_EraseImmediateBlock()</p>
<p> </p>
<p>and is processed by subsequent calls of </p>
<p>Fee_MainFunction() </p>
<p>(see also chapter 2.3). </p>
<p><b>2.5.1.6 </b></p>
<p><b>Processing of GetEraseCycle Job </b></p>
<p>The  erase  cycle  counter  is  increased  during  every  erase  of  a  certain  logical  sector  and </p>
<p>consequently counts the erase cycles of the flash. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>23 </p>
<p>based on template version 3.1 </p>
<p>To </p>
<p>get </p>
<p>the </p>
<p>erase </p>
<p>cycle </p>
<p>counter </p>
<p>of </p>
<p>a </p>
<p>specified </p>
<p>logical </p>
<p>sector, </p>
<p>the </p>
<p>API </p>
<p>function </p>
<p>Fee_GetEraseCycle()</p>
<p>  is  used.  The  availability  of  this  service  is  configurable  at  pre-</p>
<p>compile time which can be done via the configuration tool. </p>
<p>This asynchronous job is initiated with the API function </p>
<p>Fee_GetEraseCycle()</p>
<p> and is </p>
<p>processed by subsequent calls of </p>
<p>Fee_MainFunction() </p>
<p>(see also chapter 2.3). </p>
<p><b>2.5.1.7 </b></p>
<p><b>Processing of GetWriteCycle Job </b></p>
<p>The write cycle counter counts the write cycles of each block. </p>
<p>To </p>
<p>get </p>
<p>the </p>
<p>write </p>
<p>cycle </p>
<p>counter </p>
<p>of </p>
<p>a </p>
<p>specified </p>
<p>block, </p>
<p>the </p>
<p>API </p>
<p>function </p>
<p>Fee_GetWriteCycle()</p>
<p>  is  used.  The  availability  of  this  service  is  configurable  at  pre-</p>
<p>compile time which can be done via the configuration tool. </p>
<p>This asynchronous job is initiated with the API function </p>
<p>Fee_GetWriteCycle()</p>
<p> and is </p>
<p>processed by subsequent calls of </p>
<p>Fee_MainFunction()</p>
<p>(see also chapter 2.3). </p>
<p><b>2.6 </b></p>
<p><b>Error Handling </b></p>
<p>The module offers detection of errors. </p>
<p>Errors are classified in development and production errors. </p>
<p>Development errors should be detected and fixed during development/integration phase. </p>
<p>Those errors are caused by faulty configuration or incorrect usage of the module’s API. </p>
<p>Production errors are hardware errors and software exceptions that cannot be avoided and </p>
<p>are also expected  to occur in  production  code.  FEE  has no  case  to  report a production </p>
<p>error. </p>
<p><b>2.6.1 </b></p>
<p><b>Development Error Reporting </b></p>
<p>Development  errors  are  reported  to  DET  using  the  service </p>
<p>Det_ReportError()</p>
<p>  as </p>
<p>specified  in  [2],  if  development  error  detection  and  reporting,  are  enabled  (see  chapter </p>
<p>5.1.5.1). </p>
<p>If another module than DET is used for development error reporting, the function prototype </p>
<p>for  reporting  the  error  can  be  configured  by  the  integrator,  but  must  have  the  same </p>
<p>signature as the service </p>
<p>Det_ReportError()</p>
<p> (see chapter 2.6.3). </p>
<p>The reported FEE ID can be found in chapter 1. </p>
<p>The  reported  service  IDs  identify  the  services  which  are  described  in  4.3. The following </p>
<p>table presents the service IDs and the related services: </p>
<p><b>Service ID </b></p>
<p><b>Service </b></p>
<p>0x00u </p>
<p>Fee_Init() / Fee_InitEx() </p>
<p>0x01u </p>
<p>Fee_SetMode() </p>
<p>0x02u </p>
<p>Fee_Read() </p>
<p>0x03u </p>
<p>Fee_Write() </p>
<p>0x04u </p>
<p>Fee_Cancel() </p>
<p>0x05u </p>
<p>Fee_GetStatus() </p>
<p>0x06u </p>
<p>Fee_GetJobResult() </p>
<p>0x07u </p>
<p>Fee_InvalidateBlock() </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>24 </p>
<p>based on template version 3.1 </p>
<p><b>Service ID </b></p>
<p><b>Service </b></p>
<p>0x08u </p>
<p>Fee_GetVersionInfo() </p>
<p>0x09u </p>
<p>Fee_EraseImmediateBlock() </p>
<p>0x10u </p>
<p>Fee_JobEndNotification() </p>
<p>0x11u </p>
<p>Fee_JobErrorNotification() </p>
<p>0x12u </p>
<p>Fee_MainFunction() </p>
<p>0x20u </p>
<p>Fee_GetEraseCycle() </p>
<p>0x21u </p>
<p>Fee_GetWriteCycle() </p>
<p>0x22u </p>
<p>Fee_GetSectorSwitchStatus() </p>
<p>0x23u </p>
<p>Fee_ForceSectorSwitch() </p>
<p>0x24u </p>
<p>Fee_ConvertBlockConfig() </p>
<p>Table 2-5  </p>
<p>Mapping of service IDs to services </p>
<p>The errors reported to DET are described in the following table: </p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>0x02 </p>
<p>FEE_E_INVALID_BLOCK_NO </p>
<p>This error code is reported if an API service is called with </p>
<p>invalid block number. </p>
<p>0x10 </p>
<p>FEE_E_PARAM_DATABUFFERPTR </p>
<p>It is reported if a pointer parameter of an API service is </p>
<p>called with the </p>
<p>NULL_PTR</p>
<p> value. </p>
<p>0x11 </p>
<p>FEE_E_PARAM_SECTOR_NUMBER </p>
<p>It is reported if the </p>
<p>Fee_GetEraseCycle()</p>
<p> API service is </p>
<p>called with an invalid logical sector number. </p>
<p>0x12 </p>
<p>FEE_E_PARAM_LENGTH_OFFSET </p>
<p>It is reported if the </p>
<p>Fee_Read()</p>
<p> API service is called with </p>
<p>invalid </p>
<p>BlockOffset</p>
<p> and </p>
<p>Length</p>
<p> values. </p>
<p>0x13 </p>
<p>FEE_E_BUSY </p>
<p>It is reported if one of the asynchronous API services has </p>
<p>been called in parallel. </p>
<p>0x14 </p>
<p>FEE_E_NO_INIT </p>
<p>It is reported if one of the API services has been called </p>
<p>without an initialized FEE. </p>
<p>Table 2-6  </p>
<p>Errors reported to DET </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>All error codes starting from 0x10 are defined in addition to [1]. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>25 </p>
<p>based on template version 3.1 </p>
<p><b>2.6.1.1 </b></p>
<p><b>Parameter Checking </b></p>
<p>AUTOSAR requires that API functions check the validity of their parameters. The checks </p>
<p>listed in Table 2-7 are internal parameter checks of the API functions. These checks are </p>
<p>intended </p>
<p>for </p>
<p>development </p>
<p>error </p>
<p>detection </p>
<p>and </p>
<p>can </p>
<p>be </p>
<p>en-/disabled </p>
<p>separately; </p>
<p>it </p>
<p>is </p>
<p>described </p>
<p>in </p>
<p>chapter </p>
<p>5.1.5.  </p>
<p> </p>
<p>Capability of controlling execution of single checks is an addition to AUTOSAR which just </p>
<p>requires </p>
<p>to </p>
<p>en-/disable </p>
<p>the </p>
<p>complete </p>
<p>parameter </p>
<p>checking </p>
<p>via </p>
<p>the </p>
<p>parameter </p>
<p>FEE_DEV_ERROR_DETECT</p>
<p>. </p>
<p>The following table shows which parameter checks are performed on which services: </p>
<p><b>Check </b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Service </b></p>
<p>FEE_E_INVALID_BLOCK_NO </p>
<p>FEE_E_PARAM_DATABUFFERPTR </p>
<p>FEE_E_PARAM_SECTOR_NUMBER </p>
<p>FEE_E_PARAM_LENGTH_OFFSET </p>
<p>FEE_E_BUSY </p>
<p>FEE_E_NO_INIT </p>
<p>Fee_Init() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Fee_InitEx() </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Fee_SetMode() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>Fee_Read() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Fee_Write() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Fee_Cancel() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>Fee_GetStatus() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Fee_GetJobResult() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>Fee_InvalidateBlock() </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Fee_GetVersionInfo() </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Fee_EraseImmediateBlock() </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Fee_JobEndNotification() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Fee_JobErrorNotification() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Fee_MainFunction() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p>1</p>
<p>  </p>
<p>Fee_GetEraseCycle() </p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Fee_GetWriteCycle() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Fee_GetSectorSwitchStatus() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>Fee_ForceSectorSwitch() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>                                            </p>
<p>1</p>
<p> Check only; no error reporting to DET </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>26 </p>
<p>based on template version 3.1 </p>
<p><b>Check </b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Service </b></p>
<p>FEE_E_INVALID_BLOCK_NO </p>
<p>FEE_E_PARAM_DATABUFFERPTR </p>
<p>FEE_E_PARAM_SECTOR_NUMBER </p>
<p>FEE_E_PARAM_LENGTH_OFFSET </p>
<p>FEE_E_BUSY </p>
<p>FEE_E_NO_INIT </p>
<p>Fee_ConvertBlockConfig() </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Fee_SuspendWrites() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>Fee_ResumeWrites() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>Fee_EnableFss() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>Fee_DisableFss() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>Table 2-7  </p>
<p>Development Error detection: Assignment of checks to services </p>
<p><b>2.6.2 </b></p>
<p><b>Production Code Error Reporting </b></p>
<p>FEE does not report any production related error to an error/event manager like DEM. </p>
<p> </p>
<p><b>2.6.3 </b></p>
<p><b>Error notification </b></p>
<p>All detected errors in development mode are by default reported to the Development Error </p>
<p>Tracer (DET), but can be configured regarding called function and include file.</p>
<p> </p>
<p>The error declaration must have following syntax: </p>
<p><b>Prototype </b></p>
<p>Prototype syntax described in chapter 8.2.2 Det_ReportError of [2].</p>
<p> </p>
<p><b>Parameter </b></p>
<p>ModuleId </p>
<p>Specifies the identifier of the module causing the error. The module Id of FEE </p>
<p>can be found in chapter 1. </p>
<p>InstanceId </p>
<p>The identifier of the index based instance of a module, starting from 0. Thus </p>
<p>the FEE is a single instance module it will pass 0 as InstanceId. </p>
<p>ApiId </p>
<p>The identifier of the API function, which caused the error. </p>
<p>ErrorCode </p>
<p>The number of the specific error. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>User function for the </p>
<p>Fee_Errorhook</p>
<p>, which specifies development errors. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>27 </p>
<p>based on template version 3.1 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>called in application context </p>
<p>Table 2-8  </p>
<p>Det_ReportError </p>
<p><b>2.7 </b></p>
<p><b>Sector Switch </b></p>
<p>The </p>
<p>sector </p>
<p>switch </p>
<p>is </p>
<p>responsible </p>
<p>to </p>
<p>gather </p>
<p>most </p>
<p>recent </p>
<p>instances </p>
<p>data </p>
<p>of </p>
<p>all </p>
<p>blocks/datasets from one logical sector (= source sector) and write them to the other one </p>
<p>(= target sector). After this procedure has been finished, the source sector can be erased </p>
<p>to prepare it for storing data again. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>Under certain conditions, no copy is necessary at all. However, finally FEE has to erase </p>
<p>a sector to reclaim free flash space. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>There are different reasons to perform a sector switch </p>
<p></p>
<p> </p>
<p>Threshold exceeded (see below) </p>
<p></p>
<p> </p>
<p>User Request (Fee_ForceSectorSwitch) </p>
<p></p>
<p> </p>
<p>Critical Block Handling (refer to ch. 2.11) </p>
<p><b>2.7.1 </b></p>
<p><b>Background Sector Switch (BSS) </b></p>
<p>Sector  Switches  will  be  processed  in  background,  unless  FEE  was  set  to  “Fast  Mode” </p>
<p>(refer to ch. 4.3.3). This means that processing occurs only if no user job is pending. </p>
<p>Sector Switch processing is interruptible by  user jobs after a block has been processed </p>
<p>(copied, or decision to skip copying was taken). </p>
<p><b>2.7.2 </b></p>
<p><b>Foreground Sector Switch (FSS) </b></p>
<p>A  Sector  Switch  being  processed  in  Foreground  defers  a  write  job.  That  means  a  job </p>
<p>cannot be processed before a sector switch has been completed. </p>
<p>Such a sector switch is not interruptible by any other job. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>The actual reason is the pending job that was deferred. At most one job may be </p>
<p>pending at any time. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>FSS processing is always initiated to a pending write job for a particular block. This block </p>
<p>is associated with a specific partition; thus a FSS will be performed on that partition only. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>28 </p>
<p>based on template version 3.1 </p>
<p><b>2.7.3 </b></p>
<p><b>Sector Overflow </b></p>
<p>A sector overflow occurs, if FEE failed to complete data copy, because both logical sectors </p>
<p>ran out of space. Since in that case both sectors contain most recent data instances (of </p>
<p>different blocks), FEE is unable to continue with erase operation without losing most recent </p>
<p>data. </p>
<p>Such an event is caused by several consecutive aborted write attempts. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Such aborts should be avoided wherever possible, i.e. they shall be considerable being </p>
<p>exceptional (thus rare) events. Especially a SW reset shall be performed only if FEE is </p>
<p>IDLE. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>A sector overflow is local to one particular partition, i.e. other partitions are not affected. </p>
<p>Probability of an overflow depends on different parameters: </p>
<p><b>&gt; </b></p>
<p>Probability of resets, of course </p>
<p><b>&gt; </b></p>
<p>Partition’s write load, which can be defined as number of bytes over time. </p>
<p><b>&gt; </b></p>
<p>(Foreground) Sector Switch in relation to blocks’ sizes. </p>
<p>To minimize effects caused by under-voltage situations FEE provides additional services; </p>
<p>see chapter 2.10. </p>
<p>Accepting loss of most recent data instances, FEE may be instructed to perform a sector </p>
<p>erase in order to restore write ability; see chapter 3.3.5.3. Additionally the risk of losing </p>
<p>data can be restricted to certain “uncritical” blocks at configuration time. For details refer to </p>
<p>chapter 2.11. </p>
<p> </p>
<p><b>2.7.4 </b></p>
<p><b>Sector switch reserves and thresholds </b></p>
<p>The  FEE  determines  the  necessity  of  a  sector  switch  based  upon  exceeding  a  related </p>
<p>threshold value. This value is always an offset relative to the start address of the currently </p>
<p>“newer” sector.  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Basic Knowledge </b></p>
<p>A threshold is considered to have been exceeded, if one sector (the older one) <b>is </b>full </p>
<p>and the other one (newer sector) is filled up to (or exceeding) this certain level. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>29 </p>
<p>based on template version 3.1 </p>
<p> </p>
<p><b>Note </b></p>
<p>To assure that a sector switch in FBL mode can copy FBL’s data and an unknown </p>
<p>amount of application data, sector switch has to start as early as possible. Therefore in </p>
<p>FBL mode a sector switch starts once the newer logical sector is used. This might </p>
<p>degrade efficiency of flash usage, but since it would happen in FBL mode only, effects </p>
<p>are negligible. </p>
<p> </p>
<p>In configuration “reserve values”, rather than the thresholds, need to be specified by user. </p>
<p>During generation the thresholds to be used by FEE are calculated based on these values </p>
<p>and  block  configuration.  “Reserve” is meant  as follows:  How  much  space  the  FEE  shall </p>
<p>reserve  additionally  to  the  space  complete  block  configuration  would  consume  in  flash </p>
<p>(that is the amount of flash space that would be consumed, when every block was written </p>
<p>exactly once). </p>
<p>Thus a reserve value of 0 means: For every configured block, one chunk is reserved; FEE </p>
<p>shall start sector switch once less than one chunk per block fits into flash.  </p>
<p>A reserve greater than 0 adds additional space resulting in more possible aborts until the </p>
<p>flash runs full (sector overflow). </p>
<p>The  worst  case  number  of  additional  resets  the  FEE  can  deal  with  is  the  FSS  reserve </p>
<p>divided by the size of the largest chunk. </p>
<p>There is no standard recommendation how to configure this threshold, because this value </p>
<p>depends on the individual environment of the ECU and the configuration of the memory </p>
<p>stack, like: </p>
<p></p>
<p> </p>
<p>total available flash memory </p>
<p></p>
<p> </p>
<p>number of blocks/datasets </p>
<p></p>
<p> </p>
<p>size of the blocks/datasets </p>
<p></p>
<p> </p>
<p>page size of the flash hardware </p>
<p></p>
<p> </p>
<p>general handling of blocks, i.e. when blocks/datasets are written down to  the non-</p>
<p>volatile memory </p>
<p><b>2.7.5 </b></p>
<p><b>Background Sector Switch Reserve/Threshold </b></p>
<p>A  sector  switch  in  background  mode  (BSS)  is  the  type  of  sector  switch  that  should </p>
<p>normally occur. In flash, both sectors are currently in use, but there is quite much space </p>
<p>available. </p>
<p>Exceeding BSS threshold causes FEE to start BSS processing, as described above. </p>
<p><b>2.7.6 </b></p>
<p><b>Foreground Sector Switch/Threshold </b></p>
<p>If  flash/partition  fill  level  exceeds  FSS  threshold,  it  is  quite  full.  It  can  be  seen  as  “last </p>
<p>chance processing”. Therefore, a write job directed to that partition will be deferred in order </p>
<p>to complete FSS first. </p>
<p>FSS </p>
<p>threshold </p>
<p>also </p>
<p>indicates </p>
<p>most </p>
<p>critical </p>
<p>fill-level: </p>
<p>once </p>
<p>it </p>
<p>is </p>
<p>exceeded, </p>
<p>a </p>
<p>call </p>
<p>to </p>
<p>Fee_DisableFss()</p>
<p> becomes effective, i.e. in that case FEE  terminates write requests </p>
<p>delivering error result. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>30 </p>
<p>based on template version 3.1 </p>
<p>Since BSS is defined to start earlier than FSS, its threshold is smaller. This also means </p>
<p>that an FSS implies BSS, i.e. processing is done in Background, as described above. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>FEE keeps track of logical sector’s state. Once copying most recent data completed, it </p>
<p>internally marks the “older” sector as outdated. This results in reducing criticality: Flash </p>
<p>is still almost full, but we just need to erase a sector. An FSS becomes rather a BSS; </p>
<p>after completing the copy process, a pending write job gets the chance to be processed </p>
<p>before sector format is being started. If Flash is too full, the job will be deferred again; it </p>
<p>has to wait for completion of sector format. </p>
<p> </p>
<p><b>2.8 </b></p>
<p><b>Data Conversion </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>This feature is optional, i.e. it has to be ordered explicitly. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>Standard  FEE  implementation  allows  to  update  the  block  configuration,  and  to  modify </p>
<p>block  lengths  with  one  restriction:  Existing  data  of  blocks,  whose  payload  (length)  was </p>
<p>changed, </p>
<p>will </p>
<p>be </p>
<p>lost. </p>
<p>Trying </p>
<p>to </p>
<p>read </p>
<p>such </p>
<p>a </p>
<p>block </p>
<p>will </p>
<p>lead </p>
<p>to </p>
<p>job </p>
<p>result </p>
<p>MEMIF_BLOCK_INVALID</p>
<p>, </p>
<p>until </p>
<p>the </p>
<p>block </p>
<p>has </p>
<p>been </p>
<p>re-written </p>
<p>according </p>
<p>to </p>
<p>new </p>
<p>configuration. </p>
<p>Data Conversion provides a “framework” enabling the SW to keep even those blocks: The </p>
<p>FEE scans Dataflash content. For each block (in detail: each block’s most recent instance) </p>
<p>it finds, a callback function will be invoked. This function gets following arguments: </p>
<p><b>&gt; </b></p>
<p>Unique block identifier (each dataset is treated separately) </p>
<p><b>&gt; </b></p>
<p>(pointer to) most recent data </p>
<p><b>&gt; </b></p>
<p>old length (as found in flash)  </p>
<p><b>&gt; </b></p>
<p>new length (according to current configuration), if block is still configured. </p>
<p>Within the callback the user may decide what the FEE shall do with this block: </p>
<p><b>&gt; </b></p>
<p>skip it (it will be lost after finalization of Conversion) </p>
<p><b>&gt; </b></p>
<p>write it according to old length </p>
<p><b>&gt; </b></p>
<p>write it according to new length </p>
<p>The data passed to the callback may be modified; the FEE will write them, if desired. This </p>
<p>is  the  actual  conversion.  Since  the  FEE  is  not  able  to  detect  internal  configuration </p>
<p>changes, the callback will also be invoked for blocks whose length did not change. </p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>31 </p>
<p>based on template version 3.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>The callback might need to implement some code to make correct decisions, e.g. if </p>
<p>different blocks need to be treated differently, additionally depending on old </p>
<p>configuration (from which version the update to current version has been performed) </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>If a block does not contain any data, i.e. it was never (successfully) written, it had been </p>
<p>invalidated, or it became corrupted by other means, the callback will not be invoked; there </p>
<p>is no data to be converted. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Conversion must be triggered immediately after start-up, using </p>
<p>Fee_ConvertBlockConfig</p>
<p> (refer to 4.3.18), before upper layers get running, and </p>
<p>before a sector switch (with complete configuration) has been performed. Therefore it </p>
<p>must happen before the first write request (including invalidate and erase) was issued </p>
<p>to the FEE, and before an explicit </p>
<p>Fee_ForceSectorSwitch</p>
<p> has been requested. </p>
<p>Otherwise the sector switch would remove all outdated (removed or payload changed) </p>
<p>data blocks  </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>2.9 </b></p>
<p><b>Flash Page Size impacts </b></p>
<p>The  smallest  writeable  entity,  called  page  size,  differs  for  example  from  2  byte  on  the </p>
<p>S12XDP512 up to 128 byte on the TC1796. The size of every kind of data to be written </p>
<p>must be rounded up to a multiple flash device’s page size. Therefore padding is added, if </p>
<p>the data doesn’t fit a multiple of the page size. </p>
<p>For example, if you want to write 13 byte (incl. management information) into the flash of a </p>
<p>TC1796, the padding which is needed is 115 byte to reach a multiple of the page size 128 </p>
<p>byte. But if you want to write 13 byte (incl. management information) into the flash of a </p>
<p>S12XDP512, the padding which is needed is only 1 byte to reach a multiple of the page </p>
<p>size 2 byte. </p>
<p>This  example  shows,  that  the  flash  could  be  used  much  more  efficient,  if  data  which </p>
<p>should be written matches the page size or is only a little smaller. That is to say, that it is </p>
<p>possible to write more instances of a block/dataset of the same type into a smaller flash </p>
<p>with small page size than into a larger flash where plenty of padding has to be added. </p>
<p><b>2.10 </b></p>
<p><b>Services for handling under-voltage situations </b></p>
<p>The FEE provides two sets of functions enabling you to handle under-voltage situations </p>
<p>properly. </p>
<p>Both sets focus on different use cases: </p>
<p>Fee_SuspendWrites()</p>
<p> is intended to react  on actual under-voltage situation detected </p>
<p>via dedicated monitoring circuitry. Usually there is some amount of time (few milliseconds) </p>
<p>to </p>
<p>react </p>
<p>on </p>
<p>such </p>
<p>conditions </p>
<p>until </p>
<p>a </p>
<p>low </p>
<p>voltage </p>
<p>reset </p>
<p>occurs. </p>
<p>Its </p>
<p>counterpart, </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>32 </p>
<p>based on template version 3.1 </p>
<p>Fee_ResumeWrites()</p>
<p>,  was  introduced  in  order  to  prevent  from  stalling,  if  voltage </p>
<p>reaches normal range, without any reset. </p>
<p>The  other  set,  namely </p>
<p>Fee_EnableFss()</p>
<p>  and </p>
<p>Fee_DisableFss()</p>
<p>,  respectively,  is </p>
<p>intended  to  signal  the  increased  or  decreased  risk  of  resets  to  the  FEE.  For  instance, </p>
<p>usually engine start (cranking) might be a situation of higher risk, while a running engine </p>
<p>might be a much safer situation. Since this function set deals with risks, they will only have </p>
<p>a noticeable effect if the flash becomes too full, i.e. if Foreground Sector Switch Threshold </p>
<p>exceeded. As  long  as  flash  is  not  at  a  critical  fill  level  (denoted  by  Foreground  Sector </p>
<p>Switch Threshold), the write operations and (background) sector switch are permitted. On </p>
<p>the  other  hand,  execution  of  FSS  may  be  disabled.  In  this  case,  write  requests  are </p>
<p>forbidden, once FSS became necessary; they will fail with error result. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If this set of functions is enabled in configuration, FEE does not automatically enable </p>
<p>FSS, i.e. execution of Foreground Sector Switches is disabled per default (after </p>
<p>Fee_Init()</p>
<p>). In order to enable execution of FSS, you will have to call </p>
<p>Fee_EnableFss()</p>
<p> once ECU start-up completed, and operating conditions are stable </p>
<p>(esp. normal voltage). </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Basic Knowledge </b></p>
<p>Execution of Sector switch (“garbage collection”) is essential to keep FEE writable. In </p>
<p>case of exceeded Foreground Sector Switch Thresholds the flash is at a critical fill </p>
<p>level, i.e. cleaning up has become urgently necessary. Writing new data in this situation </p>
<p>might consume additional flash space; it would become insufficient to complete the </p>
<p>sector switch afterwards. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>It should be ensured </p>
<p>Fee_EnableFss()</p>
<p>will  be called after start-up, at least under </p>
<p>normal conditions. Otherwise FSS’s intention of “last-chance processing” would be </p>
<p>foiled; exceeding FSS threshold would cause entering read only mode. This in turn </p>
<p>should be exceptional behavior. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>As stated in chapter 2.7.6, criticality reduces once block copy has been completed. </p>
<p>Thus, if </p>
<p>Fee_DisableFss()</p>
<p> was recently called, FEE remains writable, once block </p>
<p>copy completed, and only sector erase is outstanding. </p>
<p> </p>
<p><b>2.11 </b></p>
<p><b>Critical Data Blocks </b></p>
<p>In order to keep FEE writable in case of sector overflows (chapter 2.7.3), it has to erase </p>
<p>one  logical  sector.  Though  this  event  is  an  exception,  occurring  really  rarely,  the  erase </p>
<p>causes loss of recent data instances. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>33 </p>
<p>based on template version 3.1 </p>
<p>While  such  a  loss  would  be  uncritical  to  some  data  blocks,  losing  some  other  blocks’ </p>
<p>recent  instances  might  cause  the  whole  ECU  to  cease  working.  Such  data  blocks  are </p>
<p>essential  to  ECUs  operability;  losing  them  is  critical  (as  would  result  in  “defective  ECU” </p>
<p>requiring service). FEE configuration provides the possibility to mark these blocks. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Basic Knowledge </b></p>
<p>Typically data block’s “criticality” rises with decreasing write frequency. The more </p>
<p>infrequently a block will be written the less number of older instances exist, and the </p>
<p>larger their semantic difference would be, disqualifying them for usage as fallback data. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>As a result FEE ensures that any write access keeps all “critical” Data Blocks’ most recent </p>
<p>instances within one logical sector. Thus there is always one logical sector that might be </p>
<p>erased (in case of error) without losing such “critical” data. </p>
<p>Keeping critical data together requires conditional execution of sector switch. If necessary, </p>
<p>i.e.  if  a  critical  block  cannot  be  written  into  the  same  logical  sector  containing  all  other </p>
<p>critical blocks, FEE performs a Foreground Sector Switch. </p>
<p>Since each  block  configured  to be  critical may  cause  an additional sector switch  before </p>
<p>writing a new instance, flash usage over life-time increases due to additional block copies.  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Due to independency of partitions, the differentiation between critical and “not as </p>
<p>critical” data blocks is also local to a partition. On one hand FEE only has to care about </p>
<p>all critical blocks in a particular partition. On the other hand, resolving a sector overflow </p>
<p>(by formatting a sector) may cause loss of recent uncritical data in only that partition. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Basic Knowledge </b></p>
<p>By marking all Blocks assigned to one partition as “critical”, that partition can be </p>
<p>configured to operate with so called “single sector usage”, that is, FEE ensures that all </p>
<p>data blocks’ recent instances are located within a single logical sector. Before switching </p>
<p>to the other one, all recent instances will be copied. This results in most robust </p>
<p>operations (concerning aborts). However, there are penalties in performance, </p>
<p>especially because no BSS can actually be performed, as well as in flash usage, </p>
<p>because always all recent data instances will be copied. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>Even though the FEE in FBL does not know anything about Application’s, critical blocks </p>
<p>can be handled safely, unless added to FBL configuration and set to “uncritical” (thus </p>
<p>configured inconsistently). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>34 </p>
<p>based on template version 3.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If Data Flash is being shared between Application and FBL, it is highly recommended </p>
<p>to configure all FBL blocks being “critical”. Typically there are some blocks, containing </p>
<p>information about Application’s validity and information whether to start Application or </p>
<p>FBL. These blocks are critical to an ECU! </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>It is not recommended to mark blocks as “critical” and “immediate”. Requirements on </p>
<p>both types contradict: while “immediate” data are required to be written fast, “critical” </p>
<p>data are required to be written very safely, implying additional operations, which slow </p>
<p>down write performance. </p>
<p><b>2.12 </b></p>
<p><b>Fee_MainFunction Triggering </b></p>
<p> </p>
<p>In  AUTOSAR  release  4.x  an  additional  option  is  introduced,  to  be  able  to  call  the </p>
<p>Fee_MainFunction</p>
<p> in a cyclic task or in a background task. </p>
<p>The cyclic task (default configuration) is used when the main function shall be triggered </p>
<p>periodically. Typically the cycle time needs to be defined, for example 10ms. </p>
<p>If the </p>
<p>Fee_MainFunction</p>
<p> shall be accessed quicker, the function shall be called in a </p>
<p>background task. The background task runs when the system has nothing to do further. </p>
<p>The </p>
<p>Fee_MainFunction</p>
<p> is called as often as the available CPU load allow.  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If the system is overloaded, it may happen that the background task is no longer called. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The </p>
<p>Fee_MainFunction</p>
<p> should not be triggered faster than </p>
<p>Fls_MainFunction</p>
<p>, </p>
<p>because the FEE must wait for the FLS. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>35 </p>
<p>based on template version 3.1 </p>
<p><b>3 </b></p>
<p><b>Integration </b></p>
<p>This chapter gives necessary information for the integration of the MICROSAR FEE into </p>
<p>an application environment of an ECU. </p>
<p><b>3.1 </b></p>
<p><b>Scope of Delivery </b></p>
<p>The delivery of the FEE contains the files which are described in the chapters 3.1.1 and </p>
<p>3.1.2. </p>
<p><b>3.1.1 </b></p>
<p><b>Static Files </b></p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>Fee.h </p>
<p>Defines the public interface of MICROSAR FEE module. </p>
<p>Fee_InitEx.h </p>
<p>Declares Fee_InitEx service. Shall be included by user if, and only if, </p>
<p>extended initialization via </p>
<p>Fee_InitEx()</p>
<p> (see chapter 4.3.2) is used. </p>
<p>Fee_Types.h </p>
<p>Defines public types of FEE. </p>
<p>Fee.c </p>
<p>Implements MICROSAR FEE module’s API. </p>
<p>Fee_Processing.c </p>
<p>Implements module’s processing, including the state machine </p>
<p>Fee_IntBase.h </p>
<p>Fee_JopParams.h </p>
<p>Defines basic internal type definitions </p>
<p>Fee_Int.h </p>
<p>Defines the internal interface for all module internal source files, as </p>
<p>well as the container for all RAM variables which are used by the FEE. </p>
<p>Fee_Partition.h </p>
<p>Fee_PartitionDefs.h </p>
<p>Fee_Partition.c </p>
<p>Provide internal services to manage partitions </p>
<p>Fee_Sector.h </p>
<p>Fee_SectorDefs.h </p>
<p>Fee_Sector.c </p>
<p>Internal services abstracting access to logical sectors </p>
<p>Fee_ChunkInfo.h </p>
<p>Fee_ChunkInfoDefs.h </p>
<p>Fee_ChunkInfo.c </p>
<p>Internal services providing access to Chunks and instances contained </p>
<p>within. </p>
<p>Fee_Cbk.h </p>
<p>Defines the callback interface for the lower layer. </p>
<p>Fee_bswmd.arxml </p>
<p>Contains the formal notation of all information, which belongs to the </p>
<p>FEE. </p>
<p>Identifier.xml </p>
<p>Defines all configuration parameters.</p>
<p>2</p>
<p> </p>
<p>Fee.xml </p>
<p>Defines the GUI which represents this module.2 </p>
<p>If_AsrIfFee.jar </p>
<p>Generator plug-in for DaVinci Configurator 5 </p>
<p>Table 3-1  </p>
<p>Static files </p>
<p>Only Fee.h shall be included directly by other components. </p>
<p>                                            </p>
<p>2</p>
<p> AUTOSAR 3.x deliveries only </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>36 </p>
<p>based on template version 3.1 </p>
<p><b>3.1.2 </b></p>
<p><b>Dynamic Files </b></p>
<p>The dynamic files are generated by the configuration tool DaVinci Configurator. </p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>Fee_Cfg.h </p>
<p>Contains the static configuration part of this module. </p>
<p>Fee_Lcfg.c </p>
<p>Contains the link-time part of configuration. </p>
<p>Fee_PrivateCfg.h </p>
<p>Contains the static configuration part, which is only included of this </p>
<p>module. </p>
<p>Table 3-2  </p>
<p>Generated files </p>
<p><b>3.2 </b></p>
<p><b>Compiler Abstraction and Memory Mapping  </b></p>
<p>The  objects  (e.g.  variables,  functions,  constants)  are  declared  by  compiler  independent </p>
<p>definitions  –  the  compiler  abstraction  definitions.  Each  compiler  abstraction  definition  is </p>
<p>assigned to a memory section. </p>
<p>The  following  table  contains  the  memory  section  names  and  the  compiler  abstraction </p>
<p>definitions defined for the FEE and illustrate their assignment among each other. </p>
<p><b>Compiler Abstraction </b></p>
<p><b>Definitions </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Memory Mapping </b></p>
<p><b>Sections </b></p>
<p>FEE_API_CODE </p>
<p>FEE_APPL_CODE </p>
<p>FEE_APPL_CONFIG </p>
<p>FEE_APPL_DATA </p>
<p>FEE_CONST </p>
<p>FEE_PRIVATE_CODE </p>
<p>FEE_PRIVATE_CONST </p>
<p>FEE_PRIVATE_DATA </p>
<p>FEE_VAR </p>
<p>FEE_VAR_NOINIT </p>
<p>FEE_START_SEC_CODE </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>FEE_START_SEC_CONST_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>FEE_START_SEC_APPL_CONFIG_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>FEE_START_SEC_VAR_NOINIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>FEE_START_SEC_VAR_INIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>Table 3-3  </p>
<p>Compiler abstraction and memory mapping </p>
<p></p>
<p> </p>
<p>FEE_START_SEC_CODE / FEE_STOP_SEC_CODE </p>
<p>– </p>
<p>Placement of all API functions</p>
<p> </p>
<p>– </p>
<p>FEE_API_CODE</p>
<p> </p>
<p>Calling convention for all API functions </p>
<p>Note that these functions are called from different modules, suitable </p>
<p>convention depends on global section mapping. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>37 </p>
<p>based on template version 3.1 </p>
<p>– </p>
<p>FEE_PRIVATE_CODE</p>
<p> </p>
<p>Calling convention all internal functions </p>
<p>It is recommended to locate all FEE code sections into one single output </p>
<p>section and to make the internal function calls as “near” as possible. </p>
<p></p>
<p> </p>
<p>FEE_START_SEC_APPL_CONFIG_UNSPECIFIED / </p>
<p>FEE_STOP_SEC_APPL_CONFIG_UNSPECIFIED </p>
<p>– </p>
<p>FEE_APPL_CONFIG</p>
<p> </p>
<p>Configurable constants allocated in Fee_Lcfg.c </p>
<p></p>
<p> </p>
<p>FEE_START_SEC_CONST_UNSPECIFIED / </p>
<p>FEE_STOP_SEC_CONST_UNSPECIFIED </p>
<p>– </p>
<p>FEE_PRIVATE_CONST</p>
<p> </p>
<p>Internal constants, to be accessed only from within FEE. </p>
<p>– </p>
<p>FEE_CONST</p>
<p> </p>
<p>All module constants, to be accessed from outside the FEE </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>At least on 16bit platforms it is recommended to locate code and constants into same </p>
<p>memory area, in order to get most efficient access (“near”). </p>
<p><b> </b></p>
<p><b> </b></p>
<p></p>
<p> </p>
<p>FEE_START_SEC_VAR_NOINIT_UNSPECIFIED / </p>
<p>FEE_STOP_SEC_VAR_NOINIT_UNSPECIFIED </p>
<p>– </p>
<p>FEE_VAR_NOINIT </p>
<p>Module variables which do not need to be initialized (not even zeroed out) </p>
<p>There are not intended to be accessed outside FEE.</p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>FEE_START_SEC_VAR_INIT_UNSPECIFIED / </p>
<p>FEE_STOP_SEC_VAR_INIT_UNSPECIFIED</p>
<p> </p>
<p>– </p>
<p>FEE_VAR </p>
<p>Internal global variables of the module which must be initialized by start-up </p>
<p>code and which are not fixed to one type </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Currently </p>
<p>Fee_ModuleStatus_t </p>
<p>is the only variable that needs to be initialized, in </p>
<p>order to get the “(Un)Init Development Check” working. </p>
<p>If this check was disabled at pre-compile time, FEE does not have any initialized </p>
<p>variables. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>38 </p>
<p>based on template version 3.1 </p>
<p> FEE_APPL_DATA</p>
<p> is used to reference to buffers provided by client software.  </p>
<p><b>3.3 </b></p>
<p><b>Dependencies on SW Modules </b></p>
<p><b>3.3.1 </b></p>
<p><b>OSEK/AUTOSAR OS </b></p>
<p>This operating system is used for task scheduling, interrupt handling, global suspend and </p>
<p>restore  of  interrupts  and  creating  of  the  Interrupt  Vector  Table.  Resources  like  shared </p>
<p>variables can be protected by the usage of OS services. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>FEE does not directly depend on OS. Rather, dependency is actually created by </p>
<p>integrator when configuring OS services and assigning Fee_MainFunction to an OS </p>
<p>task </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.3.2 </b></p>
<p><b>Module SchM </b></p>
<p>In  an  AUTOSAR  environment,  protection  of  “critical  sections”  is  encapsulated  by  the </p>
<p>Scheduling Manager, SchM. </p>
<p>Integrator  has  to  ensure,  SchM  maps  critical  section  functions  to  appropriate  services. </p>
<p>Therefore SchM just encapsulates dependency to OS.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Dependency on SchM can be globally disabled in DaVinci Configurator. Then the </p>
<p>(probable) more direct dependency to OS would be used. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.3.3 </b></p>
<p><b>Module Det </b></p>
<p>This module is the Development Error Tracer. It  is optional and records all development </p>
<p>errors for diagnostic purposes.  </p>
<p>Its usage can be enabled and disabled by the switch </p>
<p>FEE_DEV_ERROR_DETECT</p>
<p>. </p>
<p>If  another  module  is  used  for  development  error  reporting,  the  function  prototype  for </p>
<p>reporting the error can be configured by the integrator, but must have the same signature </p>
<p>as the service</p>
<p> Det_ReportError() </p>
<p>(see chapter 2.6.3). </p>
<p><b>3.3.4 </b></p>
<p><b>Module Fls </b></p>
<p>The Fls driver provides the access to the underlying hardware. The specific properties of </p>
<p>the flash hardware influence the configuration of the FEE component. </p>
<p>Its services are called to request a special job to the driver. </p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The distance of </p>
<p>FEE_APPL_DATA</p>
<p> must be the same or bigger than the distance of </p>
<p>FEE_VAR_NOINIT</p>
<p>. </p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>39 </p>
<p>based on template version 3.1 </p>
<p><b>3.3.5 </b></p>
<p><b>Callback Functions </b></p>
<p><b>3.3.5.1 </b></p>
<p><b>Lower layer interaction </b></p>
<p>The  FEE  offers  the  usage  of  callback  notification  functions  for  the  underlying  driver  to </p>
<p>inform </p>
<p>the </p>
<p>FEE </p>
<p>that </p>
<p>a </p>
<p>job </p>
<p>has </p>
<p>finished </p>
<p>successfully </p>
<p>or </p>
<p>not. </p>
<p>The </p>
<p>Fee_JobEndNotification()</p>
<p>  is called  when  a  job  is  completed  with  a  positive  result </p>
<p>and the </p>
<p>Fee_JobErrorNotification()</p>
<p> is called when a job is cancelled, aborted or </p>
<p>failed. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The interaction between FEE and the underlying driver does not need to be performed </p>
<p>via a notification mechanism. Also polling mode can be chosen if desired. </p>
<p>However, using notifications, decreases CPU usage, because Fee_MainFunction will </p>
<p>be left earlier as long as FEE waits for an Fls request to complete. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.3.5.2 </b></p>
<p><b>Upper layer interaction </b></p>
<p>The NVM offers the usage of callback notification functions for the  FEE, to get informed </p>
<p>that a job has finished successfully or not. The </p>
<p>Nvm_JobEndNotification()</p>
<p> is called </p>
<p>when a job is completed with a positive result and the </p>
<p>Nvm_JobErrorNotification()</p>
<p> </p>
<p>is called when a job is cancelled, aborted or failed. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The interaction between NVM and FEE does not need to be performed via a </p>
<p>notification mechanism. Also polling mode can be chosen if desired. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>40 </p>
<p>based on template version 3.1 </p>
<p> </p>
<p><b>3.3.5.3 </b></p>
<p><b>User Error Callback </b></p>
<p><b>Prototype </b></p>
<p>uint8 <b>Appl_CriticalErrorCallback </b>(uint8 partitionId, Fee_SectorError </p>
<p>errCode) </p>
<p><b>Parameter </b></p>
<p>partitionId </p>
<p>ID of partition the error occurred. </p>
<p>Note that FEE publishes symbolic names </p>
<p>(macros) as chosen in configuration. </p>
<p>errCode </p>
<p>See chapter 4.2.2 </p>
<p><b>Return code </b></p>
<p>FEE_ERRCBK_REJECT_WRITE</p>
<p> </p>
<p>FEE’s partition shall enter “read only mode” </p>
<p>currently pending and all subsequent write </p>
<p>requests will be completed with result </p>
<p>MEMIF_JOB_FAILED</p>
<p> </p>
<p>FEE_ERRCBK_REJECT_ALL </p>
<p>FEE’ partition shall enter “reject all mode” all </p>
<p>subsequent requests, including currently pending </p>
<p>one, will be completed with result </p>
<p>MEMIF_JOB_FAILED</p>
<p> </p>
<p>FEE_ERRCBK_RESOLVE_AUTOMATICALLY </p>
<p>Try to resolve error automatically. This might </p>
<p>result in loss of most recent data instances. </p>
<p><b>Functional Description </b></p>
<p>This function may be implemented by environment software, if special handling for serious errors </p>
<p>is necessary. For instance, FEE’s default behavior might not be feasible, or additional handling, </p>
<p>such as reporting an event to the DEM is required. </p>
<p></p>
<p> </p>
<p><b> </b></p>
<p></p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>FEE’s default behavior is to keep itself running and writable. This means, per default </p>
<p>the FEE tries to resolve the problem automatically, unless the error code is </p>
<p>FEE_SECTOR_FORMAT_FAILED</p>
<p>, where it would enter read-only mode. </p>
<p></p>
<p> </p>
<p><b> </b></p>
<p></p>
<p> </p>
<p><b> </b></p>
<p>Additionally, if development mode is configured, checks are done and in case of failure they are </p>
<p>reported to the DET by default with the according service ID and the reason of occurrence (refer </p>
<p>to chapter 2.6.1). </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service is synchronous. </p>
<p></p>
<p> </p>
<p>This service is non re-entrant. </p>
<p></p>
<p> </p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>This routine might be called on interrupt level, depending on the calling function. </p>
<p> </p>
<p>Each  error  results  in  a  specific  default  behavior,  which  becomes  effective  if  User  Error </p>
<p>Callback was disabled in configuration. This default behavior can also be requested from </p>
<p>User Error Callback by using </p>
<p>FEE_ERRCBK_RESOLVE_AUTOMATICALLY.</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>41 </p>
<p>based on template version 3.1 </p>
<p><b>Error Code </b></p>
<p><b>Default behavior </b></p>
<p>FEE_SECTORS_CORRUPTED </p>
<p>Try to erase/re-init logical sectors. </p>
<p>FEE_SECTOR_OVERFLOW </p>
<p>Erase the newer logical sector. </p>
<p>FEE_SECTOR_FORMAT_FAILED </p>
<p>Enter read only mode. </p>
<p>Return value  </p>
<p>FEE_ERRCBK_RESOLVE_AUTOMATICALLY </p>
<p>may </p>
<p>be used by user-implemented error callback. It results in </p>
<p>retrying logical sector format. Since it might fail with same error, </p>
<p>retries should be limited within error callback . </p>
<p>FEE_SECTOR_CRITICAL_FILL_LEVEL </p>
<p>Just continue, i.e. perform foreground sector switch, if it is </p>
<p>enabled. </p>
<p>Table 3-4  </p>
<p>Error Codes and FEE’s default behavior </p>
<p> </p>
<p><b>3.4 </b></p>
<p><b>Dependencies on HW modules </b></p>
<p>The FEE is principally hardware independent. Nevertheless, the Fls driver has to provide </p>
<p>some  parameters  (defined  in  the  BSWMD  file)  the  FEE  relies  on,  e.g.  the  page  size  or </p>
<p>sector sizes. </p>
<p><b>3.5 </b></p>
<p><b>Critical Sections </b></p>
<p>In  general </p>
<p>Fee_MainFunction</p>
<p>  and  FEE’s  job API  may  concurrently  access  variables; </p>
<p>they </p>
<p>need </p>
<p>to </p>
<p>be </p>
<p>synchronized. </p>
<p>FEE </p>
<p>defines </p>
<p>one </p>
<p>critical </p>
<p>section, </p>
<p>FEE_EXCLUSIVE_AREA_0</p>
<p>.  Sections  of  code  to  be  synchronized  are  very  short;  they </p>
<p>contain </p>
<p>only </p>
<p>few </p>
<p>instructions, </p>
<p>and </p>
<p>their </p>
<p>run </p>
<p>times </p>
<p>do  not </p>
<p>depend </p>
<p>on </p>
<p>configuration. </p>
<p>Therefore, a simple global interrupt lock may be used, though not necessary. </p>
<p>If </p>
<p>Fee_MainFunction</p>
<p> (the OS task(s) it is running in) cannot be preempted by callers of </p>
<p>FEE API (especially </p>
<p>NvM_MainFunction</p>
<p>) and vice versa, no synchronization mechanism </p>
<p>is necessary, at all. </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b>Changes </b></p>
<p>A second type of critical section, </p>
<p>FEE_EXCLUSIVE_AREA_1</p>
<p>, became obsolete. It </p>
<p>should not be used. Rather, it should just map to “nothing”. As specified by AUTOSAR </p>
<p>MainFunctions are not re-entrant. </p>
<p>If </p>
<p>Fee_MainFunction </p>
<p>may be called from different (task) contexts, which may pre-</p>
<p>empt each other, a synchronization mechanism (e.g. an OS Resource) should be </p>
<p>locked and released outside. </p>
<p>Usually other Main Function calls, in particular </p>
<p>NvM_MainFunction</p>
<p> and/or </p>
<p>Fls_MainFunction</p>
<p> would require synchronization as well. Thus, an externally </p>
<p>defined mechanism could be better adapted to specific needs. </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>42 </p>
<p>based on template version 3.1 </p>
<p><b>4 </b></p>
<p><b>API Description </b></p>
<p><b>4.1 </b></p>
<p><b>Interfaces Overview </b></p>
<p>For an interfaces overview please see Figure 1-2. </p>
<p><b>4.2 </b></p>
<p><b>Type Definitions </b></p>
<p><b>4.2.1 </b></p>
<p><b>Fee_SectorSwitchStatusType </b></p>
<p><b>Description </b></p>
<p>This type specifies the possible status values of the sector switch. </p>
<p><b>Range </b></p>
<p>FEE_SECTOR_SWITCH_IDLE </p>
<p>The sector switch is currently not running. </p>
<p>FEE_SECTOR_SWITCH_BLOCK_COPY </p>
<p>The sector switch is currently busy with copying blocks/datasets in a </p>
<p>partition from the logical source sector to the logical target sector. </p>
<p>FEE_SECTOR_SWITCH_ERASE </p>
<p>The sector switch is currently busy formatting the previous source </p>
<p>sector in a partition. </p>
<p>FEE_SECTOR_SWITCH_UNINIT </p>
<p>The FEE is not initialized. This result may only be delivered if </p>
<p>“Development Error Detection” was enabled. </p>
<p>Table 4-1  </p>
<p>Fee_SectorSwitchStatusType </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>This is an addition to AUTOSAR. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.2.2 </b></p>
<p><b>Fee_SectorErrorType </b></p>
<p><b>Description </b></p>
<p>This type specifies the possible errors which shall describe erroneous situations the FEE can reach. </p>
<p><b>Range </b></p>
<p>FEE_SECTORS_CORRUPTED </p>
<p>The sector headers respectively the sector ID of both logical </p>
<p>sectors could not be read. Hence, the most recent sector could </p>
<p>not be determined. </p>
<p>FEE_SECTOR_OVERFLOW </p>
<p>Both logical sectors are completely filled and it is not possible to </p>
<p>write any data. Nevertheless, it is still possible to read data from </p>
<p>the Flash memory. </p>
<p>FEE_SECTOR_FORMAT_FAILED </p>
<p>One logical sector could not be allocated correctly, e.g. sector </p>
<p>header is not valid. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>43 </p>
<p>based on template version 3.1 </p>
<p>FEE_SECTOR_CRITICAL_FILL_LEVEL </p>
<p>Foreground Sector Switch Threshold exceeded, and both logical </p>
<p>sectors are currently in use. This means that the flash is nearly </p>
<p>full. If FSS was disabled, this error code also denotes a </p>
<p>temporary read only condition, since FEE won’t write to flash </p>
<p>unless Fee_EnableFss was called. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>This code actually does not denote an error. </p>
<p>Rather it denotes a “risky” situation; an error </p>
<p>(sector overflow) might follow. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Table 4-2  </p>
<p>Fee_SectorError  Type </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>This is an addition to AUTOSAR. </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>44 </p>
<p>based on template version 3.1 </p>
<p><b>4.3 </b></p>
<p><b>Services provided by FEE </b></p>
<p>The FEE API consists of services, which are realized by function calls. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>Most of the following API functions report development errors as listed in chapter 2.6.1. </p>
<p>If an error is detected the concerning API function will be left without any further </p>
<p>actions. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.3.1 </b></p>
<p><b>Fee_Init </b></p>
<p><b>Prototype </b></p>
<p>void <b>Fee_Init</b>(void) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This service initializes the FEE module and all needed internal variables. </p>
<p>The FEE module doesn't support any runtime configuration. Hence, a pointer to the configuration structure </p>
<p>is not needed by this service. </p>
<p>The FEE does not initialize the underlying Flash driver, but this shall be done by the ECUM module. (This is </p>
<p>no AUTOSAR deviation.) </p>
<p>This function is specified in [1], and it should be used unless, a different configuration shall be used by </p>
<p>FEE. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>This service calls Fee_InitEx (see clause 4.3.2), passing pointer to generated </p>
<p>Fee_Config structure. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p><b>&gt; </b></p>
<p>This service shall not be called during a pending job. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-3  </p>
<p>Fee_Init </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>45 </p>
<p>based on template version 3.1 </p>
<p><b>4.3.2 </b></p>
<p><b>Fee_InitEx </b></p>
<p><b>Prototype </b></p>
<p>void <b>Fee_InitEx</b>(Fee_ConfigRefType ConfigPtr) </p>
<p><b>Parameter </b></p>
<p>ConfigPtr </p>
<p>Pointer to FEE’s Block configuration, which is always named </p>
<p>Fee_Config</p>
<p>; it </p>
<p>is defined in Fee_Lcfg.c, and its incomplete declaration is available via Fee.h. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>This parameter enables sharing FEE code between a Flash </p>
<p>Bootloader and application, while both use different Block </p>
<p>configurations. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This is an alternative/extended service to initialize the FEE module and all needed internal variables. </p>
<p>The FEE does not initialize the underlying Flash driver, but this shall be done by the ECUM module. (this is </p>
<p>no AUTOSAR deviation) </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p><b>&gt; </b></p>
<p>This service shall not be called during a pending job. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-4  </p>
<p>Fee_InitEx </p>
<p><b>4.3.3 </b></p>
<p><b>Fee_SetMode </b></p>
<p><b>Prototype </b></p>
<p>void <b>Fee_SetMode</b>(MemIf_ModeType Mode) </p>
<p><b>Parameter </b></p>
<p>Mode </p>
<p>MEMIF_MODE_SLOW</p>
<p>: Enable processing of Background Sector Switches </p>
<p>MEMIF_MODE_FAST</p>
<p>: Disable processing of Background Sector Switches </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>46 </p>
<p>based on template version 3.1 </p>
<p><b>Functional Description </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>Deviating from [1], this function does not call underlying Flash driver’s related </p>
<p>function, </p>
<p>Fls_SetMode()</p>
<p>. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b></p>
<p> </p>
<p>This service is a synchronous call and does not need to be processed by the </p>
<p>Fee_MainFunction()</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Any value different from MEMIF_MODE_SLOW is treated as MEMIF_MODE_FAST. </p>
<p>In particular, there is no parameter check. </p>
<p>This is important, especially if MemIf_ModeType (defined by MemIf implementation) </p>
<p>happens to be not plain numeric type but not an </p>
<p>enum</p>
<p> type. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Calling </p>
<p>Fee_SetMode()</p>
<p> has significant impact on FEE’s behavior. After startup of </p>
<p>the ECU (ReadAll-process by the NVM has finished), the FEE is set to </p>
<p>MEMIF_MODE_SLOW</p>
<p>, which is initiated by the NVM, if configured accordingly. This is </p>
<p>an indicator to the FEE, which enables processing relative time consuming sector </p>
<p>switch in background, i.e. while no user jobs are pending. Refer to chapter 2.7 for </p>
<p>details on sector switches. </p>
<p>On the other hand, during shut-down, performing sector switches in background may </p>
<p>be inhibited by setting FEE to </p>
<p>MEMIF_MODE_FAST</p>
<p>.  </p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-5  </p>
<p>Fee_SetMode </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>47 </p>
<p>based on template version 3.1 </p>
<p><b>4.3.4 </b></p>
<p><b>Fee_Read </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Fee_Read </b></p>
<p>( </p>
<p>  uint16 BlockNumber, </p>
<p>  uint16 BlockOffset, </p>
<p>  uint8 *DataBufferPtr, </p>
<p>  uint16 Length </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>BlockNumber </p>
<p>Handle of a block (depending on block configuration) </p>
<p>BlockOffset </p>
<p>Read address offset inside the block </p>
<p>DataBufferPtr </p>
<p>Pointer to data buffer </p>
<p>Length </p>
<p>Number of bytes to read </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Read job has been accepted. </p>
<p>E_NOT_OK </p>
<p>Read job has not been accepted. </p>
<p><b>Functional Description </b></p>
<p>This function starts the read processing for the specified block. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The job processing is asynchronous. The result of the finished job can be polled by </p>
<p>calling </p>
<p>Fee_GetJobResult()</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>When the current block is found, the parameters BlockOffset and Length are used to call the Read function </p>
<p>of the underlying Fls driver to read out the content of the flash memory to the provided DataBufferPtr. </p>
<p>As the processing is asynchronous the return value of the Fls Read function can only be returned indirectly </p>
<p>via the job result. </p>
<p>Additionally, if development mode is configured, parameter checks are done and in case of failure they are </p>
<p>reported to the DET by default with the according service ID and the reason of occurrence (refer to chapter </p>
<p>2.6.1). </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-6  </p>
<p>Fee_Read </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>48 </p>
<p>based on template version 3.1 </p>
<p><b>4.3.5 </b></p>
<p><b>Fee_Write </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Fee_Write  </b></p>
<p>( </p>
<p>  uint16 BlockNumber, </p>
<p>  uint8 *DataBufferPtr </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>BlockNumber </p>
<p>Handle of the block (depending on block configuration) </p>
<p>DataBufferPtr </p>
<p>Pointer to data buffer </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Write job has been accepted </p>
<p>E_NOT_OK </p>
<p>Write job has not been accepted. </p>
<p><b>Functional Description </b></p>
<p>This function starts the write processing for the specified block. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The job processing is asynchronous. The result of the finished job can be polled by </p>
<p>calling </p>
<p>Fee_GetJobResult()</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>When the next free area for the block was found, the content of the provided DataBufferPtr is written to the </p>
<p>flash memory. </p>
<p>Additionally, management information is stored to identify the block. </p>
<p>The real count of bytes which must be written depends on the hardware specific page alignment and the </p>
<p>size of the management information. </p>
<p>As the processing is asynchronous the return value of the Fls write function can only be returned indirectly </p>
<p>via the job result. </p>
<p>Additionally, if development mode is configured, parameter checks are done and in case of failure they are </p>
<p>reported to the DET by default with the according service ID and the reason of occurrence (refer to chapter </p>
<p>2.6.1). </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-7  </p>
<p>Fee_Write </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>49 </p>
<p>based on template version 3.1 </p>
<p><b>4.3.6 </b></p>
<p><b>Fee_Cancel </b></p>
<p><b>Prototype </b></p>
<p>void <b>Fee_Cancel</b>(void) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This service cancels a currently pending job.  </p>
<p>The state of the FEE  will be set to </p>
<p>MEMIF_IDLE</p>
<p>. </p>
<p>If the FEE is currently </p>
<p>IDLE</p>
<p>, calling this service is without any effect. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>Additional actions, especially unwinding internal state machine stack and cancelling a </p>
<p>pending Fls job, will be done asynchronously, within next Fee_MainFunction call </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Changes </b></p>
<p>Previous versions delayed internal clean-up until next write request arrived in order to </p>
<p>reduce probability of destructive cancellation. This behavior was removed – </p>
<p>Fee_Cancel immediately cancels any processing. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>Additionally, if development mode is configured, checks are done and in case of failure they are reported to </p>
<p>the DET by default with the according service ID and the reason of occurrence (refer to chapter 2.6.1). </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-8  </p>
<p>Fee_Cancel </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>50 </p>
<p>based on template version 3.1 </p>
<p><b>4.3.7 </b></p>
<p><b>Fee_GetStatus </b></p>
<p><b>Prototype </b></p>
<p>MemIf_StatusType <b>Fee_GetStatus</b>(void) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>MEMIF_UNINIT </p>
<p>The FEE is currently not initialized -&gt; </p>
<p>Fee_Init()</p>
<p> must be called to use </p>
<p>the functionality of the FEE. </p>
<p>MEMIF_IDLE </p>
<p>The FEE is currently idle -&gt; no asynchronous job available </p>
<p>MEMIF_BUSY </p>
<p>The FEE is currently busy-&gt; a asynchronous job is currently processed by </p>
<p>the FEE </p>
<p>MEMIF_BUSY_INTERNAL </p>
<p>The FEE has to process internal operations to ensure further write and/or </p>
<p>invalidate jobs. </p>
<p><b>Functional Description </b></p>
<p>This service returns the FEE’s current module state synchronously. Refer to chapter 2.3.1 for more details. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-9  </p>
<p>Fee_GetStatus </p>
<p><b>4.3.8 </b></p>
<p><b>Fee_GetJobResult </b></p>
<p><b>Prototype </b></p>
<p>MemIf_JobResultType <b>Fee_GetJobResult</b>(void) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>MEMIF_JOB_OK </p>
<p>The last job has been finished successfully. </p>
<p>MEMIF_JOB_PENDING </p>
<p>The last job is waiting for execution or currently being executed. </p>
<p>MEMIF_JOB_CANCELLED </p>
<p>The last job has been cancelled by the </p>
<p>Fee_Cancel()</p>
<p> service. </p>
<p>MEMIF_JOB_FAILED </p>
<p>The Flash driver reported an error or the FEE could not achieve the </p>
<p>requested job due to hardware errors (e.g. memory cell defects). </p>
<p>MEMIF_BLOCK_INCONSISTENT </p>
<p>The data of requested block could not be read, because the data are </p>
<p>corrupt. </p>
<p>MEMIF_BLOCK_INVALID </p>
<p>The requested block has been invalidated previously by the service </p>
<p>Fee_InvalidateBlock()</p>
<p> or reading from an erased block is </p>
<p>achieved (independent from called </p>
<p>Fee_EraseImmediateBlock()</p>
<p> </p>
<p>or a never written block). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>51 </p>
<p>based on template version 3.1 </p>
<p><b>Functional Description </b></p>
<p>This service returns the result of the last job executed. Refer to chapter 2.6.1 for more details. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-10  </p>
<p>Fee_GetJobResult </p>
<p><b>4.3.9 </b></p>
<p><b>Fee_InvalidateBlock </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Fee_InvalidateBlock</b>(uint16 BlockNumber) </p>
<p><b>Parameter </b></p>
<p>BlockNumber </p>
<p>Number of the block (depending on block configuration). </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Invalidate job has been accepted. </p>
<p>E_NOT_OK </p>
<p>Invalidate job has not been accepted. </p>
<p><b>Functional Description </b></p>
<p>This service invokes the invalidation procedure for the selected block. If the service succeeds the most </p>
<p>recent data block is marked as INVALID. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The job processing is asynchronous. The result of the finished job can be polled by </p>
<p>calling </p>
<p>Fee_GetJobResult()</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>When the last/current block was found the next free area will be written with special invalidate information.  </p>
<p>As this information is saved in flash memory it is resistant against resets. </p>
<p> </p>
<p>Additionally, if development mode is configured, parameter checks are done and in case of failure they are </p>
<p>reported to the DET by default with the according service ID and the reason of occurrence (refer to chapter </p>
<p>2.6.1). </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-11  </p>
<p>Fee_InvalidateBlock </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>52 </p>
<p>based on template version 3.1 </p>
<p><b>4.3.10 </b></p>
<p><b>Fee_GetVersionInfo </b></p>
<p><b>Prototype </b></p>
<p>void <b>Fee_GetVersionInfo</b>(Std_VersionInfoType *VersionInfoPtr) </p>
<p><b>Parameter </b></p>
<p>VersionInfoPtr </p>
<p>Pointer to where to store the version information of this module. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This service returns the version information of this module. The version information includes:  </p>
<p><b>&gt; </b></p>
<p>Module ID </p>
<p><b>&gt; </b></p>
<p>Vendor ID </p>
<p><b>&gt; </b></p>
<p>Instance ID </p>
<p><b>&gt; </b></p>
<p>Vendor specific version numbers. </p>
<p>Additionally, if development mode is configured, parameter checks are done and in case of failure they are </p>
<p>reported to the DET by default with the according service ID and the reason of occurrence (refer to chapter </p>
<p>0). The function does not perform any action in case of a failure. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is available, depending on pre-compile configuration checkbox 'Enable </p>
<p>Fee_GetVersionInfo API' which is configured within the configuration tool. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-12  </p>
<p>Fee_GetVersionInfo </p>
<p><b>4.3.11 </b></p>
<p><b>Fee_EraseImmediateBlock </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Fee_EraseImmediateBlock</b>(uint16 BlockNumber) </p>
<p><b>Parameter </b></p>
<p>BlockNumber </p>
<p>Number of the block (depending on block configuration). </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Erase job has been accepted. </p>
<p>E_NOT_OK </p>
<p>Erase job has not been accepted. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>53 </p>
<p>based on template version 3.1 </p>
<p><b>Functional Description </b></p>
<p>This function doesn’t erase flash memory. </p>
<p>The addressed block is marked as invalid, thus a subsequent read request on the invalidated block </p>
<p>completes with </p>
<p>MEMIF_BLOCK_INVALID</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The job processing is asynchronous. The result of the finished job can be polled by </p>
<p>calling </p>
<p>Fee_GetJobResult()</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Fee does not care about immediate blocks; there is no special handling. </p>
<p>Thus this service does exactly the same as Fee_InvalidateBlock  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p><b>&gt; </b></p>
<p>This service shall only be called by e.g. diagnostic or similar system service to pre-erase the </p>
<p>area for immediate data if necessary. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-13  </p>
<p>Fee_EraseImmediateBlock </p>
<p><b>4.3.12 </b></p>
<p><b>Fee_MainFunction </b></p>
<p><b>Prototype </b></p>
<p>void <b>Fee_MainFunction</b>(void) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This service triggers the processing of the internal state machine and handles the asynchronous job and </p>
<p>management operations. </p>
<p>The complete handling of the job and the detection of invalidated or inconsistent blocks will be done in the </p>
<p>internal job state machine. </p>
<p>Additionally, if development mode is configured, checks are done and in case of failure they are reported to </p>
<p>the DET by default with the according service ID and the reason of occurrence (refer to chapter 2.6.1).  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>54 </p>
<p>based on template version 3.1 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-14  </p>
<p>Fee_MainFunction </p>
<p><b>4.3.13 </b></p>
<p><b>Fee_GetEraseCycle </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Fee_GetEraseCycle</b>( </p>
<p>  uint8 SectorNumber, </p>
<p>  uint32 *DataPtr </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>SectorNumber </p>
<p>Identifies partition and logical sector whose erase cycle counter shall be </p>
<p>retrieved: </p>
<p>The least significant bit chooses the sector (0 or 1, meaning lower sector or </p>
<p>upper sector, respectively); higher bits identify the partition. Partitions’ </p>
<p>symbolic names may be used, but values must be adapted (doubled).  </p>
<p>DataPtr </p>
<p>Pointer to data buffer. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Job has been accepted. </p>
<p>E_NOT_OK </p>
<p>Job has not been accepted. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>55 </p>
<p>based on template version 3.1 </p>
<p><b>Functional Description </b></p>
<p>This service retrieves the erase cycle counter of the specified logical sector in the provided buffer. The user </p>
<p>can determine how often the specific sector has been erased. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>This API service is not used by the NVM. It is just a feature to retrieve the number of </p>
<p>erase cycle of a specific logical sector. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The job processing is asynchronous. The result of the finished job can be polled by </p>
<p>calling </p>
<p>Fee_GetJobResult()</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>Additionally, if development mode is configured, parameter checks are done and in case of failure they are </p>
<p>reported to the DET by default with the according service ID and the reason of occurrence (refer to chapter </p>
<p>2.6.1). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>This is an addition to AUTOSAR. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is available, depending on pre-compile configuration checkbox 'Enable </p>
<p>Fee_GetEraseCycle API' which is configured within the configuration tool. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-15  </p>
<p>Fee_GetEraseCycle </p>
<p><b>4.3.14 </b></p>
<p><b>Fee_GetWriteCycle </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Fee_GetWriteCycle  </b></p>
<p>( </p>
<p>  uint16 BlockNumber, </p>
<p>  uint32 *DataPtr </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>BlockNumber </p>
<p>Number of the block, provided by the FEE. </p>
<p>DataPtr </p>
<p>Pointer to data buffer. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Job has been accepted. </p>
<p>E_NOT_OK </p>
<p>Job has not been accepted. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>56 </p>
<p>based on template version 3.1 </p>
<p><b>Functional Description </b></p>
<p>This service retrieves the write cycle counter of a specified block and saves in the provided buffer. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>This API service is not used by the NVM. It is just a feature to retrieve the number of </p>
<p>write cycles of a specific block. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The job processing is asynchronous. The result of the finished job can be polled by calling </p>
<p>Fee_GetJobResult()</p>
<p>.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p>Additionally, if development mode is configured, parameter checks are done and in case of failure they are </p>
<p>reported to the DET by default with the according service ID and the reason of occurrence (refer to chapter </p>
<p>2.6.1). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>This is an addition to AUTOSAR. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is available, depending on pre-compile configuration checkbox 'Enable </p>
<p>Fee_GetWriteCycle API' which is configured within the configuration tool. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-16  </p>
<p>Fee_GetWriteCycle </p>
<p><b>4.3.15 </b></p>
<p><b>Fee_GetSectorSwitchStatus </b></p>
<p><b>Prototype </b></p>
<p>Fee_SectorSwitchStatusType <b>Fee_GetSectorSwitchStatus</b>(void) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>Fee_SectorSwitchStatusType </p>
<p>see chapter 4.2.1 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>57 </p>
<p>based on template version 3.1 </p>
<p><b>Functional Description </b></p>
<p>This function returns the current status of the sector switch. See chapter 4.2.1 for the specific return values. </p>
<p>For more information about the sector switch see chapter 2.7. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>This service determines FEE’s <b>current </b>sector switch processing state. </p>
<p>Necessity of a sector switch does not imply this service to return a value different </p>
<p>FEE_SECTOR_SWITCH_IDLE</p>
<p>. For example, FEE will also report </p>
<p>FEE_SECTOR_SWITCH_IDLE</p>
<p> when copying a block completed, until it starts the next </p>
<p>one. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>This is an addition to AUTOSAR. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-17  </p>
<p>Fee_GetSectorSwitchStatus </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>58 </p>
<p>based on template version 3.1 </p>
<p><b>4.3.17 </b></p>
<p><b>Fee_ForceSectorSwitch </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Fee_ForceSectorSwitch</b>(void) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Job has been accepted. </p>
<p>E_NOT_OK </p>
<p>Job has not been accepted. </p>
<p><b>Functional Description </b></p>
<p>This service forces a sector switch to be performed on all configured partitions in “Foreground Mode”, i.e. </p>
<p>the FEE will defer next incoming job until switch has been completed. </p>
<p>Purpose of this API is to compact partitions’ flash usages to one logical sector each. </p>
<p>FEE performs a sector switch (tries to copy data) even if it just completed one, i.e. it just cleaned up flash. </p>
<p> </p>
<p>Subsequent  calls to this service while FEE already is processing such a request are without any noticable </p>
<p>effects; internally FEE restarts processing. </p>
<p>Normally, issuing one single request is sufficient. However, in some cases it might be desirable to have </p>
<p>both sectors of every partition cleaned up. This requires forcing two sector switches: </p>
<p>Fee_ForceSectorSwitch(); </p>
<p>&lt;wait until IDLE&gt; </p>
<p>Fee_ForceSectorSwitch(); </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>It <b>is not mandatory </b>to explicitly wait for FEE becoming IDLE, after issuing one single </p>
<p>or for last </p>
<p>Fee_ForceSectorSwitch</p>
<p> request. </p>
<p>However, it <b>is mandatory </b>to wait between different requests, if several Sector </p>
<p>Switches are required. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In order to avoid disturbing FEE’s client layer (e.g. NVM), this service does not set </p>
<p>FEE’s status to </p>
<p>MEMIF_BUSY</p>
<p>. Instead it makes sure FEE is </p>
<p>MEMIF_BUSY_INTERNAL</p>
<p> (unless it’s already </p>
<p>MEMIF_BUSY</p>
<p>). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Fee must be initialized before calling </p>
<p>Fee_ForceSectorSwitch()</p>
<p>.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>This API service is not used by the NVM. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>59 </p>
<p>based on template version 3.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The processing state can be queried using Fee_GetStatus. It switches to </p>
<p>MEMIF_IDLE</p>
<p> once all partitions have been processed. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Additionally, if development mode is configured, parameter checks are done and in case of failure they are </p>
<p>reported to the DET by default with the according service ID and the reason of occurrence (refer to chapter </p>
<p>2.6.1). </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>This service is an addition to AUTOSAR. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is available, depending on pre-compile configuration checkbox 'Enable </p>
<p>Fee_ForceSectorSwitch API' which is configured within the configuration tool. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-18  </p>
<p>Fee_ForceSectorSwitch </p>
<p><b>4.3.18 </b></p>
<p><b>Fee_ConvertBlockConfig </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Fee_ConvertBlockConfig  </b></p>
<p>( </p>
<p>  const Fee_ConversionOptionsType* options </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>Options </p>
<p>Pointer to structure of type </p>
<p>Fee_ConversionOptionsType</p>
<p>, containing the </p>
<p>pointer to the user buffer and to the callback to be invoked for each block: </p>
<p> </p>
<p> </p>
<p>userBuffer </p>
<p>Pointer to user buffer to hold block data. Note that the </p>
<p>area pointed to must be large enough to hold largest </p>
<p>possible block’s (across all configurations) data. </p>
<p>notificationPtr </p>
<p>Pointer to callback function. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Job has been accepted. </p>
<p>E_NOT_OK </p>
<p>Job has not been accepted. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>60 </p>
<p>based on template version 3.1 </p>
<p><b>Functional Description </b></p>
<p>This service requests conversion of block configuration, as described in 2.7.5. </p>
<p>FEE uses the buffer passed in </p>
<p>options-&gt;userBuffer </p>
<p>to read block data from data flash and to pass </p>
<p>them to the user callback </p>
<p>options-&gt;notificationPtr </p>
<p>for each block it finds in data flash (having a </p>
<p>VALID instance).</p>
<p> </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Fee must have been initialized and it must be idle before calling </p>
<p><b>Fee_ConvertBlockConfig</b>()</p>
<p>.  </p>
<p>Additionally, the upper SW layers (NvM) shall be stalled, i.e. it must be prevented </p>
<p>from issuing requests to the FEE. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Basic Knowledge </b></p>
<p>Block conversion affects all partitions, i.e. FEE will iterate over all partitions. Don’t </p>
<p>expect any specific order; decisions should be based on parameters passed to “Data </p>
<p>Conversion Callback” (chapter 4.3.18). </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>This API service is not used by the NVM. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>Job completion may be polled by calling </p>
<p>Fee_GetStatus()</p>
<p>; </p>
<p>Job result may be </p>
<p>determined using </p>
<p>Fee_GetJobResult()</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>Additionally, if development mode is configured, parameter checks are done and in case of failure they are </p>
<p>reported to the DET by default with the according service ID and the reason of occurrence (refer to chapter </p>
<p>2.6.1). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>This service is an addition to AUTOSAR. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is available, depending on pre-compile configuration checkbox 'Enable </p>
<p>Fee_ConvertDataBlocks API' which is configured within the configuration tool. </p>
<p>Expected Caller Context </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>61 </p>
<p>based on template version 3.1 </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-19  </p>
<p>Fee_ConvertBlockConfig </p>
<p><b>4.3.19 </b></p>
<p><b>Fee_SuspendWrites </b></p>
<p><b>Prototype </b></p>
<p>void <b>Fee_SuspendWrites</b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This service instructs Fee to block all write class jobs (writing, invalidating and erasing a block). </p>
<p>Pending jobs will be blocked, i.e. they won’t be finished. Next Fee_MainFunction calls cause FEE to enter a </p>
<p>safe state (by means of Flash content). Once such state was reached, FEE does not issue new write </p>
<p>requests to Fls. </p>
<p>Multiple subsequent calls to this service don’t have additional effects, i.e. to re-enable write accesses only </p>
<p>one call to Fee_ResumeWrites is necessary. </p>
<p><b> </b></p>
<p><i><b> </b></i></p>
<p> </p>
<p><i><b>Info </b></i></p>
<p><i>As long as write class jobs are suspended no sector switch will be executed! </i></p>
<p><b> </b></p>
<p><i><b> </b></i></p>
<p>For more information, refer to chapter 2.10. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>May be called at interrupt level. </p>
<p>Table 4-20  </p>
<p>Fee_SuspendWrites </p>
<p><b>4.3.20 </b></p>
<p><b>Fee_ResumeWrites </b></p>
<p><b>Prototype </b></p>
<p>void <b>Fee_ResumeWrites</b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>-</p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>62 </p>
<p>based on template version 3.1 </p>
<p><b>Functional Description </b></p>
<p>This service instructs Fee to allow all write class jobs (writing, invalidating and erasing a block), including </p>
<p>sector switch processing, again which have been suspended using </p>
<p>Fee_SuspendWrites()</p>
<p>.  </p>
<p>Multiple calls to this service enable write processing once, i.e. to disable it again there is still one call to </p>
<p>Fee_SuspendWrites necessary. </p>
<p>For more information, refer to chapter 2.10. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>May be called at interrupt level. </p>
<p>Table 4-21  </p>
<p>Fee_ResumeWrites </p>
<p><b>4.3.21 </b></p>
<p><b>Fee_DisableFss </b></p>
<p><b>Prototype </b></p>
<p>void <b>Fee_DisableFss</b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>Void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function disables execution of foreground sector switch when threshold is reached. A typical situation </p>
<p>using this function is start of engine. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>When foreground sector switch threshold is reached and a write class job (writing, </p>
<p>erasing or invalidating a block) shall be processed, this job ends with result </p>
<p>MEMIF_JOB_FAILED. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>For more information, refer to chapter 2.10. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>Availability depends on setting of “Enable API to allow/prohibit FSS” (see ch. 5.1.7.1) </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-22  </p>
<p>Fee_DisableFss </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>63 </p>
<p>based on template version 3.1 </p>
<p><b>4.3.22 </b></p>
<p><b>Fee_EnableFss </b></p>
<p><b>Prototype </b></p>
<p>void <b>Fee_EnableFss</b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function enables execution of foreground sector switch when threshold is reached. </p>
<p>For more information, refer to chapter 2.10. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>Availability depends on setting of “Enable API to allow/prohibit FSS” (see ch. 5.1.7.1) </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Expected to be called in application context. </p>
<p>Table 4-23  </p>
<p>Fee_EnableFss </p>
<p><b>4.4 </b></p>
<p><b>Services used by FEE </b></p>
<p>In the following table services provided by other components, which are used by the FEE </p>
<p>are listed. For details about prototype and functionality refer to the documentation of the </p>
<p>providing component. </p>
<p><b>Component </b></p>
<p><b>API </b></p>
<p>DET </p>
<p>Det_ReportError (optionally) </p>
<p>FLS </p>
<p>Fls_Read </p>
<p>Fls_Write </p>
<p>Fls_Erase </p>
<p>Fls_GetStatus (if polling mode deactivated) </p>
<p>Fls_GetJobResult (if polling mode deactivated) </p>
<p>Fls_SetMode </p>
<p>Fls_Cancel </p>
<p>NVM </p>
<p>NvM_JobEndNotification (optionally) </p>
<p>NvM_JobErrorNotification (optionally) </p>
<p>OS </p>
<p>Interrupt locking/unlocking functions (optionally) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>64 </p>
<p>based on template version 3.1 </p>
<p>Table 4-24  </p>
<p>Services used by the FEE </p>
<p><b>4.4.1 </b></p>
<p><b>Data Conversion Callback </b></p>
<p>This  user-implemented  callback  is  related  to  the  Feature  “Data  Conversion”  (refer  to </p>
<p>2.7.5); a pointer to such a function shall be passed to </p>
<p>Fee_ConvertBlockConfig</p>
<p> (see </p>
<p>4.3.18). </p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>uint8 <i>&lt;Function_Name&gt; </i></p>
<p>( </p>
<p> uint8* userBuffer, </p>
<p> uint32 blockId,                                                                        </p>
<p> uint16 oldLength,                                                                          </p>
<p> uint16 newLength </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>userBuffer </p>
<p>Pointer to user data buffer, containing block’s most recent data read from </p>
<p>flash. Content may be modified. Points to the userBuffer originally passed to </p>
<p>Fee_ConvertBlockConfig</p>
<p> </p>
<p>blockId </p>
<p>Unique 28bit block identifier, consisting of 4bit Partition Index (bits 27:24) 16bit </p>
<p>“Block Tag” (bits 23..16) and 8bit data index (bits 7..0)</p>
<p>3</p>
<p> </p>
<p>oldLength </p>
<p>Old data length, as found in flash; the user buffer will contain exactly </p>
<p>oldLength</p>
<p> data bytes </p>
<p>newLength </p>
<p>New data length as given in current configuration, the FEE has been initialized </p>
<p>with. </p>
<p><b>Return code </b></p>
<p>FEE_CONVERSION_WRITE</p>
<p>_OLD_LENGTH </p>
<p>Instruct the FEE to keep data (user buffer’s content) according to old length.  </p>
<p>Data to be written will not be readable using the </p>
<p>Fee_Read</p>
<p> (if the both lengths </p>
<p>actually differ), but they will be kept in flash, after </p>
<p>Fee_ConvertBlockConfig</p>
<p> processing completes. </p>
<p>It is useful if several subsequent runs of </p>
<p>Fee_ConvertBlockConfig</p>
<p> are </p>
<p>necessary to perform update with multiple stages. </p>
<p>FEE_CONVERSION_WRITE</p>
<p>_NEW_LENGTH </p>
<p>Instruct the FEE to write data (user buffer’s content) according to new length.  </p>
<p>FEE_CONVERSION_SKIP </p>
<p>Instruct the FEE to skip this block. It will write nothing. Block data will actually </p>
<p>get lost when </p>
<p>Fee_ConvertBlockConfig</p>
<p> processing completes. </p>
<p><b>Functional Description </b></p>
<p><b> </b></p>
<p>This callback has to be implemented by user. It should synchronously perform any action that is necessary </p>
<p>to convert block data from old format to new format (e.g. lengths). </p>
<p><b>Particularities and Limitations  </b></p>
<p><b>&gt; </b></p>
<p>Since the FEE is busy with Fee_ConvertBlockConfig processing, it is not allowed to issue any </p>
<p>other request to it. </p>
<p>                                            </p>
<p>3</p>
<p> Bit 0 is defined to be the least significant bit, regardless of used platform. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>65 </p>
<p>based on template version 3.1 </p>
<p>Call context </p>
<p><b>&gt; </b></p>
<p>Called from context of </p>
<p>Fee_MainFunction</p>
<p> </p>
<p>Table 4-25  </p>
<p>User defined conversion callback </p>
<p><b>4.5 </b></p>
<p><b>Callback Functions </b></p>
<p>This chapter describes the callback functions that are implemented by the FEE and can be </p>
<p>invoked  by  other  modules. The  prototypes  of  the  callback  functions  are  provided  in  the </p>
<p>header file Fee_Cbk.h by the FEE. </p>
<p><b>4.5.1 </b></p>
<p><b>Fee_JobEndNotification </b></p>
<p><b>Prototype </b></p>
<p>void <b>Fee_JobEndNotification</b>(void) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This routine shall be called by the underlying flash driver to report the successful end of an asynchronous </p>
<p>operation. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>This function is configurable at pre-compile time using the parameter </p>
<p>FEE_POLLING_MODE</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This routine might be called on interrupt level, depending on the calling function. </p>
<p>Table 4-26  </p>
<p>Fee_JobEndNotification </p>
<p><b>4.5.2 </b></p>
<p><b>Fee_JobErrorNotification </b></p>
<p><b>Prototype </b></p>
<p>void <b>Fee_JobErrorNotification</b>(void) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>66 </p>
<p>based on template version 3.1 </p>
<p><b>Functional Description </b></p>
<p>This routine shall be called by the underlying flash driver to report the failure of an asynchronous operation. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>This function is configurable at pre-compile time using the parameter </p>
<p>FEE_POLLING_MODE</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This routine might be called on interrupt level, depending on the calling function. </p>
<p>Table 4-27  </p>
<p>Fee_JobErrorNotification </p>
<p><b>4.6 </b></p>
<p><b>Configurable Interfaces </b></p>
<p><b>API </b></p>
<p><b>Description </b></p>
<p>Function </p>
<p>Fee_GetVersionInfo()</p>
<p> </p>
<p>This function can be enabled/disabled by the configuration </p>
<p>switch ‘Enable Fee_GetVersionInfo API’. Refer to chapter </p>
<p>5.1.7. </p>
<p>Function </p>
<p>Fee_GetEraseCycle()</p>
<p> </p>
<p>This function can be enabled/disabled by the configuration </p>
<p>switch ‘Enable Fee_GetEraseCycle API’. Refer to chapter </p>
<p>5.1.7. </p>
<p>Function </p>
<p>Fee_GetWriteCycle()</p>
<p> </p>
<p>This function can be enabled/disabled by the configuration </p>
<p>switch ‘Enable Fee_GetWriteCycle API’. Refer to chapter </p>
<p>5.1.7. </p>
<p>Function </p>
<p>Fee_ForceSectorSwitch()</p>
<p> </p>
<p>This function can be enabled/disabled by the configuration </p>
<p>switch ‘Enable Fee_ForceSectorSwitch API’. Refer to </p>
<p>chapter 5.1.7. </p>
<p>Functions  </p>
<p>Fee_JobEndNotification() </p>
<p>Fee_JobErrorNotification()</p>
<p> </p>
<p>The functions can be enabled/disabled by the configuration </p>
<p>switch ‘Poll Flash driver’. Refer to chapter 5.1.6.2. </p>
<p>Functions </p>
<p>Fee_EnableFss() </p>
<p>Fee_DisableFss()</p>
<p> </p>
<p>The functions can be enabled/disabled by the configuration </p>
<p>switch ‘Enable API to allow/prohibit FSS’. Refer to chapter </p>
<p>5.1.7. </p>
<p>Function </p>
<p>Fee_ConvertBlockConfig()</p>
<p> </p>
<p>The functions can be enabled/disabled by the configuration </p>
<p>switch ‘Enable Data Conversion API’. Refer to chapter 5.1.7. </p>
<p>Table 4-28  </p>
<p>Configurable interfaces </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>67 </p>
<p>based on template version 3.1 </p>
<p><b>5 </b></p>
<p><b>Configuration </b></p>
<p>FEE can be configured using following tools: </p>
<p><b>&gt; </b></p>
<p>DaVinci Configurator 5, domain “Memory” (AUTOSAR 4 packages only). </p>
<p>Parameters are explained within the tool; parameters described in this chapter might </p>
<p>not   directly correspond to parameters visible in Configurator 5’s GUI. </p>
<p><b>&gt; </b></p>
<p>DaVinci Configurator 4 (AUTOSAR 3 packages only; for a detailed description see this </p>
<p>chapter) </p>
<p><b>&gt; </b></p>
<p>Using a generic configuration editor (GCE) </p>
<p><b>5.1 </b></p>
<p><b>Configuration with DaVinci Configurator </b></p>
<p><b>5.1.1 </b></p>
<p><b>Start configuration of the FEE </b></p>
<p>The component name of the Flash-EEPROM-Emulation in DaVinci Configurator is “FEE”. </p>
<p>In the “Architecture view” (initial page) of the DaVinci Configurator, the FEE can be opened </p>
<p>by  its  context  menu  to  start  its  configuration.  Optionally,  the  FEE  can  be  opened  for </p>
<p>configuration with the component list under the “Memory” tab located at the left side of the </p>
<p>DaVinci Configurator. </p>
<p><b>5.1.2 </b></p>
<p><b>Useful Chunk-Sizes (instance counts) </b></p>
<p>Carefully  chosen  chunk-sizes  may  significantly  improve  FEE’s  performance  as  well  as </p>
<p>robustness.  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Chunk sizes’ effects are basically local to a single partition, i.e. a partition’s </p>
<p>performance and robustness is affected. Another partition might be affected indirectly </p>
<p>by sector switch processing (which is not immediately interruptible). </p>
<p>Therefore, when changing a block’s settings, other blocks in same partition must be </p>
<p>considered. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Though it is not necessary (usually it is not even possible) to estimate optimum chunk-</p>
<p>sizes, they should be configured to reasonable values. Therefore their effects are </p>
<p>summarized first: </p>
<p>Basically a block’s instance count depends on the estimated number of write cycles, </p>
<p>relative to other blocks’ write cycles, as well as on its size, in relation to logical sector size. </p>
<p>A “(too) small” / “(too) large” chunk is meant to be related with “write cycle” and/or “block’s </p>
<p>size”. </p>
<p> </p>
<p>Small chunks: </p>
<p><b>&gt; </b></p>
<p>In general small chunks are suited for large and/or infrequently written blocks. </p>
<p>Allocating a small chunk results in less flash-space being reserved for related block </p>
<p>(instances). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>68 </p>
<p>based on template version 3.1 </p>
<p><b>&gt; </b></p>
<p>Smaller chunks result in less space wasted by aborts (resets), and more retries being </p>
<p>possible in a sector in case of resets. </p>
<p><b>&gt; </b></p>
<p>They result in more overhead in flash. This becomes significant with small blocks (little </p>
<p>payload), large page size, and number of write cycles. </p>
<p><b>&gt; </b></p>
<p>Decreased efficiency of flash usage, i.e. more erase cycles over life-time </p>
<p><b>&gt; </b></p>
<p>Result in increased average search efforts. Since FEE does not hold position </p>
<p>information in RAM (neither Look-up tables, nor any caching mechanisms), searching </p>
<p>must be done for each asynchronous block operation. Since one block’s chunks </p>
<p>(within one logical sector) build up a linked list; this list becomes longer. Each list node </p>
<p>(chunk) requires one additional flash request, requiring additional Fee_MainFunction </p>
<p>and Fls_MainFunction cycles. </p>
<p> </p>
<p>Large chunks: </p>
<p><b>&gt; </b></p>
<p>Frequently written, small blocks usually benefit from larger chunks. </p>
<p><b>&gt; </b></p>
<p>Overhead in flash is reduced </p>
<p><b>&gt; </b></p>
<p>Decreased average search efforts, for two reasons: </p>
<p><b>&gt; </b></p>
<p>Skipping an obsolete chunk means skipping more obsolete instances; the linked list </p>
<p>becomes shorter. </p>
<p><b>&gt; </b></p>
<p>Searching within a chunk is implemented to have logarithmic effort.  </p>
<p><b>&gt; </b> Allocating a large chunk results in more flash space (for more instances) being </p>
<p>reserved. If chunk is too large, it would never be used, because writing other blocks </p>
<p>already caused a sector switch. </p>
<p><b>&gt; </b> Increased flash usage also may increase vulnerability to aborts, because space for </p>
<p>other blocks shrinks. Usually each block requires at least one chunk per logical sector </p>
<p>(to hold at least data copied during sector switch). </p>
<p> </p>
<p>The larger a block’s payload is, the smaller the instance count should be. It becomes less </p>
<p>and less possible that such a chunk could be too small, because there is an absolute </p>
<p>upper limit, how often a chunk fits into logical sector. </p>
<p> </p>
<p>It is highly not recommended to try “optimizing” a block configuration in order to get only </p>
<p>one chunk per block, resulting in nearly completely filled logical sector. Rather the chunk </p>
<p>sizes should be set in a way that some reserve remains to be used dynamically. It is </p>
<p>advisable to use approximately 50% of smaller logical sector. However it is more important </p>
<p>to keep enough space to write even the largest blocks several times (regardless of actual </p>
<p>write cycles </p>
<p></p>
<p> due to aborts). On the other hand reserves might also be lower, if a </p>
<p>partition will be written (very) infrequently, and if written to, the situation is known to be </p>
<p>stable (very low risk of aborted writes). </p>
<p> </p>
<p>Based  on  estimated  number of  write  cycles,  it  is sufficient  to  care  about  chunk  sizes  of </p>
<p>most </p>
<p>frequently </p>
<p>written </p>
<p>blocks </p>
<p>only </p>
<p>(additionally </p>
<p>considering </p>
<p>their </p>
<p>sizes). </p>
<p>In </p>
<p>typical </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>69 </p>
<p>based on template version 3.1 </p>
<p>configurations  the  write  cycles  differ  by  magnitudes  (1  …  1’000’000)  –  only  the  largest </p>
<p>ones </p>
<p>(e.g. </p>
<p>more </p>
<p>than </p>
<p>100’000 </p>
<p>cycles, </p>
<p>then </p>
<p>more </p>
<p>than </p>
<p>10’000 </p>
<p>cycles) </p>
<p>need </p>
<p>to </p>
<p>be </p>
<p>considered. Blocks being written less than one hundredth of most frequently written one, </p>
<p>may usually be considered to be constant; their instance count should be 1. If one or more </p>
<p>large  blocks  are  frequently  written,  check  their  maximum  possible  number  writes  per </p>
<p>sector. This can be used as threshold to consider blocks being constant. </p>
<p> </p>
<p><b>5.1.3 </b></p>
<p><b>Update of block configuration </b></p>
<p>It  is  possible  to  update  the  block  configuration  (size,  datasets,...)  of  each  block.  Every </p>
<p>block  which  should be  readable after the  block  configuration update must  get  the  same </p>
<p>BlockID  as  before  (preconditioned  that  the  size  of  this  block  has  not  changed).  The </p>
<p>BlockID could be set manually if the “BlockID fixed” is checked. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>It is not possible to “move” a block from one partition to another with an update, while </p>
<p>keeping its data. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>After flashing the new block configuration it is possible, but not actually necessary, to use </p>
<p>Fee_ForceSectorSwitch()</p>
<p> in order to clean up flash contents, causing flash layout to </p>
<p>be  prepared.  In  order  to  perform  a  complete  update  of  flash  layout  –  i.e.  to  clean  up  / </p>
<p>update </p>
<p>all </p>
<p>logical </p>
<p>sectors, </p>
<p>across </p>
<p>all </p>
<p>partitions </p>
<p>–, </p>
<p>a </p>
<p>second </p>
<p>subsequent </p>
<p>run </p>
<p>of </p>
<p>Fee_ForceSectorSwitch()</p>
<p>may be used . </p>
<p>Writing </p>
<p>updated </p>
<p>blocks </p>
<p>will </p>
<p>be </p>
<p>possible </p>
<p>independent </p>
<p>of </p>
<p>usage </p>
<p>of </p>
<p>Fee_ForceSectorSwitch()</p>
<p>. </p>
<p><b>5.1.4 </b></p>
<p><b>FEE Configuration tab </b></p>
<p><b>Attribute </b></p>
<p><b>Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value </p>
<p>is written in bold </p>
<p><b>Description </b></p>
<p>Block Configuration </p>
<p>FBL </p>
<p>Configuration </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>This checkbox must be checked, if the current block configuration </p>
<p>is the flash boot loader configuration. Otherwise it must not be </p>
<p>checked. </p>
<p>Insert Block </p>
<p>-- </p>
<p><b>-- </b></p>
<p>This button inserts a FEE block into the table. This is only </p>
<p>necessary if additional blocks are needed. All NVM blocks are </p>
<p>inserted automatically. </p>
<p>Delete Block </p>
<p>-- </p>
<p><b>-- </b></p>
<p>This button deletes the selected block from the table. Only blocks </p>
<p>which where inserted with the &quot;Insert Block&quot; button should be </p>
<p>deleted with this button. NVM blocks should be deleted in the </p>
<p>NVM configuration. They are deleted automatically in the FEE </p>
<p>block table. </p>
<p>Move Up </p>
<p>-- </p>
<p><b>-- </b></p>
<p>This button moves a selected block one row above. The order of </p>
<p>the block in the table influences the physical default position </p>
<p>within the Flash. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>70 </p>
<p>based on template version 3.1 </p>
<p><b>Attribute </b></p>
<p><b>Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value </p>
<p>is written in bold </p>
<p><b>Description </b></p>
<p>Move Down </p>
<p>-- </p>
<p><b>-- </b></p>
<p>This button moves a selected block in the table one row below. </p>
<p>The order of the block in the table influences the physical default </p>
<p>position within the Flash. </p>
<p>Calculate </p>
<p>-- </p>
<p><b>-- </b></p>
<p>This button calculates the FEE block numbers, as well as </p>
<p>BlockIDs, unless set to “fixed”. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>This button must be pressed before generation </p>
<p>process is started.</p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p>BlockID </p>
<p>uint16 </p>
<p><b>no default </b></p>
<p>0...65535 </p>
<p>The BlockID will be set automatically by clicking the “Calculate”-</p>
<p>button. The BlockID could also be set manually (see BlockID </p>
<p>fixed). </p>
<p>The BlockID must be unique within a partition, i.e. amongst  all </p>
<p>blocks assigned to same partition. </p>
<p>In order to save flash space it is recommended to start </p>
<p>numbering with 0 for each partition. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If the block configuration shall be updated, each </p>
<p>block which should be readable after the block </p>
<p>configuration update must get the same </p>
<p>BlockID as before. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>NVM </p>
<p>Blockname </p>
<p>-- </p>
<p><b>-- </b></p>
<p>This field shows the name of the corresponding NVM block </p>
<p>entered within the NVM and is forwarded to the FEE. </p>
<p>For user added blocks (within the FEE) this field is empty. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The NVM Blockname can not be modified at all. It </p>
<p>provides the information to the user to associate the </p>
<p>FEE block configuration to the corresponding NVM </p>
<p>block.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>71 </p>
<p>based on template version 3.1 </p>
<p><b>Attribute </b></p>
<p><b>Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value </p>
<p>is written in bold </p>
<p><b>Description </b></p>
<p>Fee </p>
<p>Blockname </p>
<p>C-</p>
<p>identifier </p>
<p>Valid C </p>
<p>identifier, </p>
<p>default: </p>
<p><b>Fee_User </b></p>
<p><b>Block&lt;n&gt; </b></p>
<p>This field shows the name of the configured FEE block. </p>
<p>In the AUTOSAR ECUC file, it becomes the name of the Block </p>
<p>Configuration container. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>As required by AUTOSAR, the linkage between </p>
<p>block name and its numeric handle (“Block </p>
<p>Num”) will be generated. Depending on global </p>
<p>tool settings, the prefix “Fee_” will be added, or </p>
<p>omitted. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>Block Num </p>
<p>uint16 </p>
<p>2…65534, no </p>
<p>default </p>
<p>The even number of the FEE block. </p>
<p>These not modifiable values will be calculated by pressing the </p>
<p>button &quot;Calculate&quot;. The dataset selection bits are used to </p>
<p>calculate the block number. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The BlockNum should not be used directly. Instead </p>
<p>use the symbolic block names, defined in Fee_Cfg.h </p>
<p>(see chapter 3.1.2).</p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>Datasets </p>
<p>-- </p>
<p><b>1 </b></p>
<p>1…255 </p>
<p>This field determines the number of datasets configured for a </p>
<p>dedicated block. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The number of datasets can not be modified if the </p>
<p>block is configured within and forwarded from the </p>
<p>NVM. If the block is created within the FEE, the </p>
<p>datasets can be adjusted for corresponding block.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>Size </p>
<p>uint16 </p>
<p><b>1 </b></p>
<p>1…65535 </p>
<p>The natural size (in bytes) of the block (payload). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The size can not be modified if the block is </p>
<p>configured within and forwarded from the NVM, </p>
<p>because these blocks provide their size on their own.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>72 </p>
<p>based on template version 3.1 </p>
<p><b>Attribute </b></p>
<p><b>Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value </p>
<p>is written in bold </p>
<p><b>Description </b></p>
<p>Chunk block </p>
<p>count </p>
<p>-- </p>
<p><b>1</b>, 3, 7, </p>
<p>15, 31, 63, </p>
<p>127, 255, 511, </p>
<p>1023, 2047, </p>
<p>4095, 8191, </p>
<p>16383, 32767 </p>
<p>This field determines the number of blocks which can be stored </p>
<p>within one block chunk. For blocks which are written often the </p>
<p>number should be larger and vice versa. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>This value must always be adjusted within the FEE </p>
<p>and is never forwarded from the upper layer, </p>
<p>because this value is responsible to abstract </p>
<p>hardware constraints to the upper layer.</p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p>Partition </p>
<p>Ref. </p>
<p>-- </p>
<p>Reference to a defined partition container. </p>
<p>Write Cycles </p>
<p>-- </p>
<p>1… </p>
<p><b>10000 </b></p>
<p>...10000000 </p>
<p>The estimated/desired number of write cycles which are required </p>
<p>for the block. According to this value, the number of blocks within </p>
<p>a chunk shall be influenced, but which is not done automatically </p>
<p>and is left to the user. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>Currently, the adjustment of this value has no effect. </p>
<p>Instead the number of blocks within a chunk (Chunk </p>
<p>block count) influences the distribution of the </p>
<p>data/blocks on the Flash memory.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>High Prio </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>This field denotes that the block contains high priority data. If it is </p>
<p>'ON' the block/dataset can be erased and contains high priority </p>
<p>data. If it is 'OFF' the block/dataset cannot be erased and </p>
<p>contains &quot;normal&quot; data. </p>
<p>For example, high priority data can be supposed as crash data. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The marker for high priority data can not be modified </p>
<p>if the block is configured within and forwarded from </p>
<p>the NVM. If the block is created within the FEE, the </p>
<p>datasets can be adjusted for corresponding block.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>A block can only be erased by the API function </p>
<p>Fee_EraseImmediateBlock()</p>
<p> if the </p>
<p>appropriate block is set to contain high priority data.</p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>Critical Data </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Marks a block to be critical, i.e. essential, for ECU operation. </p>
<p>Refer to chapter 2.11. </p>
<p>BlockID fixed </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>This checkbox must be checked, to be able to set the BlockID </p>
<p>manually. </p>
<p>Table 5-1  </p>
<p>Fee configuration </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>73 </p>
<p>based on template version 3.1 </p>
<p><b>5.1.5 </b></p>
<p><b>General Settings tab </b></p>
<p><b>5.1.5.1 </b></p>
<p><b>Error Detection – Development Mode </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Enable </p>
<p>Development Error </p>
<p>Detection </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Preprocessor switch to enable/disable development </p>
<p>error detection and reporting. </p>
<p>It is the main switch over following items: </p>
<p><b>&gt; </b></p>
<p>Errorhook </p>
<p><b>&gt; </b></p>
<p>Include File </p>
<p>In production mode, this switch should be disabled to </p>
<p>save ROM/RAM and to speed up the module. </p>
<p>Development Error </p>
<p>Reporting </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Preprocessor switch for enabling/disabling the </p>
<p>Development Error Reporting.</p>
<p> </p>
<p>Errorhook </p>
<p>C-function </p>
<p>identifier </p>
<p>Valid C-function </p>
<p>identifier, </p>
<p>default: </p>
<p><b>Det_ Report </b></p>
<p><b>Error  </b></p>
<p>Specifies the function that shall be called if a </p>
<p>development error has occurred. </p>
<p>(see chapter 2.6.3 for function signature) </p>
<p>Include File </p>
<p>header file </p>
<p>Valid header </p>
<p>file, default: </p>
<p><b>Det.h </b></p>
<p>Specifies the file that shall be included if development </p>
<p>error reporting shall be used. The API used by the FEE </p>
<p>must be specified within this file. </p>
<p>Table 5-2  </p>
<p>Error Detection – Development Mode </p>
<p><b>5.1.5.2 </b></p>
<p><b>Area “Error Callback” </b></p>
<p><b>Attribute </b></p>
<p><b>Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Use Error </p>
<p>Callback </p>
<p>-- </p>
<p> </p>
<p> </p>
<p> </p>
<p>ON, </p>
<p><b>OFF </b></p>
<p>Defines whether the Error Callback notification mechanism </p>
<p>shall be used to inform the application about a serious </p>
<p>condition the Fee had detected. </p>
<p>Callback </p>
<p>Function </p>
<p>C-function </p>
<p>identifier </p>
<p>Valid C-function </p>
<p>identifier, default: </p>
<p><b>Appl_CriticalError </b></p>
<p><b>Callback  </b></p>
<p>Defines the function of the application that will be called if </p>
<p>a critical condition has been entered by the Fee. It is </p>
<p>expected, that the application is responsible to react on </p>
<p>this situation according to the parameter value which has </p>
<p>been passed. </p>
<p>Refer to chapter 3.3.5.3 </p>
<p>Include File </p>
<p>header file </p>
<p>Valid header file, </p>
<p>default: </p>
<p><b>Appl_Include.h </b></p>
<p>Defines the header file containing the Error Callback </p>
<p>function. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>74 </p>
<p>based on template version 3.1 </p>
<p>Table 5-3  </p>
<p>Error Callback </p>
<p><b>5.1.5.3 </b></p>
<p><b>Area Buffer </b></p>
<p><b>Attribute </b></p>
<p><b>Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Internal </p>
<p>Buffer Size </p>
<p>uint16 </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>64, </b>128, 256, </p>
<p>512, 1024 </p>
<p>Size of internal buffer to be used for instance allocation during </p>
<p>write job processing and for instance copy during sector switch. </p>
<p>Must be an integral power of two. </p>
<p>Must be equal to or larger than “Write Alignment” setting. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>The number of Fls_Read – Fls_Write request </p>
<p>pairs necessary to copy a whole block </p>
<p>depends on its size and Internal Buffer size. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>5.1.5.4 </b></p>
<p><b>Area “Upper Layer” </b></p>
<p>Following  controls  are  visible  only,  if  an  NvM  is  enabled  (part  of  configuration)  and  its </p>
<p>parameter &quot;Use Polling Mode&quot; (NvmPollingMode) is unchecked (set to False). A hint about </p>
<p>NVM’s current polling mode setting (including availability at all) will be additionally shown. </p>
<p>FEE should be used in polling mode, if NVM is disabled. </p>
<p><b>Attribute </b></p>
<p><b>Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Job End </p>
<p>Notification </p>
<p>C-function </p>
<p>identifier </p>
<p>Valid C-function </p>
<p>identifier, default: </p>
<p><b>NvM_JobEnd </b></p>
<p><b>Notification </b></p>
<p>The name of the job end callback function shall be </p>
<p>inserted to this field. </p>
<p>It is called to report to the upper layer that the job </p>
<p>processing was finished successfully. </p>
<p>Usually this function is provided by the NVM.  </p>
<p> </p>
<p>Job Error </p>
<p>Notification </p>
<p>C-function </p>
<p>identifier </p>
<p>Valid C-function </p>
<p>identifier, default: </p>
<p><b>NvM_JobError </b></p>
<p><b>Notification </b></p>
<p>The name of the job error callback function shall be </p>
<p>inserted to this field. </p>
<p>It is called to report to the upper layer that the job </p>
<p>processing was finished with failure. Usually this </p>
<p>function is provided by the NVM. </p>
<p>Include File for </p>
<p>Callbacks </p>
<p>header file </p>
<p>Valid header file, </p>
<p>default: </p>
<p><b>NvM_Cbk.h </b></p>
<p>In this field it can be inserted the name of the include </p>
<p>file that holds the callback declarations of the upper </p>
<p>layer. </p>
<p>Table 5-4  </p>
<p>Upper Layer </p>
<p><b>5.1.5.5 </b></p>
<p><b>Area “Critical Section Handling” </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>75 </p>
<p>based on template version 3.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Changes </b></p>
<p>Fee 8.xx.xx only supports Critical Section services provided by an AUTOSAR Basic </p>
<p>Software Scheduler (SchM). It ignores manual settings made, if “Use BSW Scheduler </p>
<p>(SchM)” was disabled in “Board Setting / OS Sevices” </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Attribute </b></p>
<p><b>Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Short-Lasting </p>
<p>Actions </p>
<p>-- </p>
<p><b>Use Suspend </b></p>
<p><b>Functions </b></p>
<p>UseOS Functions </p>
<p>UseEnable </p>
<p>Functions </p>
<p>Defines the function set that will be called when short-</p>
<p>lasting critical sections are entered or left. Refer to </p>
<p>chapter 3.5. </p>
<p><b> </b></p>
<p>Long-Lasting </p>
<p>Actions </p>
<p>-- </p>
<p><b>Use Suspend </b></p>
<p><b>Functions </b></p>
<p>UseOS Functions </p>
<p>UseEnable </p>
<p>Functions </p>
<p>Defines the function set that will be called when long-</p>
<p>lasting critical sections are entered or left. Long-lasting </p>
<p>actions are Fee_MainFunction as a whole. Refer to </p>
<p>chapter 3.5. </p>
<p> </p>
<p>Table 5-5  </p>
<p>Critical Section Services </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Both dropdown lists are invisible, if the BSW Scheduler is enabled within the OS configuration </p>
<p>tab of the ECU configuration.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>5.1.6 </b></p>
<p><b>Partitions </b></p>
<p>The left panel of partitions shows a tree-like overview of currently configured partitions. In </p>
<p>this panel partitions can be added, deleted and renamed, as well. </p>
<p><b>Attribute </b></p>
<p><b>Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Partition </p>
<p>Device </p>
<p>Ref. </p>
<p>-- </p>
<p>Choose a flash configuration. </p>
<p>All partitions in one single flash device must refer to the same </p>
<p>Flash Configuration (of type </p>
<p>/AUTOSAR/Fls/FlsConfigSet</p>
<p>) </p>
<p>Currently, FEE is restricted to use one Flash Driver only, i.e. all </p>
<p>partitions must point the same configuration. </p>
<p>Lower Sector </p>
<p>Start Address </p>
<p>-- </p>
<p><b>-- </b></p>
<p>In this combo box the start address of the lower logical sector </p>
<p>shall be selected. The values of the list are just typical values. </p>
<p>A custom value may be entered; it must adhere to the “Fls </p>
<p>address alignment” (see below).  </p>
<p>Lower Sector </p>
<p>Size </p>
<p>-- </p>
<p><b>1024 </b></p>
<p>Choose lower logical sector’s size in bytes. The combo box </p>
<p>suggests some typical values; a custom size may be entered. </p>
<p>The size must also adhere to “Fls address alignment” (see </p>
<p>below).  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>76 </p>
<p>based on template version 3.1 </p>
<p><b>Attribute </b></p>
<p><b>Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Upper Sector </p>
<p>Start Address </p>
<p>-- </p>
<p><b>-- </b></p>
<p>In this combo box the start address of the upper logical sector </p>
<p>shall be selected. The values of the list are suggestions, </p>
<p>derived from the chosen Fls driver (which depends on the </p>
<p>used controller). A custom value may be entered; it must </p>
<p>adhere to the “Fls address alignment” (see below).  </p>
<p>The upper sector’s start address must be located in a distinct </p>
<p>physical sector, with higher address, than the last address of </p>
<p>the lower sector. </p>
<p>Upper Sector </p>
<p>Size </p>
<p>-- </p>
<p><b>1024 </b></p>
<p>Choose upper logical sector’s size in bytes. The combo box </p>
<p>suggests some typical values; a custom size may be entered. </p>
<p>The size must also adhere to “Fls address alignment” (see </p>
<p>below). </p>
<p>Fls address </p>
<p>alignment </p>
<p>-- </p>
<p><b>8,  </b></p>
<p>64, 128, 256, 512, </p>
<p>1024 </p>
<p>In this drop down list the virtual page size in bytes will be set. </p>
<p>This must be a power of two and be equal to or larger than the </p>
<p>“Flash page size for write jobs”. This value will be used to </p>
<p>check logical sectors’ alignment, to align of block instances as </p>
<p>well as Fee management information. </p>
<p>Fls Page </p>
<p>Size for write </p>
<p>jobs </p>
<p>-- </p>
<p><b>8,  </b></p>
<p>64, 128, 256, 512, </p>
<p>1024 </p>
<p>In this drop down list the Fls page size for write jobs in bytes </p>
<p>will be set. This must be an integral multiple of the hardware </p>
<p>specific flash page size. This value will be used for the write </p>
<p>alignment, instead of the Fls page size of the hardware. </p>
<p>Table 5-6  </p>
<p>Lower Layer </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>77 </p>
<p>based on template version 3.1 </p>
<p><b>5.1.6.1 </b></p>
<p><b>Area “Management” </b></p>
<p><b>Attribute </b></p>
<p><b>Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Background </p>
<p>Reserve </p>
<p>uint32 </p>
<p> </p>
<p> </p>
<p> </p>
<p>-- </p>
<p>If there is less free space by writing data continuously to the </p>
<p>Fee, the sector switch in background mode will be started. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>See chapter 2.7 for more details.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Foreground </p>
<p>Reserve </p>
<p>uint32 </p>
<p> </p>
<p> </p>
<p> </p>
<p>-- </p>
<p>If there is less free space by writing data continuously to the </p>
<p>Fee, the sector switch in foreground mode will be started. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>See chapter 2.7 for more details</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Table 5-7  </p>
<p>sector switch reserve </p>
<p><b>5.1.6.2 </b></p>
<p><b>Area “Lower Layer” </b></p>
<p>This panel is independent from partitions; its setting has global meaning. </p>
<p><b>Attribute </b></p>
<p><b>Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Poll Flash </p>
<p>Driver </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Enables/disables polling of the underlying Flash driver.  </p>
<p>If polling is disabled, make sure, that the callbacks </p>
<p>Fee_JobEndNotification()</p>
<p> and </p>
<p>Fee_JobErrorNotification(),</p>
<p> respectively, have been </p>
<p>configured in the Flash driver. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>If polling is enabled the callback functions are not </p>
<p>available, because there is no needed to. An </p>
<p>additional hint will be visible in that case.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>Table 5-8  </p>
<p>Lower Layer </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>78 </p>
<p>based on template version 3.1 </p>
<p><b>5.1.7 </b></p>
<p><b>Module API tab </b></p>
<p><b>5.1.7.1 </b></p>
<p><b>API Configuration </b></p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is </p>
<p>written in </p>
<p>bold </p>
<p><b>Description </b></p>
<p>Enable </p>
<p>Fee_GetVersionInfo API </p>
<p>-- </p>
<p><b>ON </b></p>
<p>OFF </p>
<p>Preprocessor switch to enable/disable the existence of the </p>
<p>API service </p>
<p>Fee_GetVersionInfo()</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>If this checkbox is switched off, the </p>
<p>corresponding parameter check (&quot;Check </p>
<p>Parameter VersionInfo&quot;) within the &quot;General </p>
<p>Settings&quot; tab is deselected and disabled.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>Enable </p>
<p>Fee_GetEraseCycle API </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Preprocessor switch to enable/disable the existence of the </p>
<p>API service </p>
<p>Fee_GetEraseCycle()</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>If this checkbox is switched off, the </p>
<p>corresponding parameter check (&quot;Check </p>
<p>Parameter Sector Number&quot;) within the &quot;General </p>
<p>Settings&quot; tab is deselected and disabled.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Enable </p>
<p>Fee_GetWriteCycle API </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Preprocessor switch to enable/disable the existence of the </p>
<p>API service </p>
<p>Fee_GetWriteCycle()</p>
<p>. </p>
<p>Enable </p>
<p>Fee_ForceSectorSwitch </p>
<p>API </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Preprocessor switch to enable/disable the existence of the </p>
<p>API service </p>
<p>Fee_ForceSectorSwitch()</p>
<p>. </p>
<p>Enable Data Conversion </p>
<p>API </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Preprocessor switch to enable/disable the existence of </p>
<p>Fee_ConvertDataBlocks</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>If this feature was disabled at delivery time, </p>
<p>this switch is still available, but it is disabled.  </p>
<p>It cannot be used to enable the feature “Data </p>
<p>Conversion”.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Enable API to </p>
<p>allow/prohibit FSS </p>
<p>-- </p>
<p>ON </p>
<p><b>OFF </b></p>
<p>Preprocessor switch to enable/disable function set </p>
<p>Fee_EnableFss()</p>
<p>/</p>
<p>Fee_DisableFss() </p>
<p>Refer to chapter 2.10. </p>
<p>Table 5-9  </p>
<p>API Configuration </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>79 </p>
<p>based on template version 3.1 </p>
<p><b>5.1.7.2 </b></p>
<p><b>Provided API </b></p>
<p><b>Attribute </b></p>
<p><b>Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Provided API </p>
<p>-- </p>
<p>-- </p>
<p>This group shows the API services which are currently </p>
<p>provided by the FEE depending on its configuration. </p>
<p>Table 5-10  </p>
<p>Provided API </p>
<p><b>5.2 </b></p>
<p><b>Configuration Parameters only visible in GCE </b></p>
<p>There  are  parameters  that  cannot  be  configured  using  the  comfort  view  of  DaVinci </p>
<p>Configurator.  These  parameters  should  only  be  modified,  if  really  necessary,  and  if  the </p>
<p>user knows about their effects. These parameters’ default values are usable in very most </p>
<p>cases. </p>
<p>To </p>
<p>meet </p>
<p>platform </p>
<p>specific </p>
<p>requirements </p>
<p>and/or </p>
<p>restrictions, </p>
<p>they </p>
<p>may </p>
<p>also </p>
<p>be </p>
<p>pre-</p>
<p>configured during integration/delivery, i.e. they might not be changeable at all. </p>
<p><b>Attribute Name </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is </p>
<p>written in </p>
<p>bold </p>
<p><b>Description </b></p>
<p>FeeMaxLinkTableSize </p>
<p>(Maximum Number of </p>
<p>LinkTable Entries) </p>
<p>Integer </p>
<p>0 … <b>4095 </b></p>
<p>Defines the maximum size of the Link Table. The link table </p>
<p>itself improves performance of FEE, but it reduces space </p>
<p>available for user data. Thus it might be desirable to limit its </p>
<p>size. Especially on devices with very limited flash space </p>
<p>and/or considerably large pages (e.g. TriCore TC179x) the </p>
<p>performance penalty resulting from reducing the link table </p>
<p>size (or disabling it completely, i.e. by setting size to 0), </p>
<p>would be feasible. </p>
<p>Table 5-11  </p>
<p>Parameters only visible in GCE view. </p>
<p><b>5.2.1 </b></p>
<p><b>Fls API deviating from AUTOSAR naming convention </b></p>
<p>FEE is able to use any AUTOSAR compliant Fls “out of the box”, i.e. associating a partition </p>
<p>with a driver, its API is defined and FEE can be generated. This is the case for all internal </p>
<p>device drivers whose API shall exactly match the naming given in Flash Driver SWS. It is </p>
<p>also true for an external device driver, which shall include Vendor ID and a so-called “API </p>
<p>infix”; both shall be published in its module description file. </p>
<p>However, sometimes an Fls doesn’t fully comply, or there might be technical reasons to </p>
<p>deviate from AUTOSAR. </p>
<p> </p>
<p><b>Example </b></p>
<p>Due to address space limitiation mentioned in chapter 2.1, it is necessary to use some </p>
<p>“proxy Fls”, if FEE (a partition) shall address an Fls’s sectors beyond 2GB limit (≥ </p>
<p>0x80000000). Using this Feature of FEE, its function names do not need to comply with </p>
<p>AUTOSAR. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>In such a case FEE would not compile (or not link) because used function names do not </p>
<p>match Fls’s provided ones. This can be solved as follows: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>80 </p>
<p>based on template version 3.1 </p>
<p>1. </p>
<p>Add container </p>
<p>FeeFlsApi</p>
<p> to container </p>
<p>FeeGeneral</p>
<p>.  </p>
<p>2. </p>
<p>New Container may be renamed </p>
<p>3. </p>
<p>Enter name of Fls’s include file </p>
<p>4. </p>
<p>Change function names according to your needs. Parameter names are self-</p>
<p>explaining; they map from SWS function names (e.g. </p>
<p>Fls_Read</p>
<p>) to actually </p>
<p>implemented names (e.g. </p>
<p>MyVeryOwn_ReadFunction</p>
<p>). </p>
<p>5. </p>
<p>Associate this container with an existing Fls configuration (</p>
<p>FeeFlsDeviceIndex</p>
<p> is a </p>
<p>reference to a container of type </p>
<p>Fls/FlsGeneral</p>
<p>).  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>Container </p>
<p>FeeFlsApi</p>
<p> has a multiplicity of 0..*, i.e. you may create an arbitrary number </p>
<p>of Flses. Generator matches references to Fls drivers with partitions’ references to Fls </p>
<p>(runtime) configurations to generate necessary information of drivers which are actually </p>
<p>used. Of course, each Fls driver instance must be referenced at most once. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>81 </p>
<p>based on template version 3.1 </p>
<p><b>6 </b></p>
<p><b>AUTOSAR Standard Compliance </b></p>
<p><b>6.1 </b></p>
<p><b>Deviations </b></p>
<p><b>6.1.1 </b></p>
<p><b>Maximum Blocking Time </b></p>
<p>The parameter </p>
<p>FEE_MAXIMUM_BLOCK_TIME</p>
<p> is not supported by the current version of the </p>
<p>FEE, because a time reference is missing to support this requirement.</p>
<p> </p>
<p><b>6.2 </b></p>
<p><b>Additions/ Extensions </b></p>
<p><b>6.2.1 </b></p>
<p><b>Parameter Checking </b></p>
<p>The  internal parameter checks  of  the API functions  can be en-/disabled  separately. The </p>
<p>AUTOSAR standard requires en-/disabling of the complete parameter checking only. For </p>
<p>details see chapter 2.6.1. </p>
<p><b>6.2.2 </b></p>
<p><b>Fee_InitEx </b></p>
<p>See chapter 4.3.2 for further information. </p>
<p><b>6.2.3 </b></p>
<p><b>GetEraseCycle </b></p>
<p>See chapter 2.5.1.6 and 4.3.13 for further information. </p>
<p><b>6.2.4 </b></p>
<p><b>GetWriteCycle </b></p>
<p>See chapter 2.5.1.7 and 4.3.14 for further information. </p>
<p><b>6.2.5 </b></p>
<p><b>GetSectorSwitchStatus </b></p>
<p>See chapter 4.3.15 for further information. </p>
<p><b>6.2.6 </b></p>
<p><b>ForceSectorSwitch </b></p>
<p>See chapter 4.3.16 for further information. </p>
<p><b>6.2.7 </b></p>
<p><b>Fee_ConvertBlockConfig </b></p>
<p>This Service, and all related types, settings, etc. add the capability of performing data </p>
<p>conversion after a configuration update. Note that this extension is optional; it must be </p>
<p>ordered explicitly. </p>
<p>For more information refer to chapter 2.8. </p>
<p><b>6.2.8 </b></p>
<p><b>Fee_SuspendWrites / Fee_ResumeWrites </b></p>
<p>See chapters 2.10, 4.3.19 and 4.3.20 for further information. </p>
<p><b>6.2.9 </b></p>
<p><b>Fee_EnableFss / Fee_DisableFss </b></p>
<p>See chapters 2.10, 4.3.21 and 4.3.22 for further information. </p>
<p><b>6.3 </b></p>
<p><b>Limitations </b></p>
<p>AUTOSAR does not specify how a FEE implementation shall organize flash memory. </p>
<p>Additionally there are no requirements on performance or robustness. Following </p>
<p>restrictions result from postulating and implementing such requirements. </p>
<p><b>6.3.1 </b></p>
<p><b>Partitions </b></p>
<p>Current implementation limits the maximum number of partitions to 4. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>82 </p>
<p>based on template version 3.1 </p>
<p><b>6.3.2 </b></p>
<p><b>Flash Usage </b></p>
<p>Fee cannot provide whole configured flash memory for user data storage. </p>
<p>Net payload to be stored in flash memory is roundabout 25% of assigned flash memory, or </p>
<p>more precisely, 50% of the smaller logical sector’s size. </p>
<p>In addition to memory overhead caused by internal management information to be stored </p>
<p>along with user data, and to overhead caused by flash space to be reserved for dynamic </p>
<p>allocation  (in  order to process  write  requests),  the  FEE  must adhere  to  HW’s alignment </p>
<p>requirements. Usually this alignment is determined by flash’s smallest writable entity, i.e. </p>
<p>the flash page size. However, on some platforms, alignment must be even more stringent, </p>
<p>because read and write accesses must be secured, so that they don’t endanger already </p>
<p>stored information. </p>
<p>This means: it might be possible to add stuffing bytes carrying no information. Depending </p>
<p>on </p>
<p>flash </p>
<p>device </p>
<p>and </p>
<p>related </p>
<p>alignment </p>
<p>requirements, </p>
<p>this </p>
<p>overhead </p>
<p>might </p>
<p>become </p>
<p>significant, additionally reducing the total amount of user data that may be stored in flash. </p>
<p><b>6.3.3 </b></p>
<p><b>Performance </b></p>
<p>Due  to  dynamic  flash  allocation,  dependent  on  configuration  and  actual  write  accesses, </p>
<p>the performance, by means of request processing time (i.e. number of Fee_MainFunction </p>
<p>call  cycles),  fluctuates.  Starting  with  an empty  flash,  job processing  time  increases  over </p>
<p>time  up  to  a  maximum  search  effort  (one  logical  sector  is  completely  filled).  When  the </p>
<p>other sector is initially used, search efforts reduce again. </p>
<p>Additionally  worst  case  blocking  times  are  mostly  affected  by  clean-up  operation  (copy </p>
<p>recent data instances) and sector erase. Latter one is determined by HW; usually erase </p>
<p>timings  are  at  scales  of  hundreds  of  milliseconds  per  16kBytes.  Their  frequency  highly </p>
<p>depends on flash usage (data amount as well as write frequency). </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>The worst case – a complete sector switch that includes copying all data and erase the </p>
<p>logical sector – is a very exceptional case, as it would mean that nothing was </p>
<p>successfully copied so far, but flash is full, i.e. erase is necessary in order to remain </p>
<p>writeable. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>6.3.4 </b></p>
<p><b>Aborts/Resets </b></p>
<p>Aborts/resets  during  write  operations  result  in  artifacts  in flash  memory,  increasing flash </p>
<p>usage.  Frequent  resets  may  prevent  FEE  from  completing  a  clean-up  operation  (Sector </p>
<p>Switch), but cause much wasted space due to the artifacts. </p>
<p>Finally  the  partition  may  overflow.  There  is  no  space  left  to  copy  data  from  one  logical </p>
<p>sector to the other one, which is the precondition to perform a sector erase without any </p>
<p>recent  data  instance.  This  overflow  may  be  reported  by  FEE,  and  an  erase  may  be </p>
<p>executed, accepting the risk of data loss. For more information, refer to chapter  3.3.5.3. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>83 </p>
<p>based on template version 3.1 </p>
<p>Additionally  the  FEE  allows  marking  data  blocks  as  essential  for  ECU’s  operation;  they </p>
<p>must never be lost (chapter 2.11). </p>
<p>Finally,  FEE  provides  services  for  handling  under-voltage  situations  in  safer  ways;  see </p>
<p>chapter 2.10. </p>
<p><b>6.3.5 </b></p>
<p><b>Write Cycle and Erase Cycle Counters </b></p>
<p>Blocks’ Write Cycle and Sectors’ Erase Counters allow monitoring flash usage over time. </p>
<p>Especially, </p>
<p>they </p>
<p>allow </p>
<p>re-evaluating </p>
<p>initial </p>
<p>estimations </p>
<p>of </p>
<p>blocks </p>
<p>write </p>
<p>cycles. </p>
<p> </p>
<p>Erase cycle counters can be used to estimate total flash usage over ECU’s life-time. A key </p>
<p>parameter  is  the  number  of  erase  cycles  per  physical  sector,  which  is  limited  on  Flash </p>
<p>EEPROM devices. </p>
<p>Precisions  of  both  kinds  of  cycle  counters  are  limited.  Especially  interrupted  accesses </p>
<p>and/or resets reduce precision, for certain reasons.  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Blocks’ Write Cycle and Sectors’ Erase Cycle counters shall be used for statistical </p>
<p>purposes only. Especially, they shall not be used to affect code execution in any way. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>84 </p>
<p>based on template version 3.1 </p>
<p><b>7 </b></p>
<p><b>Glossary and Abbreviations </b></p>
<p><b>7.1 </b></p>
<p><b>Glossary </b></p>
<p><b>Term </b></p>
<p><b>Description </b></p>
<p>DaVinci Configurator </p>
<p>Tool to create a consistent and optimized ECU configuration. Generation </p>
<p>and validation tool for MICROSAR components. </p>
<p>Block Tag </p>
<p>Identifies a block in data flash. See also: Block Id </p>
<p>Block Id </p>
<p>Identifier used to uniquely identify blocks in a partition. Stored in data </p>
<p>flash, it consists of Block Tag and Data Index. </p>
<p>In conjunction with partition ID, every block in FEE can be uniquely </p>
<p>identified. </p>
<p>The Block Id abstracts from 16Bit Block Number passed via API; it </p>
<p>depends on current configuration, in particular on Dataset Selection Bits. </p>
<p>The block tag is one cornerstone in FEE’s update capability: As long as a </p>
<p>Block Id does not change across configuration updates, it can be found in </p>
<p>data flash, data may be kept, if block length also remained unchanged. </p>
<p>Table 7-1  </p>
<p>Glossary </p>
<p> </p>
<p><b>7.2 </b></p>
<p><b>Abbreviations </b></p>
<p><b>Abbreviation </b></p>
<p><b>Description </b></p>
<p>API </p>
<p>Application Programming Interface </p>
<p> </p>
<p>AUTOSAR </p>
<p>Automotive Open System Architecture </p>
<p>BSW </p>
<p>Basis Software </p>
<p>DEM </p>
<p>Diagnostic Event Manager </p>
<p>DET </p>
<p>Development Error Tracer </p>
<p>ECU </p>
<p>Electronic Control Unit </p>
<p>ECUM </p>
<p>ECU Manager </p>
<p>EEPROM </p>
<p>Electrically Erasable Programmable Read Only Memory </p>
<p>FBL </p>
<p>Flash Bootloader </p>
<p>FEE </p>
<p>Flash EEPROM Emulation Module </p>
<p>FLS </p>
<p>Flash Driver </p>
<p>HIS </p>
<p>Hersteller Initiative Software </p>
<p>MEMIF </p>
<p>Memory Abstraction Interface Module </p>
<p>MICROSAR </p>
<p>Microcontroller Open System Architecture (the Vector AUTOSAR </p>
<p>solution) </p>
<p>NVM </p>
<p>NVRAM Manager </p>
<p>NVRAM </p>
<p>Non Volatile Random Access Memory </p>
<p>SchM </p>
<p>(AUTOSAR) Scheduling Manager </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>85 </p>
<p>based on template version 3.1 </p>
<p>SRS </p>
<p>Software Requirement Specification </p>
<p>SWC </p>
<p>Software Component </p>
<p>SWS </p>
<p>Software Specification </p>
<p>Table 7-2  </p>
<p>Abbreviations </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR FEE  </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 8.02.02 </p>
<p>86 </p>
<p>based on template version 3.1 </p>
<p><b>8 </b></p>
<p><b>Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p>&gt;   News </p>
<p>&gt;   Products </p>
<p>&gt;   Demo software </p>
<p>&gt;   Support </p>
<p>&gt;   Training data </p>
<p>&gt;   Addresses </p>
<p> </p>
<p><b>www.vector-informatik.com </b></p>
<p> </p>
<p> </p>
</body>
</html>
{% endraw %}