---
layout: default
title: TechnicalReference_EcuM
nav_order: 2
parent: ECU State Manager
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>MICROSAR EcuM Flex </b></p>
<p>Technical Reference </p>
<p> </p>
<p>SysService_Asr4EcuM </p>
<p>Version 5.00.00 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Authors </p>
<p>Jochen Vorreiter </p>
<p>Status </p>
<p>Released </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>2 / 134 </p>
<p><b>Document Information </b></p>
<p><b>History </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>Jochen Vorreiter </p>
<p>2012-06-06 </p>
<p>1.00.00 </p>
<p><b>&gt; </b></p>
<p>Initial Setup </p>
<p>Jochen Vorreiter </p>
<p>2013-01-30 </p>
<p>1.00.01 </p>
<p><b>&gt; </b></p>
<p>ESCAN00064669 Updated compiler </p>
<p>abstraction and memory mapping </p>
<p>Jochen Vorreiter </p>
<p>2013-05-03 </p>
<p>1.01.00 </p>
<p><b>&gt; </b></p>
<p>Added support of post-build-loadable </p>
<p><b>&gt; </b></p>
<p>Added support of asynchronous </p>
<p>transceiver handling in 3.9.2 </p>
<p><b>&gt; </b></p>
<p>Added API </p>
<p>EcuM_ClearValidatedWakeupEvent() </p>
<p>in 5.2.10 </p>
<p><b>&gt; </b></p>
<p>Extended description of </p>
<p>EcuM_StartupTwo() in 5.2.3 </p>
<p>Jochen Vorreiter </p>
<p>2013-10-31 </p>
<p>2.00.00 </p>
<p><b>&gt; </b></p>
<p>ESCAN00069010</p>
<p> </p>
<p>Added support for </p>
<p>Alarm Clock in 3.14 </p>
<p><b>&gt; </b></p>
<p>ESCAN00071546</p>
<p> </p>
<p>Added Multi Core </p>
<p>support in 3.15 </p>
<p><b>&gt; </b></p>
<p>New API </p>
<p>EcuM_GoToSelectedShutdownTarget </p>
<p><b>&gt; </b></p>
<p>ESCAN00071553 Changed handling of </p>
<p>wakeup source states in 5.1 </p>
<p><b>&gt; </b></p>
<p>Changes in chapter 4.2 Critical Sections </p>
<p><b>&gt; </b></p>
<p>ESCAN00071552 Removed </p>
<p>BswM_EcuM_CurentState notification </p>
<p>Jochen Vorreiter </p>
<p>2014-06-03 </p>
<p>3.00.00 </p>
<p><b>&gt; </b></p>
<p>Added Support for EcuM fixed </p>
<p><b>&gt; </b></p>
<p>ESCAN00073631</p>
<p> </p>
<p>Fixed missing </p>
<p>description of EcuM_BswErrorHook() </p>
<p>Jochen Vorreiter </p>
<p>2014-11-04 </p>
<p>4.00.00 </p>
<p><b>&gt; </b></p>
<p>Added Support for Post-Build </p>
<p>Selectable </p>
<p><b>&gt; </b></p>
<p>Added chapter 3.15.1.2.1 Driver </p>
<p>initialization on the Slave Core. </p>
<p><b>&gt; </b></p>
<p>Added chapter 3.15.5 Reconfiguration </p>
<p>of the BSW Core ID </p>
<p><b>&gt; </b></p>
<p>Added MICROSAR specific CanSM </p>
<p>handling in 3.18.2.3.3 </p>
<p><b>&gt; </b></p>
<p>ESCAN00079382 Fixed missing </p>
<p>description of the StateRequest Port in </p>
<p>5.8.1.1 </p>
<p><b>&gt; </b></p>
<p>ESCAN00077124 Fixed description of </p>
<p>Critical Sections in 4.2 </p>
<p><b>&gt; </b></p>
<p>ESCAN00079407, ESCAN00068331 </p>
<p>Fixed description in Type Definitions of </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>3 / 134 </p>
<p>EcuM_WakeupStateType in 5.1 </p>
<p>Jochen Vorreiter </p>
<p>2014-11-25 </p>
<p>4.00.01 </p>
<p><b>&gt; </b></p>
<p>Adapted description of </p>
<p>EcuM_DeterminePbConfiguration </p>
<p>Jochen Vorreiter </p>
<p>2015-01-26 </p>
<p>4.01.00 </p>
<p><b>&gt; </b></p>
<p>Updated the Include structure and </p>
<p>added two files in 4.1.2 </p>
<p><b>&gt; </b></p>
<p>Updated access on PB and Variant data </p>
<p>in DriverInitLists in Ch. 5.7.2 </p>
<p>Jochen Vorreiter </p>
<p>2015-07-14 </p>
<p>5.00.00 </p>
<p><b>&gt; </b></p>
<p>Added new EcuM error ID for invalid </p>
<p>CoreID in Ch. 3.11.3 </p>
<p><b>&gt; </b></p>
<p>Added support for Mode Handling, see </p>
<p>Ch. 3.16, 5.3.13 and 5.5 </p>
<p><b>&gt; </b></p>
<p>Removed subchapters “Parameter </p>
<p>Checking” from Ch. 3.11 </p>
<p><b>&gt; </b></p>
<p>Added missing API ID in Table 3-8 </p>
<p>  Service IDs </p>
<p><b>Reference Documents </b></p>
<p><b>No. </b></p>
<p><b>Source </b></p>
<p><b>Title </b></p>
<p><b>Version </b></p>
<p>[1] </p>
<p> AUTOSAR </p>
<p>AUTOSAR_SWS_ECUStateManager.pdf </p>
<p>V3.0.0 </p>
<p>[2] </p>
<p> AUTOSAR </p>
<p>AUTOSAR_SWS_DevelopmentErrorTracer.pdf </p>
<p>V3.2.0 </p>
<p>[3] </p>
<p> AUTOSAR </p>
<p>AUTOSAR_SWS_DiagnosticEventManager.pdf.pdf </p>
<p>V4.2.0 </p>
<p>[4] </p>
<p> AUTOSAR </p>
<p>AUTOSAR_TR_BSWModuleList.pdf </p>
<p>V1.6.0 </p>
<p>[5] </p>
<p> AUTOSAR </p>
<p>AUTOSAR_EXP_ModemanagementGuide.pdf </p>
<p>V1.0.0 </p>
<p>[6] </p>
<p> VECTOR </p>
<p>TechnicalReference_PostBuildLoadable.pdf </p>
<p>see delivery </p>
<p>[7] </p>
<p> AUTOSAR </p>
<p>AUTOSAR_SWS_ECUStateManagerFixed.pdf </p>
<p>V1.4.0 </p>
<p>[8] </p>
<p> VECTOR </p>
<p>TechnicalReference_IdentityManager.pdf </p>
<p>see delivery </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>We have configured the programs in accordance with your specifications in the </p>
<p>questionnaire. Whereas the programs do support other configurations than the one </p>
<p>specified in your questionnaire, Vector’s release of the programs delivered to your </p>
<p>company is expressly restricted to the configuration you have specified in the </p>
<p>questionnaire. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>4 / 134 </p>
<p><b>Contents </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>Component History .................................................................................................... 13</b></p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>Introduction................................................................................................................. 14</b></p>
<p> </p>
<p>2.1</p>
<p> </p>
<p>Architecture Overview ...................................................................................... 15</p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Functional Description ............................................................................................... 17</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>Features .......................................................................................................... 17</p>
<p> </p>
<p>3.2</p>
<p> </p>
<p>States of EcuM flex .......................................................................................... 19</p>
<p> </p>
<p>3.3</p>
<p> </p>
<p>States of EcuM fixed ........................................................................................ 20</p>
<p> </p>
<p>3.4</p>
<p> </p>
<p>The State Diagram of the EcuM flex................................................................. 22</p>
<p> </p>
<p>3.5</p>
<p> </p>
<p>The State Diagram of the EcuM with fixed state machine ................................ 23</p>
<p> </p>
<p>3.6</p>
<p> </p>
<p>Initialization ...................................................................................................... 24</p>
<p> </p>
<p>3.6.1</p>
<p> </p>
<p>EcuM_Init ......................................................................................... 24</p>
<p> </p>
<p>3.6.2</p>
<p> </p>
<p>EcuM_StartupTwo ............................................................................ 24</p>
<p> </p>
<p>3.6.2.1</p>
<p> </p>
<p>EcuM_StartupTwo in case of EcuM flex ......................... 24</p>
<p> </p>
<p>3.6.2.2</p>
<p> </p>
<p>EcuM_StartupTwo in case of EcuM fixed ....................... 24</p>
<p> </p>
<p>3.6.3</p>
<p> </p>
<p>Initialization Order ............................................................................ 24</p>
<p> </p>
<p>3.6.4</p>
<p> </p>
<p>Additional Code in the Initialization Callouts ..................................... 25</p>
<p> </p>
<p>3.6.5</p>
<p> </p>
<p>Inclusion of Additional Header Files ................................................. 26</p>
<p> </p>
<p>3.6.6</p>
<p> </p>
<p>Configuration Set Selection .............................................................. 26</p>
<p> </p>
<p>3.7</p>
<p> </p>
<p>Initialization of a MultiCore ECU ....................................................................... 27</p>
<p> </p>
<p>3.8</p>
<p> </p>
<p>Shutdown Targets ............................................................................................ 27</p>
<p> </p>
<p>3.8.1</p>
<p> </p>
<p>Using the API EcuM_SelectShutdownTarget().................................. 27</p>
<p> </p>
<p>3.8.2</p>
<p> </p>
<p>Default Shutdown Target .................................................................. 27</p>
<p> </p>
<p>3.8.3</p>
<p> </p>
<p>Reset Modes .................................................................................... 27</p>
<p> </p>
<p>3.8.4</p>
<p> </p>
<p>Sleep Modes .................................................................................... 28</p>
<p> </p>
<p>3.9</p>
<p> </p>
<p>Wake-up Sources ............................................................................................ 28</p>
<p> </p>
<p>3.9.1</p>
<p> </p>
<p>Validation Timeout ............................................................................ 28</p>
<p> </p>
<p>3.9.2</p>
<p> </p>
<p>Check-Wakeup Validation Timeout ................................................... 29</p>
<p> </p>
<p>3.9.3</p>
<p> </p>
<p>ComM Channel Reference ............................................................... 29</p>
<p> </p>
<p>3.9.4</p>
<p> </p>
<p>Polling of Wake-up Sources ............................................................. 29</p>
<p> </p>
<p>3.9.5</p>
<p> </p>
<p>MCU Reset Reason ......................................................................... 29</p>
<p> </p>
<p>3.10</p>
<p> </p>
<p>Main Functions ................................................................................................ 30</p>
<p> </p>
<p>3.10.1</p>
<p> </p>
<p>Wake-up Validation Protocol ............................................................ 30</p>
<p> </p>
<p>3.10.2</p>
<p> </p>
<p>Wake-up Validation Protocol for asynchronous Can transceiver ....... 32</p>
<p> </p>
<p>3.11</p>
<p> </p>
<p>Error Handling .................................................................................................. 33</p>
<p> </p>
<p>3.11.1</p>
<p> </p>
<p>Development Error Reporting ........................................................... 33</p>
<p> </p>
<p>3.11.2</p>
<p> </p>
<p>Production Code Error Reporting ..................................................... 35</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>5 / 134 </p>
<p>3.11.3</p>
<p> </p>
<p>EcuM_ErrorHook ............................................................................. 35</p>
<p> </p>
<p>3.12</p>
<p> </p>
<p>Callout Execution Sequences .......................................................................... 36</p>
<p> </p>
<p>3.12.1</p>
<p> </p>
<p>Callouts from Startup to Run ............................................................ 36</p>
<p> </p>
<p>3.12.2</p>
<p> </p>
<p>Callouts from Run to Sleep (Halt) and back to Run .......................... 37</p>
<p> </p>
<p>3.12.3</p>
<p> </p>
<p>Callouts from Run to Reset .............................................................. 38</p>
<p> </p>
<p>3.12.4</p>
<p> </p>
<p>Callouts from Run to Off ................................................................... 38</p>
<p> </p>
<p>3.13</p>
<p> </p>
<p>EcuM Flex Users and Defensive Behavior ....................................................... 39</p>
<p> </p>
<p>3.14</p>
<p> </p>
<p>Alarm Clock ..................................................................................................... 40</p>
<p> </p>
<p>3.14.1</p>
<p> </p>
<p>Configuring the Gpt to provide the Time base .................................. 40</p>
<p> </p>
<p>3.14.2</p>
<p> </p>
<p>Configuring the EcuM for using the Alarm Clock .............................. 40</p>
<p> </p>
<p>3.14.3</p>
<p> </p>
<p>Setting of the EcuM Clock ................................................................ 41</p>
<p> </p>
<p>3.14.4</p>
<p> </p>
<p>Setting of a Time Triggered Wake Up Alarm ..................................... 41</p>
<p> </p>
<p>3.15</p>
<p> </p>
<p>MultiCore Ecu .................................................................................................. 42</p>
<p> </p>
<p>3.15.1</p>
<p> </p>
<p>Initialization of a MultiCore ECU ....................................................... 42</p>
<p> </p>
<p>3.15.1.1</p>
<p> </p>
<p>Initialization on the Master Core ..................................... 42</p>
<p> </p>
<p>3.15.1.2</p>
<p> </p>
<p>Initialization on the Slave Core ....................................... 43</p>
<p> </p>
<p>3.15.1.2.1</p>
<p> </p>
<p>Driver initialization on the Slave Core......... 43</p>
<p> </p>
<p>3.15.2</p>
<p> </p>
<p>Sleep handling of slave cores .......................................................... 44</p>
<p> </p>
<p>3.15.3</p>
<p> </p>
<p>Blocking of the BSW Scheduler during Sleep ................................... 45</p>
<p> </p>
<p>3.15.4</p>
<p> </p>
<p>Shutdown of the MultiCore ECU ...................................................... 45</p>
<p> </p>
<p>3.15.5</p>
<p> </p>
<p>Reconfiguration of the BSW Core ID ................................................ 45</p>
<p> </p>
<p>3.16</p>
<p> </p>
<p>Mode Handling for EcuM Flex .......................................................................... 46</p>
<p> </p>
<p>3.16.1</p>
<p> </p>
<p>Mode Handling ................................................................................. 46</p>
<p> </p>
<p>3.16.2</p>
<p> </p>
<p>Run Request Protocol ...................................................................... 47</p>
<p> </p>
<p>3.17</p>
<p> </p>
<p>Generated Template Files ................................................................................ 48</p>
<p> </p>
<p>3.18</p>
<p> </p>
<p>Wake-up Event Handling and Wake-up Validation ........................................... 48</p>
<p> </p>
<p>3.18.1</p>
<p> </p>
<p>Wake-up after a Physical Sleep Mode .............................................. 48</p>
<p> </p>
<p>3.18.1.1</p>
<p> </p>
<p>Use Case Description .................................................... 48</p>
<p> </p>
<p>3.18.1.2</p>
<p> </p>
<p>Execution Flow .............................................................. 49</p>
<p> </p>
<p>3.18.1.3</p>
<p> </p>
<p>Callout Implementation Examples .................................. 49</p>
<p> </p>
<p>3.18.2</p>
<p> </p>
<p>Wake-up Validation of Communication Channels (ECUM in RUN </p>
<p>State) ............................................................................................... 50</p>
<p> </p>
<p>3.18.2.1</p>
<p> </p>
<p>Use Case Description .................................................... 50</p>
<p> </p>
<p>3.18.2.2</p>
<p> </p>
<p>Execution Flow .............................................................. 50</p>
<p> </p>
<p>3.18.2.3</p>
<p> </p>
<p>Callout Implementation Examples .................................. 51</p>
<p> </p>
<p>3.18.2.3.1</p>
<p> </p>
<p>EcuM_CheckWakeup ................................. 51</p>
<p> </p>
<p>3.18.2.3.2</p>
<p> </p>
<p>EcuM_CheckValidation .............................. 51</p>
<p> </p>
<p>3.18.2.3.3</p>
<p> </p>
<p>EcuM_StartWakeupSources and </p>
<p>EcuM_StopWakeupSources in the case </p>
<p>of a MICROSAR CanSM ............................ 51</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>6 / 134 </p>
<p>3.18.2.3.4</p>
<p> </p>
<p>EcuM_StartWakeupSources and </p>
<p>EcuM_StopWakeupSources in the case </p>
<p>of a non MICROSAR CanSM ..................... 52</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>Integration ................................................................................................................... 53</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Scope of Delivery ............................................................................................. 53</p>
<p> </p>
<p>4.1.1</p>
<p> </p>
<p>Static Files ....................................................................................... 53</p>
<p> </p>
<p>4.1.2</p>
<p> </p>
<p>Dynamic Files .................................................................................. 53</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Critical Sections ............................................................................................... 54</p>
<p> </p>
<p>4.3</p>
<p> </p>
<p>Include Structure .............................................................................................. 55</p>
<p> </p>
<p>4.4</p>
<p> </p>
<p>Dependencies on other BSW Modules ............................................................. 56</p>
<p> </p>
<p>4.4.1</p>
<p> </p>
<p>BswM ............................................................................................... 56</p>
<p> </p>
<p>4.4.1.1</p>
<p> </p>
<p>BswM and EcuM fixed ................................................... 56</p>
<p> </p>
<p>4.4.2</p>
<p> </p>
<p>AUTOSAR OS ................................................................................. 56</p>
<p> </p>
<p>4.4.3</p>
<p> </p>
<p>MCU ................................................................................................ 56</p>
<p> </p>
<p>4.4.4</p>
<p> </p>
<p>DEM ................................................................................................. 56</p>
<p> </p>
<p>4.4.5</p>
<p> </p>
<p>DET ................................................................................................. 56</p>
<p> </p>
<p>4.4.6</p>
<p> </p>
<p>ComM .............................................................................................. 56</p>
<p> </p>
<p>4.4.6.1</p>
<p> </p>
<p>ComM and EcuM fixed ................................................... 56</p>
<p> </p>
<p>4.4.7</p>
<p> </p>
<p>SchM ............................................................................................... 57</p>
<p> </p>
<p>4.4.8</p>
<p> </p>
<p>Gpt ................................................................................................... 57</p>
<p> </p>
<p>4.4.9</p>
<p> </p>
<p>NvM ................................................................................................. 57</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>API Description ........................................................................................................... 58</b></p>
<p> </p>
<p>5.1</p>
<p> </p>
<p>Type Definitions ............................................................................................... 58</p>
<p> </p>
<p>5.2</p>
<p> </p>
<p>Services Provided by EcuM ............................................................................. 62</p>
<p> </p>
<p>5.2.1</p>
<p> </p>
<p>EcuM_MainFunction ........................................................................ 62</p>
<p> </p>
<p>5.2.2</p>
<p> </p>
<p>EcuM_Init ......................................................................................... 63</p>
<p> </p>
<p>5.2.3</p>
<p> </p>
<p>EcuM_StartupTwo ............................................................................ 64</p>
<p> </p>
<p>5.2.4</p>
<p> </p>
<p>EcuM_Shutdown .............................................................................. 65</p>
<p> </p>
<p>5.2.5</p>
<p> </p>
<p>EcuM_SelectShutdownTarget .......................................................... 66</p>
<p> </p>
<p>5.2.6</p>
<p> </p>
<p>EcuM_GetShutdownTarget .............................................................. 67</p>
<p> </p>
<p>5.2.7</p>
<p> </p>
<p>EcuM_GetLastShutdownTarget ........................................................ 68</p>
<p> </p>
<p>5.2.8</p>
<p> </p>
<p>EcuM_GetPendingWakeupEvents ................................................... 69</p>
<p> </p>
<p>5.2.9</p>
<p> </p>
<p>EcuM_ClearWakeupEvent ............................................................... 69</p>
<p> </p>
<p>5.2.10</p>
<p> </p>
<p>EcuM_ClearValidatedWakeupEvent ................................................. 70</p>
<p> </p>
<p>5.2.11</p>
<p> </p>
<p>EcuM_GetValidatedWakeupEvents .................................................. 71</p>
<p> </p>
<p>5.2.12</p>
<p> </p>
<p>EcuM_GetExpiredWakeupEvents .................................................... 72</p>
<p> </p>
<p>5.2.13</p>
<p> </p>
<p>EcuM_GetBootTarget ....................................................................... 72</p>
<p> </p>
<p>5.2.14</p>
<p> </p>
<p>EcuM_SelectBootTarget ................................................................... 73</p>
<p> </p>
<p>5.2.15</p>
<p> </p>
<p>EcuM_StartCheckWakeup ............................................................... 74</p>
<p> </p>
<p>5.2.16</p>
<p> </p>
<p>EcuM_EndCheckWakeup ................................................................ 75</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>7 / 134 </p>
<p>5.2.17</p>
<p> </p>
<p>EcuM_GetVersionInfo ...................................................................... 75</p>
<p> </p>
<p>5.2.18</p>
<p> </p>
<p>EcuM_RequestRUN ......................................................................... 76</p>
<p> </p>
<p>5.2.19</p>
<p> </p>
<p>EcuM_ReleaseRUN ......................................................................... 77</p>
<p> </p>
<p>5.2.20</p>
<p> </p>
<p>EcuM_RequestPOST_RUN ............................................................. 78</p>
<p> </p>
<p>5.2.21</p>
<p> </p>
<p>EcuM_ReleasePOST_RUN ............................................................. 79</p>
<p> </p>
<p>5.3</p>
<p> </p>
<p>Services Provided by EcuM flex ....................................................................... 80</p>
<p> </p>
<p>5.3.1</p>
<p> </p>
<p>EcuM_SelectShutdownCause .......................................................... 80</p>
<p> </p>
<p>5.3.2</p>
<p> </p>
<p>EcuM_GetShutdownCause .............................................................. 81</p>
<p> </p>
<p>5.3.3</p>
<p> </p>
<p>EcuM_GoHalt................................................................................... 81</p>
<p> </p>
<p>5.3.4</p>
<p> </p>
<p>EcuM_GoPoll ................................................................................... 82</p>
<p> </p>
<p>5.3.5</p>
<p> </p>
<p>EcuM_GoDown ................................................................................ 83</p>
<p> </p>
<p>5.3.6</p>
<p> </p>
<p>EcuM_GoToSelectedShutdownTarget .............................................. 84</p>
<p> </p>
<p>5.3.7</p>
<p> </p>
<p>EcuM_SetRelWakeupAlarm ............................................................. 85</p>
<p> </p>
<p>5.3.8</p>
<p> </p>
<p>EcuM_SetAbsWakeupAlarm ............................................................ 86</p>
<p> </p>
<p>5.3.9</p>
<p> </p>
<p>EcuM_AbortWakeupAlarm ............................................................... 87</p>
<p> </p>
<p>5.3.10</p>
<p> </p>
<p>EcuM_GetWakeupTime ................................................................... 88</p>
<p> </p>
<p>5.3.11</p>
<p> </p>
<p>EcuM_SetClock ............................................................................... 89</p>
<p> </p>
<p>5.3.12</p>
<p> </p>
<p>EcuM_GetCurrentTime .................................................................... 90</p>
<p> </p>
<p>5.3.13</p>
<p> </p>
<p>EcuM_SetState ................................................................................ 91</p>
<p> </p>
<p>5.4</p>
<p> </p>
<p>Services Provided by EcuM fixed ..................................................................... 92</p>
<p> </p>
<p>5.4.1</p>
<p> </p>
<p>EcuM_GetState ................................................................................ 92</p>
<p> </p>
<p>5.4.2</p>
<p> </p>
<p>EcuM_KillAllRUNRequests .............................................................. 93</p>
<p> </p>
<p>5.4.3</p>
<p> </p>
<p>EcuM_KillAllPostRUNRequests ....................................................... 94</p>
<p> </p>
<p>5.5</p>
<p> </p>
<p>Services Used by EcuM ................................................................................... 95</p>
<p> </p>
<p>5.6</p>
<p> </p>
<p>Callback Functions ........................................................................................... 96</p>
<p> </p>
<p>5.6.1</p>
<p> </p>
<p>EcuM_SetWakeupEvent .................................................................. 96</p>
<p> </p>
<p>5.6.2</p>
<p> </p>
<p>EcuM_ValidateWakeupEvent ........................................................... 97</p>
<p> </p>
<p>5.6.3</p>
<p> </p>
<p>EcuM_AlarmCheckWakeup.............................................................. 98</p>
<p> </p>
<p>5.6.4</p>
<p> </p>
<p>Callback Functions by EcuM fixed .................................................... 99</p>
<p> </p>
<p>5.6.4.1</p>
<p> </p>
<p>EcuM_CB_NfyNvMJobEnd ............................................ 99</p>
<p> </p>
<p>5.7</p>
<p> </p>
<p>Configurable Interfaces .................................................................................... 99</p>
<p> </p>
<p>5.7.1</p>
<p> </p>
<p>Notifications ..................................................................................... 99</p>
<p> </p>
<p>5.7.2</p>
<p> </p>
<p>Callout Functions ............................................................................. 99</p>
<p> </p>
<p>5.7.2.1</p>
<p> </p>
<p>EcuM_ErrorHook ......................................................... 100</p>
<p> </p>
<p>5.7.2.2</p>
<p> </p>
<p>EcuM_OnGoOffOne ..................................................... 100</p>
<p> </p>
<p>5.7.2.3</p>
<p> </p>
<p>EcuM_OnGoOffTwo ..................................................... 101</p>
<p> </p>
<p>5.7.2.4</p>
<p> </p>
<p>EcuM_AL_SwitchOff .................................................... 101</p>
<p> </p>
<p>5.7.2.5</p>
<p> </p>
<p>EcuM_AL_Reset .......................................................... 102</p>
<p> </p>
<p>5.7.2.6</p>
<p> </p>
<p>EcuM_AL_DriverInitZero .............................................. 102</p>
<p> </p>
<p>5.7.2.7</p>
<p> </p>
<p>EcuM_AL_DriverInitOne .............................................. 103</p>
<p> </p>
<p>5.7.2.8</p>
<p> </p>
<p>EcuM_AL_DriverRestart .............................................. 104</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>8 / 134 </p>
<p>5.7.2.9</p>
<p> </p>
<p>EcuM_AL_SetProgrammableInterrupts ........................ 105</p>
<p> </p>
<p>5.7.2.10</p>
<p> </p>
<p>EcuM_McuSetMode ..................................................... 105</p>
<p> </p>
<p>5.7.2.11</p>
<p> </p>
<p>EcuM_WaitForSlaveCores ........................................... 106</p>
<p> </p>
<p>5.7.2.12</p>
<p> </p>
<p>EcuM_StartOS ............................................................. 106</p>
<p> </p>
<p>5.7.2.13</p>
<p> </p>
<p>EcuM_ShutdownOS..................................................... 107</p>
<p> </p>
<p>5.7.2.14</p>
<p> </p>
<p>EcuM_GenerateRamHash ........................................... 108</p>
<p> </p>
<p>5.7.2.15</p>
<p> </p>
<p>EcuM_CheckRamHash ................................................ 108</p>
<p> </p>
<p>5.7.2.16</p>
<p> </p>
<p>EcuM_SleepActivity ..................................................... 109</p>
<p> </p>
<p>5.7.2.17</p>
<p> </p>
<p>EcuM_EnableWakeupSources ..................................... 110</p>
<p> </p>
<p>5.7.2.18</p>
<p> </p>
<p>EcuM_DisableWakeupSources .................................... 110</p>
<p> </p>
<p>5.7.2.19</p>
<p> </p>
<p>EcuM_StartWakeupSources ......................................... 111</p>
<p> </p>
<p>5.7.2.20</p>
<p> </p>
<p>EcuM_StopWakeupSources ......................................... 111</p>
<p> </p>
<p>5.7.2.21</p>
<p> </p>
<p>EcuM_CheckWakeup................................................... 112</p>
<p> </p>
<p>5.7.2.22</p>
<p> </p>
<p>EcuM_CheckValidation ................................................ 112</p>
<p> </p>
<p>5.7.2.23</p>
<p> </p>
<p>EcuM_DeterminePbConfiguration ................................ 113</p>
<p> </p>
<p>5.7.2.24</p>
<p> </p>
<p>EcuM_BswErrorHook ................................................... 114</p>
<p> </p>
<p>5.7.3</p>
<p> </p>
<p>Callout Functions by EcuM flex ...................................................... 115</p>
<p> </p>
<p>5.7.3.1</p>
<p> </p>
<p>EcuM_GptStartClock ................................................... 115</p>
<p> </p>
<p>5.7.3.2</p>
<p> </p>
<p>EcuM_GptSetSleep ..................................................... 116</p>
<p> </p>
<p>5.7.3.3</p>
<p> </p>
<p>EcuM_GptSetNormal ................................................... 117</p>
<p> </p>
<p>5.7.3.4</p>
<p> </p>
<p>EcuM_AL_DriverInitBswM_&lt;ID&gt; .................................. 118</p>
<p> </p>
<p>5.7.4</p>
<p> </p>
<p>Callout Functions by EcuM fixed .................................................... 119</p>
<p> </p>
<p>5.7.4.1</p>
<p> </p>
<p>EcuM_AL_DriverInitTwo .............................................. 119</p>
<p> </p>
<p>5.7.4.2</p>
<p> </p>
<p>EcuM_AL_DriverInitThree ............................................ 120</p>
<p> </p>
<p>5.7.4.3</p>
<p> </p>
<p>EcuM_OnEnterRun ...................................................... 121</p>
<p> </p>
<p>5.7.4.4</p>
<p> </p>
<p>EcuM_OnExitRun ........................................................ 121</p>
<p> </p>
<p>5.7.4.5</p>
<p> </p>
<p>EcuM_OnGoSleep ....................................................... 122</p>
<p> </p>
<p>5.7.4.6</p>
<p> </p>
<p>EcuM_OnPrepShutdown ............................................. 122</p>
<p> </p>
<p>5.7.4.7</p>
<p> </p>
<p>EcuM_OnExitPostRun ................................................. 123</p>
<p> </p>
<p>5.7.4.8</p>
<p> </p>
<p>EcuM_OnFailedNvmWriteAllJobReaction .................... 123</p>
<p> </p>
<p>5.7.4.9</p>
<p> </p>
<p>EcuM_OnWakeupReaction .......................................... 124</p>
<p> </p>
<p>5.7.4.10</p>
<p> </p>
<p>EcuM_OnRTEStartup .................................................. 124</p>
<p> </p>
<p>5.8</p>
<p> </p>
<p>Service Ports ................................................................................................. 125</p>
<p> </p>
<p>5.8.1</p>
<p> </p>
<p>Client Server Interface ................................................................... 125</p>
<p> </p>
<p>5.8.1.1</p>
<p> </p>
<p>Provide Ports on EcuM Side ........................................ 125</p>
<p> </p>
<p>5.8.1.1.1</p>
<p> </p>
<p>ShutdownTarget Port ............................... 125</p>
<p> </p>
<p>5.8.1.1.2</p>
<p> </p>
<p>BootTarget Port ........................................ 125</p>
<p> </p>
<p>5.8.1.1.3</p>
<p> </p>
<p>AlarmClock Port ....................................... 126</p>
<p> </p>
<p>5.8.1.1.4</p>
<p> </p>
<p>StateRequest Port.................................... 126</p>
<p> </p>
<p>5.8.1.2</p>
<p> </p>
<p>Require Ports on EcuM Side ........................................ 127</p>
<p> </p>
<p>5.8.1.2.1</p>
<p> </p>
<p>currentMode Port ..................................... 127</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>9 / 134 </p>
<p><b>6</b></p>
<p> </p>
<p><b>AUTOSAR Standard Compliance............................................................................. 128</b></p>
<p> </p>
<p>6.1</p>
<p> </p>
<p>Deviations ...................................................................................................... 128</p>
<p> </p>
<p>6.1.1</p>
<p> </p>
<p>Deviation in the Naming of API Parameters ................................... 128</p>
<p> </p>
<p>6.1.1.1</p>
<p> </p>
<p>ResetSleepMode ......................................................... 128</p>
<p> </p>
<p>6.1.1.2</p>
<p> </p>
<p>TargetState .................................................................. 128</p>
<p> </p>
<p>6.1.1.3</p>
<p> </p>
<p>ShutdownTarget ........................................................... 128</p>
<p> </p>
<p>6.1.1.4</p>
<p> </p>
<p>Target (ShutdownTarget) .............................................. 128</p>
<p> </p>
<p>6.1.1.5</p>
<p> </p>
<p>Target (BootTarget) ...................................................... 128</p>
<p> </p>
<p>6.1.1.6</p>
<p> </p>
<p>Sources ....................................................................... 128</p>
<p> </p>
<p>6.1.2</p>
<p> </p>
<p>Starting of the Validation Timer....................................................... 128</p>
<p> </p>
<p>6.1.3</p>
<p> </p>
<p>Multiplicity of Parameters ............................................................... 128</p>
<p> </p>
<p>6.1.3.1</p>
<p> </p>
<p>EcuMResetReasonRef ................................................ 128</p>
<p> </p>
<p>6.1.3.2</p>
<p> </p>
<p>EcuMSleepMode ......................................................... 129</p>
<p> </p>
<p>6.1.3.3</p>
<p> </p>
<p>EcuMConfigConsistencyHash ...................................... 129</p>
<p> </p>
<p>6.1.3.4</p>
<p> </p>
<p>Removed parameter ConfigPtr from DriverInit Lists ..... 129</p>
<p> </p>
<p>6.2</p>
<p> </p>
<p>Additions/ Extensions ..................................................................................... 129</p>
<p> </p>
<p>6.2.1</p>
<p> </p>
<p>Additional Configuration Parameters .............................................. 129</p>
<p> </p>
<p>6.2.2</p>
<p> </p>
<p>Buffering of Wake ups if the BswM is Not Initialized ....................... 129</p>
<p> </p>
<p>6.2.3</p>
<p> </p>
<p>Buffering of Wake ups if the ComM is Not Initialized ...................... 130</p>
<p> </p>
<p>6.2.4</p>
<p> </p>
<p>Additional API EcuM_ClearValidatedWakeupEvent ........................ 130</p>
<p> </p>
<p>6.2.5</p>
<p> </p>
<p>Support of Asynchronous Transceiver Handling ............................. 130</p>
<p> </p>
<p>6.2.6</p>
<p> </p>
<p>Deferred notification of the BswM about wake-up events ............... 130</p>
<p> </p>
<p>6.2.7</p>
<p> </p>
<p>Additional Callback EcuM_AlarmCheckWakeup ............................. 130</p>
<p> </p>
<p>6.2.8</p>
<p> </p>
<p>Additional API EcuM_GoToSelectedShutdownTarget ..................... 130</p>
<p> </p>
<p>6.2.9</p>
<p> </p>
<p>Additional Callout EcuM_WaitForSlaveCores ................................. 130</p>
<p> </p>
<p>6.2.10</p>
<p> </p>
<p>Support of EcuM fixed .................................................................... 130</p>
<p> </p>
<p>6.2.10.1</p>
<p> </p>
<p>Shutdown Target ECUM_STATE_RESET .................... 130</p>
<p> </p>
<p>6.2.10.2</p>
<p> </p>
<p>Synchronization of EcuM and RTE modes ................... 131</p>
<p> </p>
<p>6.3</p>
<p> </p>
<p>Limitations...................................................................................................... 131</p>
<p> </p>
<p>6.3.1</p>
<p> </p>
<p>Inter Module Checks ...................................................................... 131</p>
<p> </p>
<p>6.3.2</p>
<p> </p>
<p>Recording of Shutdown Causes ..................................................... 131</p>
<p> </p>
<p>6.3.3</p>
<p> </p>
<p>Not Supported Configuration Parameters and Containers .............. 131</p>
<p> </p>
<p>6.3.4</p>
<p> </p>
<p>Wake-up Events after Reset Reason Translation are not Validated 131</p>
<p> </p>
<p>6.3.5</p>
<p> </p>
<p>EcuM Fixed Limitations .................................................................. 131</p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>Glossary and Abbreviations .................................................................................... 133</b></p>
<p> </p>
<p>7.1</p>
<p> </p>
<p>Glossary ........................................................................................................ 133</p>
<p> </p>
<p>7.2</p>
<p> </p>
<p>Abbreviations ................................................................................................. 133</p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>Contact ...................................................................................................................... 134</b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>10 / 134 </p>
<p><b>Illustrations </b></p>
<p>Figure 2-1</p>
<p> </p>
<p>AUTOSAR architecture ............................................................................. 15</p>
<p> </p>
<p>Figure 2-2</p>
<p> </p>
<p>Interfaces to adjacent modules of the EcuM ............................................. 16</p>
<p> </p>
<p>Figure 3-1</p>
<p> </p>
<p>The state diagram of the EcuM flex .......................................................... 22</p>
<p> </p>
<p>Figure 3-2 State Diagram of the EcuM with fixed state machine .......................................... 23</p>
<p> </p>
<p>Figure 3-3</p>
<p> </p>
<p>Example Wake-up Validation .................................................................... 31</p>
<p> </p>
<p>Figure 3-4</p>
<p> </p>
<p>Example Wake-up Validation for asynchronous Can Transceivers ............ 32</p>
<p> </p>
<p>Figure 3-5</p>
<p> </p>
<p>Startup Sequence on a Master Core ......................................................... 42</p>
<p> </p>
<p>Figure 3-6</p>
<p> </p>
<p>Startup Sequence on a Slave Core ........................................................... 43</p>
<p> </p>
<p>Figure 4-1</p>
<p> </p>
<p>Include structure ....................................................................................... 55</p>
<p> </p>
<p><b> </b></p>
<p><b>Tables </b></p>
<p>Table 1-1 </p>
<p> </p>
<p>Component history.................................................................................... 13</p>
<p> </p>
<p>Table 3-1 </p>
<p> </p>
<p>Supported AUTOSAR EcuM common features ......................................... 17</p>
<p> </p>
<p>Table 3-2 </p>
<p> </p>
<p>Supported AUTOSAR EcuM flex features ................................................. 18</p>
<p> </p>
<p>Table 3-3 </p>
<p> </p>
<p>Supported AUTOSAR EcuM fixed features ............................................... 18</p>
<p> </p>
<p>Table 3-4 </p>
<p> </p>
<p>Features provided beyond the AUTOSAR standard .................................. 18</p>
<p> </p>
<p>Table 3-5 </p>
<p> </p>
<p>States of the EcuM ................................................................................... 19</p>
<p> </p>
<p>Table 3-6 </p>
<p> </p>
<p>States of the EcuM ................................................................................... 21</p>
<p> </p>
<p>Table 3-7 </p>
<p> </p>
<p>Initialization Order ..................................................................................... 25</p>
<p> </p>
<p>Table 3-8 </p>
<p> </p>
<p>Service IDs ............................................................................................... 34</p>
<p> </p>
<p>Table 3-9 </p>
<p> </p>
<p>Errors reported to DET ............................................................................. 34</p>
<p> </p>
<p>Table 3-10 </p>
<p> </p>
<p>Errors reported to DEM ............................................................................. 35</p>
<p> </p>
<p>Table 3-11 </p>
<p> </p>
<p>Description of EcuM internal Error Codes ................................................. 36</p>
<p> </p>
<p>Table 3-12 </p>
<p> </p>
<p>Callouts from Startup to Run ..................................................................... 36</p>
<p> </p>
<p>Table 3-13 </p>
<p> </p>
<p>Callouts from Run to Sleep (Halt) and back to Run ................................... 37</p>
<p> </p>
<p>Table 3-14 </p>
<p> </p>
<p>Callouts from Run to Reset ....................................................................... 38</p>
<p> </p>
<p>Table 3-15 </p>
<p> </p>
<p>Callouts from Run to Off ........................................................................... 38</p>
<p> </p>
<p>Table 3-16 </p>
<p> </p>
<p>Gpt Channel Configuration ....................................................................... 40</p>
<p> </p>
<p>Table 3-17 </p>
<p> </p>
<p>Sleep handling on Slave Cores ................................................................. 44</p>
<p> </p>
<p>Table 3-18 </p>
<p> </p>
<p>Mapping of States to Modes ..................................................................... 46</p>
<p> </p>
<p>Table 4-1 </p>
<p> </p>
<p>Static files ................................................................................................. 53</p>
<p> </p>
<p>Table 4-2 </p>
<p> </p>
<p>Generated files ......................................................................................... 54</p>
<p> </p>
<p>Table 4-3 </p>
<p> </p>
<p>Critical Sections ........................................................................................ 54</p>
<p> </p>
<p>Table 5-1 </p>
<p> </p>
<p>Type definitions ......................................................................................... 61</p>
<p> </p>
<p>Table 5-2 </p>
<p> </p>
<p>EcuM_MainFunction ................................................................................. 62</p>
<p> </p>
<p>Table 5-3 </p>
<p> </p>
<p>EcuM_Init ................................................................................................. 63</p>
<p> </p>
<p>Table 5-4 </p>
<p> </p>
<p>EcuM_StartupTwo .................................................................................... 64</p>
<p> </p>
<p>Table 5-5 </p>
<p> </p>
<p>EcuM_Shutdown ...................................................................................... 65</p>
<p> </p>
<p>Table 5-6 </p>
<p> </p>
<p>EcuM_SelectShutdownTarget ................................................................... 66</p>
<p> </p>
<p>Table 5-7 </p>
<p> </p>
<p>EcuM_GetShutdownTarget ....................................................................... 67</p>
<p> </p>
<p>Table 5-8 </p>
<p> </p>
<p>EcuM_GetLastShutdownTarget ................................................................ 68</p>
<p> </p>
<p>Table 5-9 </p>
<p> </p>
<p>EcuM_GetPendingWakeupEvents ............................................................ 69</p>
<p> </p>
<p>Table 5-10 </p>
<p> </p>
<p>EcuM_ClearWakeupEvent ........................................................................ 69</p>
<p> </p>
<p>Table 5-11 </p>
<p> </p>
<p>EcuM_ClearValidatedWakeupEvent ......................................................... 70</p>
<p> </p>
<p>Table 5-12 </p>
<p> </p>
<p>EcuM_GetValidatedWakeupEvents .......................................................... 71</p>
<p> </p>
<p>Table 5-13 </p>
<p> </p>
<p>EcuM_GetExpiredWakeupEvents ............................................................. 72</p>
<p> </p>
<p>Table 5-14 </p>
<p> </p>
<p>EcuM_GetBootTarget ............................................................................... 72</p>
<p> </p>
<p>Table 5-15 </p>
<p> </p>
<p>EcuM_SelectBootTarget ........................................................................... 73</p>
<p> </p>
<p>Table 5-16 </p>
<p> </p>
<p>EcuM_StartCheckWakeup ........................................................................ 74</p>
<p> </p>
<p>Table 5-17 </p>
<p> </p>
<p>EcuM_EndCheckWakeup ......................................................................... 75</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>11 / 134 </p>
<p>Table 5-18 </p>
<p> </p>
<p>EcuM_GetVersionInfo ............................................................................... 75</p>
<p> </p>
<p>Table 5-19 </p>
<p> </p>
<p>EcuM_RequestRUN ................................................................................. 76</p>
<p> </p>
<p>Table 5-20 </p>
<p> </p>
<p>EcuM_ReleaseRUN .................................................................................. 77</p>
<p> </p>
<p>Table 5-21 </p>
<p> </p>
<p>EcuM_RequestPOST_RUN ...................................................................... 78</p>
<p> </p>
<p>Table 5-22 </p>
<p> </p>
<p>EcuM_ReleasePOST_RUN ...................................................................... 79</p>
<p> </p>
<p>Table 5-23 </p>
<p> </p>
<p>EcuM_SelectShutdownCause .................................................................. 80</p>
<p> </p>
<p>Table 5-24 </p>
<p> </p>
<p>EcuM_GetShutdownCause ....................................................................... 81</p>
<p> </p>
<p>Table 5-25 </p>
<p> </p>
<p>EcuM_GoHalt ........................................................................................... 81</p>
<p> </p>
<p>Table 5-26 </p>
<p> </p>
<p>EcuM_GoPoll ............................................................................................ 82</p>
<p> </p>
<p>Table 5-27 </p>
<p> </p>
<p>EcuM_GoDown ........................................................................................ 83</p>
<p> </p>
<p>Table 5-28 </p>
<p> </p>
<p>EcuM_GoToSelectedShutdownTarget....................................................... 84</p>
<p> </p>
<p>Table 5-29 </p>
<p> </p>
<p>EcuM_SetRelWakeupAlarm...................................................................... 85</p>
<p> </p>
<p>Table 5-30 </p>
<p> </p>
<p>EcuM_SetAbsWakeupAlarm ..................................................................... 86</p>
<p> </p>
<p>Table 5-31 </p>
<p> </p>
<p>EcuM_AbortWakeupAlarm ........................................................................ 87</p>
<p> </p>
<p>Table 5-32 </p>
<p> </p>
<p>EcuM_GetWakeupTime ............................................................................ 88</p>
<p> </p>
<p>Table 5-33 </p>
<p> </p>
<p>EcuM_SetClock ........................................................................................ 89</p>
<p> </p>
<p>Table 5-34 </p>
<p> </p>
<p>EcuM_GetCurrentTime ............................................................................. 90</p>
<p> </p>
<p>Table 5-35 </p>
<p> </p>
<p>EcuM_SetState ......................................................................................... 91</p>
<p> </p>
<p>Table 5-36 </p>
<p> </p>
<p>EcuM_GetState ........................................................................................ 92</p>
<p> </p>
<p>Table 5-37 </p>
<p> </p>
<p>EcuM_ KillAllRUNRequests ...................................................................... 93</p>
<p> </p>
<p>Table 5-38 </p>
<p> </p>
<p>EcuM_ KillAllPostRUNRequests ............................................................... 94</p>
<p> </p>
<p>Table 5-39 </p>
<p> </p>
<p>Services used by the EcuM ...................................................................... 96</p>
<p> </p>
<p>Table 5-40 </p>
<p> </p>
<p>EcuM_SetWakeupEvent ........................................................................... 96</p>
<p> </p>
<p>Table 5-41 </p>
<p> </p>
<p>EcuM_ValidateWakeupEvent .................................................................... 97</p>
<p> </p>
<p>Table 5-42 </p>
<p> </p>
<p>EcuM_AlarmCheckWakeup ...................................................................... 98</p>
<p> </p>
<p>Table 5-43 </p>
<p> </p>
<p>EcuM_AlarmCheckWakeup ...................................................................... 99</p>
<p> </p>
<p>Table 5-44 </p>
<p> </p>
<p>EcuM_ErrorHook .................................................................................... 100</p>
<p> </p>
<p>Table 5-45 </p>
<p> </p>
<p>EcuM_OnGoOffOne ............................................................................... 100</p>
<p> </p>
<p>Table 5-46 </p>
<p> </p>
<p>EcuM_OnGoOffTwo ................................................................................ 101</p>
<p> </p>
<p>Table 5-47 </p>
<p> </p>
<p>EcuM_AL_SwitchOff ............................................................................... 101</p>
<p> </p>
<p>Table 5-48 </p>
<p> </p>
<p>EcuM_AL_Reset ..................................................................................... 102</p>
<p> </p>
<p>Table 5-49 </p>
<p> </p>
<p>EcuM_AL_DriverInitZero ........................................................................ 102</p>
<p> </p>
<p>Table 5-50 </p>
<p> </p>
<p>EcuM_AL_DriverInitOne ......................................................................... 103</p>
<p> </p>
<p>Table 5-51 </p>
<p> </p>
<p>EcuM_AL_DriverRestart ......................................................................... 104</p>
<p> </p>
<p>Table 5-52 </p>
<p> </p>
<p>EcuM_AL_SetProgrammableInterrupts................................................... 105</p>
<p> </p>
<p>Table 5-53 </p>
<p> </p>
<p>EcuM_McuSetMode ............................................................................... 105</p>
<p> </p>
<p>Table 5-54 </p>
<p> </p>
<p>EcuM_WaitForSlaveCores ...................................................................... 106</p>
<p> </p>
<p>Table 5-55 </p>
<p> </p>
<p>EcuM_StartOS ........................................................................................ 106</p>
<p> </p>
<p>Table 5-56 </p>
<p> </p>
<p>EcuM_ShutdownOS ............................................................................... 107</p>
<p> </p>
<p>Table 5-57 </p>
<p> </p>
<p>EcuM_GenerateRamHash ...................................................................... 108</p>
<p> </p>
<p>Table 5-58 </p>
<p> </p>
<p>EcuM_CheckRamHash .......................................................................... 108</p>
<p> </p>
<p>Table 5-59 </p>
<p> </p>
<p>EcuM_SleepActivity ................................................................................ 109</p>
<p> </p>
<p>Table 5-60 </p>
<p> </p>
<p>EcuM_EnableWakeupSources ............................................................... 110</p>
<p> </p>
<p>Table 5-61 </p>
<p> </p>
<p>EcuM_DisableWakeupSources ............................................................... 110</p>
<p> </p>
<p>Table 5-62 </p>
<p> </p>
<p>EcuM_StartWakeupSources .................................................................... 111</p>
<p> </p>
<p>Table 5-63 </p>
<p> </p>
<p>EcuM_StopWakeupSources .................................................................... 111</p>
<p> </p>
<p>Table 5-64 </p>
<p> </p>
<p>EcuM_CheckWakeup ............................................................................. 112</p>
<p> </p>
<p>Table 5-65 </p>
<p> </p>
<p>EcuM_CheckValidation ........................................................................... 112</p>
<p> </p>
<p>Table 5-66 </p>
<p> </p>
<p>EcuM_DeterminePbConfiguration ........................................................... 113</p>
<p> </p>
<p>Table 5-67 </p>
<p> </p>
<p>EcuM_BswErrorHook ............................................................................. 114</p>
<p> </p>
<p>Table 5-68 </p>
<p> </p>
<p>EcuM_GptStartClock .............................................................................. 115</p>
<p> </p>
<p>Table 5-69 </p>
<p> </p>
<p>EcuM_GptSetSleep ................................................................................ 116</p>
<p> </p>
<p>Table 5-70 </p>
<p> </p>
<p>EcuM_GptSetNormal .............................................................................. 117</p>
<p> </p>
<p>Table 5-71 </p>
<p> </p>
<p>EcuM_AL_DriverInitBswM ...................................................................... 118</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>12 / 134 </p>
<p>Table 5-72 </p>
<p> </p>
<p>EcuM_AL_DriverInitTwo ......................................................................... 119</p>
<p> </p>
<p>Table 5-73 </p>
<p> </p>
<p>EcuM_AL_DriverInitThree....................................................................... 120</p>
<p> </p>
<p>Table 5-74 </p>
<p> </p>
<p>EcuM_OnEnterRun................................................................................. 121</p>
<p> </p>
<p>Table 5-75 </p>
<p> </p>
<p>EcuM_OnExitRun ................................................................................... 121</p>
<p> </p>
<p>Table 5-76 </p>
<p> </p>
<p>EcuM_OnGoSleep .................................................................................. 122</p>
<p> </p>
<p>Table 5-77 </p>
<p> </p>
<p>EcuM_OnPrepShutdown ........................................................................ 122</p>
<p> </p>
<p>Table 5-78 </p>
<p> </p>
<p>EcuM_OnExitPostRun ............................................................................ 123</p>
<p> </p>
<p>Table 5-79 </p>
<p> </p>
<p>EcuM_OnFailedNvmWriteAllJobReaction ............................................... 123</p>
<p> </p>
<p>Table 5-80 </p>
<p> </p>
<p>EcuM_OnFailedNvmWriteAllJobReaction ............................................... 124</p>
<p> </p>
<p>Table 5-81 </p>
<p> </p>
<p>EcuM_OnRTEStartup ............................................................................. 124</p>
<p> </p>
<p>Table 5-82 </p>
<p> </p>
<p>Shutdown Target Port ............................................................................. 125</p>
<p> </p>
<p>Table 5-83 </p>
<p> </p>
<p>BootTarget Port ....................................................................................... 125</p>
<p> </p>
<p>Table 5-84 </p>
<p> </p>
<p>AlarmClock Port ...................................................................................... 126</p>
<p> </p>
<p>Table 5-85 </p>
<p> </p>
<p>StateRequest Port .................................................................................. 126</p>
<p> </p>
<p>Table 5-86 </p>
<p> </p>
<p>currentMode Port .................................................................................... 127</p>
<p> </p>
<p>Table 7-1 </p>
<p> </p>
<p>Glossary ................................................................................................. 133</p>
<p> </p>
<p>Table 7-2 </p>
<p> </p>
<p>Abbreviations .......................................................................................... 133</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>13 / 134 </p>
<p><b>1 </b></p>
<p><b>Component History </b></p>
<p>The </p>
<p>component </p>
<p>history </p>
<p>gives </p>
<p>an </p>
<p>overview </p>
<p>over </p>
<p>the </p>
<p>important </p>
<p>milestones </p>
<p>that </p>
<p>are </p>
<p>supported in the different versions of the component.  </p>
<p><b>Component Version </b></p>
<p><b>New Features </b></p>
<p>1.00.00 </p>
<p>Adaption to AUTOSAR Release 4 </p>
<p>1.01.00 </p>
<p>Added support of configuration variant Post-Build Loadable </p>
<p>Added support of asynchronous transceiver handling </p>
<p>2.00.00 </p>
<p>Added support for handling of MuliCore ECUs </p>
<p>Added support of Alarm Clock to provide the absolute time and handling </p>
<p>of time triggered wake-ups. </p>
<p>3.00.00 </p>
<p>Added support for EcuM with fixed state machine </p>
<p>4.00.00 </p>
<p>Added support for Post-Build Selectable </p>
<p>5.00.00 </p>
<p>Added support for Mode Handling in EcuM Flex </p>
<p>Table 1-1  </p>
<p>Component history </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>14 / 134 </p>
<p><b>2 </b></p>
<p><b>Introduction </b></p>
<p>This document describes the functionality, API and configuration of the AUTOSAR BSW </p>
<p>module EcuM as specified in [1] and [7].  </p>
<p> </p>
<p><b>Supported AUTOSAR Release*: </b></p>
<p>4.0.3 </p>
<p><b>Supported Configuration Variants: </b></p>
<p>Pre-Compile, Post-Build Loadable </p>
<p><b>Vendor ID: </b></p>
<p>ECUM_VENDOR_ID </p>
<p>30 decimal </p>
<p>(= Vector-Informatik, </p>
<p>according to HIS) </p>
<p><b>Module ID: </b></p>
<p>ECUM_MODULE_ID  </p>
<p>10 decimal </p>
<p>(according to ref. [4]) </p>
<p>* For the precise AUTOSAR Release 4.x please see the release specific documentation.  </p>
<p> </p>
<p> </p>
<p>This document describes the functionality and API of the ECU State Manager (EcuM) as a </p>
<p>hardware independent module. </p>
<p>The main tasks of the EcuM are:  </p>
<p><b>&gt; </b> Initialization of BSW (Basis Software) modules that are needed to start the operating </p>
<p>system </p>
<p><b>&gt; </b> Preparation of the microcontroller for a sleep phase and the following wake up </p>
<p><b>&gt; </b> Performing an ordered shut down or reset of the ECU </p>
<p><b>&gt; </b> Validation of occurred wake ups via the wake-up validation protocol </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>15 / 134 </p>
<p><b>2.1 </b></p>
<p><b>Architecture Overview </b></p>
<p>The following figure shows where the EcuM is located in the AUTOSAR architecture. </p>
<p> </p>
<p>Figure 2-1 </p>
<p>AUTOSAR architecture </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>16 / 134 </p>
<p>The next figure shows the interfaces to adjacent modules of the  EcuM. These interfaces </p>
<p>are described in chapter 5.2 Services Provided by EcuM and 5.5 Services Used by EcuM.  </p>
<p> </p>
<p>Figure 2-2 </p>
<p>Interfaces to adjacent modules of the EcuM </p>
<p><b> cmp Architecture_Ov erv iew</b></p>
<p><b>SW-C / RTE</b></p>
<p><b>SchM</b></p>
<p><b>AUTOSAR OS</b></p>
<p><b>Dem</b></p>
<p><b>Det</b></p>
<p><b>ComM</b></p>
<p><b>Mcu</b></p>
<p><b>other BSW Modules</b></p>
<p><b>EcuM</b></p>
<p><b>BswM</b></p>
<p><b>Gpt</b></p>
<p><b>Nv M</b></p>
<p><b>Rte</b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>17 / 134 </p>
<p><b>3 </b></p>
<p><b>Functional Description </b></p>
<p><b>3.1 </b></p>
<p><b>Features </b></p>
<p>The features listed in the following tables cover the complete functionality specified for the </p>
<p>EcuM. </p>
<p>The AUTOSAR standard functionality is specified in [1] and [7], the corresponding features </p>
<p>are listed in the tables: </p>
<p><b>&gt; </b></p>
<p>Table 3-1   Supported AUTOSAR EcuM common features  </p>
<p><b>&gt; </b></p>
<p>Table 3-2   Supported AUTOSAR EcuM flex features </p>
<p><b>&gt; </b></p>
<p>Table 3-3   Supported AUTOSAR EcuM fixed features </p>
<p>For further information of not supported features see also chapter 0. </p>
<p>Vector Informatik provides further EcuM functionality beyond the AUTOSAR standard. The </p>
<p>corresponding features are listed in the table: </p>
<p><b>&gt; </b></p>
<p>Table 3-4   Features provided beyond the AUTOSAR standard </p>
<p> </p>
<p>The following features specified in [1] and [7] are supported: </p>
<p><b>Supported AUTOSAR Standard Conform Features </b></p>
<p>Configuration of different wake-up sources. </p>
<p>Configuration of EcuM users. </p>
<p>Configurable startup sequence of the BSW stack that is needed before starting the OS. </p>
<p>Possibility to add additional initialization code into the initialization lists. </p>
<p>Notification of the BswM if a wake-up event occurs on a wake-up source. </p>
<p>Notification of the ComM if a wake-up event occurs on communication channels. </p>
<p>Assignment of communication channels to wake-up sources. </p>
<p>Configuration of different sleep modes. </p>
<p>Selection of different shutdown targets. </p>
<p>Selection of different shutdown causes. </p>
<p>Generation of the SW-C description file needed for the generation of the RTE. </p>
<p>Service Port: EcuM_ShutdownTarget </p>
<p>Service Port: EcuM_BootTarget </p>
<p>Consistency hash checking according to AUTOSAR specification </p>
<p>Post-build configuration of the EcuM </p>
<p>Support of MultiCore ECUs </p>
<p>Run / Post_Run Request Protocol </p>
<p>Mode Port: EcuM_CurrentMode </p>
<p>Table 3-1  </p>
<p>Supported AUTOSAR EcuM common features </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>18 / 134 </p>
<p>The following EcuM flex features specified in [1] are supported: </p>
<p><b>Supported AUTOSAR EcuM flex Features </b></p>
<p>Configuration of different reset modes. </p>
<p>Service Port: EcuM_AlarmClock </p>
<p>Defensive Behavior to check the valid call of EcuM_GoDown </p>
<p>Alarm clock to provide an absolute time and handling of time triggered wake-ups. </p>
<p>Table 3-2  </p>
<p>Supported AUTOSAR EcuM flex features </p>
<p> </p>
<p>The following EcuM fixed features specified in [7] are supported: </p>
<p><b>Supported AUTOSAR EcuM fixed Features </b></p>
<p>Full initialization of the Stack via configurable DriverInitLists </p>
<p>Fixed state machine to control the ECU states </p>
<p>Allow communication via ComM_CommunicationAllowed when entering the ECUM_STATE_RUN </p>
<p>Handle NvM_WriteAll() and NvM_CancelWriteAll() </p>
<p>Start and stop of the RTE </p>
<p>Table 3-3  </p>
<p>Supported AUTOSAR EcuM fixed features </p>
<p>The following features are provided beyond the AUTOSAR standard: </p>
<p><b>Features Provided Beyond The AUTOSAR Standard </b></p>
<p>Adding of additional initialization code by the configuration tool </p>
<p>Wake-up Events are buffered until the BswM and the ComM are initialized </p>
<p>Support of asynchronous transceiver handling (Introduced API EcuM_StartCheckWakeup + </p>
<p>EcuM_EndCheckWakeup)  </p>
<p>Providing an additional API EcuM_ClearValidatedWakeupEvent() to clear only validated, but not </p>
<p>pending wake-up events </p>
<p>Providing an additional API EcuM_GoToSelectedShutdownTarget() to decide EcuM internal if </p>
<p>EcuM_GoPoll(), EcuM_GoHalt() or EcuM_GoDown() has to be called, depending on the selected </p>
<p>shutdown target [EcuM flex only] </p>
<p>Configuration of the Core ID on which the BSW is initialized </p>
<p>Table 3-4  </p>
<p>Features provided beyond the AUTOSAR standard </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>19 / 134 </p>
<p><b>3.2 </b></p>
<p><b>States of EcuM flex </b></p>
<p>These states indicate the current internal EcuM Operation State.  </p>
<p><b>Module State </b></p>
<p><b>Activities </b></p>
<p><b>Point in Time </b></p>
<p>ECUM_STATE_STARTUP </p>
<p>Initializes the drivers out of </p>
<p>the EcuM_DriverInitZero </p>
<p>list. </p>
<p>Entered during EcuM_Init(). </p>
<p>ECUM_STATE_STARTUP_ONE </p>
<p>Initializes the drivers out of </p>
<p>the EcuM_DriverInitOne </p>
<p>list. </p>
<p>Reset reason translation, </p>
<p>setting of the default </p>
<p>shutdown target and at the </p>
<p>end start the operating </p>
<p>system. </p>
<p>Entered during EcuM_Init(). </p>
<p>ECUM_STATE_STARTUP_TWO </p>
<p>Initializes the BswM and </p>
<p>the SchM. </p>
<p>Former buffered Wake-up </p>
<p>Events are notified to the </p>
<p>BswM. </p>
<p>Entered during </p>
<p>EcuM_StartupTwo(). </p>
<p>ECUM_STATE_APP_RUN </p>
<p>After initializing the </p>
<p>necessary BSW, the EcuM </p>
<p>is in the Run state. </p>
<p>Entered during </p>
<p>EcuM_StartupTwo(), </p>
<p>EcuM_GoSleep(), EcuM_GoPoll() </p>
<p>or during the MainFunction. </p>
<p>ECUM_STATE_GO_SLEEP </p>
<p>Prepares the ECU for the </p>
<p>upcoming sleep phase. </p>
<p>Entered during EcuM_GoSleep(). </p>
<p>ECUM_STATE_SLEEP </p>
<p>Handles the sleep. </p>
<p>Entered during EcuM_GoHalt() or </p>
<p>EcuM_GoPoll(). </p>
<p>ECUM_STATE_GO_OFF_ONE </p>
<p>Prepares the ECU for the </p>
<p>upcoming Off phase.  </p>
<p>The SchM and the BswM </p>
<p>are deinitialized in this </p>
<p>phase and the </p>
<p>EcuM_OnGoOffOne() </p>
<p>Callout is invoked. </p>
<p>Finally the operating </p>
<p>system will be shut down. </p>
<p>Entered during EcuM_GoDown(). </p>
<p>ECUM_STATE_GO_OFF_TWO </p>
<p>The configured shutdown </p>
<p>target is called by the </p>
<p>EcuM. </p>
<p>Entered during </p>
<p>EcuM_Shutdown(). </p>
<p>ECUM_STATE_WAKEUP_ONE </p>
<p>The hardware is </p>
<p>reinitialized after a former </p>
<p>sleep mode. </p>
<p> </p>
<p>ECUM_STATE_WAKEUP_VALIDATION </p>
<p>Waits for the validation of </p>
<p>an occurred wake up. </p>
<p>After a wake-up event has </p>
<p>occurred that needs validation. </p>
<p>Table 3-5  </p>
<p>States of the EcuM </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>20 / 134 </p>
<p><b>3.3 </b></p>
<p><b>States of EcuM fixed </b></p>
<p>These states indicate the current internal EcuM Operation State which can be retrieved via </p>
<p>the API 5.4.1 EcuM_GetState.  </p>
<p>All the states, except ECUM_STATE_STARTUP and ECUM_STATE_ERROR are notified </p>
<p>to the BswM. In some state transitions an RTE mode switch will be performed. </p>
<p><b>Module State </b></p>
<p><b>Activities </b></p>
<p><b>RTE Mode </b></p>
<p>ECUM_STATE_STARTUP </p>
<p>Initializes the drivers via the </p>
<p>DriverInitLists. </p>
<p>Reset reason translation, setting </p>
<p>of the default shutdown target </p>
<p>and at the end start the </p>
<p>operating system.  </p>
<p>Initializes the BswM, the SchM </p>
<p>and the RTE. </p>
<p>Former buffered Wake-up </p>
<p>Events are notified to the BswM. </p>
<p>ECUM_RTE_STARTUP </p>
<p>(initial mode) </p>
<p>ECUM_STATE_APP_RUN </p>
<p>EcuM stays in this state while </p>
<p>there are active Run Requests, </p>
<p>the EcuM Self Run Request </p>
<p>timeout has not expired or </p>
<p>ComM Channels are in </p>
<p>communication. </p>
<p>ECUM_RTE_RUN </p>
<p>ECUM_STATE_APP_POST_RUN </p>
<p>Post Run Requests keep the </p>
<p>EcuM in this state. </p>
<p>ECUM_RTE_POST_RUN </p>
<p>ECUM_STATE_PREP_SHUTDOWN </p>
<p>Shutdown the DEM and transit </p>
<p>directly to </p>
<p>ECUM_STATE_GO_SLEEP or </p>
<p>ECUM_STATE_GO_OFF_ONE </p>
<p>ECUM_RTE_POST_RUN </p>
<p>ECUM_STATE_GO_SLEEP </p>
<p>EcuM triggers the </p>
<p>NvM_WriteAll() job.  </p>
<p>EcuM remains in this state until </p>
<p>the NvM calls </p>
<p>EcuM_CB_NfyNvMJobEnd() or </p>
<p>the occurrence of a wake up </p>
<p>event cancels the sleep </p>
<p>process. In case of a wake up </p>
<p>event, NvM_CancelWriteAll() is </p>
<p>called. </p>
<p>ECUM_RTE_SLEEP </p>
<p>ECUM_STATE_SLEEP </p>
<p>Handles the sleep and a wake </p>
<p>up from sleep. </p>
<p>ECUM_RTE_SLEEP </p>
<p>ECUM_STATE_GO_OFF_ONE </p>
<p>Stops the RTE and triggers </p>
<p>NvM_WriteAll().  </p>
<p>EcuM remains in this state until </p>
<p>the NvM call </p>
<p>EcuM_CB_NfyNvMJobEnd(). </p>
<p>ECUM_RTE_SHUTDOWN </p>
<p>ECUM_STATE_WAKEUP_VALIDATION </p>
<p>Waits for the validation of an </p>
<p>occurred wake up. </p>
<p>ECUM_RTE_SLEEP </p>
<p>ECUM_STATE_WAKEUP_REACTION </p>
<p>Wait for completion of a </p>
<p>potential NvM_CancelWriteAll(). </p>
<p>ECUM_RTE_SLEEP </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>21 / 134 </p>
<p><b>Module State </b></p>
<p><b>Activities </b></p>
<p><b>RTE Mode </b></p>
<p>ECUM_STATE_WAKEUP_WAKESLEEP </p>
<p>- </p>
<p>ECUM_RTE_WAKE_SLEEP </p>
<p>ECUM_STATE_ERROR </p>
<p>The EcuM_ErrorHook is called </p>
<p>in this state. </p>
<p>This state is only reached if the </p>
<p>ShutdownOS() or </p>
<p>EcuM_AL_SwitchOff returns to </p>
<p>the EcuM. </p>
<p>- </p>
<p>Table 3-6  </p>
<p>States of the EcuM </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>22 / 134 </p>
<p><b>3.4 </b></p>
<p><b>The State Diagram of the EcuM flex </b></p>
<p>The </p>
<p>following </p>
<p>figure </p>
<p>shows </p>
<p>the </p>
<p>EcuM </p>
<p>state </p>
<p>diagram </p>
<p>with </p>
<p>all </p>
<p>state </p>
<p>transitions, </p>
<p>the </p>
<p>corresponding conditions and actions: </p>
<p> </p>
<p>Figure 3-1 </p>
<p>The state diagram of the EcuM flex </p>
<p><b>stm EcuPhases</b></p>
<p><b>SLEEP</b></p>
<p><i>(from Features)</i></p>
<p><b>ECUM_STATE_SLEEP</b></p>
<p>EcuM_Init</p>
<p>called</p>
<p>Off</p>
<p><b>STARTUP</b></p>
<p><b>ECUM_STATE_STARTUP_ONE (EcuM_Init)</b></p>
<p><b>notes</b></p>
<p><i>Perform the actions in the StartPreOS Sequence:</i></p>
<p><i>- Set Interrupts</i></p>
<p><i>- DriverInitZero (init Block0)</i></p>
<p><i>- Determine PbConfiguration (return a pointer to the config struct </i></p>
<p><i>that contain post-build config data from EcuM and all other BSWs)</i></p>
<p><i>- Check consistency of the configuration data</i></p>
<p><i>- DriverInitOne (init Block1)</i></p>
<p><i>- Get Mcu reset reason</i></p>
<p><i>- Select default shutdown target</i></p>
<p><i>- Start OS</i></p>
<p><b>ECUM_STATE_STARTUP_TWO (EcuM_StartupTwo)</b></p>
<p><b>notes</b></p>
<p><i>Perform the actions in the StartPostOS Sequence:</i></p>
<p><i>- Init BSW Scheduler </i></p>
<p><i>- Init BSW Mode Manager</i></p>
<p><i>- Notify the BswM about Wakeups during Startup</i></p>
<p>Final</p>
<p><b>ECUM_STATE_GO_SLEEP </b></p>
<p><b>(EcuM_EnterSleep)</b></p>
<p><b>notes</b></p>
<p><i>EcuM prepares the Hardware for going to </i></p>
<p><i>sleep and setting the WakeUp sources.</i></p>
<p><i>(from Features)</i></p>
<p><b>Poll</b></p>
<p><b>notes</b></p>
<p><i>EcuM checks for pending wakeups </i></p>
<p><i>cyclically by calling </i></p>
<p><i>EcuM_CheckWakeup(). </i></p>
<p><i>Auxiliary EcuM_SleepActivity() must </i></p>
<p><i>be called for e.g. updating the alarm</i></p>
<p><i>clock.</i></p>
<p><b>Halt</b></p>
<p><b>notes</b></p>
<p><i>No more code is executed.</i></p>
<p><i>Before halting the MCU, EcuM must </i></p>
<p><i>invoke GenerateRamHash and call </i></p>
<p><i>CheckRamHash before leaving halt.</i></p>
<p><i>On Multicore: Only check the master </i></p>
<p><i>core.</i></p>
<p><b>ECUM_STATE_WAKEUP_ONE </b></p>
<p><b>(EcuM_WakeupRestart)</b></p>
<p><i>(from Features)</i></p>
<p><b>SHUTDOWN</b></p>
<p>Final</p>
<p>Final</p>
<p><b>ECUM_STATE_GO_OFF_ONE (EcuM_GoDown)</b></p>
<p><b>notes</b></p>
<p><i>Activities in the OffPreOS Phase:</i></p>
<p><i>- De-Init BSW Mode Manager</i></p>
<p><i>- De-Init BSW Scheduler</i></p>
<p><i>- Check for pending wakeup events</i></p>
<p><i>- Set RESET as shutdown target, if wakeup events are pending</i></p>
<p><i>- Shutdown OS</i></p>
<p><b>ECUM_STATE_GO_OFF_TWO</b></p>
<p>EntryPoint</p>
<p>EntryPoint</p>
<p>A shutdown target must </p>
<p>be set by the BswM or </p>
<p>another SW-C before </p>
<p>GoHalt or GoPoll is </p>
<p>called.</p>
<p>If a wakeup event </p>
<p>occurs the Shutdown </p>
<p>sequence shall be </p>
<p>completed and restart </p>
<p>immediately thereafter.</p>
<p>EntryPoint</p>
<p><b>UP</b></p>
<p><b>ECUM_STATE_RUN (EcuM_EnterSleep, </b></p>
<p><b>EcuM_MainFunction, </b></p>
<p><b>EcuM_StartupTw o)</b></p>
<p><b>notes</b></p>
<p><i>Tasks in the UP Phase:</i></p>
<p><i>- WakeUp Validation</i></p>
<p><b>ECUM_STATE_WAKEUP_VALIDATION </b></p>
<p><b>(EcuM_EnterSleep)</b></p>
<p>If in ECUM_STATE_WAKEUP_VALIDATION </p>
<p>no wakeup will be validated, the BswM can </p>
<p>set the EcuM back to sleep by calling GoHalt</p>
<p>() or GoPoll().</p>
<p>[Shutdown Target == ECUM_STATE_RESET]</p>
<p>/Action: EcuM_AL_Reset</p>
<p>BSW Scheduler started</p>
<p>&amp; BswM_Init called</p>
<p>EcuM_StartupTwo() is called by</p>
<p>OS or by a task</p>
<p>EcuM_GoOff</p>
<p>[GoHalt() or GoPoll() is invoked by</p>
<p>BswM]</p>
<p>[ValidatedWakeups = True]</p>
<p>/</p>
<p>[call Mcu_Setmode(GoHalt)]</p>
<p>WakeUP Event</p>
<p>[No WakeUp</p>
<p>occured]</p>
<p>[No WakeUp</p>
<p>occured]</p>
<p>[ValidatedWakeups = False]</p>
<p>[Shutdown Target == ECUM_STATE_OFF]</p>
<p>/EcuM_AL_SwitchOff</p>
<p>EcuM_Shutdown</p>
<p>[call EcuM_WakeupRestart]</p>
<p>[GoHalt() or GoPoll()]</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>23 / 134 </p>
<p><b>3.5 </b></p>
<p><b>The State Diagram of the EcuM with fixed state machine </b></p>
<p>The  following  figure  shows  the  EcuM  state  diagram  with  all  state  transitions  and  the </p>
<p>corresponding RTE modes: </p>
<p> </p>
<p> </p>
<p>Figure 3-2 State Diagram of the EcuM with fixed state machine </p>
<p><b> stm EcuMFixedStateMachine_Ov erv iew</b></p>
<p>SLEEP Mode</p>
<p>WAKE_SLEEP Mode</p>
<p>SHUTDOWN Mode</p>
<p>POST_RUN Mode</p>
<p>RUN Mode</p>
<p>STARTUP</p>
<p>from Startup</p>
<p>Code</p>
<p><b>ECUM_STATE_ INIT</b></p>
<p><b>notes</b></p>
<p><i>Init Sequence I:</i></p>
<p><i>EcuM_AL_SetProgrammableInterrupts() [type:callout]</i></p>
<p><i>EcuM_AL_DriverInitZero [type:callout]</i></p>
<p><i>EcuM_DeterminePbConfiguration [type:callout]</i></p>
<p><i>EcuM_AL_DriverInitOne [type:callout] e.g. Dem_Init</i></p>
<p><i>Retrieve reset reason from MCU module and map it to an wakeup source</i></p>
<p><i>Start OS</i></p>
<p><b>ECUM_STATE_ APP_RUN</b></p>
<p><b>notes</b></p>
<p><i>Decrease the EcuM SelfRequest Timeout.</i></p>
<p><i>EcuM remains in RUN state for minimum duration of SelfRequestTimeout.</i></p>
<p><i>Consider wakeup validation for communication channels.</i></p>
<p><b>ECUM_STATE_APP_POST_RUN</b></p>
<p><b>ECUM_STATE_ </b></p>
<p><b>PREP_SHUTDOWN</b></p>
<p><b>ECUM_STATE_ GO_OFF_ONE</b></p>
<p><b>notes</b></p>
<p><i>BswM notification about ECUM_STATE_ GO_OFF</i></p>
<p><i>Rte_Stop</i></p>
<p><i>SchM_DeInit</i></p>
<p><i>BswM_DeInit</i></p>
<p><i>ShutdownOS</i></p>
<p><b>ECUM_STATE_ GO_SLEEP</b></p>
<p><b>ECUM_STATE_SLEEP</b></p>
<p><b>ECUM_STATE_ </b></p>
<p><b>WAKEUP_VALIDATION</b></p>
<p><b>ECUM_STATE_ WAKEUP_REACTION</b></p>
<p><b>ECUM_STATE_WAKE_SLEEP</b></p>
<p>Init finished and Rte has sent its feedback</p>
<p>enter RUN mode</p>
<p>leave RUN mode</p>
<p>enter POST_RUN mode</p>
<p>leave POST_RUN mode</p>
<p>enter SHUTDOWN mode</p>
<p>enter SLEEP</p>
<p>mode</p>
<p>enter WAKE_SLEEP mode</p>
<p>enter SLEEP mode</p>
<p>Wakeup validation necessary</p>
<p>to switch into RUN mode?</p>
<p>switch back into</p>
<p>RUN mode</p>
<p>leave</p>
<p>SHUTDOWN</p>
<p>Mode</p>
<p>shutdown</p>
<p>target?</p>
<p><b>ECUM_STATE_STARTUP</b></p>
<p><b>notes</b></p>
<p><i>Init Sequence II:</i></p>
<p><i>Init BSW Scheduler (SchM_Init)</i></p>
<p><i>Init BswM (BswM_Init)</i></p>
<p><i>EcuM_AL_DriverInitTwo  [type:callout]</i></p>
<p><i>EcuM_OnRTEStartup  [type:callout]</i></p>
<p><i>Start Rte</i></p>
<p><i>EcuM_AL_DriverInitThree [type:callout]</i></p>
<p>Interrupts are </p>
<p>available now!</p>
<p><b>ECUM_STATE_ </b></p>
<p><b>GO_OFF_TWO</b></p>
<p>[valid wakeup event &amp;&amp; Rte has sent its</p>
<p>feedback &amp;&amp; NvM_WriteAll is canceled]</p>
<p>/Dem_Init</p>
<p>EcuM_OnEnterRun [type: callout]</p>
<p>BswM_EcuM_CurrentState</p>
<p>(ECUM_STATE_APP_RUN)</p>
<p>ComM_CommunicationAllowed(TRUE)</p>
<p>/Rte notification about SHUTDOWN</p>
<p>EcuM_OnGoOffOne [Type: callout]</p>
<p>Dem_Shutdown</p>
<p>NvM_WriteAll</p>
<p>/Rte notification about SLEEP</p>
<p>EcuM_OnGoSleep [Type: callout]</p>
<p>Dem_Shutdown</p>
<p>NvM_WriteAll (when coming from PREP_SHUTDOWN)</p>
<p>[wakeup reaction is</p>
<p>SLEEP]</p>
<p>[NO - &quot;normal&quot; startup]</p>
<p>/EcuM_OnEnterRun [type: callout]</p>
<p>ComM_CommunicationAllowed(TRUE)</p>
<p>[YES - wakeup by wakeup source with integrated power control]</p>
<p>/RTE notification about SLEEP</p>
<p>[shutdown target is SLEEP]</p>
<p>[shutdown target is not SLEEP]</p>
<p>[NvM finished its write job &amp;&amp; no valid wakeup</p>
<p>existent &amp;&amp; Rte has sent its feedback]</p>
<p>/BswM_EcuM_CurrentState(ECUM_STATE_SLEEP)</p>
<p>[All RUN requests released &amp;&amp; SelfRequestTimeout reached &amp;&amp;</p>
<p>Rte has sent its feedback &amp;&amp; ComM channels are not in state</p>
<p>COMM_NO_COM_PENDING_REQUEST]</p>
<p>/Clear all Wakeup Events</p>
<p>BswM_EcuM_CurrentState/(ECUM_STATE_APP_POST_RUN)</p>
<p>EcuM_OnExitRun [type: callout]</p>
<p>ComM_CommunicationAllowed(FALSE)</p>
<p>[(RUN state requested || EcuM has valid</p>
<p>wakeup || ComM channel is pending) &amp;&amp; Rte</p>
<p>has sent its feedback]</p>
<p>/EcuM_OnEnterRun [type:callout]</p>
<p>EcuM_EnableCommunication(TRUE) [type:</p>
<p>callout]</p>
<p>[All POST_RUN requests released &amp;&amp;</p>
<p>Rte has sent its feedback]</p>
<p>/EcuM_OnExitPostRun [type: callout]</p>
<p>[Rte has sent its feedback ]</p>
<p>[wakeup event occured &amp;&amp; Rte</p>
<p>has sent its feedback]</p>
<p>/NvM_CancelWriteAll</p>
<p>EcuM_AL_DriverRestart [type:</p>
<p>callout]</p>
<p>[wait for NvM AND</p>
<p>asynchron wakeup</p>
<p>events]</p>
<p>[no pending or valid wakeup</p>
<p>occured]</p>
<p>[wakeup event occured]</p>
<p>/BswM_EcuM_CurrentState(ECUM_STATE_WAKEUP_VALIDATION)</p>
<p>EcuM_OnWakeupReaction()</p>
<p>[wakeup event</p>
<p>pending]</p>
<p>[wakeup event not pending]</p>
<p>/BswM_EcuM_CurrentState</p>
<p>(ECUM_STATE_WAKEUP_REACTION)</p>
<p>EcuM_OnWakeupReaction [type: callout]</p>
<p>[Execution of ShutdownOS() successful]</p>
<p>/EcuM_OnGoOffTwo [Type: callout]</p>
<p>Rte_Stop()</p>
<p>SchM_DeInit()</p>
<p>BswM_DeInit()</p>
<p>ShutdownOS()</p>
<p>[NvM_WriteAll finished &amp;&amp;</p>
<p>Rte has sent its feedback]</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>24 / 134 </p>
<p><b>3.6 </b></p>
<p><b>Initialization </b></p>
<p>The initialization of the EcuM is split into two parts: one part is the initialization before the </p>
<p>OS is up and running and the second part must be executed when the OS is started.  </p>
<p><b>3.6.1 </b></p>
<p><b>EcuM_Init </b></p>
<p>The first part will be performed by the function EcuM_Init() (refer to chapter 5.2.2). This </p>
<p>function executes the DriverInitLists “EcuMDriverInitListZero” and “EcuMDriverInitListOne” </p>
<p>where the basic driver initialization should be performed. EcuM_Init() starts the AUTOSAR </p>
<p>OS by calling the function StartOS() (refer to chapter 5.2.3).  </p>
<p> </p>
<p><b>3.6.2 </b></p>
<p><b>EcuM_StartupTwo </b></p>
<p>The second part of the initialization sequence will be executed by the EcuM API </p>
<p>EcuM_StartupTwo(). The integrator must ensure that this function is called once right after </p>
<p>the start of the OS.  </p>
<p> </p>
<p><b>3.6.2.1 </b></p>
<p><b>EcuM_StartupTwo in case of EcuM flex </b></p>
<p>When EcuM_StartupTwo() is left, the EcuM flex is in Run state and passes the control of </p>
<p>the ECU to the BswM. </p>
<p> </p>
<p><b>3.6.2.2 </b></p>
<p><b>EcuM_StartupTwo in case of EcuM fixed </b></p>
<p>In  case  of  EcuM  fixed,  in  EcuM_StartupTwo()  the  DriverInitLists  “EcuMDriverInitListTwo” </p>
<p>and “EcuMDriverInitListThree” can be used to initialize the whole stack. </p>
<p> </p>
<p><b>3.6.3 </b></p>
<p><b>Initialization Order </b></p>
<p>Depending on which modules are needed for starting the operating system the initialization </p>
<p>lists can look different.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>At the end of the EcuM_StartupTwo the EcuM is fully initialized. That does not mean </p>
<p>that the whole stack is initialized, it means only that the EcuM has passed the control </p>
<p>over to the BswM. Further initialization is done by the BswM. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>At the end of the EcuM_StartupTwo the EcuM fixed transits to </p>
<p>ECUM_STATE_APP_RUN in case of a validated wake up, e.g. set by the MCU Reset </p>
<p>Reason (refer to chapter 3.9.5). </p>
<p>If this wake up was cleared (in EcuMDriverInitListTwo), the EcuM transits to </p>
<p>ECUM_STATE_WAKEUP_VALIDATION and performs a wake up validation if any wake </p>
<p>up source is pending. </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>25 / 134 </p>
<p>In the following an example initialization order is given. Init Block 0 corresponds to the </p>
<p>EcuM_AL_DriverInitZero() (refer to chapter 5.7.2.6) and Init Block 1 corresponds to </p>
<p>EcuM_AL_DriverInitOne() (refer to chapter 5.7.2.7). </p>
<p><b>Initialization Group </b></p>
<p>Init Block0 </p>
<p>Det_Init() </p>
<p>Dem_PreInit(ConfigPointer) </p>
<p>Init Block1 </p>
<p>Mcu_Init(ConfigPointer) </p>
<p>Gpt_Init(ConfigPointer) </p>
<p>Wdg_Init() </p>
<p>WdgM_Init() </p>
<p>Adc_Init(ConfigPointer) </p>
<p>Icu_Init(ConfigPointer) </p>
<p>Pwm_Init(ConfigPointer) </p>
<p>Table 3-7  </p>
<p>Initialization Order </p>
<p><b>3.6.4 </b></p>
<p><b>Additional Code in the Initialization Callouts </b></p>
<p>If the user needs more than the initialization routines offered by the AUTOSAR modules, </p>
<p>the configuration tool offers the facility to add own Code to the DriverInitLists. To use this </p>
<p>feature the user has to choose “Code” instead of a MSN, then the code can be added to a </p>
<p>special field. </p>
<p>The user code is added to the Init Block 0 or Init Block 1 as configured by the user. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>In this example the routine Mcu_InitClock() is added to the DriverInitListOne: </p>
<p><b>&gt; </b></p>
<p>Open the Initialization dialogue </p>
<p><b>&gt; </b></p>
<p>Go to the configuration of DriverInitListOne in the Pre-OS Init Sequence </p>
<p><b>&gt; </b></p>
<p>Add an InitItem to the list and choose a name like “McuInitClock” </p>
<p><b>&gt; </b></p>
<p>Choose “Code” in the field Type </p>
<p><b>&gt; </b></p>
<p>In the field “Code” you can insert: “Mcu_InitClock();” </p>
<p><b>&gt; </b></p>
<p>Reorder the position of the InitItem </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>26 / 134 </p>
<p><b>3.6.5 </b></p>
<p><b>Inclusion of Additional Header Files </b></p>
<p>If the user needs additional headers for using in the EcuM_Callout_Stubs.c file, the EcuM </p>
<p>offers the possibility of adding them by the configuration tool. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>All header files of the modules that are initialized in the DriverInitLists must be </p>
<p>included </p>
<p>into </p>
<p>the </p>
<p>additional </p>
<p>header </p>
<p>files </p>
<p>because </p>
<p>they </p>
<p>are </p>
<p>not </p>
<p>included </p>
<p>automatically. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.6.6 </b></p>
<p><b>Configuration Set Selection </b></p>
<p>The  AUTOSAR  compatible  mechanism  to  select  the  configuration  set  which  should  be </p>
<p>used for module initialization considers the following aspects: </p>
<p><b>&gt; </b></p>
<p>Most of the AUTOSAR modules provide a configuration reference to the provided </p>
<p>configuration sets  </p>
<p><b>&gt; </b></p>
<p>Some modules are initialized without a configuration pointer (Init-function signature </p>
<p>&lt;MSN&gt;_Init(void)) </p>
<p><b>&gt; </b></p>
<p>Some modules have an Init-function signature with configuration pointer but make </p>
<p>no use of it, therefore, they need to be initialized with a NULL_PTR. </p>
<p> </p>
<p> </p>
<p>The user must decide which routines use a configuration pointer. For these routines the </p>
<p>configuration reference must be configured. </p>
<p><b>&gt; </b></p>
<p>Module uses a configuration pointer for its initialization: </p>
<p>- </p>
<p>Select in the DriverInitList a MSN via the field Type (e.g. Dem) </p>
<p>- </p>
<p>Select the corresponding Service (e.g. Dem_PreInit) </p>
<p>- </p>
<p>Configure </p>
<p>the </p>
<p>corresponding </p>
<p>Configuration </p>
<p>Pointer </p>
<p>for </p>
<p>that </p>
<p>MSN </p>
<p>(e.g. </p>
<p>DemConfigSet) </p>
<p>- </p>
<p>Result: The EcuM generates “Dem_PreInit(&amp;DemConfigSet)” </p>
<p><b>&gt; </b></p>
<p>Module has a void Init-function signature </p>
<p>- </p>
<p>Select in the DriverInitList a MSN via the field Type (e.g. Det) </p>
<p>- </p>
<p>Select the corresponding Service (e.g. Det_Init) </p>
<p>- </p>
<p>Do not configure the corresponding Configuration Pointer for this MSN </p>
<p>- </p>
<p>Result: The EcuM generates: “Det_Init()” </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>27 / 134 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If a module initialization routine requires a configuration set as parameter, the </p>
<p>corresponding reference to the module must be configured. </p>
<p>This is also necessary if the initialization routine does not use the parameter. The </p>
<p>reference must be configured, otherwise the parameter list will be generated empty. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.7 </b></p>
<p><b>Initialization of a MultiCore ECU </b></p>
<p>The  initialization  of  a  MultiCore  Ecu  is  described  in  chapter  3.15.1  Initialization  of  a </p>
<p>MultiCore ECU. </p>
<p><b>3.8 </b></p>
<p><b>Shutdown Targets </b></p>
<p>The  EcuM  provides  the  possibility  to  select  a  shutdown  target  that  is  used  for  the  next </p>
<p>shutdown, </p>
<p>initiated </p>
<p>by </p>
<p>calling </p>
<p>EcuM_GoDown() </p>
<p>(refer </p>
<p>to </p>
<p>chapter </p>
<p>5.3.5),  </p>
<p>EcuM_GoPoll()(refer to chapter 5.3.4) or EcuM_GoHalt()(refer to chapter 5.3.3).  </p>
<p>The following three different targets can be selected by a SWC or a BSW module: </p>
<p><b>&gt; </b></p>
<p>ECUM_STATE_SLEEP </p>
<p><b>&gt; </b></p>
<p>ECUM_STATE_RESET </p>
<p><b>&gt; </b></p>
<p>ECUM_STATE_OFF </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The two targets ECUM_STATE_SLEEP and ECUM_STATE_RESET have an </p>
<p>additional mode parameter, which is used to identify the configuration for the </p>
<p>Sleep mode or to identify the reason for an upcoming reset of the ECU. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.8.1 </b></p>
<p><b>Using the API EcuM_SelectShutdownTarget() </b></p>
<p>The API EcuM_SelectShutdownTarget()(refer to chapter 5.2.5) can only be used when the </p>
<p>EcuM is in the state ECUM_STATE_RUN. In the startup phase or during the sleep phase it </p>
<p>is not allowed to change the shutdown target. </p>
<p><b>3.8.2 </b></p>
<p><b>Default Shutdown Target </b></p>
<p>A Default shutdown target must be set during the configuration. This is the first target that </p>
<p>is selected as shutdown target after a startup. During runtime the shutdown target can be </p>
<p>changed by another BSW or SWC via the API EcuM_SelectShutdownTarget(). </p>
<p><b>3.8.3 </b></p>
<p><b>Reset Modes </b></p>
<p>The reset modes can be used to identify the reason for an upcoming ECU reset. A set of </p>
<p>reset modes is defined by the AUTOSAR standard. Additional modes can be added by the </p>
<p>configuration. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>28 / 134 </p>
<p>The reset mode is passed over to the Callout EcuM_AL_Reset(EcuM_ResetType) and the </p>
<p>user can implement different ways to reset the ECU, depending on the reason for this </p>
<p>reset. </p>
<p> </p>
<p>The Vector extension ECUM_RESET_WAKEUP is used as the reset mode in the case of a </p>
<p>late wake-up event in the shutdown phase. If a wake-up occurs during the shutdown </p>
<p>procedure, the shutdown target is changed by the EcuM to ECUM_STATE_RESET and </p>
<p>the described mode is used. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Reset Modes are only available if EcuM flex is used. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.8.4 </b></p>
<p><b>Sleep Modes </b></p>
<p>A </p>
<p>sleep </p>
<p>mode </p>
<p>holds </p>
<p>the </p>
<p>information </p>
<p>about </p>
<p>the </p>
<p>configured </p>
<p>sleep </p>
<p>modes </p>
<p>and </p>
<p>the </p>
<p>corresponding relevant settings. The following items can be set for a sleep mode: </p>
<p><b>&gt; </b></p>
<p>Reference to a configured MCU mode that is executed for that sleep mode. </p>
<p><b>&gt; </b></p>
<p>Active Wake-up Sources during this sleep mode. </p>
<p><b>3.9 </b></p>
<p><b>Wake-up Sources </b></p>
<p>The EcuM flex offers the possibility to configure wake-up sources for all modules that have </p>
<p>the functionality to wake up the ECU. The EcuM handles the Wake-up Validation Protocol </p>
<p>for these sources as described in 3.10.1 Wake-up Validation Protocol. </p>
<p>The Wake-up Sources have several configurable attributes as described in the following </p>
<p>section. </p>
<p><b>3.9.1 </b></p>
<p><b>Validation Timeout </b></p>
<p>For every source, except for the standard sources 0 – 4, a validation timeout timer can be </p>
<p>configured. This  timer  specifies  the  time  (in  seconds)  until  the  wake-up  source  must  be </p>
<p>validated by calling EcuM_ValidateWakeupEvent().  </p>
<p>If the wake-up event is not validated during that time the EcuM sets this event to “expired” </p>
<p>and reports it to the BswM. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The following reset mode is defined by Vector as an extension to the standard </p>
<p>AUTOSAR modes: </p>
<p><b></b></p>
<p><b> </b></p>
<p>ECUM_RESET_WAKEUP  </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>29 / 134 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The following standard wake-up sources are pre-configured and do not need the wake-</p>
<p>up validation protocol: </p>
<p><b>&gt; </b></p>
<p>ECUM_WKSOURCE_POWER </p>
<p><b>&gt; </b></p>
<p>ECUM_WKSOURCE_RESET </p>
<p><b>&gt; </b></p>
<p>ECUM_WKSOURCE_INTERNAL_RESET </p>
<p><b>&gt; </b></p>
<p>ECUM_WKSOURCE_INTERNAL_WDG </p>
<p><b>&gt; </b></p>
<p>ECUM_WKSOURCE_EXTERNAL_WDG </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.9.2 </b></p>
<p><b>Check-Wakeup Validation Timeout </b></p>
<p>For  every  source,  except  for  the  standard  sources  0  –  4,  a  check  wake-up  validation </p>
<p>timeout timer can be configured. This timer specifies the time (in seconds) until the wake-</p>
<p>up source must be set by calling EcuM_SetWakeupEvent(). </p>
<p>This timer can be used for e.g. asynchronous transceiver drivers, which cannot check the </p>
<p>wake-up source in the context of EcuM_CheckWakeup.  </p>
<p> </p>
<p><b>3.9.3 </b></p>
<p><b>ComM Channel Reference </b></p>
<p>If the configured Wake-up Source is a ComM Channel, the reference to the corresponding </p>
<p>channel can be configured by the parameter EcuMComMChannelRef. </p>
<p>If this reference is configured and a validated wake-up event occurred, the EcuM calls the </p>
<p>function ComM_EcuM_WakeupIndication() and reports it to the ComM. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Only Wake-up Sources which represent a ComM Channel can lead to a wake up in the </p>
<p>state ECUM_STATE_RUN. Other Wake-up Sources are ignored during this state. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.9.4 </b></p>
<p><b>Polling of Wake-up Sources </b></p>
<p>If a Wake-up Source needs to be polled to detect wake-up events this parameter must be </p>
<p>set. In that case, the sleep can be entered by calling EcuM_GoPoll() and the EcuM polls </p>
<p>all Wake-up Sources that are active during that Sleep mode and the polling parameter is </p>
<p>set. </p>
<p><b>3.9.5 </b></p>
<p><b>MCU Reset Reason </b></p>
<p>The EcuM calls the routine Mcu_GetResetReason() to acquire the reason for the recent </p>
<p>reset. The EcuM iterates over all configured Wake-up Sources and checks if the </p>
<p>configured Reset Reason of one Wake-up Source matches to the return value of the MCU. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>30 / 134 </p>
<p>If a reset reason is found, the EcuM maps this MCU reset reason to an EcuM Wake-up </p>
<p>Source and reports the event to the BswM. The regular wake-up validation is done by the </p>
<p>EcuM in case it is required by the source. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>If the reset reason translation is not successful and no reset reason can be determined, </p>
<p>the EcuM reports to the BswM the default reset reason ECUM_WKSOURCE_RESET.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.10 </b></p>
<p><b>Main Functions </b></p>
<p><b>3.10.1 </b></p>
<p><b>Wake-up Validation Protocol </b></p>
<p>The wake-up validation protocol provides a standardized way to recognize valid controller </p>
<p>wake ups after a sleep phase. </p>
<p>For </p>
<p>all </p>
<p>user </p>
<p>configured </p>
<p>wake-up </p>
<p>sources </p>
<p>the </p>
<p>parameter </p>
<p>“Validation </p>
<p>Timeout” </p>
<p>is </p>
<p>configurable.  If  the  parameter  is  set  to  a  value  which  is  not  0,  the  wake-up  validation </p>
<p>protocol is active for that source. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>31 / 134 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>In the following example the whole wake-up validation procedure can be seen. A wake-</p>
<p>up event occurs for the ComMChannel CanIf and needs validation. The validation is </p>
<p>processed and the wake-up event is notified to the BswM and to the ComM. </p>
<p> </p>
<p>Figure 3-3 </p>
<p>Example Wake-up Validation </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>sd WakeupValidation</b></p>
<p>Module</p>
<p>Integration Code</p>
<p>(EcuM_Callout_Stubs)</p>
<p>Module</p>
<p>EcuM</p>
<p>Interrupt Source</p>
<p>CanIf</p>
<p>«EmbeddedInterface»</p>
<p>ComM</p>
<p>«EmbeddedInterface»</p>
<p>BswM</p>
<p><b>loop WHILE wakeup ev ent has not been v alidated</b></p>
<p><b>opt wakeup ev ent is v alidated</b></p>
<p>Interrupt()</p>
<p>EcuM_CheckWakeup(EcuM_WakeupSourceType)</p>
<p>CanIf_CheckWakeup(EcuM_WakeupSourceType)</p>
<p>EcuM_SetWakeupEvent(EcuM_WakeupSourceType)</p>
<p>BswM_EcuM_CurrentWakeup(EcuM_WakeupSourceType, EcuM_WakeupStatusType ECUM_WKSOURCE_PENDING)</p>
<p>EcuM_StartWakeupSources(EcuM_WakeupSourceType)</p>
<p>EcuM_CheckValidation(EcuM_WakeupSourceType)</p>
<p>CanIf_CheckValidation(EcuM_WakupSourceType)</p>
<p>EcuM_ValidateWakeupEvent(EcuM_WakeupSourceType)</p>
<p>BswM_EcuM_CurrentWakeup(EcuM_WakeupSourceType, EcuM_WakeupStatusType ECUM_WKSOURCE_VALIDATED)</p>
<p>ComM_EcuM_WakeUpIndication(NetworkHandleType)</p>
<p>EcuM_StopWakeupSources(EcuM_WakeupSourceType)</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>32 / 134 </p>
<p><b>3.10.2 </b></p>
<p><b>Wake-up Validation Protocol for asynchronous Can transceiver </b></p>
<p>For  all  user  configured  wake-up  sources  the  parameter  “Check  Validation  Timeout”  is </p>
<p>configurable. If the parameter is set to a value which is not 0, the check wake-up validation </p>
<p>protocol is active for that source. </p>
<p>For  these  sources  the  call  of  EcuM_SetWakeupEvent  must  not  occur  in  the  context  of </p>
<p>EcuM_CheckWakeup. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>In the following example parts of the wake-up validation procedure can be seen for an </p>
<p>asynchronous Can transceiver.  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p>Figure 3-4 </p>
<p>Example Wake-up Validation for asynchronous Can Transceivers </p>
<p><b>sd WakeupValidation</b></p>
<p>Module</p>
<p>Integration Code</p>
<p>(EcuM_Callout_Stubs)</p>
<p>Module</p>
<p>EcuM</p>
<p>Interrupt Source (CanTrcv</p>
<p>Hardware</p>
<p>CanIf</p>
<p>CanTrcv</p>
<p>Icu</p>
<p>«EmbeddedInterface»</p>
<p>BswM</p>
<p>Program flow continues, if Ecu was in a sleep mode the wake-up procedure </p>
<p>is performed. If the Ecu was in Run mode, the Run mode continues as </p>
<p>before.</p>
<p>As soon as the transceiver gets a response via SPI about a valid wake-up </p>
<p>event, the CanTrcv calls EcuM_SetWakeupEvent in the positive case.</p>
<p><b>alt Wait for Wakeup Indication by Transceiv er</b></p>
<p>[positive Wakeup Indication]</p>
<p>[negative Wakeup Indication]</p>
<p>[Timeout]</p>
<p>Interrupt()</p>
<p>EcuM_CheckWakeup(WAKEUP_SOURCE_CAN)</p>
<p>EcuM_StartCheckWakeup(WAKEUP_SOURCE_CAN)</p>
<p>WAKEUP_SOURCE_CAN, ECUM_WKSTATUS_CHECKWAKEUP(source, state)</p>
<p>start CheckWakeupTimer()</p>
<p>CanIf_CheckWakeup(WAKEUP_SOURCE_CAN)</p>
<p>CanTrcv_CB_WakeupByBus()</p>
<p>EcuM_SetWakeupEvent(EcuM_WakeupSourceType)</p>
<p>BswM_EcuM_CurrentWakeup(WAKEUP_SOURCE_CAN,</p>
<p>ECUM_WKSTATUS_VALIDATED)</p>
<p>EcuM_EndCheckWakeup(EcuM_WakeupSourceType)</p>
<p>BswM_EcuM_CurrentWakeup(WAKEUP_SOURCE_CAN, ECUM_WKSTATUS_EXPIRED)</p>
<p>CheckWakeupTimerExpired()</p>
<p>BswM_EcuM_CurrentWakeup(WAKEUP_SOURCE_CAN, ECUM_WKSTATUS_EXPIRED)</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>33 / 134 </p>
<p><b>3.11 </b></p>
<p><b>Error Handling </b></p>
<p><b>3.11.1 </b></p>
<p><b>Development Error Reporting </b></p>
<p>Development  errors  are  reported  to  the  DET  using  the  service  Det_ReportError()  as </p>
<p>specified </p>
<p>in </p>
<p>[2], </p>
<p>if </p>
<p>development </p>
<p>error </p>
<p>reporting </p>
<p>is </p>
<p>enabled </p>
<p>(ECUM_DEV_ERROR_DETECT==STD_ON). </p>
<p>The reported EcuM ID is 10. </p>
<p>The  reported  service  IDs  identify  the services  which  are described  in  5.2. The following </p>
<p>table presents the service IDs and the related services: </p>
<p><b>Service ID </b></p>
<p><b>Service </b></p>
<p>0x00 </p>
<p>EcuM_GetVersionInfo() </p>
<p>0x01 </p>
<p>EcuM_Init() </p>
<p>0x02 </p>
<p>EcuM_Shutdown() </p>
<p>0x03 </p>
<p>EcuM_RequestRun() </p>
<p>0x04 </p>
<p>EcuM_ReleaseRun() </p>
<p>0x05 </p>
<p>EcuM_KillAllRUNRequests() </p>
<p>0x06 </p>
<p>EcuM_SelectShutdownTarget() </p>
<p>0x07 </p>
<p>EcuM_GetState() </p>
<p>0x08 </p>
<p>EcuM_GetLastShutdownTarget() </p>
<p> </p>
<p>0x09 </p>
<p>EcuM_GetShutdownTarget() </p>
<p>0x0A </p>
<p>EcuM_RequestPOST_RUN() </p>
<p>0x0B </p>
<p>EcuM_ReleasePOST_RUN() </p>
<p>0x0C </p>
<p>EcuM_SetWakeupEvent() </p>
<p>0x0D </p>
<p>EcuM_GetPendingWakeupEvents() </p>
<p>0x12 </p>
<p>EcuM_SelectBootTarget() </p>
<p>0x13 </p>
<p>EcuM_GetBootTarget() </p>
<p>0x14 </p>
<p>EcuM_ValidateWakeupEvent() </p>
<p>0x15 </p>
<p>EcuM_GetValidatedWakeupEvents() </p>
<p>0x16 </p>
<p>EcuM_ClearWakeupEvent() </p>
<p>0x18 </p>
<p>EcuM_MainFunction() </p>
<p>0x19 </p>
<p>EcuM_GetExpiredWakeupEvents() </p>
<p>0x1A </p>
<p>EcuM_StartupTwo() </p>
<p>0x1B </p>
<p>EcuM_SelectShutdownCause() </p>
<p>0x1C </p>
<p>EcuM_GetShutdownCause() </p>
<p> </p>
<p>0x1D </p>
<p>EcuM_GetMostRecentShutdown()[not supported in this release] </p>
<p>0x1E </p>
<p>EcuM_GetNextRecentShutdown()[not supported in this release] </p>
<p>0x1F </p>
<p>EcuM_GoDown() </p>
<p>0x20 </p>
<p>EcuM_GoHalt() </p>
<p>0x21 </p>
<p>EcuM_GoPoll() </p>
<p>0x22 </p>
<p>EcuM_SetRelWakeupAlarm() </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>34 / 134 </p>
<p><b>Service ID </b></p>
<p><b>Service </b></p>
<p>0x23 </p>
<p>EcuM_SetAbsWakeupAlarm() </p>
<p>0x24 </p>
<p>EcuM_AbortWakeupAlarm() </p>
<p>0x25 </p>
<p>EcuM_GetCurrentTime() </p>
<p>0x26 </p>
<p>EcuM_GetWakeupTime() </p>
<p>0x27 </p>
<p>EcuM_SetClock() </p>
<p>0x28 </p>
<p>EcuM_StartCheckWakeup() </p>
<p>0x29 </p>
<p>EcuM_EndCheckWakeup() </p>
<p>0x30 </p>
<p>EcuM_ClearValidatedWakeupEvent() </p>
<p>0x2A </p>
<p>EcuM_KillAllPostRUNRequests() </p>
<p>0x2B </p>
<p>EcuM_SetState() </p>
<p>0x65 </p>
<p>EcuM_CB_NfyNvMJobEnd() </p>
<p>Table 3-8  </p>
<p>Service IDs </p>
<p>The errors reported to DET are described in the following table: </p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>0x10 </p>
<p>ECUM_E_UNINIT </p>
<p>A service was called prior to initialization. </p>
<p>0x11 </p>
<p>ECUM_E_SERVICE_DISABLE</p>
<p>D </p>
<p>Error code defined by AUTOSAR SWS (not used in this </p>
<p>implementation). </p>
<p>0x12 </p>
<p>ECUM_E_NULL_POINTER </p>
<p>A null pointer was passed as an argument. </p>
<p>0x13 </p>
<p>ECUM_E_INVALID_PAR </p>
<p>A parameter was invalid (not specified) </p>
<p>0x14 </p>
<p>ECUM_E_MULTIPLE_RUN_RE</p>
<p>QUESTS </p>
<p>EcuM_RequestRUN or EcuM_ RequestPOST_RUN was </p>
<p>called two times by the same user without release. </p>
<p>0x15 </p>
<p>ECUM_E_MISMATCHED_RUN</p>
<p>_RELEASE </p>
<p>EcuM_ReleaseRUN or EcuM_ ReleasePOST_RUN was </p>
<p>called by a user without a previous request. </p>
<p>0x16 </p>
<p>ECUM_E_STATE_PAR_OUT_</p>
<p>OF_RANGE </p>
<p>API service EcuM_SelectShutdownTarget() called with </p>
<p>parameter not in expected range  </p>
<p>0x17 </p>
<p>ECUM_E_UNKNOWN_ </p>
<p>WAKEUP_SOURCE </p>
<p>Wake-up source ID is not known by ECU State Manager </p>
<p>0x20 </p>
<p>ECUM_E_MODULE_NOT_IN_</p>
<p>STARTUP </p>
<p>EcuM_StartupTwo() is called and the EcuM is not in state </p>
<p>EcuM_Startup_One which is entered in EcuM_Init(). </p>
<p>0x21 </p>
<p>ECUM_E_MODULE_NOT_IN_</p>
<p>PREPSHUTDOWN </p>
<p>EcuM_Shutdown() was invoked without calling </p>
<p>EcuM_GoDown(). </p>
<p>0x22 </p>
<p>ECUM_E_MODULE_NOT_IN_</p>
<p>RUN_STATE </p>
<p>This error will be reported if the callout EcuM_AL_SwitchOff() </p>
<p>does not switch off the ECU.  </p>
<p>0x23 </p>
<p>ECUM_E_NO_SLEEPMODE_C</p>
<p>ONFIGURED </p>
<p>This error will be reported if EcuM_GoPoll() or </p>
<p>EcuM_GoHalt() is called and no SleepMode is configured. </p>
<p>0x24</p>
<p> </p>
<p>ECUM_E_INVALID_STATERE</p>
<p>QUEST </p>
<p>A state which was requested is invalid, perhaps because a </p>
<p>former request is not finished yet. </p>
<p>Table 3-9  </p>
<p>Errors reported to DET </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>35 / 134 </p>
<p><b>3.11.2 </b></p>
<p><b>Production Code Error Reporting </b></p>
<p>By  default,  production  code  related  errors  are  reported  to  the  DEM  using  the  service </p>
<p>Dem_ReportErrorStatus()</p>
<p> as specified in [3], if production error reporting is enabled </p>
<p>(In </p>
<p>the </p>
<p>case </p>
<p>that </p>
<p>a </p>
<p>reference </p>
<p>to </p>
<p>a </p>
<p>Dem </p>
<p>event </p>
<p>parameter </p>
<p>is </p>
<p>configured </p>
<p>in </p>
<p>EcuMDemEventParameterRefs). </p>
<p>If another  module  is  used  for production code  error  reporting,  the  function  prototype  for </p>
<p>reporting the error can be configured by the integrator, but must have the same signature </p>
<p>as the service </p>
<p>Dem_ReportErrorStatus()</p>
<p>. </p>
<p>The errors reported to DEM are described in the following table: </p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>ECUM_E_RAM_CHECK_FAILED</p>
<p> </p>
<p>The RAM check during wake-up failed.  </p>
<p>ECUM_E_CONFIGURATION_DATA_INCONSISTENT </p>
<p>Post build configuration data is inconsistent. </p>
<p>ECUM_E_IMPROPER_CALLER  </p>
<p>Defensive behavior checks have detected </p>
<p>improper use of the module. </p>
<p>ECUM_E_ALL_RUN_REQUESTS_KILLED </p>
<p>The API EcuM_KillAllRUNRequests() was </p>
<p>called. </p>
<p>Table 3-10  </p>
<p>Errors reported to DEM </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Only ECUM_E_IMPROPER_CALLER and ECUM_E_ALL_RUN_REQUESTS_KILLED </p>
<p>are passed to the Dem directly out of the static code. In the other cases </p>
<p>EcuM_ErrorHook (see 3.11.3) is called and the integrator has to decide what happens </p>
<p>in the case of these errors. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>3.11.3 </b></p>
<p><b>EcuM_ErrorHook </b></p>
<p>The  EcuM  has  an  own  ErrorHook  which  offers  the  integrator  the  possibility  to  react  on </p>
<p>occurring errors during runtime.  </p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>ECUM_E_HOOK_RAM_CHECK_FAILED</p>
<p> </p>
<p>If the Ram check has failed after a sleep </p>
<p>phase, the ErrorHook is called with this </p>
<p>parameter. </p>
<p>ECUM_E_HOOK_CONFIGURATION_DATA_INCONSISTENT </p>
<p>If the consistency check of pre-compile </p>
<p>and link-time parameters in variant post-</p>
<p>build has failed, the ErrorHook is called </p>
<p>with this parameter. </p>
<p>ECUM_E_HOOK_WRONG_ECUM_USAGE </p>
<p>If the call of ShutdownOS returns to the </p>
<p>EcuM.  </p>
<p>ShutdownOS has to call </p>
<p>EcuM_Shutdown() to perform a </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>36 / 134 </p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>shutdown.  </p>
<p>ECUM_E_HOOK_INVALID_COREID </p>
<p>The OS returned an invalid CoreID via </p>
<p>the API GetCoreID(). </p>
<p>Table 3-11  </p>
<p>Description of EcuM internal Error Codes </p>
<p>The  integrator  has  to  implement  the  behavior  of  the  EcuM  in  this  situation.  The  EcuM </p>
<p>reports the error not by default to the Dem. If this is desired, the integrator has to call the </p>
<p>Dem. </p>
<p> </p>
<p><b>3.12 </b></p>
<p><b>Callout Execution Sequences </b></p>
<p>This chapter describes the execution order of callouts and important functions. This may </p>
<p>be useful while integrating the software stack. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The execution sequences are not relevant for EcuM fixed. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.12.1 </b></p>
<p><b>Callouts from Startup to Run </b></p>
<p><b>STARTUP – RUN  </b></p>
<p>Execution in EcuM_Init() </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_AL_SetProgrammableInterrupts()</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_AL_DriverInitZero() </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_AL_DriverInitOne() </p>
<p><b></b></p>
<p><b> </b></p>
<p>Mcu_GetResetReason() </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_SetWakeupEvent(ResetReason) </p>
<p><b></b></p>
<p><b> </b></p>
<p>StartOS(ECUM_DEFAULTAPPMODE) </p>
<p>Execution in EcuM_StartupTwo() </p>
<p><b></b></p>
<p><b> </b></p>
<p>SchM_Init() </p>
<p><b></b></p>
<p><b> </b></p>
<p>BswM_Init(NULL_PTR / CfgPtr_BswM) </p>
<p><b></b></p>
<p><b> </b></p>
<p>If Wake-up Events have occurred before BswM_Init: </p>
<p><b></b></p>
<p><b> </b></p>
<p>BswM_EcuM_CurrentWakeup(WakeupSource, ECUM_WKSTATUS_VALIDATED) </p>
<p>Table 3-12  </p>
<p>Callouts from Startup to Run </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>37 / 134 </p>
<p><b>3.12.2 </b></p>
<p><b>Callouts from Run to Sleep (Halt) and back to Run  </b></p>
<p><b>Run – Sleep (Halt) – Run  </b></p>
<p>Selection of the ShutdownTarget must be done before the transition to sleep e.g. by the BswM </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_SelectShutdownTarget(ECUM_STATE_SLEEP, resetSleepMode)</p>
<p> </p>
<p>All validated wake-up events must be cleared, e.g. by the BswM </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_ClearValidatedWakeupEvent(ECUM_WKSOURCE_ALL_SOURCES) </p>
<p>GoHalt must be called e.g. by the BswM </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_GoHalt() </p>
<p>Execution in EcuM_GoHalt() </p>
<p><b></b></p>
<p><b> </b></p>
<p>BswM_EcuM_CurrentWakeup(wakeupSource, ECUM_WKSTATUS_NONE) </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_EnableWakeupSources(wakeupSource) </p>
<p><b></b></p>
<p><b> </b></p>
<p>GetResource(ECUM_OS_RESOURCE) </p>
<p><b></b></p>
<p><b> </b></p>
<p>DisableAllInterrupts() </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_GenerateRamHash() </p>
<p><b></b></p>
<p><b> </b></p>
<p>Mcu_SetMode(ECUM_SLEEPMODELIST[ECUM_CURRENTSLEEPMODE].mcuMode) </p>
<p><b></b></p>
<p><b> </b></p>
<p>EnableAllInterrupts() </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_CheckRamHash() </p>
<p><b></b></p>
<p><b> </b></p>
<p>If CheckRamHash has failed </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_ErrorHook(ECUM_E_HOOK_RAM_CHECK_FAILED) </p>
<p><b></b></p>
<p><b> </b></p>
<p>DisableAllInterrupts() </p>
<p><b></b></p>
<p><b> </b></p>
<p>Mcu_SetMode(ECUM_NORMALMCUMODEREF) </p>
<p><b></b></p>
<p><b> </b></p>
<p>EnableAllInterrupts() </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_DisableWakeupSources(EcuM_PendingWakeups | </p>
<p>EcuM_ValidatedWakeups)) </p>
<p><b></b></p>
<p><b> </b></p>
<p>BswM_EcuM_CurrentWakeup(EcuM_PendingWakeups | </p>
<p>EcuM_ValidatedWakeups),  ECUM_WKSTATUS_DISABLED) </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_Al_DriverRestart() </p>
<p><b></b></p>
<p><b> </b></p>
<p>ReleaseResource(ECUM_OS_RESOURCE) </p>
<p> </p>
<p>Table 3-13  </p>
<p>Callouts from Run to Sleep (Halt) and back to Run </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>38 / 134 </p>
<p><b>3.12.3 </b></p>
<p><b>Callouts from Run to Reset  </b></p>
<p><b>Run – Reset  </b></p>
<p>Selection of the ShutdownTarget must be done before the transition to Off e.g. by the BswM </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_SelectShutdownTarget(ECUM_STATE_RESET, resetMode)</p>
<p> </p>
<p>GoDown must be called e.g. by the BswM </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_GoDown() </p>
<p>Execution in EcuM_GoDown() </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_OnGoOffOne() </p>
<p><b></b></p>
<p><b> </b></p>
<p>BswM_Deinit() </p>
<p><b></b></p>
<p><b> </b></p>
<p>SchM_Deinit() </p>
<p><b></b></p>
<p><b> </b></p>
<p>ShutdownOS(E_OK) </p>
<p>Shutdown must be called from the ShutdownHook </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_Shutdown() </p>
<p>Execution in EcuM_Shutdown() </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_OnGoOffTwo() </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_AL_Reset( EcuM_CurrentShutdownMode ) </p>
<p>Table 3-14  </p>
<p>Callouts from Run to Reset </p>
<p><b>3.12.4 </b></p>
<p><b>Callouts from Run to Off  </b></p>
<p><b>Run – Reset  </b></p>
<p>Selection of the ShutdownTarget must be done before the transition to Off e.g. by the BswM </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_SelectShutdownTarget(ECUM_STATE_Off, 0)</p>
<p> </p>
<p>All validated wake-up events must be cleared, e.g. by the BswM </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_ClearValidatedWakeupEvent(ECUM_WKSOURCE_ALL_SOURCES) </p>
<p>GoDown must be called e.g. by the BswM </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_GoDown() </p>
<p>Execution in EcuM_GoDown() </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_OnGoOffOne() </p>
<p><b></b></p>
<p><b> </b></p>
<p>BswM_Deinit() </p>
<p><b></b></p>
<p><b> </b></p>
<p>SchM_Deinit() </p>
<p><b>&gt; </b></p>
<p>If a wake-up event has occurred, the Shutdown Target will be changed to </p>
<p>ECUM_STATE_RESET and the reset mode will be ECUM_RESET_WAKEUP </p>
<p><b></b></p>
<p><b> </b></p>
<p>ShutdownOS(E_OK) </p>
<p>Shutdown must be called from the ShutdownHook </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_Shutdown() </p>
<p>Execution in EcuM_Shutdown() </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_OnGoOffTwo() </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_AL_SwitchOff() </p>
<p>Table 3-15  </p>
<p>Callouts from Run to Off </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>39 / 134 </p>
<p><b>3.13 </b></p>
<p><b>EcuM Flex Users and Defensive Behavior </b></p>
<p>The  EcuM  offers  the  facility  to  configure  flex  Users  to  identify  the  caller  of  the  routine </p>
<p>EcuM_GoDown. The calling module has to use its Module ID as specified by AUTOSAR in </p>
<p>[4]. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>To use this feature, the switch EcuMEnableDefBehaviour must be active. </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>40 / 134 </p>
<p><b>3.14 </b></p>
<p><b>Alarm Clock </b></p>
<p>The EcuM flex offers the possibility to configure a clock which provides the absolute time </p>
<p>since the last power-on reset of the ECU. This clock can be used to retrieve the current </p>
<p>system  time  via  the  API  EcuM_GetCurrentTime  and  to  wake  up  the  ECU  from  sleep </p>
<p>phases. </p>
<p> </p>
<p>In sleep phases the ECU will be woken up by the Gpt every second, depending if the Gpt </p>
<p>supports this. If the wake up by the Gpt is the only wakeup event, the EcuM will increment </p>
<p>the system clock and falls back to sleep again. If a wake up alarm has expired, the EcuM </p>
<p>will call EcuM_SetWakeupEvent() to indicate a valid wake up of the ECU. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>To use this feature, the switch EcuMAlarmClockPresent must be active. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.14.1 </b></p>
<p><b>Configuring the Gpt to provide the Time base  </b></p>
<p>To support the Alarm Clock, a Gpt channel must be configured in a way which leads to an </p>
<p>interrupt every second. For a correct behavior of the Alarm Clock, even in sleep phases, </p>
<p>the channel must be configured as followed: </p>
<p> </p>
<p><b>Gpt Channel Parameter </b></p>
<p><b>Value </b></p>
<p>GptChannelMode </p>
<p>GPT_CH_MODE_CONTINUOUS </p>
<p>GptEnableWakeup </p>
<p>True </p>
<p>GptNotification </p>
<p>EcuM_AlarmCheckWakeup </p>
<p>GptWakeupSourceRef </p>
<p>Choose here the same Wakeup Source as configured for </p>
<p>EcuM parameter EcuMAlarmWakeupSource </p>
<p>Table 3-16  </p>
<p>Gpt Channel Configuration </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The implementation of the EcuM alarm clock requires that the Gpt provides a time base </p>
<p>of exactly one second. If this is not supported by Gpt, the EcuM does not perform a </p>
<p>correction of the time base. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>3.14.2 </b></p>
<p><b>Configuring the EcuM for using the Alarm Clock </b></p>
<p>For setting a wake up alarm during the runtime of the ECU, an  EcuMAlarmClock with a </p>
<p>reference to an EcuMFlexUserConfig must be configured. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>41 / 134 </p>
<p>The  Gpt  channel  configured  in  3.14.1 </p>
<p>must  be  referenced  by  the  EcuM  parameter </p>
<p>EcuMGptChannelRef. </p>
<p> </p>
<p><b>3.14.3 </b></p>
<p><b>Setting of the EcuM Clock </b></p>
<p>The API  EcuM_SetClock  is  offered  to  allow  configuring  an  EcuMFlexUser  to  modify  the </p>
<p>system  time  during  runtime.  This  user  must  be  set  as  reference  in  the  configuration </p>
<p>parameter EcuMSetClockAllowedUserRef. </p>
<p>Only if this reference is configured, the usage of the API EcuM_SetClock is allowed for this </p>
<p>user. </p>
<p><b>3.14.4 </b></p>
<p><b>Setting of a Time Triggered Wake Up Alarm </b></p>
<p>Via the APIs EcuM_SetRelWakeupAlarm and EcuM_SetAbsWakeupAlarm the configured </p>
<p>EcuMFlexUsers  can  set  wake  up  alarms  during  the  runtime  of  the  ECU.  This  wake  up </p>
<p>alarm will be active during the next sleep phase. </p>
<p>The wake up alarm can be cancelled by the user during runtime of the ECU via the API </p>
<p>EcuM_AbortWakeupAlarm.  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>One single EcuMFlexUser can only set one single wake up alarm. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>All wake up alarms are cleared if the ECU wakes up from a sleep phase, even if the </p>
<p>reason for this wake up was not time triggered. The wake up alarms must be rearmed </p>
<p>before the next sleep phase is entered. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>42 / 134 </p>
<p><b>3.15 </b></p>
<p><b>MultiCore Ecu </b></p>
<p>The </p>
<p>EcuM </p>
<p>offers </p>
<p>the </p>
<p>possibility </p>
<p>to </p>
<p>handle </p>
<p>multi </p>
<p>core </p>
<p>ECUs. </p>
<p>The </p>
<p>handling </p>
<p>of </p>
<p>the </p>
<p>initialization,  sleep  and  shutdown  differs  to  a  single  core  ECU  and  is  described  in  the </p>
<p>following. </p>
<p><b>3.15.1 </b></p>
<p><b>Initialization of a MultiCore ECU </b></p>
<p><b>3.15.1.1 </b></p>
<p><b>Initialization on the Master Core </b></p>
<p>After  power-on  of  the  ECU,  the  master  core  starts  running  and  EcuM_Init()  should  be </p>
<p>called in the startup code. At the end of EcuM_Init() the callout EcuM_StartOS() is called. </p>
<p>In the callout EcuM_StartOS() all other slave cores are started via the OS API StartCore().  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>In the following example the startup sequence of the master core for a ECU with 4 </p>
<p>cores can be seen: </p>
<p> </p>
<p>Figure 3-5 </p>
<p>Startup Sequence on a Master Core </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The callout EcuM_StartOS() is filled by the configuration tool per default. In some </p>
<p>cases it might be necessary to adapt this callout. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> sd MasterCore Initialization</b></p>
<p>Module</p>
<p>EcuM</p>
<p>Module</p>
<p>Os</p>
<p>Startup Code</p>
<p>Module</p>
<p>Integration Code</p>
<p>(EcuM_Callout_Stubs)</p>
<p>Module</p>
<p>SchM</p>
<p>Module</p>
<p>BswM</p>
<p><b>InitTask</b></p>
<p>EcuM_Init()</p>
<p>PreOS</p>
<p>i ni ti al i zati on</p>
<p>sequence of</p>
<p>EcuM()</p>
<p>EcuM_StartOS(AppModeType)</p>
<p>StartCore(CoreID1, &amp;Status)</p>
<p>StartCore(CoreID2, &amp;Status)</p>
<p>StartCore(CoreID3, &amp;Status)</p>
<p>StartOS(appMode)</p>
<p>ActivateTask()</p>
<p>EcuM_StartupTwo()</p>
<p>SchM_Init()</p>
<p>BswM_Init(const BswM_ConfigType *)</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>43 / 134 </p>
<p><b>3.15.1.2 </b></p>
<p><b>Initialization on the Slave Core </b></p>
<p>After the slave core has been  started by the master core, it also starts  running  with the </p>
<p>startup code. EcuM_Init() is called from the startup code, but on the slave core only driver </p>
<p>initialization and a call to StartOS() is performed via the callout EcuM_StartOS().  </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>In the following example the startup sequence of a slave core for a ECU with 4 cores </p>
<p>can be seen: </p>
<p> </p>
<p>Figure 3-6 </p>
<p>Startup Sequence on a Slave Core </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>On the slave core a call to EcuM_StartupTwo() is only necessary if the initialization of </p>
<p>the SchM should be done by the EcuM. </p>
<p>The BswM is currently not initialized on a slave core in this release! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.15.1.2.1 </b></p>
<p><b>Driver initialization on the Slave Core </b></p>
<p>The  callouts EcuM_AL_DriverInitZero() and  EcuM_AL_DriverInitOne()  are  also  called  on </p>
<p>slave cores, but the generated code is only executed on the master core. </p>
<p> </p>
<p> </p>
<p><b> sd Slav eCore Initialization</b></p>
<p>Module</p>
<p>EcuM</p>
<p>Module</p>
<p>Os</p>
<p>Startup Code</p>
<p>Module</p>
<p>Integration Code</p>
<p>(EcuM_Callout_Stubs)</p>
<p>Module</p>
<p>SchM</p>
<p><b>InitTask</b></p>
<p>EcuM_Init()</p>
<p>EcuM_AL_DriverInitZero()</p>
<p>EcuM_AL_DriverInitOne()</p>
<p>EcuM_StartOS(AppModeType)</p>
<p>StartOS(appMode)</p>
<p>ActivateTask()</p>
<p>EcuM_StartupTwo()</p>
<p>SchM_Init()</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>44 / 134 </p>
<p>On which core the driver initialization is called, is determined via the OS API GetCoreID(), </p>
<p>as it can be seen in the code example below. </p>
<p>A slave core specific handling has to be implemented by the user. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>/********************************************************************* </p>
<p>* EcuM_AL_DriverInitZero </p>
<p>*********************************************************************/ </p>
<p>FUNC(void, ECUM_CODE) EcuM_AL_DriverInitZero(void) </p>
<p>{ </p>
<p>  if(GetCoreID() == ECUM_CORE_ID_MASTER) </p>
<p>  { </p>
<p>    MasterCore_Init(); </p>
<p>  } </p>
<p> </p>
<p>/********************************************************************* </p>
<p> * DO NOT CHANGE THIS COMMENT!   &lt;USERBLOCK EcuM_AL_DriverInitZero&gt;   </p>
<p>DO NOT CHANGE THIS COMMENT! </p>
<p>*********************************************************************/ </p>
<p>  /* Add implementation of EcuM_AL_DriverInitZero() */ </p>
<p> </p>
<p>  return; </p>
<p>/********************************************************************* </p>
<p> * DO NOT CHANGE THIS COMMENT!   &lt;/USERBLOCK&gt;   DO NOT CHANGE THIS </p>
<p>COMMENT! </p>
<p>*********************************************************************/ </p>
<p>}</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>3.15.2 </b></p>
<p><b>Sleep handling of slave cores </b></p>
<p>The  EcuM  flex  supports  two  different  ways  to  set  the  ECU  to  sleep,  with  and  without </p>
<p>synchronization of all cores. Which handling is  used depends on the  boolean parameter </p>
<p>EcuMSlaveCoreHandling </p>
<p><b>EcuMSlaveCoreHandling </b></p>
<p><b>Behavior  </b></p>
<p>False </p>
<p>The Master Core does not care about slave cores during the </p>
<p>sleep  mode.  Depending  on  the  used  hardware,  it  might </p>
<p>happen that the Master Core has switched already to sleep </p>
<p>and the slave cores are still running. </p>
<p>True </p>
<p>The  Master  Core  waits  on  the  way  to  sleep  (initiated  via </p>
<p>EcuM_GoHalt()  /  EcuM_GoPoll()  )  till  all  slave  cores  has </p>
<p>already  switched  to  sleep.  During  wait  for  the  slave  cores, </p>
<p>the  callout  EcuM_WaitForSlaveCores  is  called  cyclically  till </p>
<p>all cores have switched their state to sleep. The callout can </p>
<p>be used to set the slaves to sleep. </p>
<p>Table 3-17  </p>
<p>Sleep handling on Slave Cores </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>45 / 134 </p>
<p><b>3.15.3 </b></p>
<p><b>Blocking of the BSW Scheduler during Sleep </b></p>
<p>If only one BSW scheduler is used on the master core, it is sufficient to configure only one </p>
<p>OsResource which is blocked during the sleep mode. </p>
<p>If  there  is  more  than  one  BSW  scheduler  running  on  several  cores,  it  is  necessary  to </p>
<p>configure an OsResource for every core. The configuration tool assigns automatically the </p>
<p>configured OsResource to the corresponding core.  </p>
<p><b>3.15.4 </b></p>
<p><b>Shutdown of the MultiCore ECU </b></p>
<p>It is necessary to call EcuM_GoDown() on all cores which have a running SchM to assure </p>
<p>a regular de-initialization of the SchM. </p>
<p>Finally after EcuM_GoDown() was called for all these slave cores, the API can be called </p>
<p>on the master core. This leads via the callout EcuM_ShutdownOS to a call of the OS API </p>
<p>ShutdownAllCores(). This API synchronizes all cores and stops the slaves. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>If the SchM is only running on the master core it is sufficient to call EcuM_GoDown() on </p>
<p>the master core only. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.15.5 </b></p>
<p><b>Reconfiguration of the BSW Core ID </b></p>
<p>The EcuM supports the configuration of the BSW Core Id. Per default the master Core Id </p>
<p>is mapped to the OS define OS_CORE_ID_MASTER (Id 0).  </p>
<p> </p>
<p>If the BSW shall run on another Core, the Id has to be configured via the configuration tool.</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>46 / 134 </p>
<p><b>3.16 </b></p>
<p><b>Mode Handling for EcuM Flex </b></p>
<p><b>3.16.1 </b></p>
<p><b>Mode Handling </b></p>
<p>The  BswM  can  set  a  specific  EcuM  state  (via  EcuM_SetState)  which  is  mapped  to  the </p>
<p>corresponding mode and an Rte mode switch will be initiated by the EcuM. The mapping </p>
<p>of states to modes can be seen in Table 3-18. </p>
<p>After the mode switch is initiated, the EcuM polls the Rte in each MainFunction cycle if the </p>
<p>mode  switch  is  executed  successfully.  After  the  Rte  has  acknowledged  the  successful </p>
<p>mode switch execution, the EcuM will notify the BswM about the finished mode switch. </p>
<p><b>EcuM State </b></p>
<p><b>EcuM Mode </b></p>
<p>ECUM_STATE_STARTUP </p>
<p>RTE_MODE_EcuM_Mode_STARTUP </p>
<p>ECUM_STATE_SLEEP </p>
<p>RTE_MODE_EcuM_Mode_SHUTDOWN </p>
<p>or </p>
<p>RTE_MODE_EcuM_Mode_SLEEP </p>
<p>ECUM_STATE_APP_RUN </p>
<p>RTE_MODE_EcuM_Mode_RUN </p>
<p>ECUM_STATE_APP_POST_RUN </p>
<p>RTE_MODE_EcuM_Mode_POST_RUN </p>
<p>ECUM_STATE_SHUTDOWN </p>
<p>RTE_MODE_EcuM_Mode_SHUTDOWN </p>
<p>or </p>
<p>RTE_MODE_EcuM_Mode_SLEEP </p>
<p>Table 3-18  </p>
<p>Mapping of States to Modes </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In case of a requested state ECUM_STATE_SHUTDOWN or ECUM_STATE_SLEEP, </p>
<p>the corresponding mode depends on the currently configured shutdown target.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>47 / 134 </p>
<p><b>3.16.2 </b></p>
<p><b>Run Request Protocol </b></p>
<p>The run request protocol is a mechanism for applications or Software Components (SW-C) </p>
<p>to  request  RUN  state  explicitly  via  EcuM_RequestRUN.  The  EcuM  notifies  the  BswM </p>
<p>about an active application request. If the application has nothing to do anymore it must </p>
<p>release the previous requested RUN state. If no other SW-C has requested RUN state the </p>
<p>ECU State Manger will notify the BswM that no application request is active anymore. </p>
<p>If SW-C needs special preparation for one of the shutdown states (SLEEP, OFF, RESET) </p>
<p>the  SW-C  must  request  POST  RUN  state. This  is  the  same  mechanism  like  requesting </p>
<p>RUN state. So, the POST RUN state has to be released after the job of the application is </p>
<p>finished. It is very important for SW-C’s which needs POST RUN state activities to request </p>
<p>the POST RUN state before releasing the RUN request. Otherwise it is possible that the </p>
<p>application doesn't get the chance to execute its POST RUN activities, depending on the </p>
<p>BswM configuration. </p>
<p>To request RUN or POST RUN state each SW-C must be a configured user of the ECU </p>
<p>State  Manager.  Therefore  it  is  necessary  to  define  one  user  for  each  SW-C  to  place </p>
<p>requests. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>48 / 134 </p>
<p><b>3.17 </b></p>
<p><b>Generated Template Files </b></p>
<p>A generated template file in this document is a file which:  </p>
<p><b>&gt; </b></p>
<p>is generated by the generation tool at every generation process  </p>
<p><b>&gt; </b></p>
<p>the user can modify this template for his needs  </p>
<p><b>&gt; </b></p>
<p>the changes made by the user will not be overwritten at the next generation process  </p>
<p>  </p>
<p>In order not to overwrite the changes made by the user, the template file contains special </p>
<p>comments. The user must insert his code between the two comments which delimit the </p>
<p>user block. The comments have the following format: </p>
<p> </p>
<p>/*************************************************************************************************************************************** </p>
<p> * DO NOT CHANGE THIS COMMENT!  &lt;USERBLOCK FUNCTIONNAME&gt;   DO NOT CHANGE THIS COMMENT! </p>
<p>***************************************************************************************************************************************/ </p>
<p> </p>
<p> </p>
<p>/**************************************************************************************************************************************** </p>
<p> * DO NOT CHANGE THIS COMMENT!  &lt;/USERBLOCK&gt;                   DO NOT CHANGE THIS COMMENT! </p>
<p>****************************************************************************************************************************************/ </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Do not modify or delete these comments. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.18 </b></p>
<p><b>Wake-up Event Handling and Wake-up Validation </b></p>
<p>The handling of Wake-up Sources and Wake-up Validation has to be configured and </p>
<p>implemented specifically for every ECU. The following list provides a short overview which </p>
<p>callouts are affected:  </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_EnableWakeupSources(), (refer to Ch. 5.7.2.17) </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_DisableWakeupSources(), (refer to Ch. 5.7.2.18) </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_CheckWakeup(), (refer to Ch. 5.7.2.21) </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_StartWakeupSources(), (refer to Ch. 5.7.2.19) </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_StopWakeupSources(), (refer to Ch. 5.7.2.20) </p>
<p> </p>
<p>The integration task is to fill these callouts with code which fulfill the ECU specific </p>
<p>requirements. The following paragraphs illustrate two example use cases: </p>
<p><b></b></p>
<p><b> </b></p>
<p>Wake-up after a physical sleep mode  </p>
<p><b></b></p>
<p><b> </b></p>
<p>Wake-up validation of communication channels (EcuM in Run state) </p>
<p> </p>
<p><b>3.18.1 </b></p>
<p><b>Wake-up after a Physical Sleep Mode </b></p>
<p><b>3.18.1.1 </b></p>
<p><b>Use Case Description </b></p>
<p>A raising edge on an ICU channel shall bring the ECUM into RUN state. A wake-up source </p>
<p>“ECUM_WKSOURCE_ICU_CH0” is configured for that. The name of the configured ICU </p>
<p>channel is Icu_Channel0.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>49 / 134 </p>
<p>No wake-up validation shall be performed on that  wake-up event. This wake-up event is </p>
<p>the only active wake-up event for the desired sleep mode.  </p>
<p><b>3.18.1.2 </b></p>
<p><b>Execution Flow </b></p>
<p><b>&gt; </b></p>
<p>EcuM is in ECUM_STATE_RUN  </p>
<p><b>&gt; </b></p>
<p>BswM calls EcuM_GoHalt() </p>
<p><b></b></p>
<p><b> </b></p>
<p>Callout EcuM_EnableWakeupSources() is executed. </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM transits to sleep, Mcu_SetMode() is called </p>
<p><b>&gt; </b></p>
<p>External event triggers ICU hardware to raise an interrupt </p>
<p><b>&gt; </b></p>
<p>Callout EcuM_CheckWakeup() is executed by ISR </p>
<p><b>&gt; </b></p>
<p>API function EcuM_SetWakeupEvent() is executed </p>
<p><b>&gt; </b>EcuM executes </p>
<p>implicitly</p>
<p> EcuM_ValidateWakeupEvent() because wake-up event is </p>
<p>instantly valid </p>
<p><b>&gt; </b></p>
<p>EcuM transits from ECUM_STATE_SLEEP to ECUM_STATE_WAKEUP_ONE </p>
<p><b>&gt; </b></p>
<p>EcuM transits from ECUM_STATE_WAKEUP_TWO to ECUM_STATE_ RUN </p>
<p><b></b></p>
<p><b> </b></p>
<p>Callout EcuM_DisableWakeupSources() is executed </p>
<p><b>3.18.1.3 </b></p>
<p><b>Callout Implementation Examples </b></p>
<p>FUNC(void, ECUM_CODE) EcuM_EnableWakeupSources(EcuM_WakeupSourceType </p>
<p>wakeupSource) </p>
<p>{ </p>
<p>  /* Check for each configured wake-up source the corresponding bit  </p>
<p>   * is set. Here the bit for the ICU wake-up source must be set </p>
<p>  */ </p>
<p>  if ((wakeupSource &amp; ECUM_WKSOURCE_ICU_CH0) != 0) </p>
<p>  { </p>
<p>    Icu_EnableNotification(Icu_Channel0); </p>
<p>    Icu_EnableWakeup(Icu_Channel0); </p>
<p>    Icu_SetMode(ICU_MODE_SLEEP); </p>
<p>  } </p>
<p>  /* … */ </p>
<p>} </p>
<p> </p>
<p>FUNC(void, ECUM_CODE) EcuM_CheckWakeup(EcuM_WakeupSourceType wakeupSource) </p>
<p>{ </p>
<p>  if ((wakeupSource &amp; ECUM_WKSOURCE_ICU_CH0) != 0) </p>
<p>  { </p>
<p>    /* no validation necessary, so call EcuM_SetWakeupEvent() */ </p>
<p> </p>
<p>    EcuM_SetWakeupEvent(ECUM_WKSOURCE_ICU_CH0); </p>
<p>  } </p>
<p>  /* … */ </p>
<p>} </p>
<p> </p>
<p> </p>
<p> </p>
<p>FUNC(void, ECUM_CODE) EcuM_DisableWakeupSources(EcuM_WakeupSourceType </p>
<p>wakeupSource) </p>
<p>{ </p>
<p>  if ((wakeupSource &amp; ECUM_WKSOURCE_ICU_CH0) != 0) </p>
<p>  { </p>
<p>    Icu_DisableNotification(Icu_Channel0); </p>
<p>    Icu_DisableWakeup(Icu_Channel0); </p>
<p>    Icu_SetMode(ICU_MODE_NORMAL); </p>
<p>  }  </p>
<p>} </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>50 / 134 </p>
<p> </p>
<p><b>3.18.2 </b></p>
<p><b>Wake-up Validation of Communication Channels (ECUM in RUN State) </b></p>
<p><b>3.18.2.1 </b></p>
<p><b>Use Case Description </b></p>
<p>A  wake-up  capable  CAN hardware  is  assumed. A  message  on a  CAN  channel  shall  be </p>
<p>recognized and set the CAN channel into normal operation mode (which will be triggered </p>
<p>by ComM). A wake-up source ECUM_WKSOURCE_CAN0 is configured for that. Wake-up </p>
<p>Validation shall be performed for that channel. </p>
<p><b>3.18.2.2 </b></p>
<p><b>Execution Flow </b></p>
<p><b>&gt; </b> ECUM is in RUN state, the CAN channel is in sleep state and is able to detect wake-up </p>
<p>events </p>
<p><b>&gt; </b> Callout EcuM_CheckWakeup() is executed by ISR </p>
<p><b>&gt; </b> API EcuM_SetWakeupEvent() is executed, EcuM starts wake-up validation timeout </p>
<p><b>&gt; </b> EcuM_MainFunction() triggered by SCHM </p>
<p><b></b></p>
<p><b> </b></p>
<p>(a) ECUM detects a pending wake-up event and executes callout </p>
<p>EcuM_StartWakeupSources() </p>
<p><b></b></p>
<p><b> </b></p>
<p>(b) ECUM executes callout EcuM_CheckValidation() </p>
<p><b></b></p>
<p><b> </b></p>
<p>Note: step (b) may be executed several times, with each EcuM_MainFunction() </p>
<p>call until the wake-up event is validated or expired, but </p>
<p>EcuM_StartWakeupSources() is executed only once. </p>
<p><b>&gt; </b> Case Validation successful: </p>
<p><b></b></p>
<p><b> </b></p>
<p>API EcuM_ValidateWakeupEvent() is executed, within this routine </p>
<p>ComM_WakeUpIndication() is called </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_MainFunction() triggered by SCHM </p>
<p><b></b></p>
<p><b> </b></p>
<p>ECUM stops validation timeout </p>
<p><b>&gt; </b> Case Validation failed: </p>
<p><b></b></p>
<p><b> </b></p>
<p>ECUM executes callout EcuM_StopWakeupSources() </p>
<p><b></b></p>
<p><b> </b></p>
<p>The pending wake-up changes to an expired wake-up source </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>51 / 134 </p>
<p><b>3.18.2.3 </b></p>
<p><b>Callout Implementation Examples </b></p>
<p><b>3.18.2.3.1 </b></p>
<p><b>EcuM_CheckWakeup </b></p>
<p>FUNC(void, ECUM_CODE) EcuM_CheckWakeup(EcuM_WakeupSourceType wakeupSource)  </p>
<p>{ </p>
<p>if((wakeupSource &amp; ECUM_WKSOURCE_CAN0) != 0) </p>
<p>{ </p>
<p>CanIf_CheckWakeup(ECUM_WKSOURCE_CAN0); </p>
<p>} </p>
<p>} </p>
<p> </p>
<p><b>3.18.2.3.2 </b></p>
<p><b>EcuM_CheckValidation </b></p>
<p>FUNC(void, ECUM_CODE) EcuM_CheckValidation(EcuM_WakeupSourceType wakeupSource) </p>
<p>{ </p>
<p>if ((wakeupSource &amp; ECUM_WKSOURCE_CAN0) != 0) </p>
<p>{ </p>
<p>/* Query the driver if the wake-up event was valid */ </p>
<p>CanIf_CheckValidation(ECUM_WKSOURCE_CAN0); </p>
<p>} </p>
<p>} </p>
<p> </p>
<p><b>3.18.2.3.3 </b></p>
<p><b>EcuM_StartWakeupSources and EcuM_StopWakeupSources in the case </b></p>
<p><b>of a MICROSAR CanSM </b></p>
<p>If the used CanSM module is a MICROSAR module, the following implementation can be </p>
<p>used. </p>
<p> </p>
<p>FUNC(void, ECUM_CODE) EcuM_StartWakeupSources(EcuM_WakeupSourceType </p>
<p>wakeupSource) </p>
<p>{ </p>
<p>  if ((wakeupSource &amp; ECUM_WKSOURCE_CAN0) != 0) </p>
<p>  { /* CanSM needs the corresponding Network Handle */ </p>
<p>    if (CanSM_StartWakeupSources(0x00) == E_NOT_OK) </p>
<p>    { </p>
<p>      /* place ECU depended error handling here */ </p>
<p>    } </p>
<p>  } </p>
<p>} </p>
<p> </p>
<p>void EcuM_StopWakeupSources(EcuM_WakeupSourceType wakeupSource) </p>
<p>{ </p>
<p>  if ((wakeupSource &amp; ECUM_WKSOURCE_CAN0) != 0) </p>
<p>  { /* CanSM needs the corresponding Network Handle */ </p>
<p>    if (CanSM_StopWakeupSources(0x00, wakeupSource) == E_NOT_OK) </p>
<p>    { </p>
<p>      /* place ECU depended error handling here */ </p>
<p>    }   </p>
<p>  } </p>
<p>} </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>52 / 134 </p>
<p><b>3.18.2.3.4 </b></p>
<p><b>EcuM_StartWakeupSources and EcuM_StopWakeupSources in the case </b></p>
<p><b>of a non MICROSAR CanSM </b></p>
<p>If the used CanSM module is a non MICROSAR module, the following implementation can </p>
<p>be used. </p>
<p> </p>
<p>FUNC(void, ECUM_CODE) EcuM_StartWakeupSources(EcuM_WakeupSourceType </p>
<p>wakeupSource)  </p>
<p>{ </p>
<p>  CanIf_ControllerModeType CanIfCtrlMode; </p>
<p>if ((wakeupSource &amp; ECUM_WKSOURCE_CAN0) != 0) </p>
<p>{ </p>
<p>/* determine in which is the current Can Controller state */ </p>
<p>(void)CanIf_GetControllerMode(0, &amp;CanIfCtrlMode); </p>
<p>/* in case the Can Controller is not CANIF_CS_STARTED */ </p>
<p> </p>
<p>if (CANIF_CS_STARTED != CanIfCtrlMode) </p>
<p>{ </p>
<p>/* Set the controller and transceiver mode into normal operation mode*/ </p>
<p>CanIf_SetTrcvMode(0, CANIF_TRCV_MODE_NORMAL);  </p>
<p>CanIf_SetControllerMode(0, CANIF_CS_STOPPED); </p>
<p>CanIf_SetControllerMode(0, CANIF_CS_STARTED);  </p>
<p>} </p>
<p>else </p>
<p>{ </p>
<p>/* Stack already up and running */ </p>
<p>} </p>
<p> } </p>
<p>} </p>
<p> </p>
<p> </p>
<p>FUNC(void, ECUM_CODE) EcuM_StopWakeupSources(EcuM_WakeupSourceType wakeupSource) </p>
<p>{ </p>
<p>if ((wakeupSource &amp; ECUM_WKSOURCE_CAN0) != 0) </p>
<p>{ </p>
<p>/* Validation was not successful, set the CAN controller and </p>
<p>* Transceiver back to sleep mode. */ </p>
<p>CanIf_SetControllerMode(0, CANIF_CS_STOPPED); </p>
<p>CanIf_SetControllerMode(0, CANIF_CS_SLEEP); </p>
<p>CanIf_SetTrcvMode(0, CANIF_TRCV_MODE_STANDBY); </p>
<p>} </p>
<p>} </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>53 / 134 </p>
<p><b>4 </b></p>
<p><b>Integration </b></p>
<p>This chapter gives necessary information for the integration of the MICROSAR EcuM into </p>
<p>an application environment of an ECU. </p>
<p><b>4.1 </b></p>
<p><b>Scope of Delivery </b></p>
<p>The delivery of the EcuM contains the files which are described in the chapters 4.1.1 and </p>
<p>4.1.2: </p>
<p><b>4.1.1 </b></p>
<p><b>Static Files </b></p>
<p><b>File Name </b></p>
<p><b>Source </b></p>
<p><b>Code </b></p>
<p><b>Delivery </b></p>
<p><b>Object </b></p>
<p><b>Code </b></p>
<p><b>Delivery </b></p>
<p><b>Description </b></p>
<p>EcuM.c </p>
<p></p>
<p> </p>
<p> </p>
<p>This is the source file of the EcuM. It contains the </p>
<p>implementation of the EcuM interfaces.</p>
<p> </p>
<p>EcuM.h </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>This is the header file of the EcuM. It declares the </p>
<p>interfaces of the MIRCROSAR module EcuM. </p>
<p>EcuM_Cbk.h </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Contains the prototypes of the provided callbacks and </p>
<p>callout functions. </p>
<p>Table 4-1  </p>
<p>Static files </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Do not edit manually </b></p>
<p>The static files listed above must not be edited by the user! </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.1.2 </b></p>
<p><b>Dynamic Files </b></p>
<p>The dynamic files are generated by the configuration tool. </p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>EcuM_Cfg.h </p>
<p>Contains the configuration of the EcuM. </p>
<p>EcuM_Cfg.c </p>
<p>Contains the generated configuration data of the EcuM </p>
<p>EcuM_PrivateCfg.h </p>
<p>Contains configuration data which is only relevant for the EcuM </p>
<p>implementation. This file must be only included by the EcuM </p>
<p>implementation files. </p>
<p>EcuM_Generated_Types.h </p>
<p>Contains all provided types of the EcuM. </p>
<p>EcuM_PBcfg.c </p>
<p>Contains the post-build configuration of the EcuM. </p>
<p>EcuM_Callout_Stubs.c </p>
<p>Template for the callout code which has to be filled by the integrator. </p>
<p>EcuM_Init_PBcfg.c </p>
<p>This file contains configuration pointers to post-build modules. </p>
<p>EcuM_Init_PBcfg.h </p>
<p>This file contains the definition of the global post-build struct. </p>
<p>EcuM_Init_Cfg.c </p>
<p>This file contains configuration pointers to variant modules. </p>
<p>EcuM_Init_Cfg.h </p>
<p>This file contains the definition of the variant modules struct. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>54 / 134 </p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>EcuM_Error.h </p>
<p>This file provides an BSW Error function for post-build-loadable </p>
<p>Table 4-2  </p>
<p>Generated files </p>
<p> </p>
<p><b>4.2 </b></p>
<p><b>Critical Sections </b></p>
<p><b> </b></p>
<p>The EcuM calls the following function when entering a critical section: </p>
<p><b>&gt; </b>void  SchM_Enter_EcuM_ECUM_EXCLUSIVE_AREA_0(void) </p>
<p><b>&gt; </b></p>
<p>When the critical section is left the following function is called by the EcuM: </p>
<p><b>&gt; </b>void SchM_Exit_EcuM_ECUM_EXCLUSIVE_AREA_0(void) </p>
<p><b>Critical Section Define </b></p>
<p><b>Interrupt Lock </b></p>
<p>ECUM_EXCLUSIVE_AREA_0 </p>
<p>No interrupt by any wake-up interrupt is </p>
<p>allowed. These interrupts must be locked in </p>
<p>this exclusive area. </p>
<p>ECUM_EXCLUSIVE_AREA_1 </p>
<p>If it cannot be assured that a 32bit variable </p>
<p>is written atomically, this exclusive area </p>
<p>must be configured as a spin lock to </p>
<p>protect access on global state variables. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The configuration of this exclusive </p>
<p>area is only necessary in the case </p>
<p>of a multi core ECU </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>ECUM_EXCLUSIVE_AREA_2 </p>
<p>No task switch and no interrupt from the </p>
<p>Gpt is allowed in this exclusive area to </p>
<p>protect the global system time. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The configuration of this exclusive </p>
<p>area is only necessary if the </p>
<p>feature Alarm Clock is enabled </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Table 4-3  </p>
<p>Critical Sections </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>55 / 134 </p>
<p><b>4.3 </b></p>
<p><b>Include Structure </b></p>
<p> </p>
<p> </p>
<p>Figure 4-1 </p>
<p>Include structure </p>
<p><b> class include Structure</b></p>
<p>EcuM.c</p>
<p>EcuM.h</p>
<p>EcuM_Cbk.h</p>
<p>EcuM_Cfg.h</p>
<p>SchM_EcuM.h</p>
<p>EcuM_Callout_Stubs.c</p>
<p>EcuM_Generated_Types.h</p>
<p>EcuM_PBcfg.c</p>
<p>EcuM_PrivateCfg.h</p>
<p>Rte_EcuM_Type.h</p>
<p>Std_Types.h</p>
<p>BswM.h</p>
<p>Det.h</p>
<p>Dem.h</p>
<p>Mcu.h</p>
<p>Os.h</p>
<p>ComM_EcuMBswM.h</p>
<p>BswM_EcuM.h</p>
<p>Rte_Main.h</p>
<p>ComM.h</p>
<p>EcuM_Error.h</p>
<p>EcuM_Cfg.c</p>
<p>EcuM_Init_PBcfg.h</p>
<p>EcuM_Init_PBcfg.c</p>
<p>NvM.h</p>
<p>EcuM_Init_Cfg.c</p>
<p>EcuM_Init_Cfg.h</p>
<p>«include</p>
<p>in case of</p>
<p>EcuM</p>
<p>fixed»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>56 / 134 </p>
<p><b>4.4 </b></p>
<p><b>Dependencies on other BSW Modules </b></p>
<p><b>4.4.1 </b></p>
<p><b>BswM </b></p>
<p>The  EcuM  module  depends  on  the  BswM.  The  EcuM  performs  the  initialization  of  the </p>
<p>BswM during EcuM_StartupTwo(). </p>
<p>The  states  of  all  wake-up  sources  are  reported  to  the  BswM  in  the  case  of  a  changing </p>
<p>wake-up source. </p>
<p>The usage of the BswM cannot be switched off.  </p>
<p><b>4.4.1.1 </b></p>
<p><b>BswM and EcuM fixed </b></p>
<p>The EcuM reports all state changes described in 3.6.2.1 to the BswM.  </p>
<p><b>4.4.2 </b></p>
<p><b>AUTOSAR OS </b></p>
<p>The EcuM module depends on the AUTOSAR OS. It starts and performs the shutdown of </p>
<p>the OS.  </p>
<p>The EcuM needs a valid reference within the EcuC file to a configured OS application </p>
<p>mode. Additionally an OsResource must be configured to block other tasks during a sleep </p>
<p>mode. </p>
<p>The usage of the OS cannot be switched off.  </p>
<p><b>4.4.3 </b></p>
<p><b>MCU </b></p>
<p>The EcuM module depends on a MCU. The MCU mode settings are used to enter power </p>
<p>saving  modes  in  the  phases  ECUM_STATE_SLEEP  and  ECUM_STATE_OFF,  it  is  also </p>
<p>used to restore the normal MCU mode. Every sleep mode must have configured a MCU </p>
<p>mode which will be entered in that sleep mode. </p>
<p>After a reset, the MCU is called to get the reason for the current reset.  </p>
<p>The usage of the MCU cannot be switched off. </p>
<p><b>4.4.4 </b></p>
<p><b>DEM </b></p>
<p>The EcuM depends on the DEM. The EcuM supports the pre-initialization of the DEM and </p>
<p>if the production errors for the EcuM are configured as active, the EcuM reports some </p>
<p>Errors to the DEM. Refer to chapter 3.11.2 for more information. </p>
<p>The usage of the DEM can be switched off. </p>
<p><b>4.4.5 </b></p>
<p><b>DET </b></p>
<p>The EcuM depends on the DET. The EcuM performs the initialization and reports </p>
<p>development errors for diagnostic purposes. Refer to chapter 3.11.1 for more information. </p>
<p>The usage of the DET can be switched off. </p>
<p><b>4.4.6 </b></p>
<p><b>ComM </b></p>
<p>This module depends on the ComM. The EcuM manages the validation of communication </p>
<p>channels.  In  the case  of a validated  wake-up  event from  a  communication channel,  the </p>
<p>EcuM reports this event to the ComM.  </p>
<p><b>4.4.6.1 </b></p>
<p><b>ComM and EcuM fixed </b></p>
<p>In </p>
<p>the </p>
<p>transition </p>
<p>to </p>
<p>ECUM_STATE_APP_RUN, </p>
<p>the </p>
<p>EcuM </p>
<p>calls </p>
<p>ComM_CommunicationAllowed() for all configured communication channels. </p>
<p>In </p>
<p>ECUM_STATE_APP_RUN, </p>
<p>the </p>
<p>ComM </p>
<p>API </p>
<p>ComM_GetState() </p>
<p>is </p>
<p>called </p>
<p>for </p>
<p>every </p>
<p>communication channel in EcuM_MainFunction. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>57 / 134 </p>
<p>If </p>
<p>ComM_GetState() </p>
<p>returns </p>
<p>COMM_NO_COM_NO_PENDING_REQUEST </p>
<p>for </p>
<p>all </p>
<p>channels, the EcuM can leave the ECUM_STATE_APP_RUN. </p>
<p><b>4.4.7 </b></p>
<p><b>SchM </b></p>
<p>The  EcuM  module  depends  on  the  SchM.  The  EcuM  performs  the  initialization  of  the </p>
<p>SchM during EcuM_StartupTwo(). </p>
<p>The usage of the SchM cannot be switched off. </p>
<p><b>4.4.8 </b></p>
<p><b>Gpt </b></p>
<p>In  the  case that  the Alarm  Clock  is  enabled,  the EcuM  depends on  the  Gpt.  The EcuM </p>
<p>initialize the Gpt (has to be done in EcuM_AL_DriverInitOne) and starts the corresponding </p>
<p>timer during EcuM_StartupTwo(). On the way to sleep, the mode of the Gpt is switched to </p>
<p>sleep and the normal mode is recovered after a wake-up from sleep. </p>
<p><b>4.4.9 </b></p>
<p><b>NvM </b></p>
<p>The  EcuM  handles  the  call  of  NvM_WriteAll()  and  NvM_CancelWriteAll().  Both  calls  are </p>
<p>protected with a configurable timeout to guarantee a shutdown of the ECU even in case of </p>
<p>a defect NvM. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Dependency to the NvM exists only in case of EcuM fixed. </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>58 / 134 </p>
<p><b>5 </b></p>
<p><b>API Description </b></p>
<p><b>5.1 </b></p>
<p><b>Type Definitions </b></p>
<p>The types defined by the EcuM are described in this chapter. </p>
<p><b>Type Name </b></p>
<p><b>C-Type </b></p>
<p><b>Description </b></p>
<p><b>Value Range </b></p>
<p>EcuM_StateType </p>
<p>uint8 </p>
<p>Encodes all states and </p>
<p>sub states provided by </p>
<p>the ECU State </p>
<p>Manager. </p>
<p>ECUM_SUBSTATE_MASK </p>
<p>Get the current state by AND </p>
<p>gating the state with this mask. All </p>
<p>states are delivered including </p>
<p>substates. </p>
<p>ECUM_STATE_STARTUP </p>
<p>STARTUP super state </p>
<p>ECUM_STATE_STARTUP_ONE </p>
<p>Initialization of drivers which don’t </p>
<p>need OS support. </p>
<p>ECUM_STATE_STARTUP_TWO </p>
<p>Initialization of drivers which need </p>
<p>OS support. </p>
<p>ECUM_STATE_WAKEUP </p>
<p>WAKE-UP super state </p>
<p>Not used in this EcuM flex </p>
<p>Implementation! </p>
<p>ECUM_STATE_WAKEUP_ONE </p>
<p>Reinitializing of drivers for normal </p>
<p>operation. </p>
<p>ECUM_STATE_WAKEUP_VALIDATIO</p>
<p>N </p>
<p>Waits for validation of a wake-up </p>
<p>event </p>
<p>ECUM_STATE_WAKEUP_REACTION </p>
<p>Computes the appropriate wake-up </p>
<p>reaction </p>
<p>Not used in this EcuM flex </p>
<p>Implementation! </p>
<p>ECUM_STATE_WAKEUP_TWO </p>
<p>Prepares the ECU for RUN state </p>
<p>Not used in this EcuM flex </p>
<p>Implementation! </p>
<p>ECUM_STATE_WAKEUP_WAKESLE</p>
<p>EP </p>
<p>A short system phase where the </p>
<p>ECU transit from a wake-up directly </p>
<p>to sleep again. </p>
<p>Not used in this EcuM flex </p>
<p>Implementation!</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>59 / 134 </p>
<p><b>Type Name </b></p>
<p><b>C-Type </b></p>
<p><b>Description </b></p>
<p><b>Value Range </b></p>
<p>ECUM_STATE_WAKEUP_TTII </p>
<p>Performs the TTII protocol </p>
<p>Not used in this EcuM flex </p>
<p>Implementation! </p>
<p>ECUM_STATE_RUN </p>
<p>Normal ECU operation super state </p>
<p>ECUM_STATE_APP_RUN </p>
<p>ECU is in normal operation state </p>
<p>Not used in this EcuM flex </p>
<p>Implementation!</p>
<p> </p>
<p>ECUM_STATE_APP_POST_RUN </p>
<p>ECU performs POST RUN </p>
<p>activities </p>
<p>Not used in this EcuM flex </p>
<p>Implementation!</p>
<p> </p>
<p>ECUM_STATE_SHUTDOWN </p>
<p>Shutdown super state</p>
<p> </p>
<p>ECUM_STATE_PREP_SHUTDOWN </p>
<p>Prepares the ECU for the following </p>
<p>shutdown sequence. </p>
<p>Not used in this EcuM flex </p>
<p>Implementation!</p>
<p> </p>
<p>ECUM_STATE_GO_SLEEP </p>
<p>Activation of the wake-up sources </p>
<p>ECUM_STATE_GO_OFF_ONE </p>
<p>Shutdown of system services </p>
<p>ECUM_STATE_GO_OFF_TWO </p>
<p>Performs a RESET or switches off </p>
<p>the ECU </p>
<p>ECUM_STATE_SLEEP </p>
<p>ECU is in sleep state (this </p>
<p>information cannot be retrieved) </p>
<p>ECUM_STATE_OFF </p>
<p>ECU is without power supply (this </p>
<p>information cannot be retrieved) </p>
<p>EcuM_WakeupSource</p>
<p>Type </p>
<p>uint32 </p>
<p>Each bit in this type </p>
<p>identifies a wake-up </p>
<p>source. </p>
<p>ECUM_WKSOURCE_POWER  </p>
<p>Identifies a power on reset (bit 0) </p>
<p>ECUM_WKSOURCE_RESET </p>
<p>Identifies a hardware reset (bit 1) </p>
<p>ECUM_WKSOURCE_INTERNAL_RE</p>
<p>SET  </p>
<p>Identifies resets which only reset </p>
<p>the core of the microcontroller but </p>
<p>not the peripherals. This source </p>
<p>also indicates unhandled </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>60 / 134 </p>
<p><b>Type Name </b></p>
<p><b>C-Type </b></p>
<p><b>Description </b></p>
<p><b>Value Range </b></p>
<p>exceptions (bit 2) </p>
<p>ECUM_WKSOURCE_INTERNAL_WD</p>
<p>G  </p>
<p>Identifies a reset by internal </p>
<p>watchdog (bit 3) </p>
<p>ECUM_WKSOURCE_EXTERNAL_W</p>
<p>DG  </p>
<p>Identifies a reset by external </p>
<p>watchdog (bit 4). (This is only </p>
<p>possible if the hardware supports </p>
<p>this feature) </p>
<p>ECUM_WKSOURCE_ALL_SOURCES  </p>
<p>Identifies each wake-up source </p>
<p>ECUM_WKSOURCE_NONE  </p>
<p>Value 0. This is a MICROSAR </p>
<p>ECUM extension and identifies an </p>
<p>invalid wake-up source. </p>
<p>ECUM_WKSOURCE_&lt;NAME&gt;  </p>
<p>Can be extended by configuration </p>
<p>EcuM_UserType </p>
<p>uint8 </p>
<p>ID of the Users which </p>
<p>are able to request </p>
<p>RUN state. Each user </p>
<p>must have a unique ID. </p>
<p>0..255 </p>
<p>The Range depends on the </p>
<p>number of configured users </p>
<p>EcuM_WakeupStateTy</p>
<p>pe </p>
<p>uint8 </p>
<p>The type describes </p>
<p>possible results of the </p>
<p>WAKE-UP </p>
<p>VALIDATION state. </p>
<p>ECUM_WKSTATUS_NONE  </p>
<p>The wake-up source is Disabled </p>
<p>ECUM_WKSTATUS_PENDING  </p>
<p>The wake-up event was detected </p>
<p>but not yet validated </p>
<p>ECUM_WKSTATUS_VALIDATED  </p>
<p>The wake-up event is valid </p>
<p>ECUM_WKSTATUS_EXPIRED  </p>
<p>The wake-up event has not been </p>
<p>validated and has already expired. </p>
<p>ECUM_WKSTATUS_ENABLED  </p>
<p>The wake-up source is enabled </p>
<p>(armed) and is ready for detecting </p>
<p>wake-up events. </p>
<p>ECUM_WKSTATUS_CHECKWAKEUP </p>
<p>Asynchronous wake-up event is </p>
<p>detected but SetWakeupEvent has </p>
<p>not been called yet.</p>
<p> </p>
<p>EcuM_BootTargetType </p>
<p>uint8 </p>
<p>Defines the boot target </p>
<p>which should be </p>
<p>chosen in the next start </p>
<p>up. </p>
<p>ECUM_BOOT_TARGET_APP  </p>
<p>Boot into application mode </p>
<p>ECUM_BOOT_TARGET_BOOTLOAD</p>
<p>ER  </p>
<p>Boot into boot loader mode </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>61 / 134 </p>
<p><b>Type Name </b></p>
<p><b>C-Type </b></p>
<p><b>Description </b></p>
<p><b>Value Range </b></p>
<p>EcuM_ResetType </p>
<p>uint8 </p>
<p>This type describes </p>
<p>the reset </p>
<p>mechanisms </p>
<p>supported by the </p>
<p>ECU State Manager.  </p>
<p> </p>
<p>It can be extended by </p>
<p>configuration. </p>
<p>ECUM_RESET_MCU </p>
<p>Microcontroller reset via </p>
<p>Mcu_PerformReset </p>
<p>ECUM_RESET_WDG </p>
<p>Watchdog reset via </p>
<p>WdgM_PerformReset </p>
<p>ECUM_RESET_IO </p>
<p>Reset by toggling an I/O line </p>
<p>ECUM_RESET_WAKEUP </p>
<p>Reset in the case of a wake-up </p>
<p>event during shutdown </p>
<p>ECUM_RESET_&lt;NAME&gt; </p>
<p>Can be extended by configuration. </p>
<p>EcuM_ShutdownCau</p>
<p>seType </p>
<p>uint8 </p>
<p>This type describes </p>
<p>the cause for a </p>
<p>shutdown </p>
<p>by the ECU State </p>
<p>Manager.  </p>
<p> </p>
<p>It can be extended by </p>
<p>configuration. </p>
<p>ECUM_CAUSE_UNKNOWN </p>
<p>No cause was set. </p>
<p>ECUM_CAUSE_ECU_STATE </p>
<p>ECU state machine entered a </p>
<p>state for shutdown </p>
<p>ECUM_CAUSE_WDGM </p>
<p>Watchdog Manager detected a </p>
<p>failure </p>
<p>ECUM_CAUSE_DCM </p>
<p>Diagnostic Communication </p>
<p>Manager requests a  </p>
<p>shutdown due to a service request </p>
<p>ECUM_CAUSE_&lt;NAME&gt; </p>
<p>Can be extended by configuration. </p>
<p>Table 5-1  </p>
<p>Type definitions </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>62 / 134 </p>
<p><b>5.2 </b></p>
<p><b>Services Provided by EcuM </b></p>
<p><b>5.2.1 </b></p>
<p><b>EcuM_MainFunction </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_MainFunction </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The service which implements all activities of the ECU state Manager while OS is up and running. In the </p>
<p>MainFunction the wake-up validation is handled. This service must be called on a periodic basis from an </p>
<p>adequate OS task. </p>
<p><b></b></p>
<p><b> </b></p>
<p>The service also carries out the wake-up validation protocol. The smallest validation timeout </p>
<p>typically should limit the period. </p>
<p><b></b></p>
<p><b> </b></p>
<p>As a rule of thumb, the period of this service should be in the order of half as long as the shortest </p>
<p>time constant mentioned in the topics above </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>Called by SchM </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from task level </p>
<p>Table 5-2  </p>
<p>EcuM_MainFunction </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>63 / 134 </p>
<p><b>5.2.2 </b></p>
<p><b>EcuM_Init </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_Init </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The Init function is called to initiate the startup procedure that takes place before the OS is started. </p>
<p>Additionally in this API all EcuM variables that need initialization are initialized. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>After EcuM_Init() the EcuM is not in the running state, to achieve this state </p>
<p>EcuM_StartupTwo() has to be called. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>called by start-up code </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-3  </p>
<p>EcuM_Init </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>64 / 134 </p>
<p><b>5.2.3 </b></p>
<p><b>EcuM_StartupTwo </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_StartupTwo </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The function implements the startup phase where the OS is already running. EcuM_AL_DriverInitTwo() is </p>
<p>called within this function. This function should be scheduled by a task directly after StartOS() and only be </p>
<p>called once. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The integrator has to ensure that the EcuM_StartupTwo is not interrupted by any other </p>
<p>function or task. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant.</p>
<p> </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-4  </p>
<p>EcuM_StartupTwo </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>65 / 134 </p>
<p><b>5.2.4 </b></p>
<p><b>EcuM_Shutdown </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_Shutdown </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This function performs a reset or switches off the ECU (depending on which shutdown target is currently </p>
<p>chosen).  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>This function shall be called inside the OS ShutdownHook() routine. The integrator is </p>
<p>responsible to perform this task. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant.</p>
<p> </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function should be called from the ShutdownHook of the Os. </p>
<p>Table 5-5  </p>
<p>EcuM_Shutdown </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>66 / 134 </p>
<p><b>5.2.5 </b></p>
<p><b>EcuM_SelectShutdownTarget </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_SelectShutdownTarget  </b></p>
<p>(EcuM_StateType targetState,  </p>
<p> </p>
<p> </p>
<p> </p>
<p>uint8 resetSleepMode) </p>
<p><b>Parameter </b></p>
<p>targetState </p>
<p>One of these values: </p>
<p><b></b></p>
<p><b> </b></p>
<p>ECUM_STATE_OFF </p>
<p><b></b></p>
<p><b> </b></p>
<p>ECUM_STATE_SLEEP </p>
<p><b></b></p>
<p><b> </b></p>
<p>ECUM_STATE_RESET </p>
<p>resetSleepMode </p>
<p>Depending on the parameter targetState this represents a sleep mode or a </p>
<p>reset mode. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>success </p>
<p>E_NOT_OK </p>
<p>error </p>
<p><b>Functional Description </b></p>
<p>This service selects a shutdown target in which the shutdown sequence should change </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is reentrant. The EcuM must be in RUN state. </p>
<p><b></b></p>
<p><b> </b></p>
<p>The ECU State Manager does not define any mechanism to resolve issues arising from parallel </p>
<p>requests. It is rather assumed that there will be one application which is ECU specific and handles </p>
<p>these kinds of issues. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-6  </p>
<p>EcuM_SelectShutdownTarget </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>67 / 134 </p>
<p><b>5.2.6 </b></p>
<p><b>EcuM_GetShutdownTarget </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_GetShutdownTarget  </b>(EcuM_StateType *target,  </p>
<p> </p>
<p>uint8 *resetSleepMode) </p>
<p><b>Parameter </b></p>
<p>target </p>
<p>One of these values: </p>
<p><b></b></p>
<p><b> </b></p>
<p>ECUM_STATE_OFF </p>
<p><b></b></p>
<p><b> </b></p>
<p>ECUM_STATE_SLEEP </p>
<p><b></b></p>
<p><b> </b></p>
<p>ECUM_STATE_RESET </p>
<p>resetSleepMode </p>
<p>Depending on the parameter target this represents a sleep mode or a reset </p>
<p>mode. If the target is ECUM_STATE_OFF this parameter is 0. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>success </p>
<p>E_NOT_OK </p>
<p>error </p>
<p><b>Functional Description </b></p>
<p>Returns the actual chosen shutdown target. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-7  </p>
<p>EcuM_GetShutdownTarget </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>68 / 134 </p>
<p><b>5.2.7 </b></p>
<p><b>EcuM_GetLastShutdownTarget </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_GetLastShutdownTarget </b></p>
<p>(EcuM_StateType *target,  </p>
<p>    </p>
<p> </p>
<p>uint8 *resetSleepMode) </p>
<p><b>Parameter </b></p>
<p>target </p>
<p>One of these values: </p>
<p><b></b></p>
<p><b> </b></p>
<p>ECUM_STATE_OFF </p>
<p><b></b></p>
<p><b> </b></p>
<p>ECUM_STATE_SLEEP </p>
<p><b></b></p>
<p><b> </b></p>
<p>ECUM_STATE_RESET </p>
<p>resetSleepMode </p>
<p>Depending on the parameter target this represents a sleep mode or a reset </p>
<p>mode. If the target is ECUM_STATE_OFF this parameter is 0. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>success </p>
<p>E_NOT_OK </p>
<p>error </p>
<p><b>Functional Description </b></p>
<p>This function returns not the current shutdown target but the shutdown target set before the last reset. This </p>
<p>function always shall return the same value until the next shutdown. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-8  </p>
<p>EcuM_GetLastShutdownTarget </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>69 / 134 </p>
<p><b>5.2.8 </b></p>
<p><b>EcuM_GetPendingWakeupEvents </b></p>
<p><b>Prototype </b></p>
<p>EcuM_WakeupSourceType <b>EcuM_GetPendingWakeupEvents </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>EcuM_WakeupSourceTyp</p>
<p>e </p>
<p>Every bit set in the return value indicates a wake-up source where the </p>
<p>validation is in progress. </p>
<p><b>Functional Description </b></p>
<p>Returns wake-up events which have been set but not yet validated. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-9  </p>
<p>EcuM_GetPendingWakeupEvents </p>
<p><b>5.2.9 </b></p>
<p><b>EcuM_ClearWakeupEvent </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_ClearWakeupEvent </b>(EcuM_WakeupSourceType WakeupSource) </p>
<p><b>Parameter </b></p>
<p>WakeupSource </p>
<p>Wake-up event(s) which should be cleared </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Clears the pending, validated and expired wake-up events which are passed by the parameter. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-10  </p>
<p>EcuM_ClearWakeupEvent </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>70 / 134 </p>
<p><b>5.2.10 </b></p>
<p><b>EcuM_ClearValidatedWakeupEvent </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_ClearValidatedWakeupEvent </b>(EcuM_WakeupSourceType WakeupSource) </p>
<p><b>Parameter </b></p>
<p>WakeupSource </p>
<p>Wake-up event(s) which should be cleared </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Clears only the validated wake-up events which are passed by the parameter. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-11  </p>
<p>EcuM_ClearValidatedWakeupEvent </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>71 / 134 </p>
<p><b>5.2.11 </b></p>
<p><b>EcuM_GetValidatedWakeupEvents </b></p>
<p><b>Prototype </b></p>
<p>EcuM_WakeupSourceType <b>EcuM_GetValidatedWakeupEvents </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>EcuM_WakeupSourceType </p>
<p>ID of the wake-up source which was responsible for the wake-up </p>
<p><b>Functional Description </b></p>
<p>This function returns wake-up event which causes the wake-up of the ECU from the previous sleep mode. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The validated Wake-up Events must be cleared before the EcuM is set to sleep. The </p>
<p>EcuM does not clear those events by itself. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-12  </p>
<p>EcuM_GetValidatedWakeupEvents </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>72 / 134 </p>
<p><b>5.2.12 </b></p>
<p><b>EcuM_GetExpiredWakeupEvents </b></p>
<p><b>Prototype </b></p>
<p>EcuM_WakeupSourceType <b>EcuM_GetExpiredWakeupEvents </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>EcuM_WakeupSourceType </p>
<p>ID's of wake-up sources which are expired in the validation process. </p>
<p><b>Functional Description </b></p>
<p>Returns all events that have been set and for which validation has failed. Events which do not need </p>
<p>validation must never be reported by this service. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-13  </p>
<p>EcuM_GetExpiredWakeupEvents </p>
<p><b>5.2.13 </b></p>
<p><b>EcuM_GetBootTarget </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_GetBootTarget </b>(EcuM_BootTargetType *BootTarget) </p>
<p><b>Parameter </b></p>
<p>BootTarget </p>
<p>The current selected BootTarget </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>success </p>
<p>E_NOT_OK </p>
<p>error </p>
<p><b>Functional Description </b></p>
<p>Returns the current selected boot target of the ECU. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-14  </p>
<p>EcuM_GetBootTarget </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>73 / 134 </p>
<p><b>5.2.14 </b></p>
<p><b>EcuM_SelectBootTarget </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_SelectBootTarget </b>(EcuM_BootTargetType BootTarget) </p>
<p><b>Parameter </b></p>
<p>BootTarget </p>
<p>The selected BootTarget </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>success </p>
<p>E_NOT_OK </p>
<p>error </p>
<p><b>Functional Description </b></p>
<p>Sets the boot target for the next boot. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-15  </p>
<p>EcuM_SelectBootTarget </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>74 / 134 </p>
<p><b>5.2.15 </b></p>
<p><b>EcuM_StartCheckWakeup   </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_StartCheckWakeup </b>(EcuM_WakeupSourceType WakeupSource) </p>
<p><b>Parameter </b></p>
<p>WakeupSource </p>
<p>ID of the asynchronous wake-up source  </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This function starts the check wakeup timeout mechanism and marks that the wakeup source has an </p>
<p>unapproved CheckWakeup call if applicable on given wakeup source (check wakeup timeout &gt; 0). </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>This service shall only be called by EcuM_CheckWakeup(). The call is generated </p>
<p>automatically if at least one wake-up source has a configured check wakeup timeout. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This service is synchronous. </p>
<p><b></b></p>
<p><b> </b></p>
<p>This service is reentrant for the same WakeupSource. </p>
<p><b></b></p>
<p><b> </b></p>
<p>This service is always available. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Expected to be called in interrupt context. </p>
<p>Table 5-16  </p>
<p>EcuM_StartCheckWakeup </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>75 / 134 </p>
<p><b>5.2.16 </b></p>
<p><b>EcuM_EndCheckWakeup  </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_EndCheckWakeup </b>(EcuM_WakeupSourceType WakeupSource) </p>
<p><b>Parameter </b></p>
<p>WakeupSource </p>
<p>ID of the asynchronous wake-up source  </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This function stops the check wakeup timeout mechanism and removes the wakeup source from the list of </p>
<p>unapproved CheckWakeup calls. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This service is synchronous. </p>
<p><b></b></p>
<p><b> </b></p>
<p>This service is reentrant for the same WakeupSource. </p>
<p><b></b></p>
<p><b> </b></p>
<p>This service is always available. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Expected to be called in interrupt context. </p>
<p>Table 5-17  </p>
<p>EcuM_EndCheckWakeup </p>
<p><b>5.2.17 </b></p>
<p><b>EcuM_GetVersionInfo </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_GetVersionInfo </b>(Std_VersionInfoType *versioninfo) </p>
<p><b>Parameter </b></p>
<p>versioninfo </p>
<p>pointer to store the version information </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Returns the version information of the ECU State Manager. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant. </p>
<p><b></b></p>
<p><b> </b></p>
<p>The availability of this service depends on ECUM_VERSION_INFO_API. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from task level </p>
<p>Table 5-18  </p>
<p>EcuM_GetVersionInfo </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>76 / 134 </p>
<p><b>5.2.18 </b></p>
<p><b>EcuM_RequestRUN </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_RequestRUN (EcuM_UserType user) </b></p>
<p><b>Parameter </b></p>
<p>user </p>
<p>User ID which requests the RUN state </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request accepted  </p>
<p>E_NOT_OK </p>
<p>Request not accepted </p>
<p><b>Functional Description </b></p>
<p>Places a RUN request for this user, Users represents normally an application. The tracking of the requests </p>
<p>are specific for each user. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>RUN request will be ignored after an API call to EcuM_KillAllRUNRequest(). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant.</p>
<p> </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from application context. </p>
<p>Table 5-19  </p>
<p>EcuM_RequestRUN </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>77 / 134 </p>
<p><b>5.2.19 </b></p>
<p><b>EcuM_ReleaseRUN </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_ReleaseRUN (EcuM_UserType user) </b></p>
<p><b>Parameter </b></p>
<p>user </p>
<p>User ID which requests the RUN state </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request accepted  </p>
<p>E_NOT_OK </p>
<p>Request not accepted </p>
<p><b>Functional Description </b></p>
<p>Releases the RUN request previously done with a call to EcuM_RequestRUN(). </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant.</p>
<p> </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from application context. </p>
<p>Table 5-20  </p>
<p>EcuM_ReleaseRUN </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>78 / 134 </p>
<p><b>5.2.20 </b></p>
<p><b>EcuM_RequestPOST_RUN </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_RequestPOST_RUN (EcuM_UserType user) </b></p>
<p><b>Parameter </b></p>
<p>user </p>
<p>User ID which requests the RUN state </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request accepted  </p>
<p>E_NOT_OK </p>
<p>Request not accepted </p>
<p><b>Functional Description </b></p>
<p>Places a POST_RUN request for this user, Users represents normally an application. The tracking of the </p>
<p>requests are specific for each user. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>POST_RUN request will be ignored after an API call to </p>
<p>EcuM_KillAllPostRUNRequest(). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant.</p>
<p> </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from application context. </p>
<p>Table 5-21  </p>
<p>EcuM_RequestPOST_RUN </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>79 / 134 </p>
<p><b>5.2.21 </b></p>
<p><b>EcuM_ReleasePOST_RUN </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_ReleasePOST_RUN (EcuM_UserType user) </b></p>
<p><b>Parameter </b></p>
<p>user </p>
<p>User ID which requests the RUN state </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request accepted  </p>
<p>E_NOT_OK </p>
<p>Request not accepted </p>
<p><b>Functional Description </b></p>
<p>Releases the POST_RUN request previously done with a call to EcuM_RequestPOST_RUN().  </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant.</p>
<p> </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from application context. </p>
<p>Table 5-22  </p>
<p>EcuM_ReleasePOST_RUN </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>80 / 134 </p>
<p><b>5.3 </b></p>
<p><b>Services Provided by EcuM flex </b></p>
<p>In the following the services are described which are only relevant for EcuM flex: </p>
<p><b>5.3.1 </b></p>
<p><b>EcuM_SelectShutdownCause </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_SelectShutdownCause  </b></p>
<p>(EcuM_ShutdownCauseType   </p>
<p> </p>
<p> </p>
<p> </p>
<p>shutdownCause) </p>
<p><b>Parameter </b></p>
<p>shutdownCause </p>
<p>current shutdown cause </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>success </p>
<p>E_NOT_OK </p>
<p>error </p>
<p><b>Functional Description </b></p>
<p>Selects a new Shutdown cause for an intended shutdown. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-23  </p>
<p>EcuM_SelectShutdownCause </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>81 / 134 </p>
<p><b>5.3.2 </b></p>
<p><b>EcuM_GetShutdownCause </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_GetShutdownCause  </b></p>
<p>(EcuM_ShutdownCauseType   </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>*shutdownCause) </p>
<p><b>Parameter </b></p>
<p>shutdownCause </p>
<p>current shutdown cause </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>success </p>
<p>E_NOT_OK </p>
<p>error </p>
<p><b>Functional Description </b></p>
<p>Get the currently set shutdown cause. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-24  </p>
<p>EcuM_GetShutdownCause </p>
<p><b>5.3.3 </b></p>
<p><b>EcuM_GoHalt </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_GoHalt </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>success </p>
<p>E_NOT_OK </p>
<p>error </p>
<p><b>Functional Description </b></p>
<p>This API is called in some modes for saving power. In this mode no more code is executed after entering </p>
<p>that state. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant. </p>
<p><b></b></p>
<p><b> </b></p>
<p>The selected shutdown target must set to ECUM_STATE_SLEEP </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-25  </p>
<p>EcuM_GoHalt </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>82 / 134 </p>
<p><b>5.3.4 </b></p>
<p><b>EcuM_GoPoll </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_GoPoll </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>success </p>
<p>E_NOT_OK </p>
<p>error </p>
<p><b>Functional Description </b></p>
<p>This API is called in some modes for saving power. In this mode code is executed, so the EcuM poll for </p>
<p>wake-up events. Only those Wake-up Sources with configured parameter EcuMWakeupSourcePolling are </p>
<p>polled during that sleep mode. Other active sources can set wake-up events via interrupts. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant. </p>
<p><b></b></p>
<p><b> </b></p>
<p>The selected shutdown target must set to ECUM_STATE_SLEEP </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-26  </p>
<p>EcuM_GoPoll </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>83 / 134 </p>
<p><b>5.3.5 </b></p>
<p><b>EcuM_GoDown </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_GoDown </b>(uint16 caller) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This routine is called to initiate a shutdown or a reset. The routine checks if the caller is one of the allowed </p>
<p>callers (if defensive behavior is configured) and then the EcuM calls ShutdownOS() and thereafter the API </p>
<p>EcuM_Shutdown() is called by the shutdown hook. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant. </p>
<p><b></b></p>
<p><b> </b></p>
<p>The selected shutdown target must set to ECUM_STATE_OFF or ECUM_STATE_RESET </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-27  </p>
<p>EcuM_GoDown </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>84 / 134 </p>
<p><b>5.3.6 </b></p>
<p><b>EcuM_GoToSelectedShutdownTarget </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_GoToSelectedShutdownTarget</b>(void)<b> </b></p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p> </p>
<p>E_NOT_OK </p>
<p> </p>
<p><b>Functional Description </b></p>
<p>This API can be called e.g. from the BswM without knowledge about the currently </p>
<p>configured shutdown target. The EcuM decides if EcuM_GoHalt(), EcuM_GoPoll() or </p>
<p>EcuM_GoDown() has to be called. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-28  </p>
<p>EcuM_GoToSelectedShutdownTarget </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>85 / 134 </p>
<p><b>5.3.7 </b></p>
<p><b>EcuM_SetRelWakeupAlarm </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_SetRelWakeupAlarm </b>(EcuM_UserType user, uint32 time)<b> </b></p>
<p><b>Parameter </b></p>
<p>user </p>
<p>time </p>
<p>The user that wants to set up the wake up alarm </p>
<p>Relative time for the wake-up alarm in seconds </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>E_NOT_OK </p>
<p>E_EARLIER_ACTIVE </p>
<p>Alarm was successfully started </p>
<p>No Alarm was started because of an invalid user parameter </p>
<p>An earlier alarm was already started </p>
<p><b>Functional Description </b></p>
<p>This API can be used to set a relative wake up alarm during runtime of the ECU. For further information </p>
<p>about this see chapter 3.14. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>All wake up alarms are cleared if the ECU wakes up from a sleep phase, even if the </p>
<p>reason for this wake up was not time triggered. The wake up alarms must be rearmed </p>
<p>before the next sleep phase is entered. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Each user can only set one wake-up alarm. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from task level </p>
<p>Table 5-29  </p>
<p>EcuM_SetRelWakeupAlarm </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>86 / 134 </p>
<p><b>5.3.8 </b></p>
<p><b>EcuM_SetAbsWakeupAlarm </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_SetAbsWakeupAlarm </b>(EcuM_UserType user, uint32 time) </p>
<p><b>Parameter </b></p>
<p>user </p>
<p>time </p>
<p>The user that wants to set up the wake-up alarm </p>
<p>Absolute time for the wake-up alarm in seconds </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>E_NOT_OK </p>
<p>E_EARLIER_ACTIVE </p>
<p>E_PAST</p>
<p> </p>
<p>Alarm was successfully started </p>
<p>No Alarm was started because of an invalid user parameter </p>
<p>An earlier alarm was already started </p>
<p>The time has already passed </p>
<p><b>Functional Description </b></p>
<p>This API can be used to set an absolute wake up alarm during runtime of the ECU. For further information </p>
<p>about this see chapter 3.14. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>All wake up alarms are cleared if the ECU wakes up from a sleep phase, even if the </p>
<p>reason for this wake up was not time triggered. The wake up alarms must be rearmed </p>
<p>before the next sleep phase is entered. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Each user can only set one wake-up alarm. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from task level </p>
<p>Table 5-30  </p>
<p>EcuM_SetAbsWakeupAlarm </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>87 / 134 </p>
<p><b>5.3.9 </b></p>
<p><b>EcuM_AbortWakeupAlarm </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_AbortWakeupAlarm </b>(EcuM_UserType user)<b> </b></p>
<p><b>Parameter </b></p>
<p>user </p>
<p>The user that wants to abort the wake-up alarm </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>E_NOT_OK </p>
<p>E_NOT_ACTIVE </p>
<p>Alarm was successfully aborted </p>
<p>The parameter ‘user’ was not valid </p>
<p>No alarm was active for this user </p>
<p><b>Functional Description </b></p>
<p>This API can be used to abort a wake-up alarm which was set via the APIs EcuM_SetRelWakeupAlarm or </p>
<p>EcuM_SetAbsWakeupAlarm.  </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from task level </p>
<p>Table 5-31  </p>
<p>EcuM_AbortWakeupAlarm </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>88 / 134 </p>
<p><b>5.3.10 </b></p>
<p><b>EcuM_GetWakeupTime </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_GetWakeupTime </b>(uint32 *time)<b> </b></p>
<p><b>Parameter </b></p>
<p>time </p>
<p>Absolute time of the next configured wake-up alarm in seconds </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>E_NOT_OK </p>
<p>Time was successfully returned </p>
<p>A null pointer was passed as parameter ‘time’ </p>
<p><b>Functional Description </b></p>
<p>Returns the time of the next active wake-up alarm which was set via the APIs EcuM_SetAbsWakeupAlarm </p>
<p>or EcuM_SetRelWakeupAlarm. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>If the returned value equals ‘0xFFFFFFFF’, no wake-up alarm is currently active </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from task level </p>
<p>Table 5-32  </p>
<p>EcuM_GetWakeupTime </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>89 / 134 </p>
<p><b>5.3.11 </b></p>
<p><b>EcuM_SetClock </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_SetClock </b>(EcuM_UserType user, uint32 time) </p>
<p><b>Parameter </b></p>
<p>user </p>
<p>time </p>
<p>The user that wants to set up the clock </p>
<p>The absolute time value designated for the new time in seconds</p>
<p> </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>E_NOT_ALLOWED</p>
<p> </p>
<p>Time was successfully modified </p>
<p>The user was not allowed to modify the time </p>
<p><b>Functional Description </b></p>
<p>This API can be used to modify the current time. Only special users are allowed to modify this time, e.g. for </p>
<p>test purposes. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from task level </p>
<p>Table 5-33  </p>
<p>EcuM_SetClock </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>90 / 134 </p>
<p><b>5.3.12 </b></p>
<p><b>EcuM_GetCurrentTime </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_GetCurrentTime </b>(uint32 *time)<b> </b></p>
<p><b>Parameter </b></p>
<p>time </p>
<p>Current system time in seconds</p>
<p> </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>E_NOT_OK</p>
<p> </p>
<p>Time was successfully returned </p>
<p>A null pointer was passed as parameter ‘time’ </p>
<p><b>Functional Description </b></p>
<p>This API can be used to get the current system time.  </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from task level </p>
<p>Table 5-34  </p>
<p>EcuM_GetCurrentTime </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>91 / 134 </p>
<p><b>5.3.13 </b></p>
<p><b>EcuM_SetState </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_SetState</b>(EcuM_StateType state); </p>
<p><b>Parameter </b></p>
<p>state </p>
<p>State indicated by BswM</p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Requests a specific state which will be mapped to the corresponding RTE mode. This mode will be used </p>
<p>to trigger a RTE mode switch. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from task level </p>
<p>Table 5-35  </p>
<p>EcuM_SetState </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>92 / 134 </p>
<p><b>5.4 </b></p>
<p><b>Services Provided by EcuM fixed </b></p>
<p>In the following the services are described which are only relevant for EcuM fixed: </p>
<p><b>5.4.1 </b></p>
<p><b>EcuM_GetState </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>EcuM_GetState </b>(EcuM_StateType* state)<b> </b></p>
<p><b>Parameter </b></p>
<p>state </p>
<p>Current EcuM State </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>The parameter state was a not NULL_PTR </p>
<p>E_NOT_OK </p>
<p>The parameter state was a NULL_PTR </p>
<p><b>Functional Description </b></p>
<p>This API returns the current EcuM State. The possible EcuM States for the fixed EcuM can be seen in </p>
<p>chapter <b>3.3 </b>States of EcuM fixed. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is reentrant.</p>
<p> </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from task level </p>
<p>Table 5-36  </p>
<p>EcuM_GetState </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>93 / 134 </p>
<p><b>5.4.2 </b></p>
<p><b>EcuM_KillAllRUNRequests </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_ KillAllRUNRequests (void) </b></p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Deletes all RUN requests and ensures that no new RUN request is accepted. Additionally the EcuM self-</p>
<p>run request period will be aborted. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The benefit of this function over an ECU reset is that the shutdown sequence is  </p>
<p>executed, which e.g. takes care of writing back NV memory contents. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant.</p>
<p> </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from application context. </p>
<p>Table 5-37  </p>
<p>EcuM_ KillAllRUNRequests </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>94 / 134 </p>
<p><b>5.4.3 </b></p>
<p><b>EcuM_KillAllPostRUNRequests </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_ KillAllPostRUNRequests (void) </b></p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Deletes all POST_RUN requests and ensures that no new POST_RUN request is accepted.  </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant.</p>
<p> </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from application context. </p>
<p>Table 5-38  </p>
<p>EcuM_ KillAllPostRUNRequests </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>95 / 134 </p>
<p><b>5.5 </b></p>
<p><b>Services Used by EcuM </b></p>
<p>In the following table services provided by other components, which are used by the EcuM </p>
<p>are listed. Also refer to chapter 2.1. </p>
<p>For  details  about  prototype and functionality refer to  the documentation of  the providing </p>
<p>component. </p>
<p><b>Component </b></p>
<p><b>API </b></p>
<p><b>EcuM </b></p>
<p><b>flex </b></p>
<p><b>EcuM </b></p>
<p><b>fixed </b></p>
<p>BswM </p>
<p>BswM_EcuM_CurrentWakeup()</p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>BswM_Init() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>BswM_Deinit() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>BswM_EcuM_RequestedState() </p>
<p></p>
<p> </p>
<p> </p>
<p>BswM_EcuM_CurrentState() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>ComM </p>
<p>ComM_EcuM_WakeUpIndication()</p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>ComM_GetStatus() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>ComM_GetState() </p>
<p> </p>
<p></p>
<p> </p>
<p>ComM_CommunicationAllowed() </p>
<p> </p>
<p></p>
<p> </p>
<p>ComM_DeInit() </p>
<p> </p>
<p></p>
<p> </p>
<p>Det </p>
<p>Det_ReportError() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Dem </p>
<p>Dem_ReportErrorStatus() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Dem_Init() </p>
<p> </p>
<p></p>
<p> </p>
<p>Dem_Shutdown() </p>
<p> </p>
<p></p>
<p> </p>
<p>Gpt </p>
<p>Gpt_EnableNotification() </p>
<p></p>
<p> </p>
<p> </p>
<p>Gpt_EnableWakeup() </p>
<p></p>
<p> </p>
<p> </p>
<p>Gpt_SetMode() </p>
<p></p>
<p> </p>
<p> </p>
<p>Gpt_StartTimer() </p>
<p></p>
<p> </p>
<p> </p>
<p>Mcu </p>
<p>Mcu_SetMode() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Mcu_GetResetReason() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>NvM </p>
<p>NvM_WriteAll() </p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_CancelWriteAll() </p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_KillWriteAll() </p>
<p> </p>
<p></p>
<p> </p>
<p>OS </p>
<p>ShutdownOS() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>StartOS() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>GetResource() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>ReleaseResource() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>EnableAllInterrupts() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>DisableAllInterrupts() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>RTE </p>
<p>Rte_Start() </p>
<p> </p>
<p></p>
<p> </p>
<p>Rte_Stop() </p>
<p> </p>
<p></p>
<p> </p>
<p>Rte_Switch_currentMode_currentMode() </p>
<p> </p>
<p></p>
<p> </p>
<p>Rte_Feedback_currentMode_currentMode() </p>
<p> </p>
<p></p>
<p> </p>
<p>SchM </p>
<p>SchM_Init() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>SchM_Deinit() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>96 / 134 </p>
<p><b>Component </b></p>
<p><b>API </b></p>
<p><b>EcuM </b></p>
<p><b>flex </b></p>
<p><b>EcuM </b></p>
<p><b>fixed </b></p>
<p>SchM_Enter_EcuM_ECUM_EXCLUSIVE_AREA_0() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>SchM_Exit_EcuM_ECUM_EXCLUSIVE_AREA_0() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>SchM_Enter_EcuM_ECUM_EXCLUSIVE_AREA_1() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>SchM_Exit_EcuM_ECUM_EXCLUSIVE_AREA_1() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>SchM_Enter_EcuM_ECUM_EXCLUSIVE_AREA_2() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>SchM_Exit_EcuM_ECUM_EXCLUSIVE_AREA_2() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Table 5-39  </p>
<p>Services used by the EcuM </p>
<p><b>5.6 </b></p>
<p><b>Callback Functions </b></p>
<p>This chapter describes the callback functions that are implemented by the EcuM and can </p>
<p>be invoked by other modules. The prototypes of the callback functions are provided in the </p>
<p>header file EcuM_Cbk.h by the EcuM. </p>
<p><b>5.6.1 </b></p>
<p><b>EcuM_SetWakeupEvent </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_SetWakeupEvent </b>(EcuM_WakeupSourceType WakeupSource) </p>
<p><b>Parameter </b></p>
<p>WakeupSource </p>
<p>the source of the wake-up event. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Marks a wake-up event as pending if validation is required. If no validation is required then </p>
<p>EcuM_ValidateSetWakeupEvent will be called within this function. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>None </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-40  </p>
<p>EcuM_SetWakeupEvent </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>97 / 134 </p>
<p><b>5.6.2 </b></p>
<p><b>EcuM_ValidateWakeupEvent </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_ValidateWakeupEvent </b>(EcuM_WakeupSourceType WakeupSource) </p>
<p><b>Parameter </b></p>
<p>WakeupSource </p>
<p>the wake-up source which should be validated </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>After wake-up, the ECU State Manager will stop the process during the WAKE-UP VALIDATION state to </p>
<p>wait for validation of the wake-up event. The validation is carried out with a call of this API service. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Only ComM channels can validate Wake-up Events during ECUM_STATE_RUN. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level or from task level </p>
<p>Table 5-41  </p>
<p>EcuM_ValidateWakeupEvent </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>98 / 134 </p>
<p><b>5.6.3 </b></p>
<p><b>EcuM_AlarmCheckWakeup </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_AlarmCheckWakeup</b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none</p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This API is used to update the system clock. The API is called by the EcuM callout EcuM_CheckWakeup or </p>
<p>directly by the GPT after one second has elapsed. </p>
<p>If during sleep the wake-up alarm which was set via the APIs EcuM_SetAbsWakeupAlarm or </p>
<p>EcuM_SetRelWakeupAlarm has expired, this API call will lead to a wake-up event. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level </p>
<p>Table 5-42  </p>
<p>EcuM_AlarmCheckWakeup </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>99 / 134 </p>
<p><b>5.6.4 </b></p>
<p><b>Callback Functions by EcuM fixed </b></p>
<p><b>5.6.4.1 </b></p>
<p><b>EcuM_CB_NfyNvMJobEnd </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_CB_NfyNvMJobEnd </b>(uint8 ServiceID, NvM_RequestResultType JobResult) </p>
<p><b>Parameter </b></p>
<p>ServiceID </p>
<p>Unique service ID of NVRAM manger service.</p>
<p> </p>
<p>JobResult </p>
<p>[parameter is ignored by EcuM fixed] </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Used to notify about the end of NVRAM jobs initiated by ECUM. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>Service ID: see table 'Service IDs'  </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is synchronous.</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is non-reentrant. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Function could be called from interrupt level </p>
<p>Table 5-43  </p>
<p>EcuM_AlarmCheckWakeup </p>
<p> </p>
<p><b>5.7 </b></p>
<p><b>Configurable Interfaces </b></p>
<p><b>5.7.1 </b></p>
<p><b>Notifications </b></p>
<p>The EcuM does not provide notifications. </p>
<p><b>5.7.2 </b></p>
<p><b>Callout Functions </b></p>
<p>At its configurable interfaces the EcuM defines callout functions. The declarations of the </p>
<p>callout functions are provided by the BSW module, i.e. the EcuM. It is the integrator's task </p>
<p>to  provide  the  corresponding  function  definitions.  The  definitions  of  the  callouts  can  be </p>
<p>adjusted to the system's needs. The EcuM callout function declarations are described in </p>
<p>the following tables: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>100 / 134 </p>
<p><b>5.7.2.1 </b></p>
<p><b>EcuM_ErrorHook </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_ErrorHook </b>(Std_ReturnType reason) </p>
<p><b>Parameter </b></p>
<p>reason </p>
<p>The reason for the current call of the ErrorHook. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The ECU State Manager calls the Errorhook if the following error code occur: </p>
<p><b></b></p>
<p><b> </b></p>
<p>ECUM_E_HOOK_RAM_CHECK_FAILED </p>
<p>In that case it is not possible to continue processing. The integrator has to take the decision how the ECU </p>
<p>shall react in that situation.  </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Expected to be called in application context. </p>
<p>Table 5-44  </p>
<p>EcuM_ErrorHook </p>
<p><b>5.7.2.2 </b></p>
<p><b>EcuM_OnGoOffOne </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_OnGoOffOne </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of additional activities in GO OFF I state. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in task context  </p>
<p><b></b></p>
<p><b> </b></p>
<p>Called right after entering ECUM_STATE_GO_OFF_ONE. </p>
<p>Table 5-45  </p>
<p>EcuM_OnGoOffOne </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>101 / 134 </p>
<p><b>5.7.2.3 </b></p>
<p><b>EcuM_OnGoOffTwo </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_OnGoOffTwo </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of additional activities in GO OFF II state. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in task context  </p>
<p><b></b></p>
<p><b> </b></p>
<p>Called right after entering ECUM_STATE_GO_OFF_TWO. </p>
<p>Table 5-46  </p>
<p>EcuM_OnGoOffTwo </p>
<p><b>5.7.2.4 </b></p>
<p><b>EcuM_AL_SwitchOff </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_AL_SwitchOff </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout shall take the code for shutting off the power supply of the ECU. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in EcuM_Shutdown(), task context </p>
<p>Table 5-47  </p>
<p>EcuM_AL_SwitchOff </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>102 / 134 </p>
<p><b>5.7.2.5 </b></p>
<p><b>EcuM_AL_Reset </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_AL_Reset </b>(EcuM_ResetType Reset) </p>
<p><b>Parameter </b></p>
<p>Reset </p>
<p>The parameter Reset describes the ResetType (refer to 5.1) that is currently </p>
<p>configured via EcuM_SelectShutdownTarget () (refer to 5.2.5). </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout shall take the decision what kind of reset to be performed depending on the given Reset mode.  </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Expected to be called in application context. </p>
<p>Table 5-48  </p>
<p>EcuM_AL_Reset </p>
<p><b>5.7.2.6 </b></p>
<p><b>EcuM_AL_DriverInitZero </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_AL_DriverInitZero </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout is invoked early in the PreOS Sequence during EcuM_Init(). </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is filled by the configuration tool. It can be extended by the integrator by using the </p>
<p>Userblocks. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in EcuM_Init(), task context </p>
<p>Table 5-49  </p>
<p>EcuM_AL_DriverInitZero </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>103 / 134 </p>
<p><b>5.7.2.7 </b></p>
<p><b>EcuM_AL_DriverInitOne </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_AL_DriverInitOne </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout is invoked late in the PreOS Sequence during EcuM_Init(). </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is filled by the configuration tool. It can be extended by the integrator by using the </p>
<p>Userblocks. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>PostBuild data can be accessed via the global pointer EcuM_GlobalPBConfig_Ptr, </p>
<p>example: EcuM_GlobalPBConfig_Ptr-&gt;CfgPtr_Com_Init. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Variant data can be accessed via the global pointer EcuM_GlobalPCConfig_Ptr, </p>
<p>example: EcuM_GlobalPCConfig_Ptr-&gt;CfgPtr_ComM_Init. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in EcuM_Init(), task context </p>
<p>Table 5-50  </p>
<p>EcuM_AL_DriverInitOne </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>104 / 134 </p>
<p><b>5.7.2.8 </b></p>
<p><b>EcuM_AL_DriverRestart </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_AL_DriverRestart </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout shall provide driver initialization and other hardware related startup activities after a wake-up </p>
<p>event from SLEEP state. This callout should be a combination of EcuM_DriverInitZero and </p>
<p>EcuM_DriverInitOne. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is filled by the configuration tool. It can be extended by the integrator by using the </p>
<p>Userblocks. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>PostBuild data can be accessed via the global pointer EcuM_GlobalPBConfig_Ptr, </p>
<p>example: EcuM_GlobalPBConfig_Ptr-&gt;CfgPtr_Com_Init. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Variant data can be accessed via the global pointer EcuM_GlobalPCConfig_Ptr, </p>
<p>example: EcuM_GlobalPCConfig_Ptr-&gt;CfgPtr_ComM_Init. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked directly after the wake-up phase </p>
<p>Table 5-51  </p>
<p>EcuM_AL_DriverRestart </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>105 / 134 </p>
<p><b>5.7.2.9 </b></p>
<p><b>EcuM_AL_SetProgrammableInterrupts </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_AL_SetProgrammableInterrupts </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>On ECUs with programmable interrupt priorities, these priorities must be set before the OS is started. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in EcuM_Init(), task context </p>
<p>Table 5-52  </p>
<p>EcuM_AL_SetProgrammableInterrupts </p>
<p><b>5.7.2.10 </b></p>
<p><b>EcuM_McuSetMode </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_McuSetMode </b>(Mcu_ModeType McuMode) </p>
<p><b>Parameter </b></p>
<p>McuMode </p>
<p>Mode for the upcoming sleep mode </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Switches the Mcu to a power saving mode during a sleep phase. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is filled by the configuration tool. It can be adapted by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Expected to be called by EcuM_GoHalt() or EcuM_GoPoll() </p>
<p>Table 5-53  </p>
<p>EcuM_McuSetMode </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>106 / 134 </p>
<p><b>5.7.2.11 </b></p>
<p><b>EcuM_WaitForSlaveCores </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_WaitForSlaveCores </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Is only called if EcuMSlaveCoreHandling is active. During the master core is waiting for the slave cores to </p>
<p>be ready for the upcoming sleep this callout is called cyclically.  </p>
<p>In context of this callout the slave cores can be initiated to enter sleep. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Expected to be called by EcuM_GoHalt() or EcuM_GoPoll() </p>
<p>Table 5-54  </p>
<p>EcuM_WaitForSlaveCores </p>
<p> </p>
<p><b>5.7.2.12 </b></p>
<p><b>EcuM_StartOS </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_StartOS </b>(AppModeType appMode) </p>
<p><b>Parameter </b></p>
<p>appMode </p>
<p>Default OS application Mode </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout is called at the end of EcuM_Init() to start the OS. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In case of a MultiCore ECU all slave cores are started from the Master Core via the OS </p>
<p>API StartCore() before the OS is started with a call to StartOS(). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is filled by the configuration tool. It can be adapted by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Expected to be called by EcuM_Init() </p>
<p>Table 5-55  </p>
<p>EcuM_StartOS </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>107 / 134 </p>
<p><b>5.7.2.13 </b></p>
<p><b>EcuM_ShutdownOS </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_ShutdownOS </b>(Std_ReturnType ErrCode) </p>
<p><b>Parameter </b></p>
<p>ErrCode </p>
<p>E_OK </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout is called at the end of EcuM_GoDown() to shut down the OS via </p>
<p>ShutdownOS(E_OK). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In case of a MultiCore ECU this callout should lead to a call of </p>
<p>ShutdownAllCores(E_OK), inside this OS API all cores are synchronized and stopped. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is filled by the configuration tool. It can be adapted by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Expected to be called by EcuM_GoDown() </p>
<p>Table 5-56  </p>
<p>EcuM_ShutdownOS </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>108 / 134 </p>
<p><b>5.7.2.14 </b></p>
<p><b>EcuM_GenerateRamHash </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_GenerateRamHash </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout is intended to provide a RAM integrity test. The goal of this test is to ensure that after a long </p>
<p>SLEEP duration, RAM contents are still consistent. The RAM check itself must be provided by the </p>
<p>integrator. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in task context  </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked just before setting the ECU into a sleep mode where the ECU is halted </p>
<p>Table 5-57  </p>
<p>EcuM_GenerateRamHash </p>
<p><b>5.7.2.15 </b></p>
<p><b>EcuM_CheckRamHash </b></p>
<p><b>Prototype </b></p>
<p>uint8 <b>EcuM_CheckRamHash </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>0 </p>
<p>Integrity test failed </p>
<p>1…255 </p>
<p>Integrity test passed </p>
<p><b>Functional Description </b></p>
<p>This callout is intended to provide a RAM integrity check previously done with EcuM_GenerateRamHash(). </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p> Invoked in task context  </p>
<p><b></b></p>
<p><b> </b></p>
<p> Directly called after the wake-up of the ECU. </p>
<p>Table 5-58  </p>
<p>EcuM_CheckRamHash </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>109 / 134 </p>
<p><b>5.7.2.16 </b></p>
<p><b>EcuM_SleepActivity </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_SleepActivity </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The ECU State Manager invokes this callout periodically during the Poll Sequence if the MCU is not halted. </p>
<p>The EcuM polls periodically all sources that need polling and are active during the configured Sleep mode. </p>
<p>After all sources are polled EcuM_SleepActivity is called once. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The EcuM_SleepActivity is called in a blocking loop at maximum frequency. If a </p>
<p>lower period is preferred, the integrator has to implement this behavior. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Expected to be called in task context. </p>
<p>Table 5-59  </p>
<p>EcuM_SleepActivity </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>110 / 134 </p>
<p><b>5.7.2.17 </b></p>
<p><b>EcuM_EnableWakeupSources </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_EnableWakeupSources </b>(EcuM_WakeupSourceType wakeupSource) </p>
<p><b>Parameter </b></p>
<p>wakeupSource </p>
<p>Every bit set in the parameter indicates a wake-up source which should be </p>
<p>enabled in the current sleep mode. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout will be invoked when the EcuM enters a sleep state. The EcuM calls this callout for every bit </p>
<p>that is set as an active source for the current Sleep mode.  </p>
<p>The integrator has to take care to implement the necessary activities to enable the corresponding wake-up </p>
<p>sources. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in task context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked just before setting the ECU into a sleep mode </p>
<p>Table 5-60  </p>
<p>EcuM_EnableWakeupSources </p>
<p><b>5.7.2.18 </b></p>
<p><b>EcuM_DisableWakeupSources </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_DisableWakeupSources </b>(EcuM_WakeupSourceType wakeupSource) </p>
<p><b>Parameter </b></p>
<p>wakeupSource </p>
<p>Every bit set in the parameter indicates a wake-up source which should be </p>
<p>enabled in the current sleep mode. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout will be invoked when the EcuM leaves a sleep state. The EcuM disables all wake-up sources </p>
<p>that have occurred during the recent sleep phase. The not occurred sources remain active till the EcuM </p>
<p>transits to ECUM_STATE_RUN after the successful validation of a wake-up source. </p>
<p>The integrator has to take care to implement the necessary activities to disable the corresponding wake-up </p>
<p>sources. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in task context  </p>
<p><b></b></p>
<p><b> </b></p>
<p>Called just before RUN state is entered after a sleep     OR </p>
<p><b></b></p>
<p><b> </b></p>
<p>Called just before WAKEUP_VALIDATION state is entered </p>
<p>Table 5-61  </p>
<p>EcuM_DisableWakeupSources </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>111 / 134 </p>
<p><b>5.7.2.19 </b></p>
<p><b>EcuM_StartWakeupSources </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_StartWakeupSources </b>(EcuM_WakeupSourceType wakeupSource) </p>
<p><b>Parameter </b></p>
<p>wakeupSource </p>
<p>Every bit set in the parameter indicates a wake-up source which is enabled in </p>
<p>the current sleep mode. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The callout shall start the given wake-up source(s) so that they are ready to perform wake-up validation.  </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Expected to be called in task context. </p>
<p>Table 5-62  </p>
<p>EcuM_StartWakeupSources </p>
<p><b>5.7.2.20 </b></p>
<p><b>EcuM_StopWakeupSources </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_StopWakeupSources </b>(EcuM_WakeupSourceType wakeupSource) </p>
<p><b>Parameter </b></p>
<p>wakeupSource </p>
<p>Every bit set in the parameter indicates a wake-up source which should be </p>
<p>stopped after unsuccessful wake-up validation. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout shall stop the given wake-up source(s) after unsuccessful wake-up validation.  </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Expected to be called in task context. </p>
<p>Table 5-63  </p>
<p>EcuM_StopWakeupSources </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>112 / 134 </p>
<p><b>5.7.2.21 </b></p>
<p><b>EcuM_CheckWakeup </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_CheckWakeup </b>(EcuM_WakeupSourceType wakeupSource) </p>
<p><b>Parameter </b></p>
<p>wakeupSource </p>
<p>ID of the wake-up source to be checked </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout shall be called by the ISR of a wake-up source to set up the PLL and check wake-up sources </p>
<p>that may be connected to the same interrupt. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Expected to be called in interrupt context. </p>
<p>Table 5-64  </p>
<p>EcuM_CheckWakeup </p>
<p><b>5.7.2.22 </b></p>
<p><b>EcuM_CheckValidation </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_CheckValidation </b>(EcuM_WakeupSourceType wakeupSource) </p>
<p><b>Parameter </b></p>
<p>wakeupSource </p>
<p>Wake-up IDs of pending wake-up events. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout is called by the EcuM when wake-up validation of a wake-up event is necessary. The pending </p>
<p>wake-up event(s) are passed by the parameter in order to allow the necessary reaction depending on the </p>
<p>wake-up source. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in task context  </p>
<p><b></b></p>
<p><b> </b></p>
<p>Called in WAKE-UP VALIDATION state </p>
<p>Table 5-65  </p>
<p>EcuM_CheckValidation </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>113 / 134 </p>
<p><b>5.7.2.23 </b></p>
<p><b>EcuM_DeterminePbConfiguration </b></p>
<p><b>Prototype </b></p>
<p>EcuM_ConfigRefType <b>EcuM_DeterminePbConfiguration </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>EcuM_ConfigRefType </p>
<p>Pointer to the Post-Build structure </p>
<p><b>Functional Description </b></p>
<p>In the case of Post-Build Loadable or Selectable the EcuM gets the global configuration pointer via this </p>
<p>callout.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In case of a MultiCore ECU this callout is only called on the core which starts up first. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Expected to be called in application context. </p>
<p>Table 5-66  </p>
<p>EcuM_DeterminePbConfiguration </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>114 / 134 </p>
<p><b>5.7.2.24 </b></p>
<p><b>EcuM_BswErrorHook </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_BswErrorHook </b>(uint16 BswModuleId, uint8 ErrorId) </p>
<p><b>Parameter </b></p>
<p>BswModuleId </p>
<p>The reporting BSW module </p>
<p>ErrorId </p>
<p>The Id of the reported error </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This API can be called by Basic Software Modules to notify corrupted Postbuild configuration data. </p>
<p> </p>
<p>Specified ErrorIds are: </p>
<p><b></b></p>
<p><b> </b></p>
<p>ECUM_BSWERROR_NULLPTR </p>
<p><b></b></p>
<p><b> </b></p>
<p>ECUM_BSWERROR_COMPATIBILITYVERSION </p>
<p><b></b></p>
<p><b> </b></p>
<p>ECUM_BSWERROR_MAGICNUMBER </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>The handling of an occurred error has to be specified by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in task context. </p>
<p>Table 5-67  </p>
<p>EcuM_BswErrorHook </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>115 / 134 </p>
<p><b>5.7.3 </b></p>
<p><b>Callout Functions by EcuM flex </b></p>
<p><b>5.7.3.1 </b></p>
<p><b>EcuM_GptStartClock </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_GptStartClock </b>(Gpt_ChannelType GptChannel, Gpt_ModeType Mode, </p>
<p>Gpt_ValueType Value) </p>
<p><b>Parameter </b></p>
<p>GptChannel </p>
<p>Mode </p>
<p>Value </p>
<p>The configured Gpt channel which serves as time base for alarm clock </p>
<p>The Gpt normal mode </p>
<p>The value to start the Gpt timer for second based notification / wake up </p>
<p><b>Return code </b></p>
<p>Void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout prepares the Gpt for calling the callback EcuM_AlarmCheckWakeup every second to increment </p>
<p>the system time. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>This callout is only active if the EcuM alarm clock is enabled </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is filled by the configuration tool. It can be adapted by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Expected to be called by EcuM_StartupTwo(). </p>
<p>Table 5-68  </p>
<p>EcuM_GptStartClock </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>116 / 134 </p>
<p><b>5.7.3.2 </b></p>
<p><b>EcuM_GptSetSleep </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_GptSetSleep </b>(Gpt_ChannelType GptChannel, Gpt_ModeType Mode) </p>
<p><b>Parameter </b></p>
<p>GptChannel </p>
<p>Mode </p>
<p>The configured Gpt channel which serves as time base for alarm clock </p>
<p>The Gpt sleep mode </p>
<p><b>Return code </b></p>
<p>Void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout sets the Gpt to sleep mode and enables the wake up functionality of the Gpt.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>This callout is only active if the EcuM alarm clock is enabled </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is filled by the configuration tool. It can be adapted by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Expected to be called by EcuM_GoHalt() or EcuM_GoPoll() </p>
<p>Table 5-69  </p>
<p>EcuM_GptSetSleep </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>117 / 134 </p>
<p><b>5.7.3.3 </b></p>
<p><b>EcuM_GptSetNormal </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_GptSetNormal </b>(Gpt_ChannelType GptChannel, Gpt_ModeType Mode) </p>
<p><b>Parameter </b></p>
<p>GptChannel </p>
<p>Value </p>
<p>The configured Gpt channel which serves as time base for alarm clock </p>
<p>The Gpt normal mode  </p>
<p><b>Return code </b></p>
<p>Void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout sets the Gpt back to normal mode after the ECU has woken up from a sleep mode. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>This callout is only active if the EcuM alarm clock is enabled </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is filled by the configuration tool. It can be adapted by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Expected to be called by EcuM_GoHalt() or EcuM_GoPoll() </p>
<p>Table 5-70  </p>
<p>EcuM_GptSetNormal </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>118 / 134 </p>
<p><b>5.7.3.4 </b></p>
<p><b>EcuM_AL_DriverInitBswM_&lt;ID&gt; </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_AL_DriverInitBswM_&lt;ID&gt; </b>(const EcuM_ConfigType *ConfigPtr) </p>
<p><b>Parameter </b></p>
<p>ConfigPtr </p>
<p>Pointer to global module configuration structure.  </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout can be invoked by the BswM to initialize the stack of the ECU. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The ID and the count of this callout depends on the configuration. The integrator can </p>
<p>configure multiple driver init lists of this type. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is filled by the configuration tool. It can be extended by the integrator by using the </p>
<p>Userblocks. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in BswM_Init(), task context </p>
<p>Table 5-71  </p>
<p>EcuM_AL_DriverInitBswM </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>119 / 134 </p>
<p><b>5.7.4 </b></p>
<p><b>Callout Functions by EcuM fixed </b></p>
<p><b>5.7.4.1 </b></p>
<p><b>EcuM_AL_DriverInitTwo </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_AL_DriverInitTwo </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout is invoked during EcuM_StartupTwo(), prior the Rte is started. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is filled by the configuration tool. It can be extended by the integrator by using the </p>
<p>Userblocks. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>PostBuild data can be accessed via the global pointer EcuM_GlobalPBConfig_Ptr, </p>
<p>example: EcuM_GlobalPBConfig_Ptr-&gt;CfgPtr_Com_Init. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Variant data can be accessed via the global pointer EcuM_GlobalPCConfig_Ptr, </p>
<p>example: EcuM_GlobalPCConfig_Ptr-&gt;CfgPtr_ComM_Init. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in EcuM_StartupTwo(), task context </p>
<p>Table 5-72  </p>
<p>EcuM_AL_DriverInitTwo </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>120 / 134 </p>
<p><b>5.7.4.2 </b></p>
<p><b>EcuM_AL_DriverInitThree </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_AL_DriverInitThree </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This callout is invoked during EcuM_StartupTwo(), after the Rte is started. </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function is filled by the configuration tool. It can be extended by the integrator by using the </p>
<p>Userblocks. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>PostBuild data can be accessed via the global pointer EcuM_GlobalPBConfig_Ptr, </p>
<p>example: EcuM_GlobalPBConfig_Ptr-&gt;CfgPtr_Com_Init. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Variant data can be accessed via the global pointer EcuM_GlobalPCConfig_Ptr, </p>
<p>example: EcuM_GlobalPCConfig_Ptr-&gt;CfgPtr_ComM_Init. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in EcuM_StartupTwo(), task context </p>
<p>Table 5-73  </p>
<p>EcuM_AL_DriverInitThree </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>121 / 134 </p>
<p><b>5.7.4.3 </b></p>
<p><b>EcuM_OnEnterRun </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_OnEnterRun </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none  </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of activities before entering RUN state.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in task context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Called just before entering RUN state. </p>
<p>Table 5-74  </p>
<p>EcuM_OnEnterRun </p>
<p><b>5.7.4.4 </b></p>
<p><b>EcuM_OnExitRun </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_OnExitRun </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none  </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of activities before leaving RUN state.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in task context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Called just before leaving RUN state. </p>
<p>Table 5-75  </p>
<p>EcuM_OnExitRun </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>122 / 134 </p>
<p><b>5.7.4.5 </b></p>
<p><b>EcuM_OnGoSleep </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_OnGoSleep </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none  </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of additional activities while module is in GO SLEEP state.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in task context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Called after entering GO SLEEP state. </p>
<p>Table 5-76  </p>
<p>EcuM_OnGoSleep </p>
<p><b>5.7.4.6 </b></p>
<p><b>EcuM_OnPrepShutdown </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_OnPrepShutdown </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none  </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of additional activities in PREP SHUTDOWN state.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in task context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Called just after entering PREP SHUTDOWN state. </p>
<p>Table 5-77  </p>
<p>EcuM_OnPrepShutdown </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>123 / 134 </p>
<p><b>5.7.4.7 </b></p>
<p><b>EcuM_OnExitPostRun </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_OnExitPostRun </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none  </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of activities while leaving POST RUN state.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in task context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Called while leaving POST RUN state. </p>
<p>Table 5-78  </p>
<p>EcuM_OnExitPostRun </p>
<p><b>5.7.4.8 </b></p>
<p><b>EcuM_OnFailedNvmWriteAllJobReaction </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_OnFailedNvmWriteAllJobReaction </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none  </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The ECU State Manager will call this function in case that a Nvm_WriteAll() job was not finished in time.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in task context </p>
<p>Table 5-79  </p>
<p>EcuM_OnFailedNvmWriteAllJobReaction </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>124 / 134 </p>
<p><b>5.7.4.9 </b></p>
<p><b>EcuM_OnWakeupReaction </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_OnWakeupReaction </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none  </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of additional activities in WAKEUP_REACTION state.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in task context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Called in ECUM_STATE_WAKEUP_REACTION state. </p>
<p>Table 5-80  </p>
<p>EcuM_OnFailedNvmWriteAllJobReaction </p>
<p><b>5.7.4.10 </b></p>
<p><b>EcuM_OnRTEStartup </b></p>
<p><b>Prototype </b></p>
<p>void <b>EcuM_OnRTEStartup </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none  </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Allows the execution of activities before starting the RTE.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>This function has to be filled with code by the integrator. </p>
<p>Call Context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Invoked in task context </p>
<p><b></b></p>
<p><b> </b></p>
<p>Called before Rte_Start() is executed. Module state: STARTUP </p>
<p>Table 5-81  </p>
<p>EcuM_OnRTEStartup </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>125 / 134 </p>
<p><b>5.8 </b></p>
<p><b>Service Ports  </b></p>
<p><b>5.8.1 </b></p>
<p><b>Client Server Interface </b></p>
<p>A client server interface is related to a Provide Port at the server side and a Require Port </p>
<p>at client side.  </p>
<p><b>5.8.1.1 </b></p>
<p><b>Provide Ports on EcuM Side </b></p>
<p>At  the  Provide  Ports  of  the  EcuM  the  API  functions  described  in  5.2  are  available  as </p>
<p>Runnable Entities. The Runnable Entities are invoked via Operations. The mapping from a </p>
<p>SWC client call to an Operation is performed by the RTE. In this mapping the RTE adds </p>
<p>Port Defined Argument Values to the client call of the SWC, if configured. </p>
<p>The  following  sub-chapters  present  the  Provide  Ports  defined  for  the  EcuM  and  the </p>
<p>Operations defined for the Provide Ports, the API functions related to the Operations to be </p>
<p>added by the RTE. </p>
<p> </p>
<p><b>5.8.1.1.1 </b></p>
<p><b>ShutdownTarget Port </b></p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p>SelectShutdownTarget </p>
<p>EcuM_SelectShutdownTarget() </p>
<p>GetLastShutdownTarget </p>
<p>EcuM_GetLastShutdownTarget() </p>
<p>GetShutdownTarget </p>
<p>EcuM_GetShutdownTarget() </p>
<p>SelectShutdownCause </p>
<p>EcuM_SelectShutdownCause() </p>
<p>GetShutdownCause </p>
<p>EcuM_GetShutdownCause() </p>
<p>Table 5-82  </p>
<p>Shutdown Target Port </p>
<p><b>5.8.1.1.2 </b></p>
<p><b>BootTarget Port </b></p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p>SelectBootTarget </p>
<p>EcuM_SelectBootTarget() </p>
<p>GetBootTarget </p>
<p>EcuM_GetBootTarget() </p>
<p>Table 5-83  </p>
<p>BootTarget Port </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>126 / 134 </p>
<p><b>5.8.1.1.3 </b></p>
<p><b>AlarmClock Port </b></p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p>SelectRelWakeupAlarm </p>
<p>EcuM_SelectRelWakeupAlarm() </p>
<p>SelectAbsWakeupAlarm </p>
<p>EcuM_SelectAbsWakeupAlarm() </p>
<p>AbortWakeupAlarm </p>
<p>EcuM_AbortWakeupAlarm() </p>
<p>GetCurrentTime </p>
<p>EcuM_GetCurrentTime() </p>
<p>GetWakeupTime </p>
<p>EcuM_GetWakeupTime() </p>
<p>SetClock </p>
<p>EcuM_SetClock() </p>
<p>Table 5-84  </p>
<p>AlarmClock Port </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The AlarmClock Port is only available in case of EcuM flex. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>5.8.1.1.4 </b></p>
<p><b>StateRequest Port </b></p>
<p> </p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p><b>Port Defined Argument Value </b></p>
<p>RequestRUN </p>
<p>EcuM_RequestRUN() </p>
<p>EcuM_UserType UserId </p>
<p>ReleaseRUN </p>
<p>EcuM_ReleaseRUN() </p>
<p>EcuM_UserType UserId </p>
<p>RequestPOST_RUN </p>
<p>EcuM_RequestPOST_RUN() </p>
<p>EcuM_UserType UserId </p>
<p>ReleasePOST_RUN </p>
<p>EcuM_ReleasePOST_RUN() </p>
<p>EcuM_UserType UserId </p>
<p>GetState </p>
<p>EcuM_GetStateWrapper() </p>
<p>EcuM_UserType UserId </p>
<p>Table 5-85  </p>
<p>StateRequest Port </p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>The GetState operation above is mapped to an additional API function </p>
<p>EcuM_GetStateWrapper()</p>
<p> which has to be introduced to be compliant with ASR3 </p>
<p>Microsar EcuM. This API is not described in chapter 5.2 because the functionality is the </p>
<p>same as </p>
<p>EcuM_GetState().</p>
<p> </p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>127 / 134 </p>
<p><b>5.8.1.2 </b></p>
<p><b>Require Ports on EcuM Side </b></p>
<p>The EcuM calls operations at its Require Ports. These Operations have to be provided by </p>
<p>the  SWCs  by </p>
<p>means  of  Runnable  Entities.  These  Runnable  Entities  implement  the </p>
<p>callback functions expected by the EcuM. </p>
<p>The following sub-chapters present the Require Port defined for the EcuM, the Operations </p>
<p>that are called from the EcuM and the related Notifications. </p>
<p><b>5.8.1.2.1 </b></p>
<p><b>currentMode Port </b></p>
<p><b>Operation </b></p>
<p><b>RTE Interface </b></p>
<p><b>Mode Declaration Group </b></p>
<p>currentMode </p>
<p>Rte_Switch_currentMode_currentMode </p>
<p>STARTUP </p>
<p>RUN </p>
<p>POST_RUN </p>
<p>SLEEP </p>
<p>WAKE_SLEEP </p>
<p>SHUTDOWN </p>
<p>Table 5-86  </p>
<p>currentMode Port </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The Ports CurrentMode and StateRequest are only available in case of EcuM fixed. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>128 / 134 </p>
<p><b>6 </b></p>
<p><b>AUTOSAR Standard Compliance </b></p>
<p><b>6.1 </b></p>
<p><b>Deviations </b></p>
<p><b>6.1.1 </b></p>
<p><b>Deviation in the Naming of API Parameters </b></p>
<p><b>6.1.1.1 </b></p>
<p><b>ResetSleepMode </b></p>
<p>The parameter “mode” has been changed to “resetSleepMode” for the following APIs: </p>
<p><b>&gt; </b></p>
<p>EcuM_GetLastShutdownTarget() </p>
<p><b>&gt; </b></p>
<p>EcuM_GetShutdownTarget() </p>
<p><b>&gt; </b></p>
<p>EcuM_SelectShutdownTarget() </p>
<p><b>6.1.1.2 </b></p>
<p><b>TargetState </b></p>
<p>The parameter “target” has been changed to “targetState” for the following API: </p>
<p><b>&gt; </b></p>
<p>EcuM_SelectShutdownTarget() </p>
<p><b>6.1.1.3 </b></p>
<p><b>ShutdownTarget </b></p>
<p>The parameter “shutdownTarget” has been changed to “target” for the following API: </p>
<p><b>&gt; </b></p>
<p>EcuM_GetShutdownTarget() </p>
<p><b>&gt; </b></p>
<p>EcuM_GetLastShutdownTarget() </p>
<p><b>6.1.1.4 </b></p>
<p><b>Target (ShutdownTarget) </b></p>
<p>The parameter “target” has been changed to “shutdownCause” for the following API: </p>
<p><b>&gt; </b></p>
<p>EcuM_SelectShutdownCause() </p>
<p><b>6.1.1.5 </b></p>
<p><b>Target (BootTarget) </b></p>
<p>The parameter “target” has been changed to “BootTarget” for the following API: </p>
<p><b>&gt; </b></p>
<p>EcuM_SelectBootTarget() </p>
<p><b>&gt; </b></p>
<p>EcuM_GetBootTarget() </p>
<p><b>6.1.1.6 </b></p>
<p><b>Sources </b></p>
<p>The parameter “sources” has been changed to “WakeupSource” for the following API: </p>
<p><b>&gt; </b></p>
<p>EcuM_ClearWakeupEvent() </p>
<p><b>&gt; </b></p>
<p>EcuM_SetWakeupEvent() </p>
<p><b>&gt; </b></p>
<p>EcuM_ValidateWakeupEvent() </p>
<p><b>6.1.2 </b></p>
<p><b>Starting of the Validation Timer </b></p>
<p>The validation timer is not started by calling EcuM_SetWakeupEvent(), instead it is started </p>
<p>with the next MainFunctionCycle. </p>
<p><b>6.1.3 </b></p>
<p><b>Multiplicity of Parameters </b></p>
<p><b>6.1.3.1 </b></p>
<p><b> EcuMResetReasonRef </b></p>
<p>The parameter has been changed to optional so that not every wake-up source must have </p>
<p>configured an Mcu reset reason. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>129 / 134 </p>
<p><b>6.1.3.2 </b></p>
<p><b>EcuMSleepMode </b></p>
<p>The parameter has been changed to optional to allow code optimization on ECUs without </p>
<p>the possibility to switch ECUM_STATE_OFF. </p>
<p><b>6.1.3.3 </b></p>
<p><b>EcuMConfigConsistencyHash </b></p>
<p>The parameter has been changed to optional because it is only necessary in the case of </p>
<p>variant post build. </p>
<p><b>6.1.3.4 </b></p>
<p><b>Removed parameter ConfigPtr from DriverInit Lists </b></p>
<p>Removed the parameter ConfigPtr from the prototypes of the following Callouts: </p>
<p><b>&gt; </b></p>
<p>EcuM_AL_DriverInitOne() </p>
<p><b>&gt; </b></p>
<p>EcuM_AL_DriverInitTwo() </p>
<p><b>&gt; </b></p>
<p>EcuM_AL_DriverInitThree() </p>
<p> </p>
<p><b>6.2 </b></p>
<p><b>Additions/ Extensions </b></p>
<p><b>6.2.1 </b></p>
<p><b>Additional Configuration Parameters  </b></p>
<p>To fulfill the jobs of the EcuM some more parameters beyond the AUTOSAR specification </p>
<p>are needed. The description of these parameters can be found in the BSWMD file which is </p>
<p>part of the delivery. </p>
<p>The following containers are added: </p>
<p><b>&gt; </b></p>
<p>EcuMDriverInitListBswM </p>
<p> </p>
<p>The following parameters are added: </p>
<p><b>&gt; </b></p>
<p>EcuMAdditionalInitCode </p>
<p><b>&gt; </b></p>
<p>EcuMGoDownRequestID </p>
<p><b>&gt; </b></p>
<p>EcuMAdditionalIncludes </p>
<p><b>&gt; </b></p>
<p>EcuMUserConfigurationFile </p>
<p><b>&gt; </b></p>
<p>EcuMCheckWakeupTimeout </p>
<p><b>&gt; </b></p>
<p>EcuMDeferredBswMNotification </p>
<p><b>&gt; </b></p>
<p>EcuMGptChannelRef </p>
<p><b>&gt; </b></p>
<p>EcuMSlaveCoreHandling </p>
<p><b>&gt; </b></p>
<p>EcuMGenModeSwitchPort </p>
<p><b>&gt; </b></p>
<p>EcuMIncludeDem </p>
<p><b>&gt; </b></p>
<p>EcuMModeSwitchRteAck </p>
<p><b>&gt; </b></p>
<p>EcuMGenModeSwitchPort </p>
<p><b>&gt; </b></p>
<p>EcuMNvmCancelWriteAllTimeout </p>
<p><b>&gt; </b></p>
<p>EcuMEnableFixBehavior </p>
<p><b>&gt; </b></p>
<p>EcuMBswCoreId </p>
<p><b>6.2.2 </b></p>
<p><b>Buffering of Wake ups if the BswM is Not Initialized </b></p>
<p>In  early phases  of  the ECU,  wake-up  events  can occur and should  not  be  missed.  The </p>
<p>EcuM detects these Wake-up Events and if the BswM is not initialized  the Event  will be </p>
<p>buffered and reported to the BswM as soon as the BswM is initialized by the EcuM. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>130 / 134 </p>
<p><b>6.2.3 </b></p>
<p><b>Buffering of Wake ups if the ComM is Not Initialized </b></p>
<p>In  early phases  of  the ECU,  wake-up  events  can occur and should  not  be  missed. The </p>
<p>EcuM checks if the ComM is active by the routine ComM_GetStatus(), if the ComM is not </p>
<p>active in this  phase the  Wake-up Event is also buffered. In the EcuM_MainFunction the </p>
<p>EcuM checks if the ComM is still uninitialized and the Wake-up Event is reported as soon </p>
<p>as possible to the ComM.  </p>
<p><b>6.2.4 </b></p>
<p><b>Additional API EcuM_ClearValidatedWakeupEvent </b></p>
<p>The  EcuM  implements  an API  to  clear  only  the  validated  wakeup  events. A  call  of  the </p>
<p>regular  API  EcuM_ClearWakeupEvent  leads  to  a  clear  of  all  events,  pending  wakeup </p>
<p>events will be lost in this case. </p>
<p>It is necessary to clear the validated wakeup events to enter a sleep mode or shutdown </p>
<p>the Ecu. </p>
<p><b>6.2.5 </b></p>
<p><b>Support of Asynchronous Transceiver Handling </b></p>
<p>To  support  asynchronous  transceiver  handling  a  check-wakeup  validation  timeout  was </p>
<p>introduced </p>
<p>for </p>
<p>wake-up </p>
<p>sources </p>
<p>which </p>
<p>cannot </p>
<p>be </p>
<p>checked </p>
<p>in </p>
<p>the </p>
<p>context </p>
<p>of </p>
<p>EcuM_CheckWakeup. </p>
<p><b>6.2.6 </b></p>
<p><b>Deferred notification of the BswM about wake-up events </b></p>
<p>To prevent that the notification via BswM_EcuM_CurrentWakeup() is executed in context </p>
<p>of an interrupt (via EcuM_SetWakeupEvent or EcuM_ValidateWakeupEvent), the </p>
<p>notification can be deferred to the next cycle of the EcuM_MainFunction. If the notification </p>
<p>is executed deferred or not can be configured via the parameter </p>
<p>EcuMDeferredBswMNotification. </p>
<p> </p>
<p><b>6.2.7 </b></p>
<p><b>Additional Callback EcuM_AlarmCheckWakeup </b></p>
<p>This  callback  is  called  by  the  Gpt  every  second  to  increment  the  EcuM  clock  which  is </p>
<p>provided by the alarm clock feature. </p>
<p><b>6.2.8 </b></p>
<p><b>Additional API EcuM_GoToSelectedShutdownTarget </b></p>
<p>This  API  can  be  called  e.g.  from  the  BswM  without  knowledge  about  the  currently </p>
<p>configured  shutdown  target.  The  EcuM  decides  if  EcuM_GoHalt(),  EcuM_GoPoll()  or </p>
<p>EcuM_GoDown() has to be called. </p>
<p><b>6.2.9 </b></p>
<p><b>Additional Callout EcuM_WaitForSlaveCores </b></p>
<p>This </p>
<p>callout </p>
<p>is </p>
<p>only </p>
<p>active </p>
<p>in </p>
<p>case </p>
<p>of </p>
<p>MultiCore </p>
<p>and </p>
<p>if </p>
<p>the </p>
<p>parameter </p>
<p>EcuMSlaveCoreHandling  is set true.  In  this case,  the  EcuM  Master Core  calls cyclically </p>
<p>this callout. It can be used to initiate that the sleep is also entered on the slave core. </p>
<p><b>6.2.10 </b></p>
<p><b>Support of EcuM fixed </b></p>
<p>The EcuM supports the EcuM with fixed state machine. The EcuM fixed can be configured </p>
<p>without EcuM flex or combined. </p>
<p><b>6.2.10.1 </b></p>
<p><b>Shutdown Target ECUM_STATE_RESET </b></p>
<p>The shutdown target ECUM_STATE_RESET is available and the callout EcuM_AL_Reset </p>
<p>is available, independent of EcuM_Flex configuration. The ResetMode parameter will be </p>
<p>passed to EcuM_AL_Reset but EcuM does not check  if the parameter is valid, because </p>
<p>this is a EcuM flex parameter. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>131 / 134 </p>
<p><b>6.2.10.2 </b></p>
<p><b>Synchronization of EcuM and RTE modes </b></p>
<p>Some transitions in the EcuM state machine lead to RTE mode switch notifications via the </p>
<p>API Rte_Switch_currentMode_currentMode(). </p>
<p>If the acknowledge mechanism of the EcuM is configured active, EcuM remains in its state </p>
<p>until the RTE has acknowledged the current mode switch. </p>
<p><b>6.3 </b></p>
<p><b>Limitations </b></p>
<p><b>6.3.1 </b></p>
<p><b>Inter Module Checks </b></p>
<p>The EcuM does not check the AUTOSAR version of included external modules. </p>
<p><b>6.3.2 </b></p>
<p><b>Recording of Shutdown Causes </b></p>
<p>The EcuM does not support the facility to record recent shutdown causes. Therefore the </p>
<p>following two APIs are not supported: </p>
<p><b>&gt; </b></p>
<p>EcuM_GetMostRecentShutdown() </p>
<p><b>&gt; </b></p>
<p>EcuM_GetNextRecentShutdown() </p>
<p><b>6.3.3 </b></p>
<p><b>Not Supported Configuration Parameters and Containers </b></p>
<p>Some of the specified configuration parameters are not supported. These parameters are </p>
<p>marked with the addition “Not used” in the corresponding parameter description. The </p>
<p>description is located within the module’s BSWMD file which is part of the delivery. </p>
<p>The following containers (including the parameters) are not supported in this release: </p>
<p><b>&gt; </b></p>
<p>EcuMShutdownTarget </p>
<p><b>&gt; </b></p>
<p>EcuMTTII </p>
<p>The following parameters are not supported in this release: </p>
<p><b>&gt; </b></p>
<p>EcuMSleepModeSuspend </p>
<p><b>&gt; </b></p>
<p>EcuMAlarmClockTimeOut </p>
<p><b>&gt; </b></p>
<p>EcuMFlexEcucPartitionRef </p>
<p><b>&gt; </b></p>
<p>EcuMResetLoopDetection </p>
<p><b>&gt; </b></p>
<p>EcuMIncludeDem </p>
<p><b>&gt; </b></p>
<p>EcuMIncludeDet </p>
<p><b>&gt; </b></p>
<p>EcuMNvramReadallTimeout </p>
<p><b>&gt; </b></p>
<p>EcuMIncludeNvM </p>
<p><b>&gt; </b></p>
<p>EcuMTTIIEnabled </p>
<p><b>&gt; </b></p>
<p>EcuMTTIIWakeupSourceRef </p>
<p> </p>
<p><b>6.3.4 </b></p>
<p><b>Wake-up Events after Reset Reason Translation are not Validated </b></p>
<p>During the initialization the EcuM get the reason for the current startup via the Mcu reset </p>
<p>reason translation. For this translated events the wake-up validation is not performed. </p>
<p><b>6.3.5 </b></p>
<p><b>EcuM Fixed Limitations </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>NvM_ReadAll() is not started by the EcuM. This can be done by the integrator e.g. </p>
<p>in DriverInitListTwo(). </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_AL_Reset is available, independent of EcuM_Flex configuration. ResetMode </p>
<p>parameter will be passed to EcuM_AL_Reset, but EcuM checks not if the parameter </p>
<p>is valid. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>132 / 134 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TTII  is  not  supported.  As  a  consequence,  the  callout  EcuM_OnWakeupReaction </p>
<p>has no parameter and no return value. </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_WakeupReactionType is not supported. </p>
<p><b></b></p>
<p><b> </b></p>
<p>EcuM_GetStatusOfWakeupSource is not supported. </p>
<p><b></b></p>
<p><b> </b></p>
<p>The  following  APIs </p>
<p>are </p>
<p>not </p>
<p>available </p>
<p>if </p>
<p>EcuM </p>
<p>flex </p>
<p>and </p>
<p>EcuM  fixed </p>
<p>are </p>
<p>both </p>
<p>configured: </p>
<p><b>&gt; </b></p>
<p>EcuM_GoHalt </p>
<p><b>&gt; </b></p>
<p>EcuM_GoPoll </p>
<p><b>&gt; </b></p>
<p>EcuM_GoDown </p>
<p><b>&gt; </b></p>
<p>EcuM_GoToSelectedShutdownTarget </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>133 / 134 </p>
<p><b>7 </b></p>
<p><b>Glossary and Abbreviations </b></p>
<p><b>7.1 </b></p>
<p><b>Glossary </b></p>
<p><b>Term </b></p>
<p><b>Description </b></p>
<p>Configuration Tool </p>
<p>Tool for generation like DaVinci Configurator Pro </p>
<p>MSN </p>
<p>Module Short Name, the AUTOSAR short name of the module, e.g. Can, </p>
<p>CanIf, EcuM, etc. </p>
<p>Table 7-1  </p>
<p>Glossary </p>
<p><b>7.2 </b></p>
<p><b>Abbreviations </b></p>
<p><b>Abbreviation </b></p>
<p><b>Description </b></p>
<p>API </p>
<p>Application Programming Interface </p>
<p> </p>
<p>AUTOSAR </p>
<p>Automotive Open System Architecture </p>
<p>BSW </p>
<p>Basis Software </p>
<p>BSWMD </p>
<p>Basic Software Module Description </p>
<p>BswM </p>
<p>Basis Software Mode Manager </p>
<p>CAN </p>
<p>Controller Area Network </p>
<p>ComM </p>
<p>Communication Manager </p>
<p>DEM </p>
<p>Diagnostic Event Manager </p>
<p>DET </p>
<p>Development Error Tracer </p>
<p>ECU </p>
<p>Electronic Control Unit </p>
<p>EcuC </p>
<p>ECU configuration description </p>
<p>HIS </p>
<p>Hersteller Initiative Software </p>
<p>Gpt </p>
<p>General Purpose Timer </p>
<p>ICU </p>
<p>Input Capture Unit </p>
<p>ISR </p>
<p>Interrupt Service Routine </p>
<p>MCU </p>
<p>Microcontroller Unit </p>
<p>MICROSAR </p>
<p>Microcontroller Open System Architecture (the Vector AUTOSAR </p>
<p>solution) </p>
<p>MSN </p>
<p>Module Short Name </p>
<p>PLL </p>
<p>Phase Locked Loop </p>
<p>RTE </p>
<p>Runtime Environment </p>
<p>SchM </p>
<p>Scheduling Manager </p>
<p>SRS </p>
<p>Software Requirement Specification </p>
<p>SWC </p>
<p>Software Component </p>
<p>SWS </p>
<p>Software Specification </p>
<p>Table 7-2  </p>
<p>Abbreviations </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR EcuM Flex </p>
<p></p>
<p>2015, Vector Informatik GmbH </p>
<p>Version: 5.00.00 </p>
<p>based on template version 4.8.3 </p>
<p>134 / 134 </p>
<p><b>8 </b></p>
<p><b>Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p><b>&gt; </b></p>
<p>News </p>
<p><b>&gt; </b></p>
<p>Products </p>
<p><b>&gt; </b></p>
<p>Demo software </p>
<p><b>&gt; </b></p>
<p>Support </p>
<p><b>&gt; </b></p>
<p>Training data </p>
<p><b>&gt; </b></p>
<p>Addresses </p>
<p> </p>
<p>www.vector.com </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
</body>
</html>
{% endraw %}