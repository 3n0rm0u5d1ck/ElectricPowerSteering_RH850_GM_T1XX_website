---
layout: default
title: KnownIssues_P1x_R403_2015_CW23
nav_order: 2
parent: Renesas Mcal Support
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p>ID</p>
<p>Category</p>
<p>Summary</p>
<p>Description</p>
<p>ASR_TicketType</p>
<p>Status</p>
<p>22712</p>
<p>General</p>
<p>Usage of value INF not according ASR </p>
<p>requirements</p>
<p>Problem description: </p>
<p>According AUTOSAR_TPS_ECUConfiguration the value 'inf' derived from standard module definition STMD must be used as follows: </p>
<p>• [ecuc_sws_6045] If the min value equals -inf or the max value equals inf in </p>
<p>the StMD the min/max values in the VSMD shall be replaced with the actually </p>
<p>supported min/max values for this implementation. </p>
<p> </p>
<p>Expected behavior: </p>
<p>INF shall not be used, but instead the actual MIN/MAX values shall be available in PDFs </p>
<p> </p>
<p>Current behavior: </p>
<p>See problem description field.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>26927</p>
<p>General</p>
<p>[Port] </p>
<p>AUTOSAR_PORT_Component_UserManual.</p>
<p>pdf is lacking information about Exclusives </p>
<p>areas for CRITICAL SECTION PROTECTION</p>
<p>Problem description: </p>
<p>Lack of information about Exclusives areas in AUTOSAR_PORT_Component_UserManual.pdf. As a result user is facing difficulty during integration. </p>
<p>Source Package: AUTOSAR_RH850_P1x_MCAL_E4.03 </p>
<p> </p>
<p>Expected Behavior: </p>
<p>The user manual should contain information about INIT_CONFIG_PROTECTION, REFRESH_PORT_INTERNAL_PROTECTION and SET_TO_DIO_ALT_PROTECTION. </p>
<p> </p>
<p>Actual behaviour: </p>
<p>UM only describes SET_PIN_MODE_PROTECTION in chapter 4.4, but SET_PIN_DIR_PROTECTION, INIT_CONFIG_PROTECTION, REFRESH_PORT_INTERNAL_PROTECTION and </p>
<p>SET_TO_DIO_ALT_PROTECTION, SET_PIN_DEFAULT_MODE_PROTECTION, SET_PIN_DEFAULT_DIR_PROTECTION are not mentioned.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>26988</p>
<p>General</p>
<p>CAN and LIN modules not following </p>
<p>Autosar requirement BSW00347</p>
<p>Problem description: </p>
<p>As per AUTOSAR requirement BSW00347, the driver modules shall be named as per &lt;MSN&gt;_&lt;VendorId&gt;_&lt;VendorSpecificName&gt;_&lt;ServiceName&gt;. </p>
<p>For Example : 'Can_Init()' will become 'Can_59_Renesas_Init()'.  </p>
<p>It shall be followed for File Names, Public APIs, Published Parameters, Memory allocation Keywords and Public data types. But this is not followed in CAN and LIN modules which support </p>
<p>multiple instance as per autosar base definition file. </p>
<p> </p>
<p>Expected behaviour: </p>
<p>The driver modules shall be named as per &lt;MSN&gt;_&lt;VendorId&gt;_&lt;VendorSpecificName&gt;_&lt;ServiceName&gt;. </p>
<p> </p>
<p></p>
<p>Actual behaviour:</p>
<p> </p>
<p>The driver modules(CAN and LIN) are not named as per &lt;MSN&gt;_&lt;VendorId&gt;_&lt;VendorSpecificName&gt;_&lt;ServiceName&gt;. </p>
<p> </p>
<p>The following MCAL modules have the tag 'UPPER-MULTIPLICITY-INFINITE' is set to 'true' in Autosar Base Definition file AUTOSAR_MOD_ECUConfigurationParameters.arxml and hence </p>
<p>support multiple instance. </p>
<p>1. CAN </p>
<p>2. Ethernet </p>
<p>3. FLS </p>
<p>4. Flexray </p>
<p>5. ICU </p>
<p>6. LIN </p>
<p>7. PWM </p>
<p>8. WDG </p>
<p>But for Ethernet, FLS, ICU, and PWM modules, the requirement BSW00347 is moved to NA requirements in the Traceability section.  </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>27639</p>
<p>General</p>
<p>PRAGMA define inconsistent to device </p>
<p>header file package</p>
<p>&lt;u&gt;Problem Description:&lt;/u&gt; </p>
<p>PRAGMA define differs between io_macros_v2.h from device header file packages and compiler.h in MCAL package. </p>
<p> </p>
<p>In Compiler.h: </p>
<p>#define PRAGMA(x) _Pragma(x) </p>
<p> </p>
<p>In io_macros_v2.h: </p>
<p>#define PRAGMA(x) _Pragma(#x) </p>
<p> </p>
<p>&lt;u&gt;Current Behaviour:&lt;/u&gt; </p>
<p>In customer application this might cause a compilation warning due to a macro redefinition if both header files are used. </p>
<p> </p>
<p>&lt;u&gt;Expected Behaviour:&lt;/u&gt; </p>
<p>Consistent define used in both header files. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27721</p>
<p>General</p>
<p>Command line option -F not working</p>
<p>Problem description: </p>
<p>The -F/FILEVERSION option of generation tool is not working. Instead of listing the version of tool code files, the tool is throwing error 'ERR000011:ECU Configuration Description File is </p>
<p>not provided as input to the Generation Tool'. </p>
<p> </p>
<p>Expected behavior: </p>
<p>On the usage of -F/FILEVERSION option, generation tool must list the version of tool code files. </p>
<p> </p>
<p>Actual behaviour: </p>
<p>See Problem description. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27747</p>
<p>General</p>
<p>Makefiles use invalid include paths for GHS </p>
<p>builder</p>
<p>Problem Description: </p>
<p>The GHS makefiles for sample applications use invalid include paths parameters. </p>
<p>This behaviour has currently no effect to GHS builder but this might change. </p>
<p>It lengthens the command lines without any use. </p>
<p> </p>
<p>Actual behaviour: </p>
<p>GHS builder is called with invalid options like </p>
<p>-I\4.0.3 </p>
<p>-I\common </p>
<p> </p>
<p>Expected behaviour: </p>
<p>Only valid include path parameters shall be used.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27766</p>
<p>General</p>
<p>Functional codes are executing Even after </p>
<p>DEM is reported.</p>
<p>Problem Description: </p>
<p> </p>
<p>Even after DEM error is reported, functional codes are getting executed, which may result in unexpected behavior of driver.  </p>
<p> </p>
<p>Similar issue is found in SPI while doing functional testing for E1x V4.00.04 release, And an issue is reported in mantis # bug:26731. </p>
<p> </p>
<p>Decided to create new ticket to start  investigation for similar issues in all other module (see note:181849). </p>
<p> </p>
<p> </p>
<p> </p>
<p>Expected behavior:  </p>
<p>Functional codes shall not execute after reporting DEM Error. </p>
<p> </p>
<p> </p>
<p>Actual behavior:  </p>
<p>Functional codes are executed even after reporting DEM Error. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>27974</p>
<p>General</p>
<p>Makefiles specify irrelevant folders for </p>
<p>header search</p>
<p>Problem description: </p>
<p>The -I parameter is used to specify folders where the GHS builder shall search for header files. But also source folders are given. </p>
<p> </p>
<p>Actual behaviour: </p>
<p>Many irrelevant folders are given as parameter to GHS builder. When project becomes large the maximum command line length (8k) is exceeded. </p>
<p> </p>
<p>Expected behaviour: </p>
<p>Only relevant folders shall be given with -I parameter.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28478</p>
<p>General</p>
<p>CAN-ENTER-EXCLUSIVE-AREA-REF tag is </p>
<p>missing in the BSWMDT</p>
<p>canEnterExclusiveArea is required inside the entity in BSWMDT, if the referenced exclusive area is used in the entity's code.  </p>
<p>The entity can be BswCalledEntity, BswSchedulableEntity or BswInterruptEntity. </p>
<p> </p>
<p> </p>
<p>Actual behaviour: </p>
<p> </p>
<p>&lt;BSW-INTERNAL-BEHAVIOR UUID=&quot;ECUS:951843a9-6848-4a8d-869a-7b29a87158fa&quot;&gt; </p>
<p>  &lt;SHORT-NAME&gt;BswInternalBehavior_0&lt;/SHORT-NAME&gt; </p>
<p>    &lt;EXCLUSIVE-AREA UUID=&quot;ECUS:1b965de4-5e4a-49d8-a4cb-e7782386f347&quot;&gt; </p>
<p>      &lt;SHORT-NAME&gt;VARIABLE_PROTECTION&lt;/SHORT-NAME&gt; </p>
<p>    &lt;/EXCLUSIVE-AREA&gt; </p>
<p>  &lt;/EXCLUSIVE-AREAS&gt; </p>
<p>  &lt;ENTITYS&gt; </p>
<p>    &lt;BSW-INTERRUPT-ENTITY UUID=&quot;ECUS:8d9d01cd-59a4-4f9d-a0c5-a46966e1b2ad&quot;&gt; </p>
<p>      &lt;SHORT-NAME&gt;BswInterruptEntity_1&lt;/SHORT-NAME&gt; </p>
<p>      &lt;IMPLEMENTED-ENTRY-REF DEST=&quot;BSW-MODULE-ENTRY&quot;&gt;/ArPackage_0/MCU_FEINT_ISR&lt;/IMPLEMENTED-ENTRY-REF&gt; </p>
<p>      &lt;INTERRUPT-CATEGORY&gt;CAT-1&lt;/INTERRUPT-CATEGORY&gt; </p>
<p>      &lt;INTERRUPT-SOURCE&gt;INTLVI&lt;/INTERRUPT-SOURCE&gt; </p>
<p>    &lt;/BSW-INTERRUPT-ENTITY&gt; </p>
<p> </p>
<p>Expected behaviour: </p>
<p> </p>
<p>&lt;BSW-INTERNAL-BEHAVIOR UUID=&quot;ECUS:951843a9-6848-4a8d-869a-7b29a87158fa&quot;&gt; </p>
<p>  &lt;SHORT-NAME&gt;BswInternalBehavior_0&lt;/SHORT-NAME&gt; </p>
<p>    &lt;EXCLUSIVE-AREA UUID=&quot;ECUS:1b965de4-5e4a-49d8-a4cb-e7782386f347&quot;&gt; </p>
<p>      &lt;SHORT-NAME&gt;VARIABLE_PROTECTION&lt;/SHORT-NAME&gt; </p>
<p>    &lt;/EXCLUSIVE-AREA&gt; </p>
<p>  &lt;/EXCLUSIVE-AREAS&gt; </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28534</p>
<p>General</p>
<p>Wrong upper multiplicity definition for </p>
<p>Configuration container.</p>
<p>Problem description: </p>
<p>In PDF of some MCAL modules the upper multiplicity is defined as </p>
<p>&lt;UPPER-MULTIPLICITY-INFINITE&gt;XX&lt;/UPPER-MULTIPLICITY-INFINITE&gt; </p>
<p> </p>
<p>The above definitions are not correct according to ASR ecuc_sws_2011. </p>
<p> </p>
<p> </p>
<p>Actual behavior: </p>
<p>Multiple configuration is not possible due to the above problem. </p>
<p> </p>
<p>Expected behavior: </p>
<p>The correct definitions must be as follows: </p>
<p>&lt;UPPER-MULTIPLICITY&gt;XX&lt;/UPPER-MULTIPLICITY&gt;</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>26812</p>
<p>ADC</p>
<p>Unexpected DET ADC_E_IDLE is been raised </p>
<p>from Adc_DisableHardware Trigger</p>
<p>Problem Description: </p>
<p>Unexpected DET ADC_E_IDLE is being raised when Adc_DisableHardwareTrigger is invoked for an already enabled group (using the api Adc_EnableHardwareTrigger)whose status is </p>
<p>ADC_STREAM_COMPLETED. </p>
<p> </p>
<p>Expected Behaviour : </p>
<p>As  per requirement ADC304, the DET ADC_E_IDLE should not be reported when Adc_DisableHardwareTrigger is called for a group that has already been enabled using </p>
<p>Adc_EnableHardwareTrigger. </p>
<p> </p>
<p>Actual Behaviour : </p>
<p>The DET ADC_E_IDLE is reported when Adc_DisableHardwareTrigger is called for a group that has already been enabled using Adc_EnableHardwareTrigger. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27492</p>
<p>ADC</p>
<p>HW triggered One-shot conversion in </p>
<p>Circular Streaming is not working as </p>
<p>expected</p>
<p>Problem Description: </p>
<p>As per AUTOSAR specification, one HW trigger should trigger only one ADC channel group conversion stream. The conversion must finish once it receives the HW trigger that is equal to </p>
<p>number of streams configured for the group.  </p>
<p> </p>
<p>But in the current design single trigger executes the whole stream of conversions. </p>
<p> </p>
<p>Expected Behavior:  </p>
<p>Only one ADC channel Group conversion stream should happen per H/W trigger. </p>
<p> </p>
<p>Actual Behavior: </p>
<p>Streaming conversion is getting completed with single H/W trigger</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27505</p>
<p>ADC</p>
<p>'ucGroupSettings' element of </p>
<p>Adc_GstGroupConfig[] is not generated </p>
<p>properly</p>
<p>Problem Description: </p>
<p>LSB of 'ucGroupSettings' element decides whether a group is one-shot or continuous.  </p>
<p>'0' means continuous group and  </p>
<p>'1' means one-shot group. </p>
<p>But code generator is not generating this properly. </p>
<p>For one-shot mode and circular streaming group it generates '1' and </p>
<p>for continuous mode and linear streaming group it generates '0'  </p>
<p> </p>
<p>Expected Behavior:  </p>
<p>LSB of 'ucGroupSettings' must be '0' for continuous group and '1' for one-shot group. </p>
<p> </p>
<p> </p>
<p>Actual Behavior: </p>
<p>Code generator is generating the below values, </p>
<p>For one-shot mode and circular streaming group it is generates '1' and </p>
<p>for continuous mode and linear streaming group it generates '0' </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27592</p>
<p>ADC</p>
<p>DMA enabled ADC conversion gives wrong </p>
<p>conversion result if DTFRRQn register </p>
<p>signals a pending transfer request</p>
<p>Problem description: </p>
<p> </p>
<p>Conversion of an ADC group with 'AdcResultAccessMode' =&gt; 'ADC_ISR_ACCESS' (Group without DMA) leads to the flagging of DTFRRQn.DRQ bit. </p>
<p> </p>
<p>Conversion of an ADC group with 'AdcResultAccessMode' =&gt; 'ADC_DMA_ACCESS' (DMA enabled group) when DTFRRQn.DRQ bit already set leads to the return of converted value from </p>
<p>previous cycle. </p>
<p> </p>
<p>Therefore DTFRRQn.DRQ bit must be cleared each time when DMA enabled ADC groups conversion is started. </p>
<p> </p>
<p> </p>
<p>Expected Behavior: </p>
<p>DMA enabled ADC Groups should return the converted result of the current input voltage. </p>
<p> </p>
<p> </p>
<p>Actual Behavior: </p>
<p>DMA enabled ADC Groups are not returning the converted result of the current input voltage because of already set DTFRRQn.DRQ bit.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>27603</p>
<p>ADC</p>
<p>Conversion of a DMA enabled one-shot </p>
<p>ADC group is happening only for the first </p>
<p>HW trigger and not for the next triggers</p>
<p>Problem description: </p>
<p>One-shot ADC groups with DMA as result access mode is getting converted only for the first trigger and not for the consecutive triggers.  </p>
<p> </p>
<p>Note that if the result access mode is selected as interrupt then it is working as expected. </p>
<p> </p>
<p>Expected Behavior: </p>
<p>One-shot ADC groups with DMA as result access mode should convert the group channels for every HW trigger until it is stopped explicitly by Adc_DisableHardwareTrigger() </p>
<p> </p>
<p>Actual Behavior: </p>
<p>One-shot ADC groups with DMA as result access mode is getting converted only for the first trigger and not for the consecutive triggers after enabling the group via </p>
<p>Adc_EnableHardwareTrigger()</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27613</p>
<p>ADC</p>
<p>HW triggered ADC group with DMA circular </p>
<p>streaming access should convert one </p>
<p>sample per one trigger</p>
<p>Problem description: </p>
<p>Current behaviour of the driver is, HW triggered ADC group with DMA and circular streaming access mode is converts more than one sample per H/W trigger.  </p>
<p>Sample conversion continues until the group is stopped by calling Adc_DisableHardwareTrigger(). </p>
<p> </p>
<p>As per the AUTOSAR specification only one sample conversion must be initiated for one HW trigger. </p>
<p> </p>
<p>Expected Behavior: </p>
<p>As per the AUTOSAR specification only one sample conversion must be initiated for one HW trigger. </p>
<p> </p>
<p> </p>
<p>Actual Behavior: </p>
<p>Stream conversion continues with a single HW trigger.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27624</p>
<p>ADC</p>
<p>Adc_GetStreamLastPointer() API does not </p>
<p>return the valid sample count when the </p>
<p>status of the group is </p>
<p>ADC_STREAM_COMPLETED</p>
<p>Problem description: </p>
<p>Adc_GetStreamLastPointer() API does not return correct number of valid samples when the status of the circular streaming group is ADC_STREAM_COMPLETED. This API must return the </p>
<p>value equal to the configured 'AdcStreamingNumSamples' parameter of that group. </p>
<p> </p>
<p>Expected Behavior: </p>
<p>Adc_GetStreamLastPointer() API must return the maximum sample value when the status of the circular streaming group is ADC_STREAM_COMPLETED. </p>
<p> </p>
<p>Actual Behavior: </p>
<p>Adc_GetStreamLastPointer() API is returning random value when the status of the group is ADC_STREAM_COMPLETED.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28094</p>
<p>ADC</p>
<p>Value assigned to register (ADCDnTHGSR) is </p>
<p>not correct in API Adc_HwInit().</p>
<p>Problem Description:-  </p>
<p>In Private API Adc_HwInit() value assigned to register (ADCDnTHGSR) usADCXnTHGSR is not correct, assignment to this register is as mentioned below.  </p>
<p> </p>
<p>&lt;b&gt; LpAdcRegisters-&gt;usADCXnTHGSR = (uint16)(LpHwUnitConfig-&gt;ucGroupSelectMask); &lt;/b&gt; </p>
<p> </p>
<p>Generated value in structure element &quot;ucGroupSelectMask&quot; is not correct, Thereby selection of T&amp;H group B will not work properly. </p>
<p> </p>
<p>In tool code value for structure element &lt;b&gt;&quot;ucGroupSelectMask&quot;&lt;/b&gt; is as mentioned below. Here final value in &quot;ucGroupSelectMask&quot; is the value in local variable &lt;b&gt;$grp_mask&lt;/b&gt;, </p>
<p>Understanding is that for register ADCDnTHGSR bit positions are in even number, as mentioned in section 30.3.23 of Device manual R01UH0436EJ0070 Rev.0.70, But in Generation Tool </p>
<p>code its considered that ADCDnTHGSR register bit positions are continues, As mentioned in Actual Behavior. </p>
<p> </p>
<p>Please check and do needful. </p>
<p> </p>
<p>Actual Behavior:-  </p>
<p>@Line No 749 of BswPbIm.pm file, SVN Revision $185322 </p>
<p>Looping below mentioned code for each channel. </p>
<p># Fill ucGroupSelectMask </p>
<p>      $grp_mask = 0; </p>
<p>            $BswPbIm::Dbrom_PbImage{Adc_GstHWUnitConfig}{$index} </p>
<p>              {ucGroupSelectMask} = $grp_mask; </p>
<p>            if ($chn_trck eq &quot;ADC_TH_GROUPB&quot;) </p>
<p>            { </p>
<p>             &lt;b&gt;$grp_mask = $grp_mask | (1 &lt;&lt; $ch_id); &lt;/b&gt; </p>
<p>              $BswPbIm::Dbrom_PbImage{Adc_GstHWUnitConfig}{$index} </p>
<p>                {ucGroupSelectMask} = $grp_mask; </p>
<p>            } </p>
<p> </p>
<p> </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28109</p>
<p>ADC</p>
<p>Limit check implementation is not proper </p>
<p>for Polling mode</p>
<p>Problem description: </p>
<p>In the case of Polling, Adc_ReadGroup API is called multiple times in a Loop. From Adc_PollingReadGroup function(called form Adc_ReadGroup API), Adc_ErrIsr is called. In Adc_ErrIsr the </p>
<p>following errors are being cleared by writing 0x0E to ADCDnECR register. </p>
<p>1. Upper Limit/Lower Limit Error. </p>
<p>2. Overwrite Error. </p>
<p>3. Parity Error Clear. </p>
<p> </p>
<p>In next polling(calling Adc_ReadGroup), even if the value is beyond Limit/Lower limit, ADC group notification is called and the conversion status is changed to ADC_STREAM_COMPLETED. </p>
<p> </p>
<p>Expected Behavior: </p>
<p>ADC driver should trigger the next conversion even if it is configured for one-shot conversion. </p>
<p> </p>
<p> </p>
<p>Actual Behaviour: </p>
<p>Further conversion is not triggered for one-shot groups. </p>
<p>ADC group notification is called and the conversion status is changed to ADC_STREAM_COMPLETED.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28111</p>
<p>ADC</p>
<p>Conversion is not happening for TH groups </p>
<p>when parameter 'AdcSuspendMode' is </p>
<p>'ADC_ASYNCHRONOUS_SUSPEND' and the </p>
<p>Trigger is SW</p>
<p>Problem Description: </p>
<p>Conversion is happening for ADC groups which contains Track and Hold enabled channels when the configuration parameter 'AdcSuspendMode' </p>
<p>in container 'AdcHwUnit' is configured as 'ADC_ASYNCHRONOUS_SUSPEND' and the parameter 'AdcGroupTriggSrc' is 'ADC_TRGG_SRC_SW'. </p>
<p> </p>
<p>The track and hold functionality is working fine for HW triggered groups even if the parameter 'AdcSuspendMode' is 'ADC_ASYNCHRONOUS_SUSPEND'. </p>
<p>Also, it is working properly for both SW and HW triggered groups if the parameter 'AdcSuspendMode' is 'ADC_SYNCHRONOUS_SUSPEND' </p>
<p> </p>
<p>But if the parameter 'AdcSuspendMode' is configured as 'ADC_SYNCHRONOUS_SUSPEND' the generator tool produces the following warning. </p>
<p>&quot;The parameter 'AdcSuspendMode' should be configured as &lt;ADC_ASYNCHRONOUS_SUSPEND&gt; when the channels are enabled for Track and hold feature.&quot; </p>
<p> </p>
<p> </p>
<p>Expected Behavior: </p>
<p>conversion should be happened for both SW and HW triggered groups if parameter 'AdcSuspendMode' is 'ADC_ASYNCHRONOUS_SUSPEND' </p>
<p> </p>
<p> </p>
<p>Actual Behaviour: </p>
<p>Conversion is not happening if parameter 'AdcSuspendMode' is 'ADC_ASYNCHRONOUS_SUSPEND' for SW triggered groups.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28118</p>
<p>ADC</p>
<p>Critical section protection for global </p>
<p>structure array &quot;Adc_GpGroupRamData&quot; is </p>
<p>not implemented.</p>
<p>Problem Description : </p>
<p> </p>
<p>Critical section protection for global structure array &quot;Adc_GpGroupRamData&quot; is not implemented, even though the values of the structure &quot;Adc_GpGroupRamData&quot; is modified in most of </p>
<p>the APIs.  </p>
<p> </p>
<p>In most of the private API, address of global structure array &quot;Adc_GpGroupRamData&quot; is assigned  to a local pointer and then  the elements values are changed / modified / read. </p>
<p>Even  though the values are changed using local pointer,  the value in global structure array &quot;Adc_GpGroupRamData&quot; also gets changed. </p>
<p> </p>
<p>Example : </p>
<p> </p>
<p>The value of structure element &quot;ddGroupStatus&quot; of &quot;Adc_GpGroupRamData&quot; global structure is being modified in  Adc_GroupCompleteMode()  </p>
<p>private API called from Adc_Isr().  </p>
<p> </p>
<p>/* Set group status as conversion completed */ </p>
<p>      LpGroupData-&gt;ddGroupStatus = ADC_STREAM_COMPLETED; </p>
<p> </p>
<p>Consider a  situation in which  API Adc_StopGroupConversion() is called from a high priority task ( say Timer Isr) than that of Adc_Isr(), And if Adc_StopGroupConversion() is called ( for </p>
<p>same group) just after start exciting Adc_Isr(), but not reached above mentioned code.  </p>
<p> </p>
<p>In this case the status  Group Status remain ADC_STREAM_COMPLETED, even after calling Adc_StopGroupConversion(). </p>
<p> </p>
<p>To avoid such issues, critical sections need to be implemented properly. </p>
<p> </p>
<p>Required MO suggestion on same. </p>
<p> </p>
<p>Actual Behavior : </p>
<p>Critical section protection not implemented. </p>
<p> </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28120</p>
<p>ADC</p>
<p>Autosar requirement ADC413 is not taken </p>
<p>care.</p>
<p>Problem Description : </p>
<p> </p>
<p>As per AUTOSAR requirement ADC413 all API functions, except  Adc_Init, Adc_DeInit and Adc_GetVersionInfo are re-entrant. But in current implementation it is not taken care. If the </p>
<p>functions are called  </p>
<p>for different channel groups, in current implementation these re-entrant API will not work properly. </p>
<p> </p>
<p>Example:- </p>
<p>Consider that SW triggered ADC channel group 0 is already in queue. </p>
<p> </p>
<p>Considered that we call Adc_ReadGroup() for ADC group 1 and API Adc_DisableHardwareTrigger() is invoked for ADC Channel group 1 form a interrupt (Like Timer ISR) when only DET </p>
<p>check in Adc_ReadGroup() API is completed. Then execution of Adc_ReadGroup() is pushed to stack and start execution of Adc_DisableHardwareTrigger() API.  </p>
<p> </p>
<p>When Adc_DisableHardwareTrigger() API complete execution, it pops the ADC channel group 0 from queue, trigger its conversion, and when Adc_ReadGroup() start execution, it will give </p>
<p>unexpected behavior. </p>
<p> </p>
<p>similar issues exist in most of the API's,  </p>
<p> </p>
<p>Requesting MO suggestions on same. </p>
<p> </p>
<p>Expected Behavior : </p>
<p>Requirement should be taken care properly and API's except above mentioned should be re-entrant. </p>
<p> </p>
<p>Actual Behavior : </p>
<p>Requirement is not taken care.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28121</p>
<p>ADC</p>
<p>Memory section mapping used for global </p>
<p>variable &quot;Adc_GaaHwUnitIndex[]&quot; and </p>
<p>&quot;Adc_GaaResultGroupRamData[]&quot;  is not </p>
<p>correct. </p>
<p>Probable Description:- </p>
<p>1.The global variable &quot;Adc_GaaResultGroupRamData[]&quot; is mapped to memory section &quot;CONFIG_DATA_UNSPECIFIED_SEC_STARTED&quot; (ADC_START_SEC_CONFIG_DATA_UNSPECIFIED), But </p>
<p>this global variable is not initialized in Adc_PBcfg.c (Generated file). </p>
<p> </p>
<p>Declaration of this variable is as mentioned below. </p>
<p> </p>
<p>extern VAR(Adc_ValueGroupType, ADC_NOINIT_DATA) Adc_GaaResultGroupRamData[]; </p>
<p>of Adc_Ram.c file. </p>
<p> </p>
<p>2. The global variable &quot;Adc_GaaHwUnitIndex[]&quot; is mapped to memory section &quot;VAR_NOINIT_UNSPECIFIED_SEC_STARTED&quot; (ADC_START_SEC_CONFIG_VAR_NOINIT_UNSPECIFIED), But </p>
<p>this global variable is of type const and initialized in Adc_PBcfg.c (Generated file). </p>
<p> </p>
<p>Declaration of this variable is as mentioned below. </p>
<p> </p>
<p>extern CONST(uint8, ADC_CONST) Adc_GaaHwUnitIndex[]; </p>
<p>of Adc_Ram.c file. </p>
<p> </p>
<p>Suggested Solution: </p>
<p> </p>
<p>1.Adc_GaaResultGroupRamData[] global variable needs to mapped to Uninitialized  variable section. </p>
<p> </p>
<p>2.Adc_GaaHwUnitIndex[] global variable needs to mapped to initialized constant variable section. </p>
<p> </p>
<p>Expected Behavior:- NA </p>
<p> </p>
<p>Actual Behavior:- NA</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28125</p>
<p>ADC</p>
<p>Register ADCDnTHSTPCR </p>
<p>(ucADCXnTHSTPCR) needs to use instead of </p>
<p>ADCDnTHSMPSTCR (ucADCXnTHSMPSTCR)  </p>
<p>to stop T&amp;H.</p>
<p>Problem Description : </p>
<p>Register ADCDnTHSTPCR (ucADCXnTHSTPCR) needs to use instead of ADCDnTHSMPSTCR (ucADCXnTHSMPSTCR) to stop TRACK &amp; HOLD in following mentioned Line of code. </p>
<p> </p>
<p>As per device manual R01UH0436EJ0070 Rev.0.70 section 30.3.15 ADCDnTHSMPSTCR register is used for starting T&amp;H. </p>
<p> </p>
<p>As per device manual R01UH0436EJ0070 Rev.0.70 section 30.3.16 ADCDnTHSTPCR register is used for stop T&amp;H. </p>
<p> </p>
<p>1. LpAdcRegisters-&gt;ucADCXnTHSMPSTCR = ADC_ZERO; </p>
<p>of Adc_Private_ADCD_ADCB.c file in Private API Adc_HwDeInit(). </p>
<p>2. LpAdcRegisters-&gt;ucADCXnTHSMPSTCR = ADC_BYTE_ZERO; </p>
<p>of Adc_Private_ADCD_ADCB.c file in Private API Adc_HwStopGroupConversion(). </p>
<p>3. Also Adc_Init() needs to update to stop T&amp;H by setting this register. </p>
<p> </p>
<p>Actual Behavior : </p>
<p>Register use ADCDnTHSMPSTCR (ucADCXnTHSMPSTCR) to stop TRACK &amp; HOLD. </p>
<p> </p>
<p>Expected Behavior : </p>
<p>Register ADCDnTHSTPCR (ucADCXnTHSTPCR) needs to be use to stop TRACK &amp; HOLD.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28134</p>
<p>ADC</p>
<p>Implementation of MRS requirement </p>
<p>&quot;AR_PN0076_FR_0201&quot; is not proper.</p>
<p>Problem Description: </p>
<p>If we call Adc_EnableChannel() API  before calling Adc_DisableChannel() API, illegal memory access will occur. </p>
<p>Because when we call Adc_EnableChannel() API internally private API Adc_IntDisableEnableChannel() will call as mentioned below. </p>
<p> </p>
<p>Adc_IntDisableEnableChannel(Group, ChannelId, ADC_TRUE) </p>
<p> </p>
<p>and in private API Adc_IntDisableEnableChannel(),  </p>
<p>if LblApiType( 3rd argument) == ADC_TRUE,  </p>
<p>then, decrement the number of channels to disabled,as mentioned in below code  </p>
<p> </p>
<p>LpGroupData-&gt;ucNoofChDisabled--; </p>
<p> </p>
<p> </p>
<p>Initial value of &quot;ucNoofChDisabled&quot; is zero, so after decrement it become 255, which is not correct result in  </p>
<p>illegal memory access or unexpected behavior in API Adc_ReadGroup(), Adc_GetStreamLastPointer(), Adc_ConfigureGroupForConversion() and Adc_IsrConfigureGroupForConversion(). </p>
<p> </p>
<p>Expected Behavior: </p>
<p>N/A </p>
<p> </p>
<p>Actual Behavior: </p>
<p>N/A </p>
<p> </p>
<p>Suggested solution: </p>
<p>Add a DET check if particular channel is trying to enable before it is disabled.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28135</p>
<p>ADC</p>
<p>Version check for Dem.h file is not present.</p>
<p>Problem description: </p>
<p>As per autosar requirement ADC124 The ADC module shall perform Inter Module Checks to avoid integration of incompatible files. </p>
<p> </p>
<p>But version check for Dem.h file is not present in the above mentioned file. </p>
<p> </p>
<p>FILE : Adc_Private_ADCD_ADCB.c  </p>
<p> </p>
<p>Expected Behavior :  </p>
<p>Version check should be done. </p>
<p> </p>
<p>Actual Behavior : </p>
<p>No version check is performed.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28143</p>
<p>ADC</p>
<p>General requirement </p>
<p>&quot;AR_PN0034_FR_0025&quot; is not considered.</p>
<p>Problem description : </p>
<p>The DMA related registers are not initialized in Adc_init(). </p>
<p> </p>
<p>The same issue is there with following registers also: </p>
<p> </p>
<p>1. ADCDnTHBCR (ucADCXnTHBCR), </p>
<p>2. ADCDnSGCRx (ucADCXnSGCRx), </p>
<p>3. ADCDnSGVCSPx (ucADCXnSGVCSPx) </p>
<p>4. ADCDnSGVCEPx (ucADCXnSGVCEPx) </p>
<p>5. ADCDnSGMCYCRx (ucADCXnSGMCYCRx) </p>
<p>6. ADCDnULLMSRx (ucADCXnULLMSRx) </p>
<p>7. ADCDnADTIPRy (ulADCXnADTIPRy) </p>
<p>8. ADOPDIGn (ulADOPDIGn) </p>
<p>9. ADCDnTHACR </p>
<p>10. ADCDnTHCR  </p>
<p>11. ADCXnULLMTBR 0 to 2 </p>
<p> </p>
<p>are not initialized in Adc_Init(). </p>
<p> </p>
<p>But as per General MRS &quot;AR_PN0034_FR_0025&quot;  : </p>
<p>The &lt;MSN&gt;_Init API shall ensure that the related peripheral is running correctly, even if the peripheral was previously configured by another Application that changed the registers' default </p>
<p>values. </p>
<p>Thereby this General requirement &quot;AR_PN0034_FR_0025&quot; is not considered for above mentioned registers. </p>
<p> </p>
<p>Expected Behavior: </p>
<p>The general MRS requirement &quot;AR_PN0034_FR_0025&quot; should be taken care for all above mentioned registers and DMA related registers and all should be initialized in Adc_init(). </p>
<p> </p>
<p>Actual Behavior: </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28151</p>
<p>ADC</p>
<p>AUTOSAR requirement  ADC077 is not </p>
<p>taken care while implementing Adc_Init().</p>
<p>Problem Description: </p>
<p>As per this requirement, </p>
<p>[ADC077] The function Adc_Init shall disable the notifications and hardware trigger capability (if statically configured as active). </p>
<p> </p>
<p>Configured HW triggers are not disabled in Adc_Init(). If we consider General MRS requirement &quot;AR_PN0034_FR_0025&quot;, it needs to be corrected accordingly.  </p>
<p>As per this requirement:- &quot;The &lt;MSN&gt;_Init API shall ensure that the related peripheral is running correctly, even if the peripheral was previously configured by another Application that </p>
<p>changed the registers' default values. &quot; </p>
<p> </p>
<p>Expected Behavior: </p>
<p>Configured HW triggers to be  disabled in Adc_Init() </p>
<p> </p>
<p>Actual Behavior: </p>
<p>Configured HW triggers are not disabled in Adc_Init().</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28158</p>
<p>ADC</p>
<p>The Cautions mentioned in Device manual </p>
<p>are not implemented.</p>
<p>Problem Description: </p>
<p>For example </p>
<p>As per Caution[1]: section 30.3.9 </p>
<p> To prevent malfunctions, make ADCDnADCR1 settings after making or confirming the following settings.  </p>
<p>(1) HLDTE of T&amp;H group A and B are 0. </p>
<p>(2) ADSTARTE of all scan groups are 0 and TRGMD of all scan groups are 0H. </p>
<p>(3) SGACT of all scan groups are 0 (before scan groups are started).] </p>
<p> </p>
<p>Before setting value to ADCDnADCR1 (ucADCXnADCR1) Register  in Adc_Private_ADCD_ADCB.c file in Adc_HwInit() API, we are not setting the bits or values of these register bits </p>
<p>mentioned in Caution are unknown to the driver. So based on General MRS requirement &quot;AR_PN0034_FR_0025&quot; this is to be implemented.  </p>
<p> </p>
<p> </p>
<p>Same type of issues are applicable for following registers also. Please check all applicable Cautions. </p>
<p> </p>
<p>1. ADCDnADCR2 (ucADCXnADCR2) </p>
<p>2. ADCDnSFTCR (ucADCXnSFTCR) </p>
<p>3. ADCDnTDCR (ucADCXnTDCR) </p>
<p>4. ADCDnODCR (ucADCXnODCR) </p>
<p>5. ADCDnTHACR (ucADCXnTHACR) </p>
<p>6. ADCDnTHER (ucADCXnTHER) </p>
<p>7. ADCDnTHGSR(usADCXnTHGSR) </p>
<p>8. ADCDnSGVCSPx (ucADCXnSGVCSPx) </p>
<p>9. ADOPDIGn (ulADOPDIGn) </p>
<p> </p>
<p>Expected Behavior: </p>
<p>none </p>
<p> </p>
<p>Actual Behavior: </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28165</p>
<p>ADC</p>
<p>DEM error is not reported for Overwrite </p>
<p>Error  in error ISR  Adc_ErrIsr()</p>
<p>Problem description: </p>
<p>In the  API Adc_ErrIsr(), ucADCXnOWER register is only used to calculate Physical channel ID. Understanding is that DEM error of Overwrite Error also needs to be reported. Also add </p>
<p>similar DEM error report to other errors like Parity Error, Upper / lower limit error and  ID Error. </p>
<p> </p>
<p>Expected Behavior: </p>
<p>DEM error needs to be reported. </p>
<p> </p>
<p>Actual Behavior: </p>
<p>DEm error is not reported.</p>
<p>FEATURE</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28179</p>
<p>ADC</p>
<p>Device manual CAUTION is not considered </p>
<p>for implementation in Adc_HwInit() and </p>
<p>Adc_HwDeInit()</p>
<p>Problem Description: </p>
<p>CAUTION mentioned in section 7.10.2.13 of R01UH0436EJ0070 Rev.0.70, is not considered for implementation . </p>
<p>As per device manual Caution  </p>
<p>&quot;DTFR.REQSEL can be changed while DTFR.REQEN is 0.&quot; </p>
<p> </p>
<p>But in current implementation both bits REQSEL and REQEN of DTFRn Register are updating simultaneously as mentioned in below code snippet. </p>
<p> </p>
<p>In Adc_HwInit(): </p>
<p>LpDmaRegisters-&gt;ulDTFRn = LpSGmDmaConfig-&gt;ulDmaDtfrRegValue; </p>
<p>ulDmaDtfrRegValue is generated value contain value of both bits REQSEL and REQEN of DTFRn Register. </p>
<p>In Adc_HwDeInit(): </p>
<p>LpDmaRegisters-&gt;ulDTFRn  = ADC_DOUBLE_WORD_ZERO; </p>
<p> </p>
<p>Understanding is that before changing the value of DTFR.REQSEL, needs to clear bit DTFR.REQEN. </p>
<p> </p>
<p>Expected Behavior: </p>
<p>Please update the design as below.  </p>
<p>In Adc_HwInit() </p>
<p>1. Reset: DTFRRQn register (0x00) </p>
<p>2. Clear bits LpDmaRegisters-&gt;ulDCENn  = ADC_DMA_DTE_DISABLE;  </p>
<p>3. LpDmaRegisters-&gt;ulDTFRn = LpSGmDmaConfig-&gt;ulDmaDtfrRegValue; </p>
<p> </p>
<p>For  Adc_HwDeInit() </p>
<p>Make similiar changes </p>
<p> </p>
<p>Actual Behavior: </p>
<p>In Adc_HwInit(): </p>
<p>LpDmaRegisters-&gt;ulDTFRn = LpSGmDmaConfig-&gt;ulDmaDtfrRegValue; </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28184</p>
<p>ADC</p>
<p>Clearing of  ID Error is not correct.</p>
<p>Problem Description : </p>
<p>Clearing of Error flags are not correct, In current implementation ADCDnIER.IDE error flag for ID Error is not clearing. </p>
<p> </p>
<p>LpAdcRegisters-&gt;ucADCXnECR = ADC_CHKCLR_ERROR_FLAG; </p>
<p>of Adc_Private_ADCD_ADCB.c file in Adc_ErrIsr() Private API is used to clear all the error flag. </p>
<p> </p>
<p>As per device manual R01UH0436EJ0070 Rev.0.70 Section 30.3.29, register ADCDnECR (Error Clear Register) last 4 digits should be set to clear all error flag. </p>
<p> </p>
<p>In Adc_PBTypes_ADCD_ADCB.h file  ADC_CHKCLR_ERROR_FLAG value of this macro is 0x0E. So last ADCDnIER.IDE bit is not clear. </p>
<p> </p>
<p>Suggested Solution : </p>
<p>Adc_PBTypes_ADCD_ADCB.h file  ADC_CHKCLR_ERROR_FLAG value of this macro should be 0x0F to clear all the flag. </p>
<p> </p>
<p>Actual Behavior : ID error is not getting clear when all the error flags are made clear.  </p>
<p> </p>
<p>Expected Behavior : ID error should also getting clear when all the error flags made clear. </p>
<p> </p>
<p> </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28187</p>
<p>ADC</p>
<p>Implementation of  MRS requirement </p>
<p>AR_PN0076_FR_0087 and </p>
<p>AR_PN0076_FR_0089 is not proper.</p>
<p>problem Description : </p>
<p>1.MRS requirement &quot;AR_PN0076_FR_0087&quot; is needs to be take care in Tool code, But in current implementation its not taken care. As per Device manual R01UH0436EJ0070 Rev.0.70 </p>
<p>section 30.3.28, number of  ADCDnULLMTBRx register is 3 (x = 0, 1, 2). In current implementation tool code will not give any error even if we configure channel having limit check more </p>
<p>than 2, when value of parameter &quot;AdcPriorityImplementation&quot; = ADC_PRIORITY_NONE. </p>
<p> </p>
<p>2.MRS requirement &quot;AR_PN0076_FR_0089&quot; is needs to be take care in Tool code, But in current implementation its not taken care. As per Device manual R01UH0436EJ0070 Rev.0.70 </p>
<p>section 30.3.28, number of  ADCDnULLMTBRx register is 3 (x = 0, 1, 2). In current implementation tool code will not give any error even if we configure channel having limit check more </p>
<p>than 2, when value of parameter &quot;AdcPriorityImplementation&quot; = ADC_PRIORITY_HW_SW or ADC_PRIORITY_HW. </p>
<p> </p>
<p>Actual Behavior : </p>
<p> </p>
<p>For both case generation tool code is not generating validation error, if limit check enabled for more than 3 channel Group with different Limit check setting. Understating is that, it will </p>
<p>not work properly when these groups are queued.  </p>
<p> </p>
<p>Expected Behavior : </p>
<p>For both case proper validation needs to add in Tool code. </p>
<p> </p>
<p>Required MO suggestion on same. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28188</p>
<p>ADC</p>
<p>Register &quot;ADCDnECR&quot; (ucADCXnECR) is not </p>
<p>handled properly in Adc_DeInit and </p>
<p>Adc_Init() API's.</p>
<p>Problem description: </p>
<p>In private API Adc_Init() register &quot;ADCDnECR&quot; (ucADCXnECR) is not implemented. </p>
<p> </p>
<p>and also in private API Adc_DeInit()  register &quot;ADCDnECR&quot; (ucADCXnECR) is upated with zero as mentioned below :  </p>
<p> </p>
<p>LpAdcRegisters-&gt;ucADCXnECR = ADC_ZERO; </p>
<p> </p>
<p>Understanding is that to clear error flags ADCDnOWER.OWE, ADCDnPER.PE and ADCDnIER.IDE, we need to set ( write 1) to respective bits of the &quot;ADCDnECR&quot; (ucADCXnECR) register in </p>
<p>Adc_DeInit() and Adc_Init() API. </p>
<p> </p>
<p>We can also consider general MRS requirement &quot;AR_PN0034_FR_0025&quot;, As per this requirement,  </p>
<p> </p>
<p>The Adc_Init API shall ensure that the related peripheral is running correctly, even if the peripheral was previously configured by another Application that changed the registers' default </p>
<p>values. </p>
<p> </p>
<p>and autosar requirement ADC110 : </p>
<p> </p>
<p>The function Adc_DeInit shall return all ADC HW Units to a state </p>
<p>comparable to their power on reset state. Values of registers which are not writeable are excluded. It’s the responsibility of the hardware design that this state does not lead to undefined </p>
<p>activities in the µC. </p>
<p> </p>
<p>Expected Behavior : </p>
<p>Register ADCDnECR&quot; (ucADCXnECR) should be updated correctly in Adc_Init and Adc_DeInit APIs as per requirements. </p>
<p> </p>
<p>Actual Behavior : </p>
<p>Register ADCDnECR&quot; (ucADCXnECR) is not handled as per the requirements.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28214</p>
<p>ADC</p>
<p>AUTOSAR Requirement ADC091 and </p>
<p>ADC277 is not taken care.</p>
<p>1. as per ADC091 requirement : </p>
<p> &quot;The  ADC module’s configuration shall be such that an ADC Channel group contains at least one ADC Channel&quot; </p>
<p>  </p>
<p>In current implementation AUTOSAR Requirement ADC091 is not taken care, in generation tool. </p>
<p>As per current implementation, tool code is not giving any proper error even if no channel is configured under a ADC Group and tool code will crash by giving error &quot;ERR123001&quot;, which is </p>
<p>not correct. </p>
<p> </p>
<p>2. As per ADC277 Requirement, </p>
<p>&quot;The ADC module’s configuration shall be such that all channels  </p>
<p>contained in one ADC Channel group shall belong to the same ADC HW Unit.&quot; </p>
<p> </p>
<p>Its found that this SWS requirement is not mapped properly in TSDD, Traceability and TSTP, that's needs to fix accordingly. </p>
<p> </p>
<p>Most of the requirement are not tracked properly in Traceability sheet. </p>
<p> </p>
<p> </p>
<p>Expected Behavior : </p>
<p>point 1. Tool code should give a error message stating no channel is configured for particular ADC group. </p>
<p> </p>
<p>point 2. Update TSDD, TSTP, Traceability </p>
<p> </p>
<p>Actual Behavior : </p>
<p>point 1. Tool code crash if no channel is configured for a ADC group. </p>
<p>point 2. Requirements are not tracked properly in Traceability sheet. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>26442</p>
<p>Can</p>
<p>Transmission History List issues</p>
<p>1) CanIf (CanIf_TxConfirmation) is being called while looping by the Can_TxConfirmationProcessing function. </p>
<p>   Any processing isn't being done by hardware, so I'm thinking the time-out isn't being confirmed. </p>
<p>So don't we have to check the time out handling here? </p>
<p> </p>
<p>2) It's written on &quot;CLEARING OF ALL TRANSMIT MESSAGE BUFFERS&quot; and a comment in  the Can_StartMode function, but how is a transmission history buffer initialized? </p>
<p>   RSCAN0THLACCm and RSCAN0TXQPCTRm resister weren't being read, so I didn't understand how to be initialized.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>26903</p>
<p>Can</p>
<p>PBcfg file Generation operation terminated </p>
<p>due to Illegal division by zero</p>
<p>Problem description: </p>
<p>Generation terminated due to Illegal division by zero at /PerlApp/BswConfigValidate.pm line 561. </p>
<p> </p>
<p>can_X1X.exe Can.arxml Sample_Application_F1x.trxml R403_can_F1x_BSWMDT.arxml EcuM.arxml Mcu.arxml Os.arxml Dem.arxml </p>
<p>INF000001: Tool Version: 1.2.3 </p>
<p>INF000002: Command line arguments: Can_X1x.exe Can.arxml </p>
<p>           Sample_Application_F1x.trxml R403_can_F1x_BSWMDT.arxml EcuM.arxml </p>
<p>           Mcu.arxml Os.arxml Dem.arxml </p>
<p>Illegal division by zero at /PerlApp/BswConfigValidate.pm line 561. </p>
<p> </p>
<p> </p>
<p>Expected behavior: </p>
<p>PBcfg file Generation operation should not be terminated. If any error occurred Generator tool should throw out error with ambiguous error message. </p>
<p> </p>
<p>Actual behavior: </p>
<p>PBcfg file Generation operation is terminated due to Illegal division.If any error occurred Generator tool is throwing out error with unambiguous error message.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>27020</p>
<p>Can</p>
<p>Walking 0 pattern is not implemented in </p>
<p>Can_RamTst_WalkPath_Algorithm() API</p>
<p>Problem description: </p>
<p>As per Renesas requirement AR_PN0069_FR_0023,the RAM is checked by using data patterns (checker pattern, walking-0 and walking-1 pattern).  </p>
<p>But in the current implementation walking-0 pattern is not implemented. This shall be implemented as an enhancement, but it is not a bug since Walking &quot;0&quot;'s pattern and Walking &quot;1&quot;'s </p>
<p>pattern is similar. </p>
<p> </p>
<p>Expected behaviour: </p>
<p>As per requirement walking-0 pattern shall be implemented. </p>
<p> </p>
<p>Actual behaviour: </p>
<p>In the current code, walking-0 pattern is not implemented.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27183</p>
<p>Can</p>
<p>Can_SelfTestChannel API  executes in </p>
<p>modes other than STOPPED</p>
<p>Problem description: </p>
<p> </p>
<p>If the controller is not in STOPPED state, the function 'Can_SelfTestChannel' shall be aborted and returns E_NOT_OK. But as per the current implementation, this check is not provided and </p>
<p>the code try to set the operation mode as Halt mode. </p>
<p> </p>
<p> </p>
<p>Expected behavior: </p>
<p> </p>
<p>The function shall be aborted and returns E_NOT_OK, if the controller is not in the STOPPED state.  </p>
<p> </p>
<p>Actual behavior: </p>
<p> </p>
<p>Please see the problem description. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27647</p>
<p>Can</p>
<p>Transmission occurs even if the return of </p>
<p>Can_write() API is CAN_BUSY</p>
<p>Problem description: </p>
<p>If cancellation is enabled, cancellation has to be initiated for the lower priority ID/Identical ID (if identical Id cancellation is also enabled) request when the write request came with the </p>
<p>higher priority ID / identical ID for the same HTH. The TX request for the new L-PDU shall be repeated by the CanIf module, inside the notification function CanIf_CancelTxConfirmation - </p>
<p>requirement [CAN288].  </p>
<p> </p>
<p>If cancellation is disabled, the new Can_Write() request for the same HTH shall not be accepted and returned with CAN_BUSY. The first write request shall be transmitted which was in </p>
<p>pending state. </p>
<p> </p>
<p>The same information is covered with the requirements [CAN213], [CAN214], [CAN215] and [CAN434] </p>
<p> </p>
<p>Expected Behaviour: </p>
<p>1. The transmission shall not be there for the Can_Write() request when its return value is CAN_BUSY. </p>
<p>2. The cancellation of the pending transmission has to happen properly, when transmission cancellation is enabled. </p>
<p> </p>
<p>Actual Behaviour: </p>
<p>In different scenarios the transmission of the frame happens even after returning the reply as CAN_BUSY for the Can_Write() API call. </p>
<p> </p>
<p>EX: </p>
<p>1. When the cancellation is OFF (In polling mode), however the return value of the Can_Write() request for the same HTH is CAN_BUSY, the transmission of the frame is observed on the </p>
<p>CANAlyzer and also Tx confirmation is received. </p>
<p> </p>
<p>2. When Identical ID cancellation is ON, however the return for the Can_Write() request for the same HTH with identical ID is CAN_BUSY as expected and cancel confirmation is received, </p>
<p>the transmission is happening without re-requested as stated in requirement [CAN288]. Also complete frame data is '0' and Tx confirmation is received as well.  </p>
<p> </p>
<p>3. When cancellation is ON, however the return for the Can_Write() request for the same HTH with higher priority ID is CAN_BUSY as expected and cancel confirmation is received, the </p>
<p>transmission is happening without re-requested as stated in requirement [CAN288] and also Tx confirmation is received . </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>27649</p>
<p>Can</p>
<p>Hth Cancellation is not notifed correctly to </p>
<p>the upper layer (CanIf) in case of multiple </p>
<p>Hth to cancel</p>
<p>Problem description: </p>
<p>There is no while loop, but unnecessarily LucArrPosition incremented and wrong comment provided. </p>
<p>  uint8_least LucArrPosition; </p>
<p>  --code---- </p>
<p>  if (LblTxCancelFlag == CAN_TRUE) </p>
<p>  { </p>
<p>    /* Set the BasicCAN HTH count to maximum to exit the while loop */ </p>
<p>    LucArrPosition = LpPBController-&gt;ucNoOfBasicCanHth; </p>
<p>    /* Set the TX Cancellation Status flag of the HTH */ </p>
<p>    Can_RSCAN_GaaTxCancelStsFlgs[(LucArrPosition &gt;&gt; CAN_THREE)] = </p>
<p>           (Can_RSCAN_GaaTxCancelStsFlgs[(LucArrPosition &gt;&gt; CAN_THREE)]) | </p>
<p>           ((uint8)(CAN_ONE &lt;&lt; (LucCount % CAN_EIGHT))); </p>
<p>    /* Increment the array position to point to next </p>
<p>     * BasicCAN HTH of the controller */ </p>
<p>    LucArrPosition++; </p>
<p>  } </p>
<p>  else </p>
<p>  { </p>
<p>    /* No action required */ </p>
<p>  } </p>
<p> </p>
<p> </p>
<p>Expected behavior: </p>
<p>None </p>
<p> </p>
<p>Actual behavior: </p>
<p>None</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27650</p>
<p>Can</p>
<p>Multiple DET error reporting from one API </p>
<p>not compliant with AUTOSAR requirement</p>
<p>Description: </p>
<p>According to CAN091 from AUTOSAR 4.0.3 CAN SWS - a function that reports a development error shall return immediately after. </p>
<p>In many CAN driver APIs multiple errors are checked and reported, before the function returns. Examples: </p>
<p>* Can_Init() may report CAN_E_TRANSITION, CAN_E_PARAM_POINTER before it returns </p>
<p>* Can_Can_InitController() may report e.g. CAN_E_UNINIT and CAN_E_PARAM_POINTER before it returns) </p>
<p> </p>
<p> </p>
<p>Expected behaviour: </p>
<p>Every CAN driver API should return immediately with not action after a development error is detected is reported </p>
<p> </p>
<p>Actual behaviour: </p>
<p>In some case in CAN APIs multiple development errors can be reported, like for Can_Init(), Can_InitController()</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27654</p>
<p>Can</p>
<p>DEM version Check is missing</p>
<p>Problem Description: </p>
<p>As per the requirement [CAN111](BSW004), the AUTOSAR major and minor release version needs to be checked for all the external modules. But the version check for the DEM module is </p>
<p>missing. </p>
<p> </p>
<p>Expected Behaviour: </p>
<p>The compilation error shall be reported when the DEM module with different AUTOSAR release version is integrated. </p>
<p> </p>
<p>Actual behaviour: </p>
<p>The compilation is happening successfully even when the DEM module with different AUTOSAR release version is integrated.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27742</p>
<p>Can</p>
<p>The MCAL CAN driver shall clear the </p>
<p>corresponding WUF flag in the ISR </p>
<p>(AR_PN0069_FR_0025)</p>
<p>Problem Description: The MCAL CAN driver will not clear the corresponding WUF flag in the ISR if the precompile configuration parameter CanWakeUpFactorClearIsr is set to TRUE. </p>
<p>Default value should be FALSE. PDF is reviewed and found that the parameter CanWakeUpFactorClearIsr  is not implemented. </p>
<p> </p>
<p>Expected Behavior: AR_PN0069_FR_0025 shall be implemented. </p>
<p> </p>
<p>Actual Behavior: AR_PN0069_FR_0025 is not implemented properly</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>27874</p>
<p>Can</p>
<p>Autosare requirment CAN065_Conf is not </p>
<p>taken care</p>
<p>Problem Description:  </p>
<p>As per Autosare SWS CAN065_Conf, CanIdType  shall support ID's of type STANDARD, MIXED and EXTENDED. In the current implementation only STANDARD and EXTENDED types are </p>
<p>taken care. </p>
<p> </p>
<p>Expected Behavior: MIXED ID type shall also be supported by the PDF. </p>
<p> </p>
<p>Actual Behavior: NA</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27880</p>
<p>Can</p>
<p>Additional API to cancel Tx is not available </p>
<p>for CanIf / Upper layer.</p>
<p>Problem Description: The internal function “Can_TxCancel” is available as private API. As per the requirement description, the API shall be available as public API such that CanIf AUTOSAR </p>
<p>module can have corresponding call to this API in order to use it. </p>
<p> </p>
<p>Expected Behavior: The internal function “Can_TxCancel” shall be available as additional API (public) </p>
<p> </p>
<p>Actual Behavior: NA</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27882</p>
<p>Can</p>
<p>CAN_E_DATALOST development error is </p>
<p>not reported</p>
<p>Problem description: </p>
<p>According to AUTOSAR 4.0.3 CAN SWS CAN395: &quot;If the development error detection for the Can module is enabled, the Can module shall raise the error CAN_E_DATALOST in case of </p>
<p>“overwrite” or “overrun” event detection.&quot; </p>
<p> </p>
<p>This DET error CAN_E_DATALOST is declared in Can.h but it is not used in the code. </p>
<p> </p>
<p> </p>
<p>Expected behaviour: </p>
<p>Development error CAN_E_DATALOST should be reported if overwrite or overrun events are detected in the reception buffers. </p>
<p> </p>
<p>Actual behaviour: </p>
<p>CAN_E_DATALOST development error reporting is nowhere encountered in CAN driver code</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27934</p>
<p>Can</p>
<p>Unexpected Behavior of in Can wake up</p>
<p>Problem description: CAN wake up shows unexpected behavior. Wake up ISR is getting triggered, even if wake up is not initiated. </p>
<p> </p>
<p>Expected Bahavior: Wake up shall be triggered only on occurance of a wake up event </p>
<p> </p>
<p>Actual Behavior: Undefined behavior of CAN wake up</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27945</p>
<p>Can</p>
<p>Can_Write request returns  CAN_OK when </p>
<p>HTH is busy</p>
<p>Problem Description: Can_Write request returns  CAN_OK when HTH is busy to process another transmit request. Can transmission shall only be initiated after getting tx confirmation on </p>
<p>the last transmitted message. </p>
<p> </p>
<p>Expected Behavior: Can_Write request shall return CAN_BUSY when HTH is busy to process another transmit request </p>
<p> </p>
<p>Actual Behavior: NA</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27965</p>
<p>Can</p>
<p>Can module is malfunctioning on HW Tx </p>
<p>Cancellation.</p>
<p>Problem description: </p>
<p>Can module is malfunctioning when HW Tx Cancellation support is enabled and a Transmit abort request was not successful (the CAN frame was transmitted). </p>
<p>It this particular case, once the Tx Cancellation is initiated inside the Can module source code the global transmit cancel flag “Can_GblTxCancelIntFlg” is set to CAN_TRUE. Later this flag </p>
<p>“Can_GblTxCancelIntFlg” is cleared inside the source code invoked when the &quot;INTCnWUP&quot; interrupt is serviced. But in the current use case, since the Transmit abort request was not </p>
<p>successful, the &quot;INTCnWUP&quot; interruupt is not activated. Instead, the &quot;INTCnTRX&quot; interrupt is activated (frame successfully transmitted from message buffer m), but the source code </p>
<p>invoked when &quot;INTCnTRX&quot; interrupt is serviced (ex. CAN_CONTROLLER0_TX_ISR) does not clear the “Can_GblTxCancelIntFlg” flag. </p>
<p>The flag remains set and this causes subsequent calls to &quot;Can_Write()&quot; to fail and return &quot;CAN_BUSY&quot; result. This renders the Can module incapable to transmit CAN frames any more </p>
<p>(until being re-initialized). </p>
<p> </p>
<p>Actual behavior: N/A </p>
<p> </p>
<p>Expected behavior: N/A</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28070</p>
<p>Can</p>
<p>[X1x][CAN] </p>
<p>Can_RamTst_WalkPath_Algorithm is not </p>
<p>called from Can_RAMTest API</p>
<p>Problem Description: While updating ECODE for merging the changes done as part of F1H E4.00.01 release to trunk, in Can_RAMTest API call of 'Can_RamTst_WalkPath_Algorithm' was </p>
<p>replaced by 'Can_RamTest_Checker_Algorithm'. So now instead of calling Can_RamTst_WalkPath_Algorithm, Can_RamTest_Checker_Algorithm is called second time. </p>
<p>Work Around: Repeated call of 'Can_RamTest_Checker_Algorithm' has to be replaced with 'Can_RamTst_WalkPath_Algorithm'. </p>
<p> </p>
<p>Expected behavior: Can_RamTst_WalkPath_Algorithm should be called from Can_RAMTest API. </p>
<p> </p>
<p>Actual behavior: Can_RamTst_WalkPath_Algorithm is not called from Can_RAMTest API.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28503</p>
<p>Can</p>
<p>CAN_E_DATALOST development error is </p>
<p>not reported</p>
<p>Problem description: </p>
<p>According to AUTOSAR 4.0.3 CAN SWS CAN395: &quot;If the development error detection for the Can module is enabled, the Can module shall raise the error CAN_E_DATALOST in case of </p>
<p>“overwrite” or “overrun” event detection.&quot; </p>
<p> </p>
<p>This DET error CAN_E_DATALOST is declared in Can.h but it is not used in the code. </p>
<p> </p>
<p> </p>
<p>Expected behaviour: </p>
<p>Development error CAN_E_DATALOST should be reported if overwrite or overrun events are detected in the reception buffers. </p>
<p> </p>
<p>Actual behaviour: </p>
<p>CAN_E_DATALOST development error reporting is nowhere encountered in CAN driver code</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28505</p>
<p>Can</p>
<p>Multiple polling period for Tx and Rx (valid </p>
<p>for R3.2and R4.x) is not supported</p>
<p>Problem Description: </p>
<p>This is a task to verify the possibility to configure and handle multiple transmission or reception in polling mode based on SWS R3.2 ID: CAN356,CAN436 (Rx) and CAN358, CAN345 (Tx). </p>
<p> </p>
<p>The solution to this issue is to update the CAN code generator to count how many instances of the parameter CanMainFunctionWritePeriod and CanMainFunctionReadPeriod are </p>
<p>configured  </p>
<p>and based on this to generate the opportune number of macro  </p>
<p> </p>
<p>#defines Can_MainFunction_Write_0  </p>
<p>#define  Can_MainFunction_Read_0  </p>
<p>for the 1st instance,  </p>
<p> </p>
<p>#define Can_MainFunction_Write_1  </p>
<p>#define Can_MainFunction_Read_1 for the 2nd instance </p>
<p> </p>
<p>The generated code should look like this: </p>
<p> </p>
<p>/*Polling Period 0 for Write*/ </p>
<p>#define Can_MainFunction_Write_0() Can_MainFunction_Write() </p>
<p> </p>
<p>/*Polling Period 1 for Write*/ </p>
<p>#define Can_MainFunction_Write_1() Can_MainFunction_Write() </p>
<p>...etc. </p>
<p> </p>
<p>Expected behaviour: </p>
<p>N/A </p>
<p> </p>
<p>Actual Behaviour: </p>
<p>N/A </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28541</p>
<p>Can</p>
<p>Restrict the baudrate to only a limited </p>
<p>range is wrong.</p>
<p>Restrict the baudrate to only a limited range is wrong. There are other buadrate like 50K or 25K  that can be realized. </p>
<p> </p>
<p>Actually the generator impelementation is to occur error, if the value of the parameter CanControllerBaudRate is other than 33, 83,100,125,250,500 or 1000Kbps for the particular </p>
<p>controller. </p>
<p> </p>
<p>Actual Behaviour: Error occurs, if the value of the parameter CanControllerBaudRate is other than 33,83,100,125,250,500 or 1000Kbps for the particular controller. </p>
<p> </p>
<p>Expected Behaviour:Error should not occur, if the value of the parameter CanControllerBaudRate is other buadrate like 50K or 25K.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28601</p>
<p>Can</p>
<p>Correct typo in error ERR080034.</p>
<p>Problem Description: </p>
<p> </p>
<p>Correct typo in error ERR080034 in BswConfigValidate.pm </p>
<p> </p>
<p>Expected behavior:  </p>
<p> </p>
<p>The description of the ERR shall be &quot;The calculated 'Time Quanta' should be in the range of &lt;8- 25&gt;&quot; </p>
<p> </p>
<p>Actual Behavior: </p>
<p> </p>
<p>The description of the error is currently </p>
<p> </p>
<p>The calculated 'DBT (Data Bit Time)' should be in the range of &lt;8- 25&gt;.  </p>
<p> </p>
<p> </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>24131 DIO</p>
<p>Initialization Check is not performed for </p>
<p>Dio_MaskedWritePort() API In the DIO </p>
<p>driver.</p>
<p>Problem Description: </p>
<p> Dio_MaskedWritePort() API is not checked whether DIO Is initialized or not. </p>
<p> </p>
<p>Expected behavior: </p>
<p>FUNC(void, DIO_PUBLIC_CODE) Dio_MaskedWritePort </p>
<p>(Dio_PortType PortId, </p>
<p> Dio_PortLevelType Level, </p>
<p> Dio_PortLevelType  Mask) </p>
<p>{ </p>
<p>  ------variable declaraiton ---------- </p>
<p>  /* Check whether DIO_DEV_ERROR_DETECT is enabled */ </p>
<p>  #if (DIO_DEV_ERROR_DETECT == STD_ON) </p>
<p>  /*START of DIO_AR_VERSION */ </p>
<p>  #if (DIO_AR_VERSION  == DIO_AR_HIGHER_VERSION) </p>
<p>  if (Dio_GblDriverStatus == DIO_UNINITIALIZED) </p>
<p>  { </p>
<p>    /* Report Error to DET */ </p>
<p>    (void)Det_ReportError(DIO_MODULE_ID, DIO_INSTANCE_ID, </p>
<p>                      DIO_MASKED_WRITE_PORT_SID, DIO_E_UNINIT); </p>
<p>    LenDetErrFlag = E_OK; </p>
<p>  } </p>
<p>  else </p>
<p>  { </p>
<p>    /* No action required */ </p>
<p>  } </p>
<p>  #endif </p>
<p>    </p>
<p>  --------- </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>26249</p>
<p>DIO</p>
<p>The channel group not validated correctly </p>
<p>in </p>
<p>Dio_ReadChannelGroup/Dio_WriteChannel</p>
<p>Group APIs</p>
<p>Problem Description: </p>
<p>Functional argument pointer 'ChannelGroupIdPtr' is checked only against NULL_PTR in Dio_ReadChannelGroup/Dio_WriteChannelGroup APIs and it is not validated properly to report </p>
<p>DIO_E_PARAM_INVALID_GROUP.  </p>
<p> </p>
<p>Currently, if wrong or out-of-bound address is passed (Ex: If Dio_GstChannelGroupData[] size is 4 i.e. 0-3 and if &amp;Dio_GstChannelGroupData[4] is passed by mistake), the NULL_PTR </p>
<p>condition check is unable to catch this and the API proceeds for further processing instead of reporting DET DIO_E_PARAM_INVALID_GROUP. </p>
<p> </p>
<p>While doing further processing the behaviour might be un-predictable. </p>
<p> </p>
<p>Expected Behavior: </p>
<p>The channel group needs to be validated to report DET and it shall not do any further processing detecting DET. </p>
<p> </p>
<p>Actual Behavior: </p>
<p>The channel group is not validated to report DET and it shall do further processing even during development error condition. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>26251</p>
<p>DIO</p>
<p>Global variable </p>
<p>(Dio_GusNoOfChannelGroups) and config </p>
<p>structure member (usNoofChannelGroups) </p>
<p>names are misleading</p>
<p>Problem Description: </p>
<p>The global variable 'Dio_GusNoOfChannelGroups' which is initialised with the value of the config structure member 'usNoofChannelGroups' is used as offset for accessing the channel </p>
<p>group structure when multi config set comes into picture. But the name suggests that it holds the value of &quot;number of channel groups configured&quot; which misleading. </p>
<p> </p>
<p>E.g.: If 8 channel groups are configured with two config sets (each), the handles will be generated as, </p>
<p> </p>
<p> </p>
<p>#define DioConf_DioChannelGroup_DioChannelGroup1 (&amp;Dio_GstChannelGroupData[0]) </p>
<p>#define DioConf_DioChannelGroup_DioChannelGroup2 (&amp;Dio_GstChannelGroupData[1]) </p>
<p>#define DioConf_DioChannelGroup_DioChannelGroup3 (&amp;Dio_GstChannelGroupData[2]) </p>
<p>#define DioConf_DioChannelGroup_DioChannelGroup4 (&amp;Dio_GstChannelGroupData[3]) </p>
<p>#define DioConf_DioChannelGroup_DioChannelGroup5 (&amp;Dio_GstChannelGroupData[4]) </p>
<p>#define DioConf_DioChannelGroup_DioChannelGroup6 (&amp;Dio_GstChannelGroupData[5]) </p>
<p>#define DioConf_DioChannelGroup_DioChannelGroup7 (&amp;Dio_GstChannelGroupData[6]) </p>
<p>#define DioConf_DioChannelGroup_DioChannelGroup8 (&amp;Dio_GstChannelGroupData[7]) </p>
<p> </p>
<p>It shall generate 8 handles pointing 8 channel group structures and the channel structures 9-16 which is applicable for second config set shall be accessed with the help of same handles </p>
<p>with offset value in 'Dio_GusNoOfChannelGroups'. i.e. When config set 0 is initialised its value will be 0. When config set 1 is initialised  its value will be 8 for the above case. </p>
<p> </p>
<p> </p>
<p>Expected Behavior: </p>
<p>The name of this global variable and respective config structure member has to be corrected with meaningful name which is near to it usage. Ex: 'Dio_GusChannelGroupsOffset' and </p>
<p>'usChannelGroupsOffset' respectively. </p>
<p> </p>
<p>Actual Behavior: </p>
<p>Variable names are misleading</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>26572</p>
<p>DIO</p>
<p>Optimize the execution time of RSR register </p>
<p>setting sequence</p>
<p>Problem description: </p>
<p>Check the pin direction and prepare the value and write to psr register will take less time to execute when the pin direction check is failed(beginning check itself it will come out). As per </p>
<p>current method Even the pin direction check is failed, Prepare the value to set to the register operation is performed. </p>
<p> </p>
<p>Expected behavior: </p>
<p>1.Check the pins direction.(Check the PMSR register.) </p>
<p>2.Prepare the value to set to the register. </p>
<p>3.Write the PSR register. </p>
<p>Source : Please refer to the attached file.(Proposed amendments) </p>
<p>       Dio_WriteChannel 168-191 </p>
<p>       Dio_WriteChannelGroup 407-415 </p>
<p>       Dio_MaskedWritePort 584-591 </p>
<p> </p>
<p>Actual behavior: </p>
<p>1.Prepare the value to set to the register. </p>
<p>2.Check the pins direction.(Check the PMSR register.) </p>
<p>3.Write the PSR register. </p>
<p>Function : Dio_WriteChannel, Dio_WriteChannelGroup, Dio_MaskedWritePort </p>
<p>Line : Dio_WriteChannel 931-956 </p>
<p>       Dio_WriteChannelGroup 1573-1583 </p>
<p>       Dio_MaskedWritePort 1714-1721</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>27729</p>
<p>DIO</p>
<p>Unreachable code present in Dio.c</p>
<p>In API Dio_ReadChannelGroup and API Dio_WriteChannelGroup, In the below code if the first condition got true, code will not go inside else part. If the first condition fails the second </p>
<p>condition would also be false. So the code inside the second if block is unreachable that is dead code. The issue is found during UT. </p>
<p> </p>
<p>  if (ChannelGroupIdPtr == NULL_PTR) </p>
<p>  { </p>
<p>    /* TRACE [R3, DIO140][R4, DIO140] */ </p>
<p>    /* TRACE [R4, DIO178] */ </p>
<p>    /* Report Error to DET */ </p>
<p>    (void)Det_ReportError(DIO_MODULE_ID, DIO_INSTANCE_ID, </p>
<p>                      DIO_WRITE_CHANNEL_GROUP_SID, DIO_E_PARAM_POINTER); </p>
<p>    LenDetErrFlag = E_OK; </p>
<p>  } </p>
<p>  else </p>
<p>  { </p>
<p>    /* Get the pointer to corresponding index in the </p>
<p>       array Dio_GstChannelGroupData */ </p>
<p>    /* MISRA Violation: START Msg(4:0492)-6 */ </p>
<p>     LpChannelGroupPtr = &amp;ChannelGroupIdPtr[Dio_GusNoOfChannelGroups]; </p>
<p>    /* END Msg(4:0492)-6 */ </p>
<p>      if (NULL_PTR == LpChannelGroupPtr) </p>
<p>      { </p>
<p>        /* Report Error to DET */ </p>
<p>        (void)Det_ReportError(DIO_MODULE_ID, DIO_INSTANCE_ID, </p>
<p>                      DIO_WRITE_CHANNEL_GROUP_SID, DIO_E_PARAM_INVALID_GROUP); </p>
<p>        LenDetErrFlag = E_OK; </p>
<p>      } </p>
<p>      else </p>
<p>      { </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>26594</p>
<p>FLS</p>
<p>[F1L][FLS] Mismatch in memory mapping of </p>
<p>Fls_MainFunction</p>
<p></p>
<p>Problem descripaon:</p>
<p> </p>
<p>There is a mismatch in the memory mapping of Fls_MainFunction. </p>
<p> </p>
<p>In Fls.h, Fls_MainFunction is mapped to FLS_START_SEC_PUBLIC_CODE:(See the code below) </p>
<p> </p>
<p>254 : #define FLS_START_SEC_PUBLIC_CODE </p>
<p>255 : #include &quot;MemMap.h&quot; </p>
<p>       </p>
<p>280 : extern FUNC(void, FLS_PUBLIC_CODE) Fls_MainFunction(void); </p>
<p> </p>
<p> </p>
<p>In Fls.c, Fls_MainFunction is mapped to FLS_START_SEC_SCHEDULER_CODE(See the code below) </p>
<p> </p>
<p>1689 : define FLS_START_SEC_SCHEDULER_CODE </p>
<p>1690 : #include &quot;MemMap.h&quot; </p>
<p>1691 : </p>
<p>1692 : FUNC(void, FLS_PUBLIC_CODE)Fls_MainFunction(void) </p>
<p> </p>
<p>And in MemMap.h, both FLS_START_SEC_PUBLIC_CODE and FLS_START_SEC_SCHEDULER_CODE are defined as &quot;.FLS_PUBLIC_CODE_RAM&quot;. </p>
<p> </p>
<p></p>
<p>Expected behaviour:</p>
<p> </p>
<p>Memory mapping in both declaration and definition of function shall be unique. </p>
<p> </p>
<p>Actual behaviour: </p>
<p>There is difference in the memory mapping of declaration and definition of function Fls_MainFunction.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>26925</p>
<p>FLS</p>
<p>Length calculation for misaligned access </p>
<p>fails</p>
<p>Description: </p>
<p>Length calculation in Fls_Internal leads to invalid values. </p>
<p> </p>
<p>Actual behaviour: </p>
<p>Resulting length is around 4 billion which causes other function to be in endless loop. </p>
<p> </p>
<p>Expected behaviour: </p>
<p>Correct length calculation</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27581</p>
<p>FLS</p>
<p>Fls_GVar structure is not initialised </p>
<p>properly according to C89/C90 (ISO/IEC </p>
<p>9899:1990)</p>
<p>Problem description: </p>
<p>The initialization of Fls_GVar in Fls_Ram.c is not according to C90 standard. A structure that contains pointers, variables and further structures is simply initialized with &quot;0&quot;. </p>
<p>This is possible in C99 (ISO/IEC 9899:1999, chapter 6.7.8.21), but MCAL shall be implemented according to C89/C90 (ISO/IEC 9899:1990). </p>
<p> </p>
<p>In Coding Guidelines EAAR-GL-0084.pdf, EAAR_PN0084_NR_0065 an example is given: </p>
<p>/* Usage and initialization in a C file: */   </p>
<p>MyModule_Vector_tst Vector1_st = { 0, 0, 0 }; </p>
<p> </p>
<p> </p>
<p>Expected behaviour: </p>
<p>Each element in the structure shall be initialised properly. </p>
<p> </p>
<p>Actual behaviour: </p>
<p>Structure is initialised as VAR(Fls_GVarProperties, FLS_INIT_DATA) Fls_GVar = {FLS_ZERO}; </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27819</p>
<p>FLS</p>
<p>Fls_Resume cannot interrupt the FLS </p>
<p>ISR(JOB END).(AR_PN0072_FR_0046)</p>
<p>Problem Description:  </p>
<p>As per current implementation in Fls_Resume() API, If FLS_DEV_ERROR_DETECT = STD_ON and FLS_TIMEOUT_MONITORING = STD_ON then after waiting for FLS_ISR_TIMEOUT_VALUE, It </p>
<p>starts FLS Resume process without checking whether FLS ISR is serviced (Check whether Fls_GVar.Fls_MutexFlag == FLS_ZERO). In current implementation, It will also not report any DET if </p>
<p>timeout occurred after waiting for FLS ISR is serviced. </p>
<p> </p>
<p>This issue exist in file Fls.c V1.3.6. </p>
<p> </p>
<p> </p>
<p>As per requirement AR_PN0072_FR_0046:-  </p>
<p> </p>
<p>&lt;Fls_Suspend cannot interrupt the FLS ISR(JOB END). It means when FLS ISR(JOB END) has already entered critical section (protected by semaphore/mutex) the upcoming Fls_Suspend </p>
<p>must wait until ISR(JOB END) exits critical section. until ISR(JOB END) exits critical section.&gt; </p>
<p> </p>
<p>Understanding is that above mentioned point in MRS is not correct. As per our understanding correct one is as mentioned below. </p>
<p> </p>
<p>&lt;Fls_Resume cannot interrupt the FLS ISR(JOB END). It means when FLS ISR(JOB END) has already entered critical section (protected by semaphore/mutex) the upcoming Fls_Resume must </p>
<p>wait until ISR(JOB END) exits critical section. until ISR(JOB END) exits critical section.&gt; </p>
<p> </p>
<p>Expected Behavior: MRS requirement AR_PN0072_FR_0046 needs to implement properly. </p>
<p> </p>
<p>Actual Behavior: MRS requirement AR_PN0072_FR_0046 is not implemented properly. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>27829</p>
<p>FLS</p>
<p>Fls_Suspend cannot interrupt the FLS </p>
<p>ISR(JOB END).(AR_PN0072_FR_0045)</p>
<p>Problem Description:  </p>
<p>As per current implementation in Fls_Suspend() API, If FLS_DEV_ERROR_DETECT = STD_ON and FLS_TIMEOUT_MONITORING = STD_ON then after waiting for FLS_ISR_TIMEOUT_VALUE, It </p>
<p>starts FLS Suspend process without checking whether FLS ISR is serviced (Check whether Fls_GVar.Fls_MutexFlag == FLS_ZERO). In current implementation, It will also not report any DET if </p>
<p>timeout occurred after waiting for FLS ISR is serviced. </p>
<p> </p>
<p>This issue exist in file Fls.c V1.3.6. </p>
<p> </p>
<p> </p>
<p>As per requirement AR_PN0072_FR_0045:- Fls_Suspend cannot interrupt the FLS ISR(JOB END). It means when FLS ISR(JOB  </p>
<p>END) has already entered critical section (protected by semaphore/mutex) the upcoming Fls_Suspend must wait until ISR(JOB END) exits critical section.  </p>
<p> </p>
<p>Expected Behavior: MRS requirement AR_PN0072_FR_0045 needs to implement properly. </p>
<p> </p>
<p>Actual Behavior: MRS requirement AR_PN0072_FR_0045 is not implemented properly. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27839</p>
<p>FLS</p>
<p>Fls_Cancel cannot interrupt the FLS ISR(JOB </p>
<p>END).(AR_PN0072_FR_0011)</p>
<p>Problem Description:  </p>
<p>As per current implementation in Fls_Cancel() API if FLS_DEV_ERROR_DETECT = STD_ON and FLS_TIMEOUT_MONITORING = STD_ON then after waiting for FLS_ISR_TIMEOUT_VALUE, It </p>
<p>starts FLS Cancel process without checking whether FLS ISR is serviced (Check whether Fls_GVar.Fls_MutexFlag == FLS_ZERO). In current implementation, It will also not report any DET if </p>
<p>timeout occurred after waiting for FLS ISR is serviced. </p>
<p> </p>
<p>This issue exist in file Fls.c V1.3.6. </p>
<p> </p>
<p> </p>
<p>As per requirement AR_PN0072_FR_0011:- Fls_Cancel cannot interrupt the FLS ISR(JOB END). It means when FLS ISR(JOB END) has already entered critical section (protected by </p>
<p>semaphore/mutex) the upcoming Fls_Cancel must wait until ISR(JOB END) exits critical section. </p>
<p> </p>
<p>Expected Behavior: MRS requirement AR_PN0072_FR_0011 needs to implement properly. </p>
<p>Actual Behavior: NA </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27867</p>
<p>FLS</p>
<p>Pre compile switch required to partition </p>
<p>FCL and FDL in source code </p>
<p>(AR_PN0072_FR_0027)</p>
<p>Problem description: </p>
<p> </p>
<p>As per AR_PN0072_FR_0027, The source code of FLS module must be partitioned in FCL part and FDL part by </p>
<p>using pre-compile switches. </p>
<p>The Flash library files, in this case FCL/FDL files, shall be included in build process as per FLS module configuration for respective use-cases. Redundant library files shall be excluded from </p>
<p>build process </p>
<p> </p>
<p>Expected behavior: The requirement AR_PN0072_FR_0027 shall be implemented </p>
<p> </p>
<p>Actual Behavior: NA</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27890</p>
<p>FLS</p>
<p>Flash library status mapping</p>
<p>Problem description: </p>
<p>Internal status of underlying libraries, ie. FCL and FDL shall be mapped to FLS driver status accordingly and shall lead to proper job processing result of FLS driver. </p>
<p> </p>
<p>In case of critical internal errors, notification must be given and user can decide to take necessary remedy. </p>
<p> </p>
<p>Expected behavior: </p>
<p>MRS requirement AR_PN0072_FR_0042 needs to implement. </p>
<p> </p>
<p>Actual behavior: </p>
<p>MRS requirement AR_PN0072_FR_0042 is not implemented properly.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28459</p>
<p>FLS</p>
<p>Incomplete linker directive file for FLS </p>
<p>sample application</p>
<p>&lt;B&gt;Problem Description:&lt;/B&gt; </p>
<p>The linker directive file of FLS sample application does not contain the entries for  </p>
<p>copying the initial variable values from ROM to RAM during startup. </p>
<p>This is typically done by e.g. &lt;pre&gt;.romdata  ROM(.data)&lt;/pre&gt; </p>
<p> </p>
<p>&lt;B&gt;Expected Behaviour:&lt;/B&gt; </p>
<p>Variables are initialized by GHS startup as required by C standard. </p>
<p> </p>
<p>&lt;B&gt;Actual Behaviour:&lt;/B&gt; </p>
<p>Variables are uninitialized, typically at 0 after power on, at any undefined value after reset. </p>
<p>Application might show strange behaviour.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28514</p>
<p>FLS</p>
<p>Negative test cases required to verify the </p>
<p>boundary check of FLS_CF_OFFSET_VALUE</p>
<p>In Fls.c,in section </p>
<p> </p>
<p>#if (FLS_FLASH_ACCESS == FLS_CODEFLASH_ACCESS) </p>
<p>    /* Virtual address is mapped to physical address */ </p>
<p>    TargetAddress = TargetAddress - FLS_CF_OFFSET_VALUE; </p>
<p> </p>
<p>There shall be a check for TargetAddress against FLS_CF_OFFSET_VALUE before doing subtraction. </p>
<p> </p>
<p>Further, it requires negative test cases to verify the boundary check.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28515</p>
<p>FLS</p>
<p>Fls_GulTimeout to be removed from </p>
<p>functions Fls_CFProcessReadCommand and </p>
<p>Fls_CFProcessCompareCommand</p>
<p>In Fls_Internal.c, Fls_GulTimeout is actually not used in functions Fls_CFProcessReadCommand and Fls_CFProcessCompareCommand. </p>
<p> </p>
<p>So it should be removed from above mentioned two subfunctions.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28516</p>
<p>FLS</p>
<p>Setting of variable job notification to True </p>
<p>is actually not depending on data flash </p>
<p>status or code flash status</p>
<p>In Fls_Internal.c, in API Fls_EndJobProcess(), 'LblJobNotification' variable is set to true irrespective of the condition check &quot;if (R_FDL_OK == Fls_GstVar.GucDFStatus)&quot;. </p>
<p> </p>
<p>Similar is the case with the check &quot;if (R_FCL_OK == Fls_GstVar.GucCFStatus)&quot;. </p>
<p> </p>
<p>So the redundant code can be merged in these cases.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28517</p>
<p>FLS</p>
<p>DEM error report should be added </p>
<p>depending on the Erase/Write operations.</p>
<p>In Fls_Irq.c, Dem_ReportErrorStatus(FLS_E_ERASE_FAILED, DEM_EVENT_STATUS_FAILED) and Dem_ReportErrorStatus(FLS_E_WRITE_FAILED, DEM_EVENT_STATUS_FAILED) should be </p>
<p>added depending on the Erase/Write operations. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28518</p>
<p>FLS</p>
<p>Tool shall throw error message when </p>
<p>'FlsUseInterrupt = ON' and the call back </p>
<p>functions are not mapped</p>
<p>If interrupt is supported (FlsUseInterrupt = ON) and the call back functions are not mapped (NULL), the program will hang. </p>
<p> </p>
<p>The tool code shall be updated to throw error message for above mentioned user configuration.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28520</p>
<p>FLS</p>
<p>Default value of LenReturnValue shall be </p>
<p>E_NOT_OK</p>
<p>In Fls.c, </p>
<p> </p>
<p>Default value of LenReturnValue shall be E_NOT_OK. In this way, FLS job request will be rejected in the first place when driver state is busy. This logic is not dependent on DET settings.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28521</p>
<p>FLS</p>
<p>The logic for updating </p>
<p>Fls_GVar.Fls_GenState and </p>
<p>Fls_GVar.Fls_GenJobResult shall be in line </p>
<p>with the logic in Fls_EndJobProcess</p>
<p>In Fls_Irq.c, at end of job processing, the logic for updating Fls_GVar.Fls_GenState, Fls_GVar.Fls_GenJobResult and triggering JobEnd or JobError notifications shall be in line with the logic </p>
<p>in Fls_EndJobProcess function in Fls_Internal.c. </p>
<p> </p>
<p>In the current implementation, Fls_Erase and Fls_Write support interrupt based job processing. And Fls_EndJobProcess is not required at end of interrupt based job processing.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28522</p>
<p>FLS</p>
<p>JobEnd and JobErrorNotification should </p>
<p>depend on both (FLS_JOB_NOTIF_CONFIG </p>
<p>== STD_ON) &amp;&amp; (FLS_INTERRUPT_MODE == </p>
<p>STD_ON)</p>
<p>In Fls_Irq.c, Fls_GpConfigPtr-&gt;pJobEndNotificationPointer() and Fls_GpConfigPtr-&gt;pJobErrorNotificationPointer() should be depending on both (FLS_JOB_NOTIF_CONFIG == STD_ON) &amp;&amp; </p>
<p>(FLS_INTERRUPT_MODE == STD_ON). </p>
<p> </p>
<p>Actual Behaviour : </p>
<p> </p>
<p>if (R_FDL_OK == Fls_GstVar.GucDFStatus) </p>
<p>{ </p>
<p>  /* Set the job Result to OK */ </p>
<p>  Fls_GVar.Fls_GenJobResult = MEMIF_JOB_OK; </p>
<p>  /* If job ended with success and call the job end call back </p>
<p>   * function. </p>
<p>   */ </p>
<p>  Fls_GpConfigPtr-&gt;pJobEndNotificationPointer(); </p>
<p>} </p>
<p>else </p>
<p>{ </p>
<p>  /* Set the job Result to Failed */ </p>
<p>  Fls_GVar.Fls_GenJobResult = MEMIF_JOB_FAILED; </p>
<p>  /* If job ended with error and call the job error call back </p>
<p>   * function. </p>
<p>   */ </p>
<p>  Fls_GpConfigPtr-&gt;pJobErrorNotificationPointer(); </p>
<p>} </p>
<p> </p>
<p>Expected Behaviour : </p>
<p> </p>
<p>if (R_FDL_OK == Fls_GstVar.GucDFStatus) </p>
<p>{ </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28523</p>
<p>FLS</p>
<p>Improvement in PDF of P1x</p>
<p>The following points should be taken care in the Parameter Definition File of P1x. </p>
<p> </p>
<p>a. The upper bound/maximum value of FlsFclRamAddress shall be 4276092927 (0xFEDF_FFFF) for P1x. </p>
<p> </p>
<p>b. The parameters used in each of the following containers should be re-ordered to give a better overview of parameters. </p>
<p>     1. FlsDataFlash </p>
<p>     2. FlsCodeFlash </p>
<p>     3. FlsPublishedInformation </p>
<p> </p>
<p>c. Parameter &quot;FlsDFTotalSize&quot; in 'FlsDataFlash' container should be renamed as &quot;FlsDataFlashSize&quot;. </p>
<p> </p>
<p>d. The statement in the description of following parameters shall be updated as mentioned. </p>
<p>     1. FlsMaxWriteNormalMode : add into description - This parameter is not used for implementation. </p>
<p>     2. FlsMaxEraseNormalMode : add into description - This parameter is not used for implementation. </p>
<p>     3. FlsTotalSize : improve description - This parameter specifies the total amount of flash memory in bytes that is accessible by FLS driver. </p>
<p>     4. FlsNumberOfSectors : add into description - This parameter setting shall be in line with FlsSectorStartaddress. </p>
<p>     5. FlsFclRamAddress : add into description - This parameter is not used for implementation. </p>
<p>     6. FlsDFTotalSize : improve description - This parameter indicates the physical total size of Data Flash memory.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28545</p>
<p>FLS</p>
<p>Safe exit from while-loop for </p>
<p>R_FDL_Handler in Fls_Init shall be realized </p>
<p>as per general requirement</p>
<p>In Fls.c, </p>
<p> </p>
<p>Safe exit from while-loop for R_FDL_Handler in Fls_Init shall be realized as per general requirement. </p>
<p> </p>
<p>Timeout monitoring can be considered here.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28546</p>
<p>FLS</p>
<p>DEM error should be reported for transient </p>
<p>failures</p>
<p>FLS Initialization (Fls_Init) can fail during driving cycle of ECU, due to eg. operation voltage change, clock frequency change, etc. (transient failures). </p>
<p>Such kind of fault must be notified and afterwards the upper layer can, for example, retry with init procedure until succeeds, or the system can be switched to a safety state if required. </p>
<p>DEM error should be reported here.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28547</p>
<p>FLS</p>
<p>R_FDL_Handler() call in Fls_MainFunction </p>
<p>and Fls_Init should be protected with </p>
<p>critical section</p>
<p>In Fls.c, R_FDL_Handler() call in Fls_MainFunction and Fls_Init should be protected with critical section.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28587</p>
<p>FLS</p>
<p>Unexpected Interrupt pending bit is set in </p>
<p>Fls_Write and Fls_Erase APIs</p>
<p>Problem description: </p>
<p>In Fls_Write and Fls_Erase APIs, interrupt processing is enabled as follows: </p>
<p> #if (FLS_INTERRUPT_MODE == STD_ON) </p>
<p>        /* Enable interrupt processing */ </p>
<p>        RH850_SV_MODE_IMR_AND(16, (Fls_GpConfigPtr-&gt;pFlEndImrAddress), </p>
<p>                                   (Fls_GpConfigPtr-&gt;usFlEndImrMask)); </p>
<p> #endif </p>
<p> </p>
<p>At that point SW nearly always had the interrupt pending bit set, so a first unwanted interrupt occurs quite fast there. </p>
<p> </p>
<p>Pending interrupts are not properly handled in the code so that this will cause some confusion because of a pending interrupt from the previous operation. </p>
<p> </p>
<p>There is a chance of setting interrupt pending bit from the previous Read operation, which have inbuilt blank check. </p>
<p> </p>
<p>Expected behaviour: </p>
<p>Before enabling interrupts, interrupt pending bit shall be cleared. </p>
<p> </p>
<p>Actual behaviour: </p>
<p>Interrupt pending bit is set when interrupt processing is enabled in Fls_Write and Fls_Erase APIs </p>
<p>FEATURE</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28507</p>
<p>FlsTst</p>
<p>As per Autosar requirement, FlsTst.h </p>
<p>should include Std_Types.h directly.</p>
<p>According to Autosar requirement specification, the include of Std_Types.h should be done in FlsTst.h </p>
<p> </p>
<p>But in FlsTst, Std_Types.h is included through FlsTst_PBTypes.h and FlsTst_Types.h in the current implementation. The files can be found in the following svn path - </p>
<p> </p>
<p>/trunk/external/X1X/common_platform/modules/flstst/include </p>
<p> </p>
<p> </p>
<p> </p>
<p>Expected behaviour : </p>
<p>FlsTst.h should include Std_Types.h directly. </p>
<p> </p>
<p>Actual behaviour :  </p>
<p>Std_Types.h is included through FlsTst_PBTypes.h and FlsTst_Types.h</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28511</p>
<p>FlsTst</p>
<p>FlsTst_GenLastFgndResult and </p>
<p>FlsTst_GenOverallBgndResult shall be </p>
<p>declared as FLSTST_INIT_DATA</p>
<p>FlsTst_GenLastFgndResult and FlsTst_GenOverallBgndResult shall be declared as FLSTST_INIT_DATA, so as to match with memory section FLSTST_START_SEC_VAR_UNSPECIFIED. </p>
<p>But in the current implementation FlsTst_GenLastFgndResult and FlsTst_GenOverallBgndResult are declared as FLSTST_NOINIT_DATA. This can be found in the path - </p>
<p>   \trunk\external\X1X\common_platform\modules\flstst\src\FlsTst_Ram.c </p>
<p> </p>
<p>Expected Behaviour : </p>
<p>/* Variable to store the fgnd test result  */ </p>
<p>VAR(FlsTst_TestResultFgndType, FLSTST_INIT_DATA)FlsTst_GenLastFgndResult </p>
<p>                                                            = FLSTST_NOT_TESTED; </p>
<p>/* TRACE [R4, FlsTst154] */ </p>
<p>/* Variable to store the overall Bgnd test result  */ </p>
<p>VAR(FlsTst_TestResultType, FLSTST_INIT_DATA)FlsTst_GenOverallBgndResult </p>
<p>                                                     = FLSTST_RESULT_NOT_TESTED; </p>
<p> </p>
<p>Actual Behaviour : </p>
<p>/* Variable to store the fgnd test result  */ </p>
<p>VAR(FlsTst_TestResultFgndType, FLSTST_NOINIT_DATA)FlsTst_GenLastFgndResult </p>
<p>                                                            = FLSTST_NOT_TESTED; </p>
<p>/* TRACE [R4, FlsTst154] */ </p>
<p>/* Variable to store the overall Bgnd test result  */ </p>
<p>VAR(FlsTst_TestResultType, FLSTST_NOINIT_DATA)FlsTst_GenOverallBgndResult </p>
<p>                                                     = FLSTST_RESULT_NOT_TESTED;</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>27528</p>
<p>Fr</p>
<p>[P1x][Fr] While doing QAC Static Analysis, </p>
<p>Some of the Misra violations are not </p>
<p>justified.</p>
<p>Problem Description: </p>
<p>While running QAC Static Analysis for the Fr_59.c file and Fr_59_Internal.c, QAC Misra rules violations are occuring.Some of the violations are justified and some violations are not </p>
<p>justified.(For example: The messages such as 4:1843, 4:1863, 4:2985 etc. are not justified.). </p>
<p>Common code change is not in the scope of V4.00.04 P1x release. </p>
<p> </p>
<p>Expected Behaviour: </p>
<p>NA </p>
<p> </p>
<p>Actual Behaviour: </p>
<p>NA</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27727</p>
<p>Fr</p>
<p>[P1x][V4.00.04][FR] The test cases related </p>
<p>to </p>
<p>Dem_ReportErrorStatus(FrDemCtrlTestRes</p>
<p>ultRef, DEM_EVENT_STATUS_FAILED) - </p>
<p>FR_ETC_06</p>
<p>Problem Description: </p>
<p>The test cases related to Dem_ReportErrorStatus(FrDemCtrlTestResultRef, DEM_EVENT_STATUS_FAILED) - FR_ETC_065, Dem_ReportErrorStatus (FrIfDemFTSlotStatusRef, </p>
<p>DEM_EVENT_STATUS_FAILED) - FR_ETC_066 and FR_ETC_067 are failing. </p>
<p> </p>
<p>FR_ETC_065: </p>
<p>In the ESTS, in the Tested functionality, Dem_ReportErrorStatus(FR_E_ACCESS, DEM_EVENT_STATUS_FAILED) is tested.But in the expected test result, </p>
<p>Dem_ReportErrorStatus(FrDemCtrlTestResultRef, DEM_EVENT_STATUS_FAILED) is checked for the APIs Fr_ReceiveRxLPdu, Fr_CheckTxLPduStatus, Fr_TransmitTxLPdu, Fr_CancelTxLPdu. </p>
<p>The test cases FR_ETC_065 is not tested because the Dem_ReportErrorStatus (FrDemCtrlTestResultRef, DEM_EVENT_STATUS_FAILED) is not implemented in the following APIs </p>
<p>Fr_ReceiveRxLPdu, Fr_CheckTxLPduStatus, Fr_TransmitTxLPdu, Fr_CancelTxLPdu. </p>
<p> </p>
<p>FR_ETC_066 and FR_ETC_067: </p>
<p>In the ESTS, in the Tested functionality, Dem_ReportErrorStatus(FR_E_ACCESS, DEM_EVENT_STATUS_FAILED) is tested.But in the expected test result,Dem_ReportErrorStatus </p>
<p>(FrIfDemFTSlotStatusRef, DEM_EVENT_STATUS_FAILED) is checked for the APIs Fr_TransmitTxLPdu, Fr_ReceiveRxLPdu. </p>
<p>The test cases FR_ETC_066 and FR_ETC_067 are not tested because the Dem_ReportErrorStatus (FrIfDemFTSlotStatusRef, DEM_EVENT_STATUS_FAILED) is not implemented in the </p>
<p>following APIs Fr_TransmitTxLPdu, Fr_ReceiveRxLPdu. </p>
<p> </p>
<p>Expected Behaviour: </p>
<p>FR_ETC_065: </p>
<p>As per the Autosar R4.03 FlexRay SWS requirement, </p>
<p>if any hardware error occurs while running the APIs Fr_ReceiveRxLPdu[FR232], Fr_CheckTxLPduStatus[FR243] , Fr_TransmitTxLPdu[FR223], Fr_CancelTxLPdu[FR613], then it should call </p>
<p>Dem_ReportErrorStatus (FrDemCtrlTestResultRef, DEM_EVENT_STATUS_FAILED) and return E_NOT_OK. </p>
<p> </p>
<p>FR_ETC_066 and FR_ETC_067: </p>
<p>As per the Autosar R4.03 FlexRay SWS requirement, </p>
<p>In the API Fr_ReceiveRxLPdu, [FR605]If the optional configuration parameter FrIfDemFTSlotStatusRef exists and a single slot status error bit (vSS!SyntaxError, vSS!ContentError, </p>
<p>vSS!Bviolation) is set, then the slot status information shall be reported to DEM as Dem_ReportErrorStatus (FrIfDemFTSlotStatusRef, DEM_EVENT_STATUS_FAILED). </p>
<p> </p>
<p>Actual Behaviour: </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27728</p>
<p>Fr</p>
<p>[P1x][V4.00.04][FR] the functional </p>
<p>testcases related to Transmit Queue and </p>
<p>Receive Queue functionality are failing.</p>
<p>Problem Description: </p>
<p>In ESTS the functional testcases related to Transmit Queue and Receive Queue functionality (FR_ETC_098, FR_ETC_099, FR_ETC_100, FR_ETC_101, FR_ETC_102, FR_ETC_103) are failing. </p>
<p> </p>
<p>Expected Behaviour: </p>
<p>After transmitting the Data by invoking Fr_TransmitQueue_Table() it is returning E_OK as per the Expected Test result and when Fr_ReceiveQueue_Table() is invoked, it should E_OK and </p>
<p>also the transmitted data should be received by the controller. </p>
<p> </p>
<p>Actual Behaviour: </p>
<p>After transmitting the Data by invoking Fr_TransmitQueue_Table() it is returning E_OK as per the Expected Test result and when Fr_ReceiveQueue_Table() is invoked, it is returning E_OK </p>
<p>as per the expected Test Result but the data is not received. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28147</p>
<p>Fr</p>
<p>[P1x][Fr][R4.0] </p>
<p>Fr_User_Request_Output_Transfer and </p>
<p>Fr_User_Request_Input_Transfer API's are </p>
<p>not working.</p>
<p>Problem Description: </p>
<p>Fr_User_Request_Output_Transfer and Fr_User_Request_Input_Transfer API's are returning E_OK but no transmit/receive functionality is happening. </p>
<p> </p>
<p>Expected Behaviour: </p>
<p>Transmit/receive functionality should happen in this Fr_User_Request_Output_Transfer and Fr_User_Request_Input_Transfer API's . </p>
<p> </p>
<p>Actual Behaviour: </p>
<p>Transmit/receive functionality is not happen in this Fr_User_Request_Output_Transfer and Fr_User_Request_Input_Transfer API's .</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28326</p>
<p>Fr</p>
<p>[P1x][FR]Some Ecode lines are more than  </p>
<p>80 characters and trailing spaces are </p>
<p>present.</p>
<p>Problem Description: </p>
<p>1.More than 80 characters in following lines :  </p>
<p>Fr_59_Internal.c : @L1332 , L1352, 1405,1424,1519,1591,1620,1632,1774,1905,2101 </p>
<p>Fr_59.c : @L1909,2561 </p>
<p>Fr_59_Debug.h : @L83 </p>
<p>Fr_59_GeneralTypes.h:@L277,286 </p>
<p>Fr_59_Internal.h : @L71, @L97 </p>
<p>Fr_59_Version.h: @L86 </p>
<p>Fr_59.h : @L436, L70 </p>
<p> </p>
<p>2. Trim trailing space not done in following files: </p>
<p>Fr_59.h, Fr_59_Ram.h, Fr_59_PBTypes.h, Fr_59_Internal.h, Fr_59.c, Fr_59_Ram.c, Fr_59_Internal.c </p>
<p> </p>
<p>Actual Behavior: </p>
<p>NA </p>
<p> </p>
<p>Expected Behavior: </p>
<p>NA </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28474</p>
<p>Fr</p>
<p>[P1x][Fr][R4.0] Null pointer checking is not </p>
<p>performing.</p>
<p>Problem Description: </p>
<p>Null pointer checking is not performing in the following API's </p>
<p> </p>
<p>1.Fr_59_ReceiveRxLPdu </p>
<p>  line: 3053  (*Fr_LPduStatusPtr = FR_59_NOT_RECEIVED;) </p>
<p>  line: 3058  (*Fr_LSduLengthPtr = FR_59_ZERO;) </p>
<p>2.Fr_59_CheckTxLPduStatus  </p>
<p>  line: 8485  (*Fr_TxLPduStatusPtr = FR_59_NOT_TRANSMITTED;) </p>
<p> </p>
<p> </p>
<p>Actual behaviour: </p>
<p>When dereference a NULL pointer thereby raising a NullPointerException. It will cause the controller to reset. </p>
<p> </p>
<p>Expected behaviour: </p>
<p>Null pointer checking should be performed in the API Fr_59_ReceiveRxLPdu, Fr_59_CheckTxLPduStatus</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28397</p>
<p>GPT</p>
<p>Wake up disabled channels are giving DET </p>
<p>after GPT_MODE_SLEEP to </p>
<p>GPT_MODE_NORMAL  mode transition.</p>
<p>Description </p>
<p>----------- </p>
<p>While Running ATF test case &quot;GPT_FTC_142&quot; its observed that unexpected DET with </p>
<p>ApiId = 0X2 =&gt; Service Id of Gpt_DeInit API. </p>
<p>ErrorId = 0XB =&gt; DET code to report Timer is already running. </p>
<p> </p>
<p>is occurring when calling Gpt_DeInit(), here all channels are expected be in &quot;stopped&quot; state. </p>
<p> </p>
<p>We tested as mentioned below, in ATF configuration &quot;ATF_cfg01&quot;. </p>
<p> </p>
<p>Test Scenario </p>
<p>------------- </p>
<p> </p>
<p>1.  Call Gpt_Init(&amp;GPT_CONFIG_01) to initialize the driver with [GPT_CONFIG_01]. </p>
<p>     </p>
<p>2.  Call Gpt_EnableNotification() for channel 0. </p>
<p>3.  Call Gpt_EnableNotification() for channel 1. </p>
<p>4.  Call Gpt_EnableNotification() for channel 3. </p>
<p>     </p>
<p>5.  Call Gpt_EnableWakeup() for channel 0. </p>
<p>6.  Call Gpt_DisableWakeup() for channel 1. </p>
<p>5.  Call Gpt_DisableWakeup() for channel 3. </p>
<p>     </p>
<p>6.  Call Gpt_StartTimer() for channel 0. </p>
<p>7.  Call Gpt_StartTimer() for channel 1. </p>
<p>8.  Call Gpt_StartTimer() for channel 3. </p>
<p>     </p>
<p>9.  Wait for 1 Seconds. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28405</p>
<p>GPT</p>
<p>Timer is starting automatically when call </p>
<p>Gpt_EnableWakeup() in GPT_MODE_SLEEP </p>
<p>mode.</p>
<p>While testing ATF test case &quot;App_Gpt_Sample&quot; its observed that notification is occurring when call Gpt_EnableWakeup() in GPT_MODE_SLEEP mode before starting the timer. </p>
<p> </p>
<p>We tested as mentioned below, in ATF configuration &quot;ATF_cfg05&quot;. </p>
<p> </p>
<p>1.  Call Gpt_Init(&amp;GPT_CONFIG_01) to initialize the driver with [GPT_CONFIG_01]. </p>
<p>2.  Call Gpt_EnableNotification() for channel 0. </p>
<p>3.  Start timer for channel 0. </p>
<p>4.  Wait for 200 (ms). </p>
<p>5.  call Gpt_GetTimeElapsed() for channel 0. </p>
<p>6.  Check whether Time Elapsed &gt; 0 , and it's obtained as expected. </p>
<p>7.  Wait for 10 (ms). </p>
<p>8.  call Gpt_GetTimeRemaining() for channel 0. </p>
<p>9.  Check whether Time Remaining &gt; 0 , and it's obtained as expected. </p>
<p>10. Wait for 5 Seconds. </p>
<p>11. Check whether notification obtained is  &gt; 0 , and it's obtained as expected. </p>
<p>12. call Gpt_DisableWakeup() for channel 0. </p>
<p>13. Set GPT mode to 'GPT_MODE_SLEEP' by calling  &quot;Gpt_SetMode(GPT_MODE_SLEEP)&quot;. </p>
<p>14. Wait for 1 Seconds. </p>
<p>15. Clear The Notification Count. </p>
<p>16. Wait for 2 Seconds. </p>
<p>17. Check whether notification obtained is  = 0 , and it's obtained as expected. </p>
<p>18. Set GPT mode to 'GPT_MODE_NORMAL' by calling  &quot;Gpt_SetMode(GPT_MODE_NORMAL)&quot;. </p>
<p>19. Wait for 2 Seconds. </p>
<p>20. Check whether notification obtained is  = 0 , and it's obtained as expected. </p>
<p>21. Set GPT mode to 'GPT_MODE_SLEEP' by calling  &quot;Gpt_SetMode(GPT_MODE_SLEEP)&quot;. </p>
<p>22. call Gpt_EnableWakeup() for channel 0. </p>
<p>23. Set GPT mode to 'GPT_MODE_NORMAL' by calling  &quot;Gpt_SetMode(GPT_MODE_NORMAL)&quot;. </p>
<p>24. Wait for 5 Seconds. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>25856</p>
<p>ICU</p>
<p>Obsolete code in Icu_HW_Init() function.</p>
<p>Problem description: </p>
<p>At line 754 in Icu_LLDriver.c the following loop is present: </p>
<p>  for (LucCnt = ICU_MAX_TIMER_CHANNELS_CONFIGURED; LucCnt &lt; ICU_MAX_CHANNEL; </p>
<p>                                                                       LucCnt++) </p>
<p>  { </p>
<p> </p>
<p>This &quot;for&quot; loop is used for external interrupts only and not for timer channels initialization. </p>
<p> </p>
<p>Inside the loop you have checks for timer channels, which will always fail, since the loop is only for channels configured with external interrupts. </p>
<p> </p>
<p>It seems that everything above the &quot;switch&quot; at line 823 in this loop is obsolete code. </p>
<p> </p>
<p> </p>
<p>Expected behavior: </p>
<p>N/A </p>
<p> </p>
<p>Actual behavior: </p>
<p>N/A</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27622 ICU</p>
<p>Interrupts(IMR) are enabled All Channel </p>
<p>After calling Icu_SetMode() Api form </p>
<p>ICU_MODE_SLEEP to ICU_MODE_NORMAL.</p>
<p>Problem Description: </p>
<p>As per Autosar4.0.3 ICU requirement says that ICU194  ICU_MODE_NORMAL: Normal operation, all used interrupts are enabled according to the notification requests. ICU_MODE_SLEEP: </p>
<p>Reducedpower mode. In sleep mode only those notifications are available which are configured as wakeup capable.  </p>
<p> </p>
<p>Current implementation is </p>
<p>In Icu_SetMode(ICU_MODE_NORMAL) Api  called after Icu_SetMode(ICU_MODE_SLEEP) Api. </p>
<p>All interrupts are enabled with out considering Current notification status. </p>
<p> </p>
<p> Ver4.01.06 -- release  Icu_LLDriver.c </p>
<p> 1765:        /* Enable Interrupt */  </p>
<p> 1766:        RH850_SV_MODE_IMR_AND(16, (LpImrIntpCntrlReg),  </p>
<p>                           (LpChannelConfig-&gt;usImrMaskValue));  </p>
<p> </p>
<p> </p>
<p>Expected Behaviour: </p>
<p>All used interrupts are enabled according to the notification requests </p>
<p> </p>
<p>Actual Behaviour: </p>
<p>All interrupts are enabled with out considering notification status.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28585</p>
<p>ICU</p>
<p>Component User Manual - Unimplemented </p>
<p>APIs and Not supported features </p>
<p>Problem Description: </p>
<p>1. The functionalities which are not supported by the hardware are present in the component user manual.Icu_CheckWakeup, Icu_DisableWakeup and Icu_EnableWakeup should be </p>
<p>removed from user manual. </p>
<p> </p>
<p>2. If a feature is not supported please mention &quot;Not supported&quot; in Table 5-1 </p>
<p> </p>
<p>Expected Behaviour: </p>
<p>NA </p>
<p> </p>
<p>Actual Behaviour: </p>
<p>Wakeup functionalities(Icu_CheckWakeup, Icu_DisableWakeup and Icu_EnableWakeup) which are not implemented are mentioned in the user manual, which misleads the user.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>27490</p>
<p>MCU</p>
<p>McuResetReason could not be accessed By </p>
<p>EcuMResetReason from </p>
<p>McuPublishedInformation0/McuResetReas</p>
<p>onConf0 container</p>
<p>Problem Description: </p>
<p>The contents of McuPublishedInformation0/McuResetReasonConf0/McuResetReason could not be accessed from EcuMResetReason since the implementation methodology in </p>
<p>McuPublishedInformation dont seem to be according to what AUTOSAR has prescribed </p>
<p> </p>
<p>Note: Why is the P1x McuResetReason implementation  different from F1x (The McuResetReason implemented in different way for F1x and P1x devices ) </p>
<p>  </p>
<p>Expected Behavior: </p>
<p>None </p>
<p> </p>
<p>Actual Behavior: </p>
<p>None</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28160</p>
<p>MCU</p>
<p>GetVersionInfo() API of each module shall </p>
<p>also return “instanceID” as one of the </p>
<p>parameter in Std_VersionInfoType</p>
<p>Problem Description: </p>
<p> </p>
<p>This ticket is created to track the pre-release review done on P1x MCU work products as part of V4.00.04 release.  </p>
<p> </p>
<p>Requirement: AR_PN0034_FR_0017 </p>
<p> </p>
<p>Finding: As per the requirement GetVersionInfo() API of each module shall also return “instanceID” as one of the </p>
<p>parameter in Std_VersionInfoType pointed by the output parameter versioninfo. In the current implementation only moduleid, and vendorid are returned. Instance id is not returned </p>
<p> </p>
<p> </p>
<p>Expected Behavior: </p>
<p>GetVersionInfo() API of each module shall return moduleid, vendorid and instanceID </p>
<p> </p>
<p>Actual Behavior: </p>
<p>GetVersionInfo() API of each module shall return moduleid and vendorid </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28170</p>
<p>MCU</p>
<p>Dummy read to register must be </p>
<p>performed after writing to register.</p>
<p>Problem Description: </p>
<p> </p>
<p>This ticket is created to track the pre-release review done on P1x MCU work products as part of V4.00.04 release. </p>
<p> </p>
<p>Requirement: AR_PN0034_FR_0068 </p>
<p> </p>
<p>Finding: Synchronizing peripherals register write operation by dummy read. As per this requirement, Dummy read to register must be performed after writing to register. The requirement </p>
<p>is not taken care in Mcu source code. </p>
<p> </p>
<p>Expected Behavior: </p>
<p>NA </p>
<p> </p>
<p>Actual Behavior: </p>
<p>NA</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28202</p>
<p>MCU</p>
<p>APIs Mcu_GetResetReason() and </p>
<p>Mcu_GetResetRawValue() shall return the </p>
<p>same result in case they are called multiple </p>
<p>times</p>
<p>Problem Description: </p>
<p> </p>
<p>This ticket is created to track the pre-release review done on P1x MCU work products as part of V4.00.04 release. </p>
<p> </p>
<p>Requirement: EAAR_PN0079_FR_0086 </p>
<p> </p>
<p>The APIs Mcu_GetResetReason() and Mcu_GetResetRawValue() shall return the </p>
<p>same result in case they are called multiple times after a reset or a power on </p>
<p>event. </p>
<p> </p>
<p>Finding: Add test case to test the requirement. </p>
<p> </p>
<p>Expected behaviour: </p>
<p>NA </p>
<p> </p>
<p>Actual behaviour: </p>
<p>NA </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28382</p>
<p>MCU</p>
<p>McuResetReason added in Mcu schema </p>
<p>cannot be referenced by EcuM</p>
<p>In Mcu Schema several reset reason was added in McuPublishedInformation container. </p>
<p> </p>
<p>According with ECUM128_Conf Mcu Reset Reason should be in McuResetReasonConf container so this can be referenced by EcuM module .</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28421</p>
<p>MCU</p>
<p>In definition file Mandatory parameter's </p>
<p>Lower and Upper multiplicity values are not </p>
<p>taken care properly</p>
<p>Problem Description: </p>
<p>In definition .arxml file Mandatory parameter's Lower and Upper multiplicity value should be one.  </p>
<p>parameters are McuLoopCount and McuPbusWaitCount. </p>
<p> </p>
<p>example: </p>
<p>In Mcu_PBTypes.h MCU_PBUSWAITCOUNT is define with MCU_PBUSWAITCOUNT_VALUE and is used in Mcu.c file </p>
<p>If McuPbusWaitCount value is not set, In Mcu_Cfg.h for MCU_PBUSWAITCOUNT_VALUE will not be generated any value: </p>
<p>In PBcfg.h file </p>
<p>/* Pbus Count Value for the MCU_PBUSWAITCOUNT */ </p>
<p>#define MCU_PBUSWAITCOUNT_VALUE </p>
<p> </p>
<p> </p>
<p>Expected Behavior: </p>
<p>&lt;!-- PARAMETER DEFINITION: McuPbusWaitCount --&gt; </p>
<p>&lt;ECUC-INTEGER-PARAM-DEF UUID=&quot;ECUS:dbeafba1-bfaf-4ca0-8572-235f3c9b9b35&quot;&gt; </p>
<p>&lt;SHORT-NAME&gt;McuPbusWaitCount&lt;/SHORT-NAME&gt; </p>
<p>&lt;DESC&gt; </p>
<p>&lt;L-2 L=&quot;EN&quot;&gt;The parameter represents the PBus access wait time.The loop can be minimum 1 to maximum 65535&lt;/L-2&gt; </p>
<p>&lt;/DESC&gt; </p>
<p>&lt;LOWER-MULTIPLICITY&gt;1&lt;/LOWER-MULTIPLICITY&gt; </p>
<p>&lt;UPPER-MULTIPLICITY&gt;1&lt;/UPPER-MULTIPLICITY&gt; </p>
<p> </p>
<p>Actual Behavior: </p>
<p>&lt;!-- PARAMETER DEFINITION: McuPbusWaitCount --&gt; </p>
<p>&lt;ECUC-INTEGER-PARAM-DEF UUID=&quot;ECUS:dbeafba1-bfaf-4ca0-8572-235f3c9b9b35&quot;&gt; </p>
<p>&lt;SHORT-NAME&gt;McuPbusWaitCount&lt;/SHORT-NAME&gt; </p>
<p>&lt;DESC&gt; </p>
<p>&lt;L-2 L=&quot;EN&quot;&gt;The parameter represents the PBus access wait time.The loop can be minimum 1 to maximum 65535&lt;/L-2&gt; </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28444</p>
<p>MCU</p>
<p>Reset reson handling depending on </p>
<p>POF.POF bit</p>
<p>What is the difference between &quot;McuResetReasonConfPowerOnReset&quot; and &quot;McuResetReasonConfPowerOnFlagReset&quot; ? </p>
<p> </p>
<p>The implementation seems to be wrong as POF.POF bit seems to be set in both cases mentioned, which means only McuResetReasonConfPowerOnFlagReset is reported and </p>
<p>McuResetReasonConfPowerOnFlagReset is never reported. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28473</p>
<p>MCU</p>
<p>App_MCU_Device_Sample.h Which is not </p>
<p>as per AR_PN0034_FR_0039.</p>
<p>Problem Description: </p>
<p> </p>
<p>App_MCU_Device_Sample.h Which is not as per AR_PN0034_FR_0039.  </p>
<p> </p>
<p>Expected Behavior: </p>
<p>NA </p>
<p> </p>
<p>Actual Behavior: </p>
<p>NA</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>25132</p>
<p>Port</p>
<p>When changing port pin to a DIO mode, </p>
<p>handling of PSRn(Pn) is different by API.</p>
<p>Problem Description: </p>
<p>The port pin can be changed to a DIO mode at API Port_SetPinMode, Port_SetToDioMode and Port_SetPinDefaultMode.Among these the Port_SetToDioMode doesn't set to PSR </p>
<p>register.Is this what Development Team intended? </p>
<p> </p>
<p>DIO output level change should be performed in DIO Driver and the user can also decide at the timing of change in the DIO output level.I'm thinking this specification is simplest and is </p>
<p>without mistakes. </p>
<p> </p>
<p>Could you tell me why it's such specification? </p>
<p> </p>
<p>Expected Behavior  : </p>
<p>It is necessary to unify these specifications </p>
<p> </p>
<p>Actual Behavior    : </p>
<p>the Port_SetToDioMode doesn't set to PSR register.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>26487</p>
<p>Port</p>
<p>When Port_SetPinDirection() change </p>
<p>direction from o/p to o/p (refeshing) for </p>
<p>JTAG pins, the o/p level will set to default </p>
<p>state.</p>
<p>PortPinDirectionChangeable = True </p>
<p>PortPinModeChangeable = True </p>
<p>PortPinLevelValue = PORT_PIN_LEVEL_LOW </p>
<p>PortPinInitialMode = DIO_SUPP_PFC_PMCSR </p>
<p>PortPinDirection = &lt;b&gt;PORT_PIN_OUT&lt;/b&gt; </p>
<p> </p>
<p>Test case: </p>
<p>Port_Init(PortConfigSet0); </p>
<p>while(1) </p>
<p>{  </p>
<p>    /* This API will initilize all the registers to the initial values */ </p>
<p>    Port_Init(PortConfigSet0); </p>
<p>    /* Set Port Pin level of for JP0_6 to High. */ </p>
<p>    JPSR0 = 0xFFFF0040; </p>
<p>    /* Refresh the pin. */ </p>
<p>    Port_SetPinDirection (Port_PortGroupJtag00_PortPin60, &lt;b&gt;PORT_PIN_OUT&lt;/b&gt;); </p>
<p>} </p>
<p> </p>
<p>Expected result: </p>
<p>JP0_6 remains High. </p>
<p> </p>
<p>Actual result: </p>
<p>JP0_6 sets to Low.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>26852</p>
<p>Port</p>
<p>Local variables may remain not initialized in </p>
<p>Port_SetToDioOrAltMode API.</p>
<p>Problem description: </p>
<p>If we have a configuration with the following generated code </p>
<p> </p>
<p>/* Availability of numeric port groups */ </p>
<p>#define PORT_NUM_PORT_GROUPS_AVAILABLE STD_OFF </p>
<p> </p>
<p>/* Availability of alphabetic port groups */ </p>
<p>#define PORT_ALPHA_PORT_GROUPS_AVAILABLE STD_OFF </p>
<p> </p>
<p>/* Availability of jtag port groups */ </p>
<p>#define PORT_JTAG_PORT_GROUPS_AVAILABLE STD_OFF </p>
<p> </p>
<p>then in Port_SetToDioOrAltMode() API the local variables LpFuncCtrlReg and LulBaseAddress will be used without being initialized. </p>
<p> </p>
<p>Expected result: </p>
<p>N/A </p>
<p> </p>
<p>Actual result: </p>
<p>N/A</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27039</p>
<p>Port</p>
<p>Port Group 4 Pin 6 MUX appears to be mis-</p>
<p>labeled in the Parameter defitnition file.</p>
<p>Problem description: </p>
<p>Port Group 4 Pin 6 MUX appears to be mis-labeled in the Parameter definition file. It is labeled as TAUD202_ALT6_OUT, while according to the HW user manual &quot;2.4.1.7 Port 4 (P4)&quot; it is </p>
<p>related to TAUD2O3. </p>
<p> </p>
<p>Expected behavior: </p>
<p>Port Group 4 Pin 6 MUX must be labeled as TAUD2O3_ALT6_OUT. </p>
<p> </p>
<p>Actual behavior: </p>
<p>Port Group 4 Pin 6 MUX is labeled as TAUD2O2_ALT6_OUT.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27079</p>
<p>Port</p>
<p>Port Generator throwing unwanted error</p>
<p>Problem description: </p>
<p>If PortIpControl is enabled for e.g. CSI pins as recommended in description of PortIpControl, then error 124018 is raised. </p>
<p>Pin names in description of PortIpControl do not match to available options in PortPinInitialMode. </p>
<p>This issue is valid for 701011 device, but not for 701035. </p>
<p> </p>
<p>Expected behaviour: </p>
<p>No error should occur. </p>
<p> </p>
<p>Actual behaviour: </p>
<p>ERR124018 Error occurs that is in contradiction to description. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27676</p>
<p>Port</p>
<p>Fail to initialize the PFCAE registers </p>
<p>correctly</p>
<p>Problem Description: </p>
<p>The register initialization sequence in Port_InitConfig() api is not as mentioned in r01uh0436ej0070_rh850p1x.pdf(v0.70) at page 122 Section 2.3.4.6. </p>
<p> </p>
<p> </p>
<p>Expected Behavior : </p>
<p> </p>
<p>PFCAE register along with PFC and PFCE should be initialized after initializing </p>
<p>PINV register. </p>
<p> </p>
<p> </p>
<p>Actual Behavior : </p>
<p> </p>
<p>The function control registers(PFC,PFCE,PFCAE) are initialized before PINV register initialization</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28391</p>
<p>Port</p>
<p>PINVn register is not setting properly in API </p>
<p>Port_SetPinDirection()</p>
<p>Problem description: </p>
<p>Value updating to PINVn — Port Output Level Inversion Register write protection is not implemented as in device User Manual.  </p>
<p> </p>
<p> </p>
<p>Expected behavior: </p>
<p>Needs to follow the write protection sequence mentioned in device User Manual.   </p>
<p> </p>
<p>Actual behavior: </p>
<p>Register write protection is not implemented properly.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28447</p>
<p>Port</p>
<p>PMSR register access is not correct</p>
<p>Problem description: </p>
<p>PMSR register is accessing without checking whether PMSR register is present for that particular Port group.  </p>
<p> </p>
<p> </p>
<p>Expected behavior: Before accessing PMSR register check whether PMSR register is exist is required. </p>
<p>    /*Check for PMSR register availability */ </p>
<p>    if (PORT_REG_NOTAVAILABLE != LpSetPinModeGroupStruct-&gt;ucPMSRRegIndex) </p>
<p>    { </p>
<p>   ... </p>
<p>    } </p>
<p> </p>
<p>Actual behavior: </p>
<p>This check is not present result in illegal memory access.  </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28539</p>
<p>Port</p>
<p>Pre compiler Macro is surrounded code at </p>
<p>wrong place in Port_FilterConfig()</p>
<p>Problem description: </p>
<p> </p>
<p>Pre compiler Macro &quot;PORT_DNFA_REG_CONFIG&quot; is surrounded code at wrong place in Port_FilterConfig(). </p>
<p> </p>
<p>#if ((PORT_DNFA_REG_CONFIG == STD_ON) || (PORT_FCLA_REG_CONFIG == STD_ON)) </p>
<p>#define PORT_START_SEC_PRIVATE_CODE </p>
<p>#include &quot;MemMap.h&quot; </p>
<p>STATIC FUNC(void, PORT_PRIVATE_CODE) Port_FilterConfig(void) </p>
<p>{ </p>
<p>  /* Pointer to digital filter DNFA register data structure */ </p>
<p>  #if (PORT_DNFA_REG_CONFIG == STD_ON) </p>
<p>  P2CONST(volatile Port_DNFARegs, AUTOMATIC, PORT_CONFIG_DATA) LpDNFAReg; </p>
<p> </p>
<p>  /* Pointer to Edge control EDC register data structure */ </p>
<p>  #if (PORT_EDGE_DETECT_CONTROL == STD_ON) </p>
<p>  P2CONST(volatile Port_EDCRegs, AUTOMATIC, PORT_CONFIG_DATA) LpEDCReg; </p>
<p>  #endif /* End of PORT_EDGE_DETECT_CONTROL == STD_ON */ </p>
<p> </p>
<p> -----code----- </p>
<p>  #endif /* End of PORT_DNFA_REG_CONFIG == STD_ON */ </p>
<p> </p>
<p> -----code---- </p>
<p> </p>
<p>Port_FilterConfig() API is enabled by PORT_DNFA_REG_CONFIG is STD_ON or PORT_FCLA_REG_CONFIG is STD_ON, </p>
<p>In side variable declaration is done for PORT_DNFA_REG_CONFIG is STD_ON, When PORT_DNFA_REG_CONFIG is STD_OFF and PORT_FCLA_REG_CONFIG is STD_ON it will corrupted. </p>
<p> </p>
<p>Expected behavior: </p>
<p>Pre compiler Macro should be surrounded the E-code at appropriate places. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>25724</p>
<p>PWM</p>
<p>Det PWM_E_PARAM_CHANNEL is not </p>
<p>reporting for Pwm_SetTriggerDelay().</p>
<p>Problem description: </p>
<p> For the current PWM driver implementation we face the problem that it is not reporting Det PWM_E_PARAM_CHANNEL for Pwm_SetTriggerDelay() when configured for PWM TAU </p>
<p>channel.  </p>
<p> </p>
<p>Expected behavior: </p>
<p> Det PWM_E_PARAM_CHANNEL should report for Pwm_SetTriggerDelay() when configured for PWM TAU channel. </p>
<p>  </p>
<p>Actual behavior: </p>
<p> DET is not occuring.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>26874</p>
<p>PWM</p>
<p>Pwm_SelectChannelClk is starting the PWM </p>
<p>diag channels configured for sync start</p>
<p>Problem Description: </p>
<p>If you configure 2 channels 1 on TAU and one PWM diag in sync start mode. If after Pwm_SynchronousInit() API, Pwm_SelectChannelClk() is called, the pwm diag channel will start even </p>
<p>before calling Pwm_SynchronousStart(). </p>
<p> </p>
<p>Expected behavior: </p>
<p>Channels marked as synchronous shall start only after Pwm_SynchronousStart() API is called. </p>
<p> </p>
<p>Current behavior: </p>
<p>Check the problem description </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28292</p>
<p>PWM</p>
<p>[P1x][PWM] PWM notification is not </p>
<p>handled properly</p>
<p>Problem Description: </p>
<p>1. PWM notification null pointer checking is not performing on Pwm_HW_Callback ISR </p>
<p>2. Notification will send for wrong PWM channels/channels which are not configured. </p>
<p> </p>
<p> </p>
<p>Actual behaviour: </p>
<p>With in Pwm_HW_Callback ISR, channel id is incrementing with in a for loop. Notification checking and sending is doing outside this for loop. After the execution of that for loop channel id </p>
<p>will be, exact channel id + 1 + number of slave channels. So the notification will send for wrong channels or try to send notification for the channels which are not configured. </p>
<p> </p>
<p>Example: we have configured 7 channels out of which 3 are slave channels. </p>
<p>and the interrupt is coming for 4th master channel. </p>
<p>So at the end of the 'for' loop, channel id will be 8. This will cause out of array access and if the value of that memory location is one, it will try to send notification, which is not configured. </p>
<p>This will cause the controller to reset. </p>
<p> </p>
<p>Expected behaviour: </p>
<p>1.PWM notification null pointer checking should be performed in Pwm_HW_Callback ISR </p>
<p>2.PWM notification checking should be with proper channel id.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>25663</p>
<p>RamTst</p>
<p>[P1x][RAMTST][R4.0] The test result is not   </p>
<p>RAMTST_RESULT_UNDEFINED, if a March </p>
<p>Test on this block is running.</p>
<p>RamTst_GetTestResultPerBlock() does not return RAMTST_RESULT_UNDEFINED, when March test on the specific block is running.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>25664</p>
<p>RamTst</p>
<p>[P1x][RAMTST][R4.0] RamTst_FillPattern </p>
<p>not getting updated in the RAM location </p>
<p>when RamTstTestPolicy is </p>
<p>RAMTEST_DESTRUCTIVE.</p>
<p>When the configuration parameter RamTstTestPolicy for a block is set to RAMTEST_DESTRUCTIVE, the test algorithm does not fill the tested cells after the test with the bit pattern defined </p>
<p>for this block by parameter RamTst_FillPattern except for the test algorithm RAMTST_ABRAHAM_TEST_APP.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>26482</p>
<p>RamTst</p>
<p>Dem event parameter name not generated </p>
<p>correctly</p>
<p>Problem Description: </p>
<p>If the short name of DemEventParameter in file Dem_RamTst.arxml is not appended with any number then the Dem event parameter name is not getting generated correctly. </p>
<p> </p>
<p>Expected Behaviour: </p>
<p>DEM event parameters should generated correctly as follows </p>
<p> </p>
<p>#define RAMTST_E_RAM_FAILURE                               \ </p>
<p>  DemConf_DemEventParameter_DemEventParameter </p>
<p> </p>
<p>Actual Behaviour: </p>
<p>DEM event parameters are generated as follows </p>
<p> </p>
<p>#define RAMTST_E_RAM_FAILURE                               \ </p>
<p>  DemConf_DemEventParameter_ </p>
<p> </p>
<p>This results in compilation issues as &quot;the identifier &quot;DemConf_DemEventParameter_&quot; is undefined&quot; </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28604</p>
<p>RamTst</p>
<p>Issues in EUM.</p>
<p>Problem Description: </p>
<p>This ticket is to report the defects found in EUM. </p>
<p> </p>
<p>1.In Section 8 &quot;Software Generation Tool&quot; and &quot;Driver Generation Tool&quot; are used in parallel, which is misleading. </p>
<p>[Driver Generation Tool] should be used here. </p>
<p> </p>
<p>2.In Revision History SI. No. 4 &quot;As part of P1x V4.00.04 activity following changes are made:&quot; should be removed. </p>
<p> </p>
<p>3.In Section 4.5 'X' is not marked for user mode for RamTst APIs, even with known limitations listed in Table 4-1. This is not in line with other MCAL modules.User mode is supported by </p>
<p>RamTst_RunFullTest, RamTst_RunPartialTest, RamTst_MainFunction, but with precondition that the critical section should be disabled. </p>
<p> </p>
<p>Expected behavior </p>
<p>N/A </p>
<p> </p>
<p>Actual behavior </p>
<p>N/A </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28605</p>
<p>RamTst</p>
<p>RamTst_Ram.c and RamTst_Ram.h files are </p>
<p>missing.</p>
<p>Problem Description : </p>
<p> </p>
<p>Unlike other MCAL modules there are no dedicated files, ie. RamTst_Ram.c and RamTst_Ram.h, to address global variables. </p>
<p> </p>
<p>In other MCAL modules &lt;MSN&gt;_Ram.c and &lt;MSN_Ram.h&gt; used to address global variables. </p>
<p> </p>
<p>Actual Behavior : </p>
<p>No dedicated file is exist to address global variables. </p>
<p> </p>
<p>Expected Behavior : </p>
<p>To maintain consistent file structures across all the MCAL modules these files should be added to address global variables.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28607</p>
<p>RamTst</p>
<p>Autosar requirement RamTst033 is not </p>
<p>implemented properly.</p>
<p>Problem Description : </p>
<p> </p>
<p>As per AUTOSAR requirement RamTst033 : </p>
<p>&quot;If the DET is enabled and the execution status of the RAM Test is </p>
<p>not RAMTST_EXECUTION_RUNNING or RAMTST_EXECUTION_SUSPENDED, the </p>
<p>function RamTst_Stop shall report the error value RAMTST_E_STATUS_FAILURE to </p>
<p>the DET, and then immediately return.&quot; </p>
<p> </p>
<p> </p>
<p>Actual Behavior : </p>
<p>In the current implementation execution status is checked against STOPPED as below:  </p>
<p>else if (RAMTST_EXECUTION_STOPPED == RamTst_ExecutionStatus) in RamTst_Stop API. </p>
<p> </p>
<p>Expected Behavior : </p>
<p>N/A</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28608</p>
<p>RamTst</p>
<p>Autosar requirement RamTst003 is not </p>
<p>implemented properly.</p>
<p>Problem Description : </p>
<p> </p>
<p>As per this requirement RamTst.h shall include Std_Types.h directly. </p>
<p> </p>
<p>In  current implementation Std_Types.h is included via RamTst_Types.h. </p>
<p> </p>
<p>Actual Behavior : </p>
<p>Std_Types.h is included RamTst_Types.h and RamTst_Types.h is included RamTst.h which is not correct as per Autosar requirement RamTst003. </p>
<p> </p>
<p>Expected Behavior : </p>
<p>RamTst.h shall include Std_Types.h directly.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>25109</p>
<p>SPI</p>
<p>SpiJobEndNotification functions are not </p>
<p>generated correctly, when two or more </p>
<p>Jobs have the same JobEndNotification </p>
<p>function.</p>
<p>Problem description: </p>
<p>SpiJobEndNotification functions are not generated correctly, when two or more Jobs have the same JobEndNotification function. </p>
<p>Some JobEndNotifications functions are NULL after the generation, in spite they are not configured as NULL. </p>
<p>There is no information or warning in the generator's manual, that this configuration would not be allowed. </p>
<p> </p>
<p>Expected behavior: </p>
<p>If the following SpiJobEndNotifications are in one configuration: </p>
<p> </p>
<p>  TswSpi_AsyncJobEndNotif </p>
<p>  TswSpi_AsyncJobEndNotif </p>
<p>  NULL </p>
<p>  NULL </p>
<p>  TswSpi_PrioCheckJob1EndNotif </p>
<p>  TswSpi_PrioCheckJob2EndNotif </p>
<p>  TswSpi_PrioCheckJob3EndNotif </p>
<p>  TswSpi_PrioCheckJob4EndNotif </p>
<p>  TswSpi_PrioCheckJob5EndNotif </p>
<p>  NULL </p>
<p>  NULL </p>
<p> </p>
<p>the same should be expected to be generated in  Spi_BPcfg.c </p>
<p> </p>
<p>Actual behavior: </p>
<p>Instead in Spi_BPcfg.c we have the following: </p>
<p> </p>
<p> NULL_PTR </p>
<p>  TswSpi_AsyncJobEndNotif </p>
<p>  NULL_PTR </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>26389</p>
<p>SPI</p>
<p>Short name, File name and Path generated </p>
<p>for error id ERR083058 is incorrect</p>
<p>Problem Description: </p>
<p>ERR083058 message is generating as follows </p>
<p>The reference path &lt;/AUTOSAR/EcucDefs/Dem0/DemConfigSet0/DemEventParamete&gt; provided for the parameter 'SPI_E_HARDWARE_ERROR' in the container </p>
<p>'SpiDemEventParameterRefs', having shortname &lt;HASH(0x31829ac){ShortName}&gt; is incorrect. </p>
<p> File Name: HASH(0x31829ac) {FileName} </p>
<p> Path: HASH(0x31829ac){ShortName} </p>
<p> </p>
<p>Expected Behaviour: </p>
<p>Correct Short name, File name and Path should be generated for error id ERR083058. </p>
<p> </p>
<p>Actual Behaviour: </p>
<p>Short name, File name and Path generated for error id ERR083058 are wrong.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>26420</p>
<p>SPI</p>
<p>Execution stuck in Spi_HWTransmitSyncJob </p>
<p>function</p>
<p>Problem Description: </p>
<p> </p>
<p>When a sequence is transmitted synchronously, the execution hangs in Spi_HWTransmitSyncJob. </p>
<p> </p>
<p>Expected Behaviour: </p>
<p>Sequence should be transmitted without hang. </p>
<p> </p>
<p>Actual Behaviour: </p>
<p>Calling Spi_SyncTransmit API results hanging in Spi_HWTransmitSyncJob API .</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>26764</p>
<p>SPI</p>
<p>The SPI driver does not change its status in </p>
<p>case of data consistency error occurs </p>
<p>during sync transmission.</p>
<p>Problem description: </p>
<p>In case of data consistency error flag (CSIHnDCE) is set during SPI sync transmission, the ongoing sequence is aborted. </p>
<p>The problem is that after the ongoing sequence was aborted, the global variable Spi_GusHwStatus is not changed by the Spi_SyncTransmit API. This blocks all the next SPI communication. </p>
<p> </p>
<p>Expected result: </p>
<p>In case of consistency error detection during SPI Sync transmission, the ongoing sequence must be cancelled. </p>
<p> </p>
<p>Actual result: </p>
<p>After consistency error detection during SPI Sync transmission, whole further communication is blocked. </p>
<p> </p>
<p>A workaround is not to enable the CSIHnCTL1.CSIHnDCS bit, until this issue is not fixed.  </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27688</p>
<p>SPI</p>
<p>Illegal Memory access in Spi_Driver.c in API </p>
<p>Spi_TransmitISR()</p>
<p>Problem description:  </p>
<p>If the if condition: </p>
<p>if (SPI_FIFO_BUFFER_FULL != Spi_GucHWFifoBufferSts[SPI_FIFO_RX_INDEX])) fails,  </p>
<p>the pointer LpPBChannelConfig will not be initialised (since it is written in the if condition at Line 5618) </p>
<p>This would lead to an illegal memory access (at Line:5707) where LpPBChannelConfig is used. </p>
<p> </p>
<p>Expected Behavior:  </p>
<p>The variable LpPBChannelConfig shall be initialized before used </p>
<p> </p>
<p>Actual behavior:  </p>
<p>If the if condition ((if (SPI_FIFO_BUFFER_FULL != Spi_GucHWFifoBufferSts[SPI_FIFO_RX_INDEX]))) fails, LpPBChannelConfig is not initialized. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>27707</p>
<p>SPI</p>
<p>Illegal Memory access in Spi_Driver.c</p>
<p>Problem Description: In Spi_Driver.c, API Spi_TransmitISR(), the local variable LpJobConfig is initialized in the part of code as below.  </p>
<p> </p>
<p> if (SPI_FIFO_BUFFER_UNINIT == Spi_GucHWFifoBufferSts[SPI_FIFO_RX_INDEX]) </p>
<p>      { </p>
<p>         ..............; </p>
<p>         ...............; </p>
<p>        LpJobConfig = Spi_GpFirstJob + LddJobIndex; </p>
<p>       } </p>
<p> </p>
<p>If the condition SPI_FIFO_BUFFER_UNINIT is not equal to Spi_GucHWFifoBufferSts[SPI_FIFO_RX_INDEX]), the variable LpJobConfig will not be initialized. This could lead to illegal memory </p>
<p>access since the variable is also used elsewhere. Eg: In the do while loop below the if loop mentioned in the description, </p>
<p> </p>
<p>#if (SPI_DMA_MODE_ENABLE == STD_ON) </p>
<p>        /* MISRA Violation: START Msg(4:2962)-18 */ </p>
<p>        if ((SPI_INTERRUPT_MODE == Spi_GddAsyncMode) &amp;&amp; </p>
<p>                    (SPI_INVALID_DMAUNIT == LpJobConfig-&gt;ucRxDmaDeviceIndex)) </p>
<p>        /* END Msg(4:2962)-18 */ </p>
<p>        #endif </p>
<p> </p>
<p>Expected Behavior: None </p>
<p> </p>
<p>Actual Behavior: Illegal Memory access could happen if the if condition mentioned in the problem description fails.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>27978</p>
<p>SPI</p>
<p> Spi_SyncTransmit API is not working </p>
<p>properly.</p>
<p>Problem Description: </p>
<p> </p>
<p>when calling Spi_SyncTransmit() an exception is occurring from private API Spi_HWTransmitSyncJob(). On analysis we found that this is because of improper handling of a while loop exit </p>
<p>criteria, resulting in illegal memory access.  </p>
<p> </p>
<p>Expected behavior:  </p>
<p>Spi_SyncTransmit() execute with out any exception.   </p>
<p> </p>
<p>Actual behavior:  </p>
<p>An exception is occurring while execution of Spi_SyncTransmit() API.  </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28233</p>
<p>SPI</p>
<p>Improper pre-compiler switch for the </p>
<p>Spi_Mainfunction_Handling function </p>
<p>definition</p>
<p>Problem Description: </p>
<p>Spi_Mainfunction_Handling  function should be invoked only when polling mechanism is selected by Spi_SetAsyncMode API. This mode can be set only when the SPI_LEVEL_DELIVERED is </p>
<p>two. but the pre compiler switch for the function definition is as follows </p>
<p>#if (((SPI_LEVEL_DELIVERED == SPI_ONE) || (SPI_LEVEL_DELIVERED == SPI_TWO)) \ </p>
<p>      &amp;&amp; (SPI_HWUNIT_ASYNCHRONOUS == STD_ON)) </p>
<p> </p>
<p>#define SPI_START_SEC_PUBLIC_CODE </p>
<p>#include &quot;MemMap.h&quot; </p>
<p> </p>
<p>FUNC(void, SPI_PUBLIC_CODE) Spi_MainFunction_Handling (void) </p>
<p>{ </p>
<p>... </p>
<p> </p>
<p>Expected Behaviour: </p>
<p>Spi_Mainfunction_Handling function shall be available in Level 2 only. </p>
<p> </p>
<p>Actual Behaviour: </p>
<p>Spi_Mainfunction_Handling function is available in Level 1 and 2 also.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28249</p>
<p>SPI</p>
<p>SpiFifoTimeOut parameter is mandatory</p>
<p>Problem description: </p>
<p>SpiFifoTimeOut parameter is made mandatory but it is only valid for CSIH </p>
<p> </p>
<p>Expected behaviour: </p>
<p>SpiFifoTimeOut parameter should be optional (multiplicity 0..1) and additionally there should be a generator error check in case it is not configured for CSIH HW units in FIFO mode.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28251</p>
<p>SPI</p>
<p>The information provided about user mode </p>
<p>and supervisor mode is not correct in the </p>
<p>user manual</p>
<p>Problem Description: </p>
<p>In the user manual Table 4-5, it indicates that Spi_MainFunction_Handling() requires Supervisor mode access when Interrupt mode is active (SI. No. 14), though </p>
<p>Spi_MainFunction_Handling() is not necessary in interrupt mode. </p>
<p>Also, Spi_AsyncTransmit(), SI. No. 4 in Table 4-5, is missing any mark in the Interrupt Mode/user mode column.. </p>
<p> </p>
<p>Expected Behaviour: </p>
<p>Spi_MainFunction_Handling shall be removed in interrupt mode and  Spi_AsyncTransmit() shall be corrected for applicable modes. </p>
<p> </p>
<p>Actual Behaviour: </p>
<p>Spi_MainFunction_Handling is marked for both interrupt and Polling modes. and Spi_AsyncTransmit() is missing any mark in the Interrupt Mode/user mode column.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28364</p>
<p>SPI</p>
<p>Error ERR083120 is generated when </p>
<p>SpiEnableCs is configured as false</p>
<p>Problem Description: </p>
<p>When the Parameter SpiEnableCs is configured as false SpiPortPinSelect should not be configured. But when SpiPortPinSelect is not configured tool is generating error ERR083120- the </p>
<p>parameter 'SpiPortPinSelect' value in the container 'SpiJob&lt;x&gt;', should be configured as CSL&lt;n&gt; since 'CSIH&lt;x&gt;' is configured. </p>
<p> </p>
<p>Expected Behaviour: </p>
<p>Tool should not generate error. </p>
<p> </p>
<p>Actual Behaviour: </p>
<p>ERR083120 is generated.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28456</p>
<p>SPI</p>
<p>Variables are uninitialized when the certain </p>
<p>condition does not meet.</p>
<p>Problem description: </p>
<p>Some of the Variables are uninitialized when the following conditions are not met.  </p>
<p>when the SPI_DIRECT_ACCESS_MODE is STD_OFF </p>
<p> </p>
<p> </p>
<p>Expected behavior: </p>
<p>Before using the variables, Variables should be initialized. </p>
<p> </p>
<p>Actual behavior: </p>
<p>Before using the variables, Variables are not initialized when SPI_DIRECT_ACCESS_MODE is STD_OFF</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<p>28676</p>
<p>SPI</p>
<p>Calling of Spi_MainFunction_Handling </p>
<p>possible in interrupt mode</p>
<p>Description: </p>
<p>If interrupt mode is selected (Spi_SetAsyncMode(SPI_INTERRUPT_MODE))  </p>
<p>a call to Spi_MainFunction_Handling() is possible. Functions Spi_TransmitISR and Spi_ReceiveISR are called there without further checks. This can cause </p>
<p>corrupted data transmission. </p>
<p> </p>
<p>Actual Behavior: </p>
<p>No error but corrupted data. </p>
<p> </p>
<p>Expected Behavior: </p>
<p>In interrupt mode a call to Spi_MainFunction_Handling shall be rejected, e.g. by DET.</p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
<h1 style="page-break-before:always; "></h1>
<p>28199</p>
<p>WDG</p>
<p>Wdg_SetMode function reports DEM error </p>
<p>if WDGIF_OFF_MODE is selected</p>
<p>Problem description: </p>
<p>As per AUTOSAR specification [WDG160], Wdg_SetMode function supports WDGIF_OFF_MODE. </p>
<p>And the user sets WdgDisableAllowed parameter 'true' in Configuration tool. </p>
<p>However, in code Wdg_59_DriverA_SetMode function reports a Dem Error in case WDGIF_OFF_MODE is selected. </p>
<p> </p>
<p>Wdg_59_DriverA_SetMode function in Wdg_59_DriverA.c: </p>
<p>    if (Mode == WDGIF_OFF_MODE) </p>
<p>    { </p>
<p>      /* Report Error to DEM */ </p>
<p>      Dem_ReportErrorStatus(WDG_59_DRIVERA_E_DISABLE_REJECTED, </p>
<p>                                                      DEM_EVENT_STATUS_FAILED); </p>
<p> </p>
<p>WDG driver does not allow Wdg_SetMode function to translate the state into OFF by &quot;4.4 WDG State Diagram&quot; in WDG Driver Component Embedded User's Manual Rev.0.01 Nov 2013. </p>
<p> </p>
<p>Customer need to know the background for this. </p>
<p> </p>
<p>Expected behaviour: </p>
<p>Wdg_SetMode function shall report DEM error only if required mode is 'WDGIF_OFF_MODE' and 'WdgDisableAllowed' is false. </p>
<p> </p>
<p>Actual behaviour: </p>
<p>Wdg_SetMode function is reporting DEM error only if required mode is 'WDGIF_OFF_MODE' and 'WdgDisableAllowed' is true. </p>
<p>BUG</p>
<p>OPEN </p>
<p>ISSUE</p>
</body>
</html>
{% endraw %}