---
layout: default
title: TechnicalReference_CANdesc
nav_order: 11
parent: Component Implementation
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>1 / 164 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>CANdesc </b></p>
<p>Technical Reference </p>
<p> </p>
<p> </p>
<p>Version 3.07.00 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Authors </p>
<p>Oliver  Garnatz,  Mishel  Shishmanyan,  Stefan  Hübner, </p>
<p>Matthias Heil, Katrin Thurow, Patrick Rieder </p>
<p>Status </p>
<p>Released </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>2 / 164 </p>
<p><b>1 </b></p>
<p><b>History </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>Oliver Garnatz </p>
<p>2003-11-12 </p>
<p>2.00.00 </p>
<p>Splitting into separate documents </p>
<p>and general revision </p>
<p>Oliver Garnatz </p>
<p>2004-01-13 </p>
<p>2.00.01 </p>
<p>Added chapter ‘Application interface </p>
<p>flow’ </p>
<p>Updated format template </p>
<p>Mishel Shishmanyan </p>
<p>2004-03-09 </p>
<p>2.01.00 </p>
<p>New application callback convention </p>
<p>(from CANdesc 2.09.00) </p>
<p>Mishel Shishmanyan </p>
<p>2004-03-29 </p>
<p>2.02.00 </p>
<p>New APIs: </p>
<p>-</p>
<p> </p>
<p><b>DescGetActivityState </b>(from </p>
<p>CANdesc 2.10.00) </p>
<p>-</p>
<p> </p>
<p><b>DescSchedulerTask() </b>(from </p>
<p>CANdesc 2.09.00) </p>
<p>Mishel Shishmanyan </p>
<p>2004-04-26 </p>
<p>2.03.00 </p>
<p>Added more information and </p>
<p>limitations about the ring-buffer </p>
<p>mechanism (12.6.9 “Ring Buffer </p>
<p>Mechanism”) </p>
<p>New feature: </p>
<p>-</p>
<p> </p>
<p><b>Support for generic user </b></p>
<p><b>service </b>(from CANdesc </p>
<p>2.11.00) </p>
<p>-</p>
<p> </p>
<p><b>Force CANdesc to send </b></p>
<p><b>RCR-RP response </b>(from </p>
<p>CANdesc 2.11.00) </p>
<p>Stefan Hübner </p>
<p>2004-07-16 </p>
<p>2.03.01 </p>
<p>Editorial revision </p>
<p>Oliver Garnatz </p>
<p>2004-08-12 </p>
<p>2.04.00 </p>
<p>Added chapter 4.2 </p>
<p>ReadDataByIdentifier (SID $22) </p>
<p>within the Single- and the Multiple </p>
<p>PID mode is described </p>
<p>Oliver Garnatz </p>
<p>2004-10-08 </p>
<p>2.05.00 </p>
<p>ESCAN0000982: Description of </p>
<p>MainHandler structure is not </p>
<p>readable </p>
<p>ROE transmission unit is described </p>
<p>in detail  </p>
<p>Stefan Hübner </p>
<p>Oliver Garnatz </p>
<p>2004-10-15 </p>
<p>2.06.00 </p>
<p>Some additional information are </p>
<p>provided  </p>
<p>Peter Herrmann </p>
<p>Klaus Emmert </p>
<p>2005-06-22 </p>
<p>2.07.00 </p>
<p><b>Added: </b>Service $2C description. </p>
<p><b>Added: </b>Warning Text added </p>
<p>Mishel Shishmanyan </p>
<p>Oliver Garnatz </p>
<p>2005-08.03 </p>
<p>2.08.00 </p>
<p><b>API added:  </b></p>
<p>-</p>
<p> </p>
<p>DescStateTask, </p>
<p>-</p>
<p> </p>
<p>DescTimerTask,  </p>
<p>-</p>
<p> </p>
<p>DescMayCallStateTaskAgain</p>
<p>. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>3 / 164 </p>
<p>-</p>
<p> </p>
<p>ApplDescFatalError </p>
<p><b>API modified:  </b></p>
<p>-</p>
<p> </p>
<p>DescTask,  </p>
<p>-</p>
<p> </p>
<p>ApplDescCheckSessionTran</p>
<p>sition,  </p>
<p>-</p>
<p> </p>
<p>DescGetActivityState,  </p>
<p>-</p>
<p> </p>
<p>DescGetStateSession. </p>
<p><b>API removed:  </b></p>
<p>-</p>
<p> </p>
<p>DescSchedulerTask </p>
<p>Modified description for </p>
<p>ReadDataByIdentifier with long data </p>
<p>and negative response in main-</p>
<p>handler. </p>
<p>Oliver Garnatz </p>
<p>2006-03-02 </p>
<p>2.09.00 </p>
<p><b>Added: </b>...prevent the ECU going to </p>
<p>sleep while diagnostic is active </p>
<p>Mishel Shishmanyan </p>
<p>2006-03-24 </p>
<p>2.10.00 </p>
<p><b>Added: </b>document overview </p>
<p>Mishel Shishmanyan </p>
<p>2006-04-27 </p>
<p>2.11.00 </p>
<p><b>Modified:  </b></p>
<p>-12.6.13 </p>
<p>DynamicallyDefineDataIdentifier  </p>
<p>($2C) (UDS) functions </p>
<p>-12.6.13.1 </p>
<p>DescMayCallStateTaskAgain() </p>
<p><b> </b></p>
<p>Mishel Shishmanyan </p>
<p>2007-02-22 </p>
<p>2.12.00 </p>
<p><b>Added:  </b></p>
<p> - </p>
<p><i>12.6.9.3 </i></p>
<p><i>“DescRingBufferCancel()” </i></p>
<p><b> </b></p>
<p>Matthias Heil </p>
<p>2008-01-03 </p>
<p>2.13.00 </p>
<p><b>Added: </b></p>
<p>Caution    concerning    user    main  </p>
<p>handler on protocol level l </p>
<p>Matthias Heil </p>
<p>2008-02-29 </p>
<p>2.14.00 </p>
<p><b>Added: </b></p>
<p>Handling of read/write memory by </p>
<p>address: </p>
<p> - <i>9.3 “Read/Write Memory by </i></p>
<p><i>Address” </i></p>
<p><i>- 12.6.8.2 </i></p>
<p><i>“DescStartMemByAddrRepeatedCal</i></p>
<p><i>l()” </i></p>
<p><i>- 12.6.14 ”Memory Access </i></p>
<p><i>Callbacks” </i></p>
<p>Mishel Shishmanyan </p>
<p>2008-06-06 </p>
<p>2.15.00 </p>
<p><i><b>Removed: </b></i></p>
<p><i>Chapter “ResponseOnEvent </i></p>
<p><i>Transmission Unit” </i></p>
<p><i><b>Added: </b></i></p>
<p><i><b> </b>- 12.6.13.3 <b>“</b>Non-volatile memory </i></p>
<p><i>support<b>” </b></i></p>
<p>Mishel Shishmanyan </p>
<p>2008-11-09 </p>
<p>2.16.00 </p>
<p><i><b>Modified: </b></i></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>4 / 164 </p>
<p>- <i>12.6.9 </i>and <i>12.6.9.1</i>: Added </p>
<p>limitation for UDS and SPRMIB with </p>
<p>the ring buffer usage. </p>
<p>- <i>13.6 …work with the ring-buffer </i></p>
<p><i>mechanism </i></p>
<p><i><b>Added: </b></i></p>
<p><i>- 12.6.15 Flash Boot Loader </i></p>
<p><i>Support </i></p>
<p><i>- 13.8 …send a positive response </i></p>
<p><i>without request after FBL flash job  </i></p>
<p>Mishel Shishmanyan </p>
<p>2009-05-18 </p>
<p>2.17.00 </p>
<p><i><b>Modified: </b></i></p>
<p><i>12.6.6.1ApplDescCheckSessionTra</i></p>
<p><i>nsition() </i></p>
<p><i><b>Added: </b></i></p>
<p><i>12.6.6.3DescIsSuppressPosResBit</i></p>
<p><i>Set () </i></p>
<p>Mishel Shishmanyan </p>
<p>2009-08-11 </p>
<p>2.18.00 </p>
<p><i><b>Modified: </b></i></p>
<p>Minor editorial changes </p>
<p><i>5.2 Configure Handlers using  </i></p>
<p><i>CANdela attributes – added new  </i></p>
<p><i>data object attributes  </i></p>
<p><i><b>Added: </b></i></p>
<p><i>13.9 …enforce CANdesc to use </i></p>
<p><i>ANSI C instead of hardware </i></p>
<p><i>optimized bit type </i></p>
<p><i>5.1 Configure DBC attributes for </i></p>
<p><i>diagnostics </i></p>
<p> </p>
<p>Mishel Shishmanyan </p>
<p>2009-09-17 </p>
<p>3.00.00 </p>
<p><i><b>Added: </b></i></p>
<p><i>6 CANdesc Configuration in GENy </i></p>
<p><i>8 Multi Identity  </i></p>
<p><i>12.6.2 Multi Variant Configuration </i></p>
<p><i>Functions </i></p>
<p>Mishel Shishmanyan </p>
<p>2010-01-26 </p>
<p>3.01.00 </p>
<p><i><b>Added: </b></i></p>
<p><i>7 CANdescBasic Configuration in </i></p>
<p><i>GENy </i></p>
<p>Mishel Shishmanyan </p>
<p>2010-12-21 </p>
<p>3.02.00 </p>
<p><i><b>Modified: </b></i></p>
<p><i>12.6.14.1 </i></p>
<p><i>ApplDescReadMemoryByAddress() </i></p>
<p><i>12.6.14.2 </i></p>
<p><i>ApplDescWriteMemoryByAddress() </i></p>
<p><i>12.6.9.2 DescRingBufferWrite() </i></p>
<p>Katrin Thurow </p>
<p>2011-08-25 </p>
<p>3.03.00 </p>
<p><i><b>Added: </b></i></p>
<p><i>8.1 </i>Single Identity Mode </p>
<p><i>8.3 </i>Multi Identity Mode </p>
<p><i>13.10 </i>…configure Extended </p>
<p>Addressing </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>5 / 164 </p>
<p><i>13.11 </i>…use Multiple Addressing </p>
<p><i>12.6.6.7 </i></p>
<p>DescGetSessionIdOfSessionState </p>
<p><i><b>Modified: </b></i></p>
<p><i>8  </i>Multi Identity Support </p>
<p><i>13.8 </i>…send a positive response </p>
<p>without request after FBL flash job </p>
<p>Katrin Thurow </p>
<p>2011-09-19 </p>
<p>3.04.00 </p>
<p><i><b>Added: </b></i></p>
<p><i>13.12</i>…use “Dynamic Normal </p>
<p>Addressing Multi TP” with multiple </p>
<p>tester </p>
<p><i><b>Modified: </b></i></p>
<p><i>13.11 </i>…use Multiple Addressing </p>
<p>Katrin Thurow </p>
<p>2011-11-27 </p>
<p>3.05.00 </p>
<p><i><b>Added:  </b></i></p>
<p><i>12.6.17 </i>“Spontaneous Response” </p>
<p>transmission </p>
<p><i><b>Modified: </b></i></p>
<p><i>6.2.1 </i>Global CANdesc Settings </p>
<p>Patrick Rieder </p>
<p>2013-01-23 </p>
<p>3.06.00 </p>
<p><i><b>Added: </b></i></p>
<p><i>10 </i>Generic Processing Notifications </p>
<p><i>12.6.18 </i>Generic Processing </p>
<p>Notifications </p>
<p><i><b> </b></i></p>
<p><i><b>Modified: </b></i></p>
<p><i>6.2.1 </i>Global CANdesc Settings </p>
<p><i>12.6.4 </i>Service callback functions </p>
<p><i>12.6.9 </i>Ring Buffer Mechanism </p>
<p>Small fixes </p>
<p>Patrick Rieder </p>
<p>2013-05-27 </p>
<p>3.07.00 </p>
<p><i><b>Added: </b></i></p>
<p><i>11 </i>Busy Repeat Responder Support </p>
<p><i><b>Modified: </b></i></p>
<p><i>13.12 </i>…use “Dynamic Normal </p>
<p>Addressing Multi TP” with multiple </p>
<p>tester </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>6 / 164 </p>
<p><b>Contents </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>History ........................................................................................................................... 2</b></p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>Introduction................................................................................................................. 12</b></p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Documents this one refers to… ................................................................................. 13</b></p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>Architecture Overview ................................................................................................ 14</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>CANdesc – Internal processing ........................................................................ 14</p>
<p> </p>
<p>4.1.1</p>
<p> </p>
<p>Diagnostic protocol .......................................................................... 14</p>
<p> </p>
<p>4.1.2</p>
<p> </p>
<p>How does this flow actually work? .................................................... 15</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Application interface flow ................................................................................. 18</p>
<p> </p>
<p>4.2.1</p>
<p> </p>
<p>Session- and CommunicationControl ............................................... 18</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>Advanced Configuration ............................................................................................ 19</b></p>
<p> </p>
<p>5.1</p>
<p> </p>
<p>Configure DBC attributes for diagnostics ......................................................... 19</p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b>CANdesc Configuration in GENy ............................................................................... 20</b></p>
<p> </p>
<p>6.1</p>
<p> </p>
<p>Step One – Importing an ECU Diagnostic Description ..................................... 20</p>
<p> </p>
<p>6.2</p>
<p> </p>
<p>Step Two – ECU Diagnostic Configuration in GENy ......................................... 21</p>
<p> </p>
<p>6.2.1</p>
<p> </p>
<p>Global CANdesc Settings ................................................................. 22</p>
<p> </p>
<p>6.2.1.1</p>
<p> </p>
<p>Generic Processing Notifications (UDS2012) ................. 27</p>
<p> </p>
<p>6.2.2</p>
<p> </p>
<p>Service Specific Settings .................................................................. 27</p>
<p> </p>
<p>6.2.2.1</p>
<p> </p>
<p>Generic Service Settings ............................................... 28</p>
<p> </p>
<p>6.2.2.2</p>
<p> </p>
<p>Predefined (implemented) Services in CANdesc ............ 29</p>
<p> </p>
<p>6.2.2.3</p>
<p> </p>
<p>Signal Access Enabled Services .................................... 31</p>
<p> </p>
<p>6.2.3</p>
<p> </p>
<p>Timing Settings ................................................................................ 35</p>
<p> </p>
<p>6.2.4</p>
<p> </p>
<p>Security Access Settings (UDS2006) ............................................... 36</p>
<p> </p>
<p>6.2.5</p>
<p> </p>
<p>Security Access Settings (UDS2012) ............................................... 38</p>
<p> </p>
<p>6.2.6</p>
<p> </p>
<p>Scheduler Settings ........................................................................... 39</p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>CANdescBasic Configuration in GENy ..................................................................... 42</b></p>
<p> </p>
<p>7.1</p>
<p> </p>
<p>Global CANdescBasic Settings ........................................................................ 42</p>
<p> </p>
<p>7.2</p>
<p> </p>
<p>Service Specific Settings .................................................................................. 42</p>
<p> </p>
<p>7.3</p>
<p> </p>
<p>Timing Settings ................................................................................................ 43</p>
<p> </p>
<p>7.4</p>
<p> </p>
<p>Diagnostic State Configuration ......................................................................... 43</p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>Multi Identity Support ................................................................................................. 47</b></p>
<p> </p>
<p>8.1</p>
<p> </p>
<p>Single Identity Mode ........................................................................................ 47</p>
<p> </p>
<p>8.1.1.1</p>
<p> </p>
<p>Configuration in CANdela............................................... 47</p>
<p> </p>
<p>8.1.1.2</p>
<p> </p>
<p>Configuration in GENy ................................................... 47</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>7 / 164 </p>
<p>8.2</p>
<p> </p>
<p>VSG Mode ....................................................................................................... 47</p>
<p> </p>
<p>8.2.1</p>
<p> </p>
<p>Implementation Limitations............................................................... 48</p>
<p> </p>
<p>8.2.2</p>
<p> </p>
<p>Configuration in CANdela ................................................................. 49</p>
<p> </p>
<p>8.2.3</p>
<p> </p>
<p>Configuration in CANdela ................................................................. 50</p>
<p> </p>
<p>8.2.4</p>
<p> </p>
<p>Configuration in GENy ..................................................................... 51</p>
<p> </p>
<p>8.3</p>
<p> </p>
<p>Multi Identity Mode ........................................................................................... 51</p>
<p> </p>
<p><b>9</b></p>
<p> </p>
<p><b>Diagnostic Service Implementation Specifics .......................................................... 52</b></p>
<p> </p>
<p>9.1</p>
<p> </p>
<p>ReadDataByIdentifier (SID $22) ....................................................................... 52</p>
<p> </p>
<p>9.1.1</p>
<p> </p>
<p>Limitations of the service .................................................................. 53</p>
<p> </p>
<p>9.1.2</p>
<p> </p>
<p>Single PID mode .............................................................................. 54</p>
<p> </p>
<p>9.1.2.1</p>
<p> </p>
<p>Sending a positive response using linear buffer </p>
<p>access ........................................................................... 54</p>
<p> </p>
<p>9.1.2.2</p>
<p> </p>
<p>Sending a positive response using ring buffer access .... 55</p>
<p> </p>
<p>9.1.2.3</p>
<p> </p>
<p>Sending a negative response ......................................... 56</p>
<p> </p>
<p>9.1.3</p>
<p> </p>
<p>Multiple PID mode ............................................................................ 56</p>
<p> </p>
<p>9.1.3.1</p>
<p> </p>
<p>Pure linear buffer configuration ...................................... 57</p>
<p> </p>
<p>9.1.3.1.1</p>
<p> </p>
<p>Sending a positive response ...................... 57</p>
<p> </p>
<p>9.1.3.1.2</p>
<p> </p>
<p>Sending a negative response ..................... 58</p>
<p> </p>
<p>9.1.3.2</p>
<p> </p>
<p>Ring buffer active configuration ...................................... 58</p>
<p> </p>
<p>9.1.3.2.1</p>
<p> </p>
<p>Sending a positive response ...................... 60</p>
<p> </p>
<p>9.1.3.2.2</p>
<p> </p>
<p>Sending a negative response ..................... 61</p>
<p> </p>
<p>9.1.3.2.3</p>
<p> </p>
<p>PostHandler execution rule ........................ 62</p>
<p> </p>
<p>9.2</p>
<p> </p>
<p>DynamicallyDefineDataIdentifier (SID $2C) (UDS) ........................................... 62</p>
<p> </p>
<p>9.2.1</p>
<p> </p>
<p>Feature set ....................................................................................... 63</p>
<p> </p>
<p>9.2.2</p>
<p> </p>
<p>API Functions................................................................................... 63</p>
<p> </p>
<p>9.2.3</p>
<p> </p>
<p>Sequence Charts ............................................................................. 64</p>
<p> </p>
<p>9.3</p>
<p> </p>
<p>Read/Write Memory by Address (SID $23/$3D) (UDS) .................................... 67</p>
<p> </p>
<p>9.3.1</p>
<p> </p>
<p>Tasks performed by CANdesc .......................................................... 67</p>
<p> </p>
<p>9.3.2</p>
<p> </p>
<p>Task to be performed by the Application ........................................... 67</p>
<p> </p>
<p>9.3.3</p>
<p> </p>
<p>Repeated service calls ..................................................................... 67</p>
<p> </p>
<p><b>10</b></p>
<p> </p>
<p><b>Generic Processing Notifications .............................................................................. 69</b></p>
<p> </p>
<p>10.1</p>
<p> </p>
<p>Using dynamically defined data Identifier ......................................................... 70</p>
<p> </p>
<p><b>11</b></p>
<p> </p>
<p><b>Busy Repeat Responder Support (UDS2006 and UDS2012) .................................... 71</b></p>
<p> </p>
<p>11.1</p>
<p> </p>
<p>Configuration in GENy ..................................................................................... 72</p>
<p> </p>
<p><b>12</b></p>
<p> </p>
<p><b>CANdesc API ............................................................................................................... 73</b></p>
<p> </p>
<p>12.1</p>
<p> </p>
<p>API Categories ................................................................................................. 73</p>
<p> </p>
<p>12.1.1</p>
<p> </p>
<p>Single Context .................................................................................. 73</p>
<p> </p>
<p>12.1.2</p>
<p> </p>
<p>Multiple Context (only CANdesc)...................................................... 73</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>8 / 164 </p>
<p>12.2</p>
<p> </p>
<p>Data Types ....................................................................................................... 73</p>
<p> </p>
<p>12.3</p>
<p> </p>
<p>Global Variables ............................................................................................... 73</p>
<p> </p>
<p>12.4</p>
<p> </p>
<p>Constants ........................................................................................................ 73</p>
<p> </p>
<p>12.4.1</p>
<p> </p>
<p>Component Version.......................................................................... 73</p>
<p> </p>
<p>12.5</p>
<p> </p>
<p>Macros ............................................................................................................. 74</p>
<p> </p>
<p>12.5.1</p>
<p> </p>
<p>Data exchange ................................................................................. 74</p>
<p> </p>
<p>12.5.1.1</p>
<p> </p>
<p>Splitting 16 bit data ........................................................ 74</p>
<p> </p>
<p>12.5.1.2</p>
<p> </p>
<p>Splitting 32 bit data ........................................................ 74</p>
<p> </p>
<p>12.5.1.3</p>
<p> </p>
<p>Assembling 16 bit data ................................................... 74</p>
<p> </p>
<p>12.5.1.4</p>
<p> </p>
<p>Assembling 32 bit data ................................................... 75</p>
<p> </p>
<p>12.6</p>
<p> </p>
<p>Functions ......................................................................................................... 75</p>
<p> </p>
<p>12.6.1</p>
<p> </p>
<p>Administrative Functions .................................................................. 75</p>
<p> </p>
<p>12.6.1.1</p>
<p> </p>
<p>DescInitPowerOn()......................................................... 75</p>
<p> </p>
<p>12.6.1.2</p>
<p> </p>
<p>DescInit() ....................................................................... 76</p>
<p> </p>
<p>12.6.1.3</p>
<p> </p>
<p>DescTask() ..................................................................... 77</p>
<p> </p>
<p>12.6.1.4</p>
<p> </p>
<p>DescStateTask() ............................................................ 78</p>
<p> </p>
<p>12.6.1.5</p>
<p> </p>
<p>DescTimerTask() ............................................................ 79</p>
<p> </p>
<p>12.6.1.6</p>
<p> </p>
<p>DescGetActivityState() ................................................... 80</p>
<p> </p>
<p>12.6.2</p>
<p> </p>
<p>Multi Variant Configuration Functions ............................................... 81</p>
<p> </p>
<p>12.6.2.1</p>
<p> </p>
<p>DescInitConfigVariant() .................................................. 81</p>
<p> </p>
<p>12.6.2.2</p>
<p> </p>
<p>DescGetConfigVariant() ................................................. 82</p>
<p> </p>
<p>12.6.3</p>
<p> </p>
<p>Service Functions ............................................................................ 83</p>
<p> </p>
<p>12.6.3.1</p>
<p> </p>
<p>DescSetNegResponse() ................................................ 83</p>
<p> </p>
<p>12.6.3.2</p>
<p> </p>
<p>DescProcessingDone() .................................................. 84</p>
<p> </p>
<p>12.6.4</p>
<p> </p>
<p>Service callback functions ................................................................ 84</p>
<p> </p>
<p>12.6.4.1</p>
<p> </p>
<p>Service PreHandler ........................................................ 87</p>
<p> </p>
<p>12.6.4.2</p>
<p> </p>
<p>Service MainHandler ...................................................... 88</p>
<p> </p>
<p>12.6.4.3</p>
<p> </p>
<p>Service PostHandler ...................................................... 90</p>
<p> </p>
<p>12.6.5</p>
<p> </p>
<p>User (Unknown) Service Handling ................................................... 91</p>
<p> </p>
<p>12.6.5.1</p>
<p> </p>
<p>How it works .................................................................. 91</p>
<p> </p>
<p>12.6.5.2</p>
<p> </p>
<p>ApplDescCheckUserService() ........................................ 92</p>
<p> </p>
<p>12.6.5.3</p>
<p> </p>
<p>DescGetServiceId()........................................................ 93</p>
<p> </p>
<p>12.6.5.4</p>
<p> </p>
<p>Generic User Service MainHandler ................................ 94</p>
<p> </p>
<p>12.6.5.5</p>
<p> </p>
<p>Generic User Service PostHandler ................................ 95</p>
<p> </p>
<p>12.6.6</p>
<p> </p>
<p>Session Handling ............................................................................. 96</p>
<p> </p>
<p>12.6.6.1</p>
<p> </p>
<p>ApplDescCheckSessionTransition() ............................... 96</p>
<p> </p>
<p>12.6.6.2</p>
<p> </p>
<p>DescSessionTransitionChecked() .................................. 97</p>
<p> </p>
<p>12.6.6.3</p>
<p> </p>
<p>DescIsSuppressPosResBitSet () .................................... 98</p>
<p> </p>
<p>12.6.6.4</p>
<p> </p>
<p>ApplDescOnTransitionSession() .................................... 99</p>
<p> </p>
<p>12.6.6.5</p>
<p> </p>
<p>DescSetStateSession() ................................................ 100</p>
<p> </p>
<p>12.6.6.6</p>
<p> </p>
<p>DescGetStateSession() ............................................... 101</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>9 / 164 </p>
<p>12.6.6.7</p>
<p> </p>
<p>DescGetSessionIdOfSessionState ............................... 102</p>
<p> </p>
<p>12.6.7</p>
<p> </p>
<p>CommunicationControl Handling .................................................... 103</p>
<p> </p>
<p>12.6.7.1</p>
<p> </p>
<p>ApplDescCheckCommCtrl() ......................................... 103</p>
<p> </p>
<p>12.6.7.2</p>
<p> </p>
<p>DescCommCtrlChecked() ............................................ 104</p>
<p> </p>
<p>12.6.8</p>
<p> </p>
<p>Periodic call of ‘Service MainHandler’ ............................................ 105</p>
<p> </p>
<p>12.6.8.1</p>
<p> </p>
<p>DescStartRepeatedServiceCall() ................................. 105</p>
<p> </p>
<p>12.6.8.2</p>
<p> </p>
<p>DescStartMemByAddrRepeatedCall() .......................... 106</p>
<p> </p>
<p>12.6.9</p>
<p> </p>
<p>Ring Buffer Mechanism .................................................................. 106</p>
<p> </p>
<p>12.6.9.1</p>
<p> </p>
<p>DescRingBufferStart() .................................................. 108</p>
<p> </p>
<p>12.6.9.2</p>
<p> </p>
<p>DescRingBufferWrite() ................................................. 109</p>
<p> </p>
<p>12.6.9.3</p>
<p> </p>
<p>DescRingBufferCancel() .............................................. 110</p>
<p> </p>
<p>12.6.9.4</p>
<p> </p>
<p>DescRingBufferGetFreeSpace() ................................... 111</p>
<p> </p>
<p>12.6.9.5</p>
<p> </p>
<p>DescRingBufferGetProgress()...................................... 112</p>
<p> </p>
<p>12.6.10</p>
<p> </p>
<p>Signal Interface of CANdesc .......................................................... 113</p>
<p> </p>
<p>12.6.10.1</p>
<p> </p>
<p>ApplDesc&lt;Signal-Handler&gt;() ....................................... 113</p>
<p> </p>
<p>12.6.10.2</p>
<p> </p>
<p>Configuration of direct signal access ............................ 114</p>
<p> </p>
<p>12.6.11</p>
<p> </p>
<p>State Handling (CANdesc only) ...................................................... 114</p>
<p> </p>
<p>12.6.11.1</p>
<p> </p>
<p>DescGetState&lt;StateGroup&gt;() ...................................... 114</p>
<p> </p>
<p>12.6.11.2</p>
<p> </p>
<p>DescSetState&lt;StateGroup&gt;() ...................................... 115</p>
<p> </p>
<p>12.6.11.3</p>
<p> </p>
<p>ApplDescOnTransition«StateGroup»() ......................... 116</p>
<p> </p>
<p>12.6.12</p>
<p> </p>
<p>Force “Response Correctly Received - Response Pending” </p>
<p>transmission ................................................................................... 117</p>
<p> </p>
<p>12.6.12.1</p>
<p> </p>
<p>DescForceRcrRpResponse() ....................................... 118</p>
<p> </p>
<p>12.6.12.2</p>
<p> </p>
<p>ApplDescRcrRpConfirmation() ..................................... 119</p>
<p> </p>
<p>12.6.13</p>
<p> </p>
<p>DynamicallyDefineDataIdentifier  ($2C) (UDS) functions ................ 119</p>
<p> </p>
<p>12.6.13.1</p>
<p> </p>
<p>DescMayCallStateTaskAgain() ..................................... 120</p>
<p> </p>
<p>12.6.13.2</p>
<p> </p>
<p>ApplDescCheckDynDidMemoryArea() ......................... 121</p>
<p> </p>
<p>12.6.13.3</p>
<p> </p>
<p>Non-volatile memory support ....................................... 122</p>
<p> </p>
<p>12.6.13.3.1</p>
<p> </p>
<p>DescDynDefineDidPowerUp() .................. 125</p>
<p> </p>
<p>12.6.13.3.2</p>
<p> </p>
<p>DescDynIdMemContentRestored () ......... 126</p>
<p> </p>
<p>12.6.13.3.3</p>
<p> </p>
<p>DescDynDefineDidPowerDown () ............ 127</p>
<p> </p>
<p>12.6.13.3.4</p>
<p> </p>
<p>ApplDescStoreDynIdMemContent () ........ 128</p>
<p> </p>
<p>12.6.13.3.5</p>
<p> </p>
<p>ApplDescRestoreDynIdMemContent () .... 129</p>
<p> </p>
<p>12.6.14</p>
<p> </p>
<p>Memory Access Callbacks ............................................................. 130</p>
<p> </p>
<p>12.6.14.1</p>
<p> </p>
<p>ApplDescReadMemoryByAddress() ............................. 130</p>
<p> </p>
<p>12.6.14.2</p>
<p> </p>
<p>ApplDescWriteMemoryByAddress() ............................. 131</p>
<p> </p>
<p>12.6.15</p>
<p> </p>
<p>Flash Boot Loader Support ............................................................ 131</p>
<p> </p>
<p>12.6.15.1</p>
<p> </p>
<p>DescSendPosRespFBL() ............................................. 132</p>
<p> </p>
<p>12.6.15.2</p>
<p> </p>
<p>ApplDescInitPosResFblBusInfo() ................................. 133</p>
<p> </p>
<p>12.6.16</p>
<p> </p>
<p>Debug Interface / Assertion ............................................................ 134</p>
<p> </p>
<p>12.6.16.1</p>
<p> </p>
<p>ApplDescFatalError() ................................................... 134</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>10 / 164 </p>
<p>12.6.17</p>
<p> </p>
<p>“Spontaneous Response” transmission .......................................... 137</p>
<p> </p>
<p>12.6.17.1</p>
<p> </p>
<p>DescApplSendSpontaneousResponse() ...................... 138</p>
<p> </p>
<p>12.6.17.2</p>
<p> </p>
<p>ApplDescSpontaneousResponseConfirmation() .......... 139</p>
<p> </p>
<p>12.6.18</p>
<p> </p>
<p>Generic Processing Notifications.................................................... 140</p>
<p> </p>
<p>12.6.18.1</p>
<p> </p>
<p>ApplDescManufacturerIndication ................................. 140</p>
<p> </p>
<p>12.6.18.2</p>
<p> </p>
<p>ApplDescManufacturerConfirmation ............................ 141</p>
<p> </p>
<p>12.6.18.3</p>
<p> </p>
<p>ApplDescSupplierIndication ......................................... 142</p>
<p> </p>
<p>12.6.18.4</p>
<p> </p>
<p>ApplDescSupplierConfirmation .................................... 143</p>
<p> </p>
<p><b>13</b></p>
<p> </p>
<p><b>How To… ................................................................................................................... 144</b></p>
<p> </p>
<p>13.1</p>
<p> </p>
<p>…implement a protocol service MainHandler ................................................. 144</p>
<p> </p>
<p>13.2</p>
<p> </p>
<p>…implement a service MainHandler............................................................... 147</p>
<p> </p>
<p>13.3</p>
<p> </p>
<p>…implement a Signal Handler........................................................................ 148</p>
<p> </p>
<p>13.4</p>
<p> </p>
<p>…implement a Packet Handler ....................................................................... 149</p>
<p> </p>
<p>13.5</p>
<p> </p>
<p>…implement a state transition function .......................................................... 149</p>
<p> </p>
<p>13.6</p>
<p> </p>
<p>…work with the ring-buffer mechanism .......................................................... 151</p>
<p> </p>
<p>13.6.1</p>
<p> </p>
<p>with asynchronous write ................................................................. 151</p>
<p> </p>
<p>13.6.2</p>
<p> </p>
<p>with synchronous write ................................................................... 153</p>
<p> </p>
<p>13.7</p>
<p> </p>
<p>…prevent the ECU going to sleep while diagnostic is active .......................... 154</p>
<p> </p>
<p>13.8</p>
<p> </p>
<p>…send a positive response without request after FBL flash job ..................... 155</p>
<p> </p>
<p>13.9</p>
<p> </p>
<p>…enforce CANdesc to use ANSI C instead of hardware optimized bit type .... 155</p>
<p> </p>
<p>13.10</p>
<p> </p>
<p>…configure Extended Addressing .................................................................. 156</p>
<p> </p>
<p>13.11</p>
<p> </p>
<p>…use Multiple Addressing .............................................................................. 156</p>
<p> </p>
<p>13.12</p>
<p> </p>
<p>…use “Dynamic Normal Addressing Multi TP” with multiple tester ................. 158</p>
<p> </p>
<p><b>14</b></p>
<p> </p>
<p><b>Related documents ................................................................................................... 162</b></p>
<p> </p>
<p><b>15</b></p>
<p> </p>
<p><b>Glossary .................................................................................................................... 163</b></p>
<p> </p>
<p><b>16</b></p>
<p> </p>
<p><b>Contact ...................................................................................................................... 164</b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>11 / 164 </p>
<p><b>Illustrations </b></p>
<p>Figure 3-1: Manuals and References for CANdesc .............................................................. 13</p>
<p> </p>
<p>Figure 4-1: General request flow .......................................................................................... 14</p>
<p> </p>
<p>Figure 4-2: DESC run diagram ............................................................................................. 15</p>
<p> </p>
<p>Figure 4-3: Request message mapping ............................................................................... 16</p>
<p> </p>
<p>Figure 4-4: Request processing stages ................................................................................ 17</p>
<p> </p>
<p>Figure 6-1 CANdesc GENy startup screen ........................................................................... 20</p>
<p> </p>
<p>Figure 6-2 Example of GENy global CANdesc settings ........................................................ 22</p>
<p> </p>
<p>Figure 6-3 Activated feature “Generic Processing Notifications” ........................................... 27</p>
<p> </p>
<p>Figure 6-4 GENy diagnostic service overview ...................................................................... 28</p>
<p> </p>
<p>Figure 6-5 GENy generic sub-service setup ......................................................................... 29</p>
<p> </p>
<p>Figure 6-6 GENy predefined sub-service setup .................................................................... 30</p>
<p> </p>
<p>Figure 6-7 GENy signal API enabled sub-service setup ....................................................... 32</p>
<p> </p>
<p>Figure 6-8 GENy signal view of a sub-service ...................................................................... 33</p>
<p> </p>
<p>Figure 6-9 GENy signal handler types .................................................................................. 33</p>
<p> </p>
<p>Figure 6-10 GENy direct access signal handler settings ...................................................... 34</p>
<p> </p>
<p>Figure 6-11 GENy CANdesc timing parameters ................................................................... 36</p>
<p> </p>
<p>Figure 6-12 GENy CANdesc security access parameters .................................................... 37</p>
<p> </p>
<p>Figure 6-13</p>
<p> </p>
<p>Security settings in GENy ......................................................................... 38</p>
<p> </p>
<p>Figure 6-14 GENy CANdesc scheduler parameters ............................................................. 40</p>
<p> </p>
<p>Figure 7-1 CANdescBasic add a user session ..................................................................... 43</p>
<p> </p>
<p>Figure 7-2 CANdescBasic change user session name, id or completely delete user </p>
<p>session ..................................................................................................... 44</p>
<p> </p>
<p>Figure 7-3 CANdescBasic session configuration at service overview ................................... 45</p>
<p> </p>
<p>Figure 7-4 CANdescBasic session configuration at service Id level ..................................... 45</p>
<p> </p>
<p>Figure 7-5 CANdescBasic session configuration at sub-service level................................... 46</p>
<p> </p>
<p>Figure 8-1 CANdesc multi identity mode .............................................................................. 48</p>
<p> </p>
<p>Figure 8-2 Defining VSGs in CANdelaStudio ....................................................................... 50</p>
<p> </p>
<p>Figure 8-3 Setting a VSG for service in CANdelaStudio ....................................................... 51</p>
<p> </p>
<p>Figure 9-1: Linearly written positive response on single PID request.................................... 54</p>
<p> </p>
<p>Figure 9-2: “On the fly” response data writing. ..................................................................... 55</p>
<p> </p>
<p>Figure 9-3: Negative response on single PID ....................................................................... 56</p>
<p> </p>
<p>Figure 9-4: Linearly written positive response on multiple PIDs (global ring buffer option is </p>
<p>off) ............................................................................................................ 57</p>
<p> </p>
<p>Figure 9-5: Negative response on multiple PIDs (global ring buffer option is off) .................. 58</p>
<p> </p>
<p>Figure 9-6: Linearly written response data on multiple PIDs (global ring buffer option is on) 61</p>
<p> </p>
<p>Figure 9-7: Negative response on multiple PIDs (global ring buffer option is on) .................. 61</p>
<p> </p>
<p>Figure 9-8: Post-Handler execution sequence. .................................................................... 62</p>
<p> </p>
<p>Figure 9-9: Defining a DDID. ................................................................................................ 65</p>
<p> </p>
<p>Figure 9-10: Reading a DDID. .............................................................................................. 66</p>
<p> </p>
<p>Figure 10-1 Call order of Manufacturer- and Supplier-Notficiation ........................................ 69</p>
<p> </p>
<p>Figure 10-2 Read out a DDID with generic processing notifications ..................................... 70</p>
<p> </p>
<p>Figure 11-1</p>
<p> </p>
<p>Illustration of the feature BusyRepeatResponder ...................................... 71</p>
<p> </p>
<p>Figure 11-2 Example of the “Number of Rx(Tx) Channels” settings ...................................... 72</p>
<p> </p>
<p>Figure 12-1 DynDID definition restore and tester interaction .............................................. 123</p>
<p> </p>
<p>Figure 12-2 Store DynDID definitions ................................................................................. 124</p>
<p> </p>
<p>Figure 13-1 GENy TP configuration ................................................................................... 156</p>
<p> </p>
<p>Figure 13-2 GENy TP callbacks ......................................................................................... 157</p>
<p> </p>
<p>Figure 13-3 GENy TP callbacks (physical addressing) ....................................................... 159</p>
<p> </p>
<p>Figure 13-4 GENy TP callbacks (functional addressing) .................................................... 159</p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>12 / 164 </p>
<p><b>2 </b></p>
<p><b>Introduction </b></p>
<p>This document has not the job to describe the diagnostic itself. The focus of this document </p>
<p>is the technical aspects of the CANdesc component. </p>
<p> </p>
<p> </p>
<p><b>Please note </b></p>
<p>We have configured the programs in accordance with your specifications in the </p>
<p>questionnaire. Whereas the programs do support other configurations than the one </p>
<p>specified in your questionnaire, Vector’s release of the programs delivered to your </p>
<p>company is expressly restricted to the configuration you have specified in the </p>
<p>questionnaire. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>13 / 164 </p>
<p><b>3 </b></p>
<p><b>Documents this one refers to… </b></p>
<p></p>
<p> </p>
<p>User Manuals CANdesc and CANdescBasic (one for both) </p>
<p></p>
<p> </p>
<p>Docu OEM </p>
<p> </p>
<p> </p>
<p>Figure 3-1: Manuals and References for CANdesc </p>
<p>All common topics with CANdesc and CANdescBasic are described within this technical </p>
<p>reference very detailed.  </p>
<p>Read all about OEM-specific differences in the TechnicalReference_OEM. </p>
<p>For  faster  integration,  refer  to  the  product’s  corresponding  user  manual  CANdesc  or </p>
<p>CANdescBasic. </p>
<p> </p>
<p><b>You are here</b></p>
<p><b>User Manual</b></p>
<p><b>Technical</b></p>
<p><b>Reference</b></p>
<p><b>General</b></p>
<p><b>Technical</b></p>
<p><b>Reference</b></p>
<p><b>OEM</b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>14 / 164 </p>
<p><b>4 </b></p>
<p><b>Architecture Overview </b></p>
<p>This </p>
<p>chapter </p>
<p>should </p>
<p>describe </p>
<p>the </p>
<p>internal </p>
<p>structure </p>
<p>and </p>
<p>behavior </p>
<p>of </p>
<p>the </p>
<p>CANdesc </p>
<p>component.  </p>
<p> </p>
<p><b>4.1 </b></p>
<p><b>CANdesc – Internal processing </b></p>
<p><b>4.1.1 </b></p>
<p><b>Diagnostic protocol </b></p>
<p>The </p>
<p>communication </p>
<p>described </p>
<p>in </p>
<p>the </p>
<p>diagnostic </p>
<p>protocol </p>
<p>consists </p>
<p>of </p>
<p>a </p>
<p>ping-pong </p>
<p>communication  between  a  tester  (client)  and  an  ECU  (server).  The  tester  requests  a </p>
<p>service  in  the  ECU  by  transmitting  a  request  to  him.  The  ECU  should  response  with  a </p>
<p>positive response, if the result of this service is valid or the action is prepared to be done. </p>
<p>Is  the  result  negative  or  the  action  could  not  be  executed,  the  ECU  should  respond </p>
<p>negative.  </p>
<p>The  validity  checks  have  typically  the  same  pattern for all  services  (as  shown  in  Figure </p>
<p>4-1: General request flow). These components which are included in this flow, build up the </p>
<p>main base of the CANdesc component. </p>
<p> </p>
<p> </p>
<p>Figure 4-1: General request flow </p>
<p> </p>
<p> </p>
<p>t</p>
<p><b>Diagnostics - CANdesc</b></p>
<p><b>Application</b></p>
<p>Check<b> Svc</b></p>
<p>Check<b> Session</b></p>
<p>Check<b> SvcInst</b></p>
<p>Check<b> Format</b></p>
<p><b>Mainhandler</b></p>
<p>{</p>
<p>....</p>
<p>DescProcessingDone( );</p>
<p>}</p>
<p><b>Prehandler </b></p>
<p><b>optional</b></p>
<p>{</p>
<p>}</p>
<p><b>Posthandler </b></p>
<p><b>optional</b></p>
<p>{</p>
<p>}</p>
<p><b>Request</b></p>
<p><b>negative Response</b></p>
<p><b>Tester</b></p>
<p><b>positive Response</b></p>
<p><b>ACK</b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>15 / 164 </p>
<p><b>4.1.2 </b></p>
<p><b>How does this flow actually work? </b></p>
<p>The picture below shows a simply structured description of the module functionality. </p>
<p><b>Request reception</b></p>
<p><b>Dispatching the request</b></p>
<p><b>Processing the request</b></p>
<p><b>Finishing processing of the </b></p>
<p><b>request</b></p>
<p><b>Idle mode/Awaiting request</b></p>
<p> </p>
<p>Figure 4-2: DESC run diagram </p>
<p>Lets assume that the component is currently in the <i><b>“</i>Awaiting request<i>” </b></i>state. In this state </p>
<p>it  waits  for  the  next  diagnostic  request  and  if  it  is  needed  –  it  provides  also  timing </p>
<p>monitoring.  </p>
<p>Once </p>
<p>a </p>
<p>diagnostic </p>
<p>request </p>
<p>transmission </p>
<p>was </p>
<p>initiated </p>
<p>from </p>
<p>the </p>
<p>transport </p>
<p>layer, </p>
<p>the </p>
<p>component  enters in  the  state <i><b> “</i>Request  reception<i>”</b></i>.  If  the  reception  is finished, further </p>
<p>physical requests will be blocked until the response is sent. Depending on the used OEM a </p>
<p>functional request in the ISO 14230 standard will be handled parallel</p>
<p>1</p>
<p> to physical request. </p>
<p>The </p>
<p>ISO </p>
<p>14229-1 </p>
<p>standard </p>
<p>is </p>
<p>more </p>
<p>restricted </p>
<p>to </p>
<p>the </p>
<p>parallel </p>
<p>handling. </p>
<p>Except </p>
<p>the </p>
<p>TesterPresent Service no other service could be handled parallel. </p>
<p>                                            </p>
<p>1</p>
<p> Not all services could be handled parallel. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>16 / 164 </p>
<p>After the reception of the request is completed the request processing  will be prepared. </p>
<p>The component is in the <i><b>“</i>Dispatching request<i>” </b></i>state. The processing of the request is </p>
<p>done at a task level within the next call of the DescTask() function. </p>
<p>First </p>
<p>the </p>
<p>SID </p>
<p>is </p>
<p>checked </p>
<p>whether </p>
<p>supported </p>
<p>or </p>
<p>not. </p>
<p>If </p>
<p>not </p>
<p>a </p>
<p>negative </p>
<p>response </p>
<p>‘ServiceNotSupported’ (NRC $11) will be sent. </p>
<p>Next step is to check if the supported SID is permitted in the current Session (Diagnostic </p>
<p>Mode).  If  not,  the  negative  response  ‘ServiceNotSupportedInTheCurrentSession’  (NRC </p>
<p>$7F) is sent automatically by the CANdesc component. </p>
<p> </p>
<p> </p>
<p>Figure 4-3: Request message mapping </p>
<p><i><b> </b></i></p>
<p>After  that  the  CANdesc  component  validates,  if  the  sub-service  (service  instance)  is </p>
<p>supported  or  not.  This  is  implemented  with  a  powerful  binary  search.  If  the  service </p>
<p>instance is not supported, the request will be rejected with the corresponding error code </p>
<p>‘SubFunctionNotSupported’ </p>
<p>(NRC </p>
<p>$11, </p>
<p>for </p>
<p>service </p>
<p>which </p>
<p>have </p>
<p>SubFunctions) </p>
<p>or </p>
<p>‘InvalidFormat’ (NRC $13, for service with data identifiers). </p>
<p>For each service instance which is supported by the current configuration, the CANdesc </p>
<p>component knows the exact length of most requests. (Some requests use variable data </p>
<p>length elements thus a fixed length doesn’t exist.)  If the length is known and it does not </p>
<p>match, the dispatcher will reject this request (dependent to the manufacturer specification). </p>
<p>If the complete request length is not known, the application has to do this job. </p>
<p>If the service instance is found, the state checks (e.g. ‘Security Level’) will be performed. If </p>
<p>all of them are passed then the component enters the state <i><b>“</i>Processing the request<i>” </b></i>in </p>
<p>the  diagram  above.  This  state  consists  of  several  parts  that  are  represented  in  more </p>
<p>detailed </p>
<p>structure </p>
<p>shown </p>
<p>below. </p>
<p>The </p>
<p>dotted </p>
<p>lines </p>
<p>reveal </p>
<p>the </p>
<p>optional </p>
<p>parts </p>
<p>for </p>
<p>the </p>
<p>implementation. For example – the Pre-, Post- and SignalHandlers are optional and might </p>
<p>not be implemented.  </p>
<p> </p>
<p>  </p>
<p>Service instance qualification </p>
<p>  </p>
<p>“Request head </p>
<p>“   </p>
<p>  </p>
<p> </p>
<p>n Bytes (n=0..N) </p>
<p>  </p>
<p>  </p>
<p>1Byte </p>
<p>  </p>
<p>  </p>
<p>m </p>
<p> Bytes (m = 0..M) </p>
<p>  </p>
<p>  </p>
<p>Application data</p>
<p> </p>
<p> </p>
<p> </p>
<p>  </p>
<p>SID</p>
<p> </p>
<p> </p>
<p> </p>
<p>  </p>
<p>SID</p>
<p> </p>
<p>_EXT</p>
<p> </p>
<p> </p>
<p> </p>
<p>  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>17 / 164 </p>
<p><b>Request analyzed</b></p>
<p><b>PreHandler</b></p>
<p><b>MainHandler</b></p>
<p><i><b>Signal-Handler #0</b></i></p>
<p><i><b>Signal-Handler #1</b></i></p>
<p><i><b>Signal-Handler #k</b></i></p>
<p><b>PostHandler</b></p>
<p> </p>
<p> </p>
<p>Figure 4-4: Request processing stages </p>
<p>After </p>
<p>the </p>
<p>response </p>
<p>is </p>
<p>composed </p>
<p>CANdesc </p>
<p>must </p>
<p>be </p>
<p>informed </p>
<p>about, </p>
<p>to </p>
<p>start </p>
<p>the </p>
<p>transmission  of  the  final  response.  CANdesc  is  doing  the  handshake  with  the  Tester </p>
<p>(automatic transmission of RCR-RP) while the state <i><b>“</i>Processing the request<i>” </b></i>is active. </p>
<p>Within  the  end  of  the  transmission  the  state  “<b>Finishing  processing  of  the  request” </b> is </p>
<p>entered and the PostHandler (if configured) is called. In this PostHandler the application </p>
<p>has to do the closing (e.g. updating a state machine, prepare the ECU for a reset …). The </p>
<p>session </p>
<p>state </p>
<p>for </p>
<p>example </p>
<p>(which </p>
<p>is </p>
<p>managed </p>
<p>by </p>
<p>CANdesc) </p>
<p>is </p>
<p>also </p>
<p>updated </p>
<p>in </p>
<p>a </p>
<p>PostHandler.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>18 / 164 </p>
<p><b>4.2 </b></p>
<p><b>Application interface flow </b></p>
<p><b>4.2.1 </b></p>
<p><b>Session- and CommunicationControl  </b></p>
<p>The </p>
<p>services </p>
<p>SessionControl </p>
<p>and </p>
<p>CommunicationControl </p>
<p>are </p>
<p>typically </p>
<p>handled </p>
<p>by </p>
<p>CANdesc. But the application still has the possibility to reject these service requests. You </p>
<p>can find a detailed description in chapter 12.6.6 Session Handling and in chapter 12.6.7 </p>
<p>CommunicationControl Handling also. </p>
<p>IDLE</p>
<p>Receive a Request</p>
<p>Search</p>
<p>SID</p>
<p>IDLE</p>
<p><b>ApplDesc&lt;PreHandler&gt;</b></p>
<p><b>callback</b></p>
<p>SID $28</p>
<p>(SID $29)</p>
<p><b>ApplDescCheckCommCtrl</b></p>
<p><b>{</b></p>
<p><b>  ...</b></p>
<p><b>DescCommCtrlChecked();</b></p>
<p><b>}</b></p>
<p>Transmit positive</p>
<p>response $68</p>
<p>TX acknowledge</p>
<p>$68</p>
<p><i><b>ApplDescOnCommunicationEnabled</b></i></p>
<p><i><b>ApplDescOnCommunicationDisabled</b></i></p>
<p><i>&gt;optional - not all OEMs&lt;</i></p>
<p>WAIT</p>
<p><b>ApplDesc&lt;PreHandler&gt;</b></p>
<p><b>callback</b></p>
<p>Supported</p>
<p>SID $xx</p>
<p><b>ApplDesc&lt;MainHandler&gt;</b></p>
<p><b>{</b></p>
<p><b>  ...</b></p>
<p><b>  DescProcessingDone();</b></p>
<p><b>}</b></p>
<p>TX acknowledge</p>
<p>$xx</p>
<p><b>ApplDesc&lt;PostHandler&gt;</b></p>
<p>WAIT</p>
<p><b>ApplDesc&lt;PreHandler&gt;</b></p>
<p><b>callback</b></p>
<p>SID $10</p>
<p><b>ApplDescCheckSessionTransition</b></p>
<p><b>{</b></p>
<p><b>  ...</b></p>
<p><b>DescSessionTransitionChecked();</b></p>
<p><b>}</b></p>
<p>TX acknowledge</p>
<p>$50</p>
<p><b>ApplDescOnSessionTransition</b></p>
<p>WAIT</p>
<p>Unsupported</p>
<p>SID $xx</p>
<p>Transmit positive</p>
<p>response $50</p>
<p>Transmit</p>
<p>negative</p>
<p>response</p>
<p>NRC $11</p>
<p>Transmit positive</p>
<p>response $xx</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>19 / 164 </p>
<p><b>5 </b></p>
<p><b>Advanced Configuration </b></p>
<p><b>5.1 </b></p>
<p><b>Configure DBC attributes for diagnostics </b></p>
<p>If the diagnostic messages shall be defined in the communication data-base file (DBC), </p>
<p>and not received via CANdriver ranges (e.g. in case of normal fixed or extended </p>
<p>addressing), the following attributes in the DBC file must exist and shall be set as shown </p>
<p>below. </p>
<p> </p>
<p><b>Attribute Name </b></p>
<p><b>Object </b></p>
<p><b>Type </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>the default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>DiagRequest </p>
<p>Message </p>
<p>Enum </p>
<p><b>No </b></p>
<p>Yes </p>
<p>Specifies (Yes) that the message is a diagnostic </p>
<p><b>physical USDT </b>request message. </p>
<p>DiagResponse </p>
<p>Message </p>
<p>Enum </p>
<p><b>No </b></p>
<p>Yes </p>
<p>Specifies (Yes) that the message is a diagnostic </p>
<p><b>USDT </b>response message. </p>
<p>DiagState </p>
<p>Message </p>
<p>Enum </p>
<p><b>No </b></p>
<p>Yes </p>
<p>Specifies (Yes) that the message is a diagnostic </p>
<p><b>functional USDT </b>request message. </p>
<p>DiagUudtResponse </p>
<p>Message </p>
<p>Enum </p>
<p><b>false </b></p>
<p>true </p>
<p>Specifies (true) that the message is a diagnostic </p>
<p><b>UUDT </b>response message. </p>
<p>Table 5-1: DBC file diagnostic message attributes </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>20 / 164 </p>
<p><b>6 </b></p>
<p><b>CANdesc Configuration in GENy </b></p>
<p>Since version 6.00.00, the CANdesc configuration concept has been improved by splitting </p>
<p>the </p>
<p>concrete </p>
<p>ECU </p>
<p>parameterization </p>
<p>and </p>
<p>software </p>
<p>integration </p>
<p>from </p>
<p>the </p>
<p>diagnostic </p>
<p>specification. </p>
<p>The configuration of CANdesc in GENy consists of two important steps: </p>
<p>-</p>
<p> </p>
<p>Importing  a  diagnostic  description  file.  Currently  only  CANdela  (CDD)  files  are </p>
<p>supported therefore in further only the term CDD file will be used. </p>
<p>-</p>
<p> </p>
<p>Setup all service options required by the application like: </p>
<p>o</p>
<p> </p>
<p>Configure the service handlers (pre-, main- and post-handlers) </p>
<p>o</p>
<p> </p>
<p>Setup  the  service  specific  settings,  like  maximum  number  of  dynamically </p>
<p>defined items per DynDID, size of scheduler for periodic data reading, etc. </p>
<p>o</p>
<p> </p>
<p>Setup timing parameters (e.g. periodic rates). </p>
<p>The second step is optional, since after importing a CDD file all important settings will be </p>
<p>already prepared for usage. If there are missing or invalid settings, GENy will notify you at </p>
<p>generation time. </p>
<p> </p>
<p><b>6.1 </b></p>
<p><b>Step One – Importing an ECU Diagnostic Description </b></p>
<p>After activating the CANdesc component in GENy, you will have the following view: </p>
<p> </p>
<p>Figure 6-1 CANdesc GENy startup screen </p>
<p>At this time GENy does not have any CDD file and can not generate CANdesc. You have </p>
<p>to specify a CDD file, using the button on the option “CANdela document name”. </p>
<p> </p>
<p>After selecting the CDD file, the CANdesc component tree view will look like: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>21 / 164 </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>Please note, the diagnostic buffer size is now set to a non-zero value. At CDD import </p>
<p>time, GENy calculates a statistic over all services with simple, linear data structure and </p>
<p>sets the buffer size to fit the longest request resp. response message. The message </p>
<p>window will show you which service requires the suggested buffer size: </p>
<p> </p>
<p>Complex services like reading the faultmemory information or </p>
<p>upload/download/transferdata are excluded from this statistic, since the worst case </p>
<p>response calculation is not possible. </p>
<p>You can still set another value for the buffer size, even lower as the size suggested by </p>
<p>GENy. At generation time, the code generator will check again the set buffer size and </p>
<p>consider more options you have changed (like RingBuffer support) and notify you if the </p>
<p>buffer size is too small. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Now you can try to generate your diagnostic layer, using the default settings. </p>
<p> </p>
<p><b>6.2 </b></p>
<p><b>Step Two – ECU Diagnostic Configuration in GENy </b></p>
<p>Once the CDD content is imported, there are several options that can and shall be set up </p>
<p>for best match on your ECU integration needs. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>22 / 164 </p>
<p><b>What You Can Configure in GENy </b></p>
<p>The </p>
<p>goal </p>
<p>of </p>
<p>splitting </p>
<p>the </p>
<p>ECU </p>
<p>integration </p>
<p>configuration </p>
<p>from </p>
<p>the </p>
<p>ECU </p>
<p>diagnostic </p>
<p>specification  is  to  provide  a  simplified  view  on  what  the  ECU  diagnostic  application </p>
<p>developer  is  able  to  configure  without  danger  of  changing  the  diagnostic  specification </p>
<p>provided by the OEM.  </p>
<p>If a CANdesc parameter is not available in the source diagnostic description (CDD file), </p>
<p>you will be able to edit it in GENy, even if it is relevant for the diagnostic specification. </p>
<p>The chapters below will show you all configuration parameters of CANdesc that can be set </p>
<p>up in GENy. </p>
<p><b>What You Can Not Configure in GENy </b></p>
<p>All  diagnostic  parameters  that  could  affect  the  ECU  behaviour  regarding  its  diagnostic </p>
<p>specification, provided by the concrete OEM or would lead to inconsistency between the </p>
<p>tester expectations on the ECU behaviour are not editable in GENy. If a change is required </p>
<p>on such a parameter, the diagnostic description source shall be modified, to guarantee that </p>
<p>the OEM or/and the tester will take this change into account. </p>
<p> </p>
<p><b>6.2.1 </b></p>
<p><b>Global CANdesc Settings  </b></p>
<p>Under </p>
<p>the </p>
<p>generic </p>
<p>settings </p>
<p>you </p>
<p>will </p>
<p>find  the  options </p>
<p>that </p>
<p>affect </p>
<p>the  overall </p>
<p>module </p>
<p>performance,  independently  of  the  diagnostic  services  that  shall  be  supported.  In  the </p>
<p>picture and the table below follows the description of the settings for CANdesc. </p>
<p> </p>
<p>Figure 6-2 Example of GENy global CANdesc settings </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>23 / 164 </p>
<p><b>Attribute Name </b></p>
<p><b>Availability </b></p>
<p><b>Value Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>Cycle Time [ms] </p>
<p>Always available. </p>
<p>Integer </p>
<p><b>10 </b></p>
<p>1..255 </p>
<p>The DescTask (resp. </p>
<p>DescTimerTask) function must be </p>
<p>called EXACTLY in the time period </p>
<p>specified here. </p>
<p>This is important since the time </p>
<p>constant will be converted into a </p>
<p>number of function calls and if this </p>
<p>setting doesn't match the real call </p>
<p>cycle, the component internal </p>
<p>timeout monitors will not function </p>
<p>properly. </p>
<p>Generate CANdesc </p>
<p>Always available. </p>
<p>Button </p>
<p><b> </b></p>
<p>This feature is only available after </p>
<p>you have generated the whole </p>
<p>CANbedded package. </p>
<p>NOTE: If you run into problems, </p>
<p>generate the whole package again! </p>
<p>Number of ‘Busy-</p>
<p>RepeatRequest’ </p>
<p>responded </p>
<p>Requests </p>
<p>OEM dependent </p>
<p>availability. </p>
<p>Integer </p>
<p><b>0 </b></p>
<p>0..255 </p>
<p>The value is the maximum count of </p>
<p>parallel handled diagnostic </p>
<p>requests. Only the first diagnostic </p>
<p>request will be processed, all other </p>
<p>(additonal) request, which will be </p>
<p>received while the first one is in </p>
<p>process, will be also received, but </p>
<p>only responded with NRC $21 </p>
<p>('BUSY - repeat request'). If there </p>
<p>are more requests onto the bus </p>
<p>than this number, only the first N </p>
<p>will be responded - all other will be </p>
<p>just ignored. </p>
<p>Flashable ECU </p>
<p>OEM dependent </p>
<p>availability. </p>
<p>Boolean </p>
<p><b>False </b></p>
<p>True </p>
<p>Depending on the car </p>
<p>manufacturer this option has </p>
<p>different effects. Please, see the </p>
<p>OEM specific technical reference </p>
<p>document for more information. </p>
<p>Ring Buffer Support </p>
<p>Always available. </p>
<p>Boolean </p>
<p><b>False </b></p>
<p>True </p>
<p>In case your ECU shall send a </p>
<p>very long positive response for </p>
<p>some services (usually when </p>
<p>reading fault memory) you can </p>
<p>reserve enough RAM for the </p>
<p>diagnostic buffer to handle the </p>
<p>longest possible response length, </p>
<p>or you can use the built-in ring-</p>
<p>buffer mechanism which allows </p>
<p>usage of smaller buffer. The linear </p>
<p>buffer usage saves ROM and run-</p>
<p>time but needs more RAM, the </p>
<p>ring-buffer saves RAM (you may </p>
<p>send 4095 Byte response with a </p>
<p>20Byte buffer) but requires more </p>
<p>ROM and causes run-time </p>
<p>overhead when used. NOTE: This </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>24 / 164 </p>
<p><b>Attribute Name </b></p>
<p><b>Availability </b></p>
<p><b>Value Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>option just unlocks the built-in </p>
<p>support, but the selection usage of </p>
<p>the feature is done at run-time by </p>
<p>your application (for each service </p>
<p>independently).  </p>
<p>Forced RCR-RP </p>
<p>Response </p>
<p>OEM dependent </p>
<p>availability. </p>
<p>Boolean </p>
<p><b>False </b></p>
<p>True </p>
<p>In some cases (e.g. prior jump into </p>
<p>the FBL (FlashBootLoader), ECU </p>
<p>busy so no task function can be </p>
<p>called for long period of time) it is </p>
<p>necessary to prevent the tester </p>
<p>from ECU response timeout. </p>
<p>Enabling this feature you will be </p>
<p>able to send a RCR-RP </p>
<p>(ResponseCorrectlyReceived-</p>
<p>ResponsePending) response any </p>
<p>time during an active serivce </p>
<p>processing (main-handler called </p>
<p>but no DescProcessingDone has </p>
<p>been called yet). </p>
<p>Repeated Service </p>
<p>Call Type </p>
<p>Always available. </p>
<p>Enum </p>
<p><b>Deactivated </b></p>
<p>Always </p>
<p>Individual </p>
<p>In some cases (usually for slow </p>
<p>services like reading from </p>
<p>EEPROM) it is useful to let the </p>
<p>component to poll your application </p>
<p>(service main-handler) until the </p>
<p>service execution is completed. </p>
<p>Otherwise you have to leave the </p>
<p>service's main-handler function </p>
<p>and trigger an own additional </p>
<p>polling task and finalize the service </p>
<p>from there. Using the built-in </p>
<p>polling mechanism you will save </p>
<p>ROM and run-time. Also it prevents </p>
<p>from confusing code structures. </p>
<p>Always: Each main-handler will be </p>
<p>called as long as the application </p>
<p>didn’t call <i>DescProcessingDone</i>(). </p>
<p>Individual: Each main-handler will </p>
<p>decide by itself if it will be called </p>
<p>once or as long as the application </p>
<p>didn’t call <i>DescProcessingDone</i>(). </p>
<p>Production Mode </p>
<p>OEM dependent </p>
<p>availability. </p>
<p>Boolean </p>
<p><b>False </b></p>
<p>True </p>
<p>Enabling the production mode will </p>
<p>set all options in the possible </p>
<p>safest (uncritical) value. </p>
<p>Some car manufacturers don't </p>
<p>allow all of the features in </p>
<p>production, so they will be turned </p>
<p>off. </p>
<p>Spontaneous </p>
<p>Response </p>
<p>Available if Service </p>
<p>0x86 is part of the </p>
<p>diagnostic </p>
<p>configuration. </p>
<p>Boolean </p>
<p><b>False </b></p>
<p>True </p>
<p>This setting enables the possibility </p>
<p>to send diagnostic responses </p>
<p>without a preceding request. </p>
<p>This feature is needed for Service </p>
<p>0x86 with Transmission Type I. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>25 / 164 </p>
<p><b>Attribute Name </b></p>
<p><b>Availability </b></p>
<p><b>Value Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>The spontaneous response can be </p>
<p>triggered via the API </p>
<p>DescSendApplSpontaneousRespo</p>
<p>nse. </p>
<p>Supplier Notification </p>
<p>Support </p>
<p>Available if </p>
<p>CANdesc </p>
<p>according to ISO </p>
<p>14229-1 2012 is </p>
<p>used. </p>
<p>Boolean </p>
<p><b>False </b></p>
<p>True </p>
<p>If this option is enabled, CANdesc </p>
<p>notifies the application on incoming </p>
<p>service requests and outgoing </p>
<p>responses. CANdesc only notifies </p>
<p>the application if the requested </p>
<p>service is supported in the active </p>
<p>session and security state. For </p>
<p>more details see <i>10 Generic </i></p>
<p><i>Processing Notifications </i></p>
<p>Manufacturer </p>
<p>Notification Support </p>
<p>Available if </p>
<p>CANdesc </p>
<p>according to ISO </p>
<p>14229-1 2012 is </p>
<p>used. </p>
<p>Boolean </p>
<p><b>False </b></p>
<p>True </p>
<p>If this option is enabled, CANdesc </p>
<p>notifies the application on incoming </p>
<p>service requests and outgoing </p>
<p>responses. CANdesc notifies the </p>
<p>application right before the </p>
<p>processing of the request starts </p>
<p>and after a response has been </p>
<p>sent. For more details see <i>10 </i></p>
<p><i>Generic Processing Notifications </i></p>
<p>Unknown Services </p>
<p>Acceptance </p>
<p>OEM dependent </p>
<p>availability. </p>
<p>Boolean </p>
<p><b>False </b></p>
<p>True </p>
<p>In some cases if the diagnostic </p>
<p>database doesn't contain all </p>
<p>necessary service Ids, or you need </p>
<p>a (some) test identifier(s), you can </p>
<p>enable this option which will </p>
<p>redirect all received requests with </p>
<p>unknown service Ids to your </p>
<p>application for additional </p>
<p>acknowledgment and processing. </p>
<p>Unknown Services </p>
<p>Post Handler Calls </p>
<p>OEM dependent </p>
<p>availability. </p>
<p>Boolean </p>
<p><b>False </b></p>
<p>True </p>
<p>If the option 'Unknown Services </p>
<p>Acceptance' is enabled, you may </p>
<p>use this feature to be notified each </p>
<p>time an unknown service </p>
<p>processing has been </p>
<p>accomplished. This post handler </p>
<p>usage is the same as the one of </p>
<p>the normal services post handlers. </p>
<p>Application Interface </p>
<p>Assertions </p>
<p>Always available. </p>
<p>Boolean </p>
<p><b>False </b></p>
<p>True </p>
<p>The SW component provides built-</p>
<p>in debug support (assertion) to </p>
<p>ease up the integration and test </p>
<p>into the project. </p>
<p>In general, the usage of assertions </p>
<p>is recommended during the </p>
<p>integration and pre-test phases. It </p>
<p>is not recommended to enable the </p>
<p>assertions in production code due </p>
<p>to increased runtime and ROM </p>
<p>needs. The assertion checks the </p>
<p>correctness of the assigned </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>26 / 164 </p>
<p><b>Attribute Name </b></p>
<p><b>Availability </b></p>
<p><b>Value Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>condition and calls an error-</p>
<p>handler in case this fails. The error </p>
<p>handler is called with an error and </p>
<p>line number. You can find </p>
<p>information about the defined error </p>
<p>numbers in the Desc.h file. </p>
<p>Internal Assertions </p>
<p>Always available. </p>
<p>Boolean </p>
<p><b>False </b></p>
<p>True </p>
<p>The SW component provides built-</p>
<p>in debug support (assertion) to </p>
<p>ease up the integration and test </p>
<p>into the project. </p>
<p>In general, the usage of assertions </p>
<p>is recommended during the </p>
<p>integration and pre-test phases. It </p>
<p>is not recommended to enable the </p>
<p>assertions in production code due </p>
<p>to increased runtime and ROM </p>
<p>needs. The assertion checks the </p>
<p>correctness of the assigned </p>
<p>condition and calls an error-</p>
<p>handler in case this fails. The error </p>
<p>handler is called with an error and </p>
<p>line number. You can find </p>
<p>information about the defined error </p>
<p>numbers in the Desc.h file. </p>
<p>List of DANIS </p>
<p>drivers </p>
<p>Always available. </p>
<p>String List </p>
<p><b> </b></p>
<p>Add an arbitrary list of DANIS </p>
<p>drivers for custom bus access. </p>
<p> </p>
<p>Each entry here will result in a user </p>
<p>driver, which can be used to </p>
<p>connect CANdesc to arbitrary </p>
<p>transport layers. </p>
<p> </p>
<p>Example:  </p>
<p>Adding a driver name “MostTp” will </p>
<p>force CANdesc to generate </p>
<p>templates for a driver with this </p>
<p>name. You will have only to </p>
<p>implement the functions of the </p>
<p>driver skeleton. </p>
<p>UUDT Message </p>
<p>Confirmation </p>
<p>Timeout [ms] </p>
<p>Available only if </p>
<p>UUDT message </p>
<p>transmission is </p>
<p>supported. </p>
<p>Integer </p>
<p><b>100 </b></p>
<p>1..65535 </p>
<p>This is the maximum time after </p>
<p>which a UUDT (Unacknowledged </p>
<p>Unsegmented Data Transfer) </p>
<p>message will be deleted from the </p>
<p>CAN drive request queue and (if </p>
<p>possible) will be replaced by the </p>
<p>next queued message. </p>
<p>Faultmemory </p>
<p>Iteration Limiter </p>
<p>Available only if </p>
<p>CANdesc provides </p>
<p>fault-memory </p>
<p>service </p>
<p>Integer </p>
<p><b>0 </b></p>
<p>0..255 </p>
<p>Limit the iteration depth for </p>
<p>faultmemory read services. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>27 / 164 </p>
<p><b>Attribute Name </b></p>
<p><b>Availability </b></p>
<p><b>Value Type </b></p>
<p><b>Values </b></p>
<p>The default </p>
<p>value is written </p>
<p>in bold </p>
<p><b>Description </b></p>
<p>implementation. </p>
<p>Some faultmemory ($19) services </p>
<p>can consume much runtime when </p>
<p>performed en bloc. To reduce the </p>
<p>run time of the CANdesc task, use </p>
<p>this option to limit the iteration </p>
<p>depth of the faultmemory access </p>
<p>function so your controller can </p>
<p>handle the workload. </p>
<p>ATTENTION: Depending on your </p>
<p>Tp timeout settings, to low a </p>
<p>number of iterations can result in </p>
<p>an aborted transmission due to </p>
<p>buffer underrun. </p>
<p> </p>
<p>A value of 0 (zero) will disable any </p>
<p>limitation. </p>
<p>Variant Mode </p>
<p>Selection </p>
<p>OEM dependent </p>
<p>availability. </p>
<p>Enum </p>
<p><b>None </b></p>
<p>Multi Identity </p>
<p>Mode </p>
<p>VSG Mode </p>
<p>Note: This setting is independent </p>
<p>from communication identities! </p>
<p>None: The diagnostics support one </p>
<p>configuration only. </p>
<p>Multi Identity Mode: The </p>
<p>diagnostics support different </p>
<p>diagnostic variants. One variant is </p>
<p>active a time. </p>
<p>VSG Mode: Diagnostic Entities </p>
<p>(SubServices, DTCs...) are </p>
<p>grouped into VSGs. Several VSGs </p>
<p>can be active at a time. </p>
<p> </p>
<p><b>6.2.1.1 </b></p>
<p><b>Generic Processing Notifications (UDS2012) </b></p>
<p>On activation of the feature “Generic Processing Notifications”, GENy shows the names of </p>
<p>the additional callbacks that will be generated. The names of the callbacks are fixed and </p>
<p>can not be modified (see Figure 6-3). For a detailed description of the feature see chapter </p>
<p>10 Generic Processing Notifications. </p>
<p> </p>
<p>Figure 6-3 Activated feature “Generic Processing Notifications” </p>
<p><b>6.2.2 </b></p>
<p><b>Service Specific Settings </b></p>
<p>Once the CDD file is imported you can have an overview of the supported services of your </p>
<p>ECU: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>28 / 164 </p>
<p> </p>
<p>Figure 6-4 GENy diagnostic service overview </p>
<p> </p>
<p>On this level you can also configure all services that will be supported on service Id level </p>
<p>only. </p>
<p> </p>
<p><b>6.2.2.1 </b></p>
<p><b>Generic Service Settings </b></p>
<p>Using the CANdesc component tree view you can explore the detailed settings for each </p>
<p>service and its sub-services (if available). </p>
<p>A generic sub-service setup looks like the picture below: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>29 / 164 </p>
<p> </p>
<p>Figure 6-5 GENy generic sub-service setup </p>
<p>Almost all services have a very simple configuration view. You can see the main-handler is </p>
<p>always available and a preview of the call-back name is shown.  </p>
<p>You can only add a pre- and / or a post-handler to such a service, if required. </p>
<p> </p>
<p><b>6.2.2.2 </b></p>
<p><b>Predefined (implemented) Services in CANdesc </b></p>
<p>There are configurations (OEM dependent) where several services are fully implemented </p>
<p>by </p>
<p>CANdesc. </p>
<p>Such </p>
<p>service </p>
<p>can </p>
<p>be, </p>
<p>StartDiagnsoticSession, </p>
<p>SecurityAccess, </p>
<p>DynamicallyDefinedDataIdentifier, ReadDataByPeriodicIdentifier, etc. </p>
<p>Those services that will not be handled by the application are marked in GENy as shown </p>
<p>on the picture: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>30 / 164 </p>
<p> </p>
<p>Figure 6-6 GENy predefined sub-service setup </p>
<p>As you can see, the main-handler is grayed and marked as “implemented by CANdesc”. </p>
<p>The same can apply (depends on the service) also to the pre- and post-handlers of the </p>
<p>service.  </p>
<p>In the example on the <i>Figure 6-6 GENy predefined sub-service setup </i>you see that the pre-</p>
<p>handler is still free for usage. This means you can still implement a pre-handler to check </p>
<p>additional conditions prior CANdesc will be able to process the service. For other service it </p>
<p>could be also the post-handler free for implementation. </p>
<p> </p>
<p>There are several services that make some exceptions to the predefined implementation </p>
<p>rule: </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>31 / 164 </p>
<p><b>Service 0x2A: </b></p>
<p>-</p>
<p> </p>
<p>PreHandler configuration is possible: If a pre-handler is required, it must be </p>
<p>enabled on all sub-functions of the concrete DID. The pre-handler name will </p>
<p>be “ApplDescPreReadPeriodicDid&lt;DID instance name&gt;”. </p>
<p>-</p>
<p> </p>
<p>PreHandler on “stop all” is not used by CANdesc and will not be considered </p>
<p>during the code generation even if it is enabled. </p>
<p>-</p>
<p> </p>
<p>Main-Handler are set to “implemented by CANdesc” since the data reading </p>
<p>call-back will be the corresponding 0x22 DID service call. This means that if </p>
<p>the corresponding service 0x22 DID has been set to use the “Signal API”, the </p>
<p>periodic reading service will use it too. </p>
<p>-</p>
<p> </p>
<p>Post-Handlers are not supported at all. </p>
<p> </p>
<p><b>Service 0x2C: </b></p>
<p>-</p>
<p> </p>
<p>PreHandler configuration is possible: If a pre-handler is required, it must be </p>
<p>enabled on all sub-functions of the concrete DID. The pre-handler name will </p>
<p>be “ApplDescPreDynDefineDid&lt;DID instance name&gt;”. </p>
<p>-</p>
<p> </p>
<p>PreHandler on “clear all” is not used by CANdesc and will not be considered </p>
<p>during the code generation even if it is enabled. </p>
<p>-</p>
<p> </p>
<p>Main-Handler are set to “implemented by CANdesc” since the DID definition </p>
<p>is always done by CANdesc.  </p>
<p>-</p>
<p> </p>
<p>Post-Handler are not supported at all. </p>
<p><b>6.2.2.3 </b></p>
<p><b>Signal Access Enabled Services </b></p>
<p>Some services such as the UDS ones 0x22/0x2A and 0x2E, can be processed on signal </p>
<p>level. This means CANdesc will analyze the request/response data structure and generate </p>
<p>the  service  main-handler,  leaving  to  the  application  only  the  task  to  provide  the  signal </p>
<p>values for the response, resp. to write the requested signal values to the ECU memory. </p>
<p>The setting view of such a service is shown below: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>32 / 164 </p>
<p> </p>
<p>Figure 6-7 GENy signal API enabled sub-service setup </p>
<p>Note: For the read dynamically defined DID service, there is no signal access since they </p>
<p>are always implemented by CANdesc internally. </p>
<p> </p>
<p>If the “Signal API” option is not enabled this service is to be implemented like any other </p>
<p>diagnostic service. The data object specific settings, described below, will have no effect </p>
<p>on the code generation. </p>
<p>If the “Signal API” option is enabled, CANdesc will generate per default a call-back function </p>
<p>for any data object (signal) the service contains. You can specify more options on each </p>
<p>signal,  to  achieve  the  maximum  advantage  of  CANdesc  –  fully  implemented  diagnostic </p>
<p>service. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>33 / 164 </p>
<p> </p>
<p>Figure 6-8 GENy signal view of a sub-service </p>
<p>You can have three types of signal handling: </p>
<p> </p>
<p>Figure 6-9 GENy signal handler types </p>
<p><b> </b></p>
<p> </p>
<p><b>FAQ </b></p>
<p>Constant is only possible if the CDD file has contained constant value for the selected data </p>
<p>object. You can not specify in GENy a constant value for a signal handler. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>In case of selected “Direct Access” signal handling, the following options will be enabled: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>34 / 164 </p>
<p> </p>
<p>Figure 6-10 GENy direct access signal handler settings </p>
<p> </p>
<p><b>Attribute Name </b></p>
<p><b>Availability </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Signal Handler Type </p>
<p>Only for signal API </p>
<p>enabled services. </p>
<p>Enum </p>
<p><b>SignalHandler </b></p>
<p>Constant </p>
<p>DirectAccess </p>
<p>Select the type of signal handler </p>
<p> </p>
<p>Constant: The data value is </p>
<p>constant. The data value can be </p>
<p>used directly. This is used only </p>
<p>when the corresponding </p>
<p>subservice uses a signal API main </p>
<p>handler. </p>
<p> </p>
<p>Signal Handler: Use a callback </p>
<p>function to get/set the data value. </p>
<p>This function is used only when the </p>
<p>corresponding subservice uses a </p>
<p>signal API main handler. </p>
<p> </p>
<p>Direct Access: Directly use a </p>
<p>variable to access the data object. </p>
<p>Also, a signal API main handler </p>
<p>has to be used for this setting to </p>
<p>have any effect. </p>
<p>SignalHandler </p>
<p>Function Base </p>
<p>Name </p>
<p>Only for signal API </p>
<p>enabled services </p>
<p>and a signal </p>
<p>access through a </p>
<p><b>SignalHandler </b>is </p>
<p>selected </p>
<p>String </p>
<p><b>&lt;DataObjectQ</b></p>
<p><b>ualifier&gt;+&lt;Dia</b></p>
<p><b>gInstanceQual</b></p>
<p><b>ifier&gt; </b></p>
<p>This value is used as base for the </p>
<p>signal access function - depending </p>
<p>on how the value is used, the </p>
<p>name entered here is prefixed with </p>
<p>different prefixes, e.g </p>
<p>ApplDescRead / ApplDescWrite. </p>
<p> </p>
<p>You can override the default name, </p>
<p>by specifying an own signal base. </p>
<p>The Prefix (e.g. ApplDesc can not </p>
<p>be overridden). </p>
<p>Signal Variable </p>
<p>Name </p>
<p>Only for signal API </p>
<p>enabled services </p>
<p>String </p>
<p><b>&lt;DataObjectQ</b></p>
<p><b>ualifier&gt; </b></p>
<p>The name of the signal variable. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>35 / 164 </p>
<p><b>Attribute Name </b></p>
<p><b>Availability </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>and if </p>
<p><b>DirectAccess </b></p>
<p>signal handling is </p>
<p>selected </p>
<p>Example: </p>
<p>c_dataTemp </p>
<p>g_applData.bit0 </p>
<p>Signal Variable </p>
<p>Prototype </p>
<p>Only for signal API </p>
<p>enabled services </p>
<p>and if </p>
<p><b>DirectAccess </b></p>
<p>signal handling is </p>
<p>selected </p>
<p>Enum </p>
<p><b>Ram </b></p>
<p>None </p>
<p>Const </p>
<p>User </p>
<p>To create the proper extern </p>
<p>declaration to access the signal </p>
<p>variable, the proper access </p>
<p>modifiers have to be specified. </p>
<p> </p>
<p>None: No prototype is generated at </p>
<p>all. &quot;DescType.h&quot; where the user </p>
<p>has to define the real typedefs (for </p>
<p>structure access for example). </p>
<p> </p>
<p>Ram: The variable is located in </p>
<p>RAM. </p>
<p> </p>
<p>Const: The variable is located in </p>
<p>ROM. </p>
<p> </p>
<p>User: Set a user defined prototype. </p>
<p>Signal Variable User </p>
<p>Prototype </p>
<p>Only for signal API </p>
<p>enabled services </p>
<p>and if </p>
<p><b>DirectAccess </b></p>
<p>signal handling is </p>
<p>selected </p>
<p>and if the Signal </p>
<p>Variable Prototype </p>
<p>is set to <b>User </b></p>
<p>String </p>
<p><b>Empty </b></p>
<p>Set the prototype of the signal </p>
<p>variable. </p>
<p>Example: </p>
<p>boolean </p>
<p>EcuTempType </p>
<p> </p>
<p><b>6.2.3 </b></p>
<p><b>Timing Settings </b></p>
<p>GENy imports all possible timings that the diagnostic description source provides. Those </p>
<p>parameters  that  are  available  in  the  CDD  file  are  considered  as  a  part  of  the  ECU </p>
<p>specification  and  are  not  modifiable  in  GENy.  If  a  modification  of  those  parameters  is </p>
<p>required,  please  change  their  values  in  the diagnostic  description file and  re-import  it  in </p>
<p>GENy. </p>
<p>All other parameters can be set up manually, but the default value already matches the </p>
<p>OEM specification. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>36 / 164 </p>
<p> </p>
<p>Figure 6-11 GENy CANdesc timing parameters </p>
<p><b>6.2.4 </b></p>
<p><b>Security Access Settings (UDS2006) </b></p>
<p>If the security access service is implemented by CANdesc (see the service handler on the </p>
<p>service 0x27 instances), you can set here the level specific attributes, like attempts to start </p>
<p>the delay time, delay time on power on, etc. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>It is OEM specific property whether the security access parameters will be evaluated </p>
<p>security  level  specific  or  not. In  case the  security  access  service  specification  of the </p>
<p>concrete OEM requires only global configuration of these options, the code generator </p>
<p>will calculate the maximum value over all levels for each parameter and this value will </p>
<p>be used by the service implementation in CANdesc.  </p>
<p>Example: Level 1 has “Attempt Counter” = 1, and Level 2 has for the same parameter = </p>
<p>3. CANdesc will use then for “Attempt Counter” = 3 for all security levels. </p>
<p><b> </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>37 / 164 </p>
<p> </p>
<p>Figure 6-12 GENy CANdesc security access parameters </p>
<p> </p>
<p><b>Attribute Name </b></p>
<p><b>Availability </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Attempt Counter </p>
<p>Only if the </p>
<p>SecurityAccess </p>
<p>state group is </p>
<p>available </p>
<p>Integer </p>
<p><b>0 </b></p>
<p>1..255 </p>
<p>Specifies the maximum number of </p>
<p>failed attempts to unlock the ECU. </p>
<p>If this number is reached, a delay </p>
<p>for the next security access try will </p>
<p>be inserted. </p>
<p>If a non-zero value is entered, the </p>
<p>delay time must be set to a non-</p>
<p>zero value too. </p>
<p> </p>
<p>Note: This parameter has only </p>
<p>effect only if the SecurityAccess </p>
<p>service is handled by CANdesc. </p>
<p>Initial Delay [ms] </p>
<p>Only if the </p>
<p>SecurityAccess </p>
<p>state group is </p>
<p>available </p>
<p>Integer </p>
<p><b>0 </b></p>
<p>1..65535 </p>
<p>Specifies the delay time after the </p>
<p>maximum retry attempt count has </p>
<p>been reached. </p>
<p> </p>
<p>If a non-zero value is entered, the </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>38 / 164 </p>
<p><b>Attribute Name </b></p>
<p><b>Availability </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>attempt count must be set to a </p>
<p>non-zero value too. </p>
<p> </p>
<p>Note: This parameter has only </p>
<p>effect only if the SecurityAccess </p>
<p>service is handled by CANdesc. </p>
<p>PowerOn Delay [ms] </p>
<p>Only if the </p>
<p>SecurityAccess </p>
<p>state group is </p>
<p>available </p>
<p>Integer </p>
<p><b>0 </b></p>
<p>1..65535 </p>
<p>Specifies the delay time at power </p>
<p>on. </p>
<p> </p>
<p>If a non-zero value is entered, the </p>
<p>delay time must be set to a non-</p>
<p>zero value too. </p>
<p> </p>
<p>Note: This parameter has only </p>
<p>effect only if the SecurityAccess </p>
<p>service is handled by CANdesc. </p>
<p> </p>
<p><b>6.2.5 </b></p>
<p><b>Security Access Settings (UDS2012) </b></p>
<p>Due to the new features in CANdesc UDS2012, the configuration of the security levels in </p>
<p>GENy has changed. </p>
<p> </p>
<p>Figure 6-13 Security settings in GENy </p>
<p><b>Attribute Name </b></p>
<p><b>Availability </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Level Specific Failed </p>
<p>Access Attempt </p>
<p>Supervision </p>
<p>Only if the </p>
<p>SecurityAccess </p>
<p>state group is </p>
<p>available </p>
<p>Boolean </p>
<p><b>False </b></p>
<p>True </p>
<p>Switch to select whether a global </p>
<p>false attempt counter and delay </p>
<p>timer for all security levels shall be </p>
<p>used (false) or if each level has its </p>
<p>own false attempt counter and </p>
<p>delay timer (true). </p>
<p>Use Static Seed </p>
<p>Only if the </p>
<p>SecurityAccess </p>
<p>state group is </p>
<p>Boolean </p>
<p><b>False </b></p>
<p>True </p>
<p>For each level can be selected if a </p>
<p>static seed is used (true) or not </p>
<p>(false). Static seed means that </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>39 / 164 </p>
<p><b>Attribute Name </b></p>
<p><b>Availability </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>available </p>
<p>CANdesc stores the seed and re-</p>
<p>uses the seed in a positive </p>
<p>response to a seed request for that </p>
<p>level, until the level is unlocked. </p>
<p>Failed Attempt </p>
<p>Counter to Delay </p>
<p>Only if the </p>
<p>SecurityAccess </p>
<p>state group is </p>
<p>available </p>
<p>Integer </p>
<p><b>Value </b></p>
<p><b>imported from </b></p>
<p><b>the Cdd file. </b></p>
<p>0..65535 </p>
<p>The number of failed security </p>
<p>unlock attempts allowed before a </p>
<p>delay is imposed between </p>
<p>attempts. </p>
<p>Failed Attempt </p>
<p>Delay [ms] </p>
<p>Only if the </p>
<p>SecurityAccess </p>
<p>state group is </p>
<p>available </p>
<p>Integer </p>
<p><b>Value </b></p>
<p><b>imported from </b></p>
<p><b>the Cdd file. </b></p>
<p>0..65535 </p>
<p>The delay time in ms which is </p>
<p>imposed if the Failed Attempt </p>
<p>Counter limit has been reached. </p>
<p>Further security access attempts </p>
<p>are discarded, until the delay has </p>
<p>expired. </p>
<p>PowerOn Delay [ms] </p>
<p>Only if the </p>
<p>SecurityAccess </p>
<p>state group is </p>
<p>available </p>
<p>Integer </p>
<p><b>Value </b></p>
<p><b>imported from </b></p>
<p><b>the Cdd file. </b></p>
<p>0..65535 </p>
<p>The delay time in ms which is </p>
<p>imposed when the ECU is </p>
<p>powered on. Requests to unlock </p>
<p>the security level are declined until </p>
<p>the delay has expired. </p>
<p> </p>
<p><b>6.2.6 </b></p>
<p><b>Scheduler Settings </b></p>
<p>If  the  ECU  shall  support  the  periodic  data  reading  service,  the  following  settings  are </p>
<p>relevant and shall be setup to match the ECU performance and RAM resource availability. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>40 / 164 </p>
<p> </p>
<p>Figure 6-14 GENy CANdesc scheduler parameters </p>
<p> </p>
<p><b>Attribute Name </b></p>
<p><b>Availability </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>Maximum Count of </p>
<p>Scheduled Items </p>
<p>Only if the periodic </p>
<p>data reading </p>
<p>service is available </p>
<p>in the ECU </p>
<p>configuration. </p>
<p>Integer </p>
<p><b>5 </b></p>
<p>1..255 </p>
<p>The maximum number of items </p>
<p>that are sent periodically. </p>
<p>You can only request at most this </p>
<p>number of periodic DIDs, </p>
<p>independently per scheduling rate. </p>
<p> </p>
<p>Example: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>41 / 164 </p>
<p><b>Attribute Name </b></p>
<p><b>Availability </b></p>
<p><b>Value </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p>The default value is </p>
<p>written in bold </p>
<p><b>Description </b></p>
<p>If set up 5 items for scheduling, </p>
<p>CANdesc will be able to schedule </p>
<p>at most 5 items at fast, 5 items at </p>
<p>slow and 5 items at medium rate. </p>
<p> </p>
<p>Note: If the scheduler size exceeds </p>
<p>the total number of available </p>
<p>periodic DIDs, CANdesc will </p>
<p>automatically reduce the size to </p>
<p>the lowest value. </p>
<p>Fast/Medium/Slow </p>
<p>Scheduling Rate </p>
<p>[ms] </p>
<p>Only if the periodic </p>
<p>data reading </p>
<p>service is available </p>
<p>in the ECU </p>
<p>configuration. </p>
<p>Integer </p>
<p><b>OEM </b></p>
<p><b>dependent </b></p>
<p>1..65535 </p>
<p>Specifies the timings of each </p>
<p>scheduling rate that the ECU </p>
<p>supports. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>42 / 164 </p>
<p><b>7 </b></p>
<p><b>CANdescBasic Configuration in GENy </b></p>
<p>As  already  stated  in </p>
<p><i>6  CANdesc  Configuration  in  GENy </i> since  version  6.00.00,  the </p>
<p>CANdesc  configuration  in  GENy  has  been changed.  Both  CANdesc  and  CANdescBasic </p>
<p>variants  share  the  same  GUI  and  settings  representation  in  GENy.  Due  to  the  reduced </p>
<p>feature  set  in  CANdescBasic,  its  GENy  GUI  provides  you  correspondingly  a  reduced </p>
<p>configuration option set, covering all of the CANdescBasic requirements.  </p>
<p><b>7.1 </b></p>
<p><b>Global CANdescBasic Settings </b></p>
<p>CANdescBasic shares the same global settings as the CANdesc variant (refer to chapter </p>
<p><i>6.2.1 Global CANdesc Settings</i>). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>CANdescBasic does not support any of the multi identity modes! </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>7.2 </b></p>
<p><b>Service Specific Settings </b></p>
<p>In CANdescBasic, you don’t have any more an external diagnostic specification document </p>
<p>that  shall  be  imported  (like  a  CDD  file).  In  your  software  delivery,  there  is  already  a </p>
<p>prepared diagnostic configuration template that fulfills the concrete OEM and its diagnostic </p>
<p>protocol requirements.  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>In CANdescBasic versions, prior 6.00.00, it was possible to import information, out of a </p>
<p>CDD file, whether a service Id is supported or not-supported and any new sessions. In </p>
<p>CANdesc 6.00.00 and newer this feature is temporarily disabled, but you still can </p>
<p>manually configure these changes. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>Since CANdescBasic provides only a Sid view over the diagnostic services, its service specific configuration is performed </p>
<p>primarily within the service overview grid in GENy (refer to chapter 0  </p>
<p>Service Specific Settings </p>
<p> </p>
<p>CANdescBasic  also  provides  a  built  in  support  for  some  of  the  diagnostic  services  like </p>
<p>CANdesc, but its scope is reduced (due to lack of enough service definition information) </p>
<p>only </p>
<p>to </p>
<p>the </p>
<p>most </p>
<p>important </p>
<p>for </p>
<p>diagnostic </p>
<p>communication </p>
<p>services </p>
<p>(e.g. </p>
<p>DiagnosticSessionControl, TesterPresent, etc.). You will recognize these services in GENy </p>
<p>as described in chapter <i>6.2.2.2 Predefined (implemented) Services in CANdesc</i>. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>43 / 164 </p>
<p><b>7.3 </b></p>
<p><b>Timing Settings </b></p>
<p>The configuration aspect of the CANdescBasic timings settings is the same as described </p>
<p>in <i>6.2.3 Timing Settings</i>, with the difference, that here there is no CDD file but a predefined </p>
<p>template. </p>
<p> </p>
<p><b>7.4 </b></p>
<p><b>Diagnostic State Configuration </b></p>
<p>CANdescBasic has a built in support only for the diagnostic session states. All other states </p>
<p>like SecurityAccess and ECU specific service execution conditions shall be implemented </p>
<p>by the application. </p>
<p>The supplied CANdescBasic template already includes all mandatory session, specified by </p>
<p>the  concrete  OEM.  If  some  additional  sessions  needed,  you  can  add  them  in  GENy  as </p>
<p>shown below: </p>
<p> </p>
<p>Figure 7-1 CANdescBasic add a user session </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>44 / 164 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>For any session added by you (user sessions), GENy automatically creates all session </p>
<p>transitions, required by the concrete diagnostic protocol (e.g. UDS, KWP2000). </p>
<p>Examples: </p>
<p>        Service 0x10:  </p>
<p>                 &lt;AllExistingSessions&gt;-&gt;&lt;NewSsession&gt;,  </p>
<p>                 &lt;NewSession&gt;-&gt;&lt;NewSession&gt; </p>
<p>        Service 0x20: </p>
<p>                  &lt;NewSession&gt;-&gt;&lt;DefaultSession&gt; </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The allowed session Ids are protocol dependent. For example: on UDS you can not </p>
<p>specify user sessions with Ids greater than 0x7F. On KWP2000 any value is acceptable </p>
<p>for session Id. </p>
<p> </p>
<p>The session Id must be a unique value among all sessions, supported by your ECU. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>For the user defined session, you can any time change their name, session or completely </p>
<p>remove them: </p>
<p> </p>
<p>Figure 7-2 CANdescBasic change user session name, id or completely delete user session </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>45 / 164 </p>
<p>Once a user session has been added, you can configure for each service whether it shall </p>
<p>be supported or not in the new session. You can do this configuration either on the service </p>
<p>overview grid, or if there are some service that have sub-services, for each sub-service. </p>
<p>The pictures below show each of the service level configuration views. </p>
<p> </p>
<p>Figure 7-3 CANdescBasic session configuration at service overview  </p>
<p> </p>
<p>Figure 7-4 CANdescBasic session configuration at service Id level </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>46 / 164 </p>
<p> </p>
<p>Figure 7-5 CANdescBasic session configuration at sub-service level </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>47 / 164 </p>
<p><b>8 </b></p>
<p><b>Multi Identity Support </b></p>
<p>CANdesc allows you to use multiple diagnostic configuration sets – a use case where the </p>
<p>ECU  always  communicates  over  the  same  connection,  but  shall  implement  different </p>
<p>functionality depending on some hardware (jumper) setting. </p>
<p>All supported configuration sets are described in the following chapters. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>Please note:  </p>
<p>The multi identity feature of CANdesc is: </p>
<p>-</p>
<p> </p>
<p>firstly supported in CANdesc 6.00.00; </p>
<p>-</p>
<p> </p>
<p>not supported at all in the CANdescBasic variant. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>8.1 </b></p>
<p><b>Single Identity Mode </b></p>
<p>CANdesc </p>
<p>has </p>
<p>a </p>
<p>static </p>
<p>configuration </p>
<p>set </p>
<p>– </p>
<p>once </p>
<p>all </p>
<p>services </p>
<p>and </p>
<p>communication </p>
<p>connections are configured, and the program code is flashed into the ECU there are no </p>
<p>more configuration changes possible. </p>
<p><b>8.1.1.1 </b></p>
<p><b>Configuration in CANdela  </b></p>
<p>You  need  just  to  prepare  the  corresponding  CDD  variant  for  your  ECU  configuration  in </p>
<p>CANdelaStudio. </p>
<p><b>8.1.1.2 </b></p>
<p><b>Configuration in GENy </b></p>
<p>Import the CDD file and the corresponding variant in GENy (refer to <i>chapter 6.2 Step Two </i></p>
<p><i>– ECU Diagnostic Configuration in GENy </i>for details). </p>
<p> </p>
<p><b>8.2 </b></p>
<p><b>VSG Mode </b></p>
<p>The VSG mode is a special multi identity mode, which has the following characteristics: </p>
<p></p>
<p> </p>
<p>Allows  to  support  multiple  diagnostic  configuration  variants  –  each  variant  reflects  a </p>
<p>VSG from the imported CDD file, and additionally there is a base variant that contains </p>
<p>all services that does not belong to any VSG. </p>
<p></p>
<p> </p>
<p>One or several configuration variants can be simultaneously activated during the ECU </p>
<p>initialization. The base variant is always active. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>48 / 164 </p>
<p> </p>
<p>Figure 8-1 CANdesc multi identity mode </p>
<p>CANdesc  will be  initialized  with  the  base  variant  at ECU  start  up sequence.  If  required, </p>
<p>additional  variant(s)  can  be  activated  by  the  application  (please  refer  to  chapter <i> 12.6.2 </i></p>
<p><i>Multi Variant Configuration Functions </i>for more information about the variant initialization). </p>
<p> </p>
<p><b>8.2.1 </b></p>
<p><b>Implementation Limitations </b></p>
<p>In </p>
<p>order </p>
<p>to </p>
<p>generate </p>
<p>the </p>
<p>correct </p>
<p>NRC </p>
<p>for </p>
<p>a </p>
<p>requested </p>
<p>service </p>
<p>Id </p>
<p>(e.g. </p>
<p>0x7F </p>
<p>(ServiceNotSupprtedInActiveSession), </p>
<p>CANdesc </p>
<p>considers </p>
<p>all </p>
<p>of </p>
<p>its </p>
<p>sub-services </p>
<p>diagnostic  session  specific  execution  precondition  and  calculates  a  diagnostic  session </p>
<p>filter for the SID. In case of a multi-identity such a calculation shall be made for all of the </p>
<p>diagnostic configuration variants, which will cost a lot of ROM resources. </p>
<p> </p>
<p>In  order  to  keep  CANdesc  ROM  resources  as  low  as  possible  the  service  Id  specific </p>
<p>session </p>
<p>filtering </p>
<p>is </p>
<p>created </p>
<p>considering </p>
<p>the </p>
<p>superset </p>
<p>of </p>
<p>all </p>
<p>sub-services </p>
<p>it </p>
<p>contains, </p>
<p>independently of their configuration affiliation. Depending on the active configuration set in </p>
<p>the ECU, this limitation can lead to the following effect:  </p>
<p>A requested service will be responded with the NRC 0x12 (SubfunctionNotSupported) or </p>
<p>0x31(requestOutOfRange),  depending  on  if  it  has  a  sub-function  or  not,  instead  of  the </p>
<p>NRC 0x7F. Such a configuration could be for example: </p>
<p>Service 0x22 (ReadDataByIdentifier) supports only two DIDs: </p>
<p>0xF100 - supported only in the default diagnostic sessions and available only in variant 1; </p>
<p>0xF101 – supported only in a non-default session and available only in variant 2. </p>
<p>CANdesc  will  summarize  in  this  case,  that  service  0x22  is  allowed  in  any  diagnostic </p>
<p>session since there is at least one DID supported in at least one of each session. </p>
<p>Now  let’s  assume  the  ECU  is  powered  up  with  active  variant  2.  If  the  client  sends  a </p>
<p>request 0x22 0xF100 while in the default diagnostic session, CANdesc will respond with </p>
<p> </p>
<p> </p>
<p> </p>
<p>CANdesc </p>
<p>TP </p>
<p>CANdesc </p>
<p>APPL </p>
<p> </p>
<p>CANdesc </p>
<p>DIAG CFG </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>49 / 164 </p>
<p>the NRC 0x31 (DID not supported), instead of the 0x7F (none of the DIDs in the active </p>
<p>configuration is executable in the default session -&gt; the service Id itself is not executable in </p>
<p>the session -&gt; NRC 0x7F would be expected). </p>
<p> </p>
<p><b>8.2.2 </b></p>
<p><b>Configuration in CANdela  </b></p>
<p></p>
<p> </p>
<p>If multiple diagnostic configuration sets shall be selectable in CANdesc, you will need a </p>
<p>CDD with several VSGs where each describes a diagnostic configuration set. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>CANdesc supports the multiple diagnostic configurations only on service/sub-service </p>
<p>availability level. Therefore the following limitations must be considered while creating </p>
<p>the separate CDD files resp. CANdela variants for CANdesc: </p>
<p></p>
<p> </p>
<p>A service can be completely deactivated within a VSG; </p>
<p></p>
<p> </p>
<p>A sub-service (e.g. DID, sub-function, etc.) can be completely deactivated within a </p>
<p>VSG; </p>
<p></p>
<p> </p>
<p>If a service exist in multiple VSGs, then it must have exactly the same properties </p>
<p>-</p>
<p> </p>
<p>Execution pre-conditions (e.g. diagnostic session, security access, etc.) </p>
<p>-</p>
<p> </p>
<p>Support of SPRMIB </p>
<p>-</p>
<p> </p>
<p>Addressing mode (physical/function) </p>
<p>-</p>
<p> </p>
<p>Response behavior (response on physical/function request) </p>
<p></p>
<p> </p>
<p>If a sub-service exist in multiple VSGs, then it must have exactly the same </p>
<p>properties </p>
<p>-</p>
<p> </p>
<p>Execution pre-conditions (e.g. diagnostic session, security access, etc.), </p>
<p>resp. trigger of state transitions. </p>
<p>-</p>
<p> </p>
<p>Addressing mode (physical/function) </p>
<p>-</p>
<p> </p>
<p>Response behavior (response on physical/function request) </p>
<p>-</p>
<p> </p>
<p>Protocol information semantic (sub-function, identifier, etc.) </p>
<p>-</p>
<p> </p>
<p>Request resp. response content must be identical – same data </p>
<p>structure, data types, and constant value (if any available) </p>
<p></p>
<p> </p>
<p>Service 0x31 (RoutineControlByIdentifier) specifics </p>
<p>-</p>
<p> </p>
<p>The multi-identity varying is allowed only on RID level. If a RID is </p>
<p>supported in multiple variants, then the sub-functions supported by this </p>
<p>RID must be the same (i.e. it is not allowed to have one variant with only </p>
<p>“start” sub-function and one with “start and stop” for the one and same </p>
<p>RID). </p>
<p></p>
<p> </p>
<p>Service 0x2F (IoControlByIdentifier) specifics </p>
<p>-</p>
<p> </p>
<p>The multi-identity varying is allowed only on DID level. If a DID is </p>
<p>supported in multiple variants, then the control options supported by this </p>
<p>DID must be the same (i.e. it is not allowed to have one variant with only </p>
<p>“ShortTermAdjustment” and one with “ShortTerm-Adjustment and </p>
<p>ReturnControlToEcu” for the one and same DID). </p>
<p> </p>
<p>If at least one of the above requirements is not fulfilled, the variant that violates the rule </p>
<p>will not be imported. </p>
<p><b> </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>50 / 164 </p>
<p><b>8.2.3 </b></p>
<p><b>Configuration in CANdela </b></p>
<p>Please follow the steps below on how to configure VSG in CANdelaStudio. </p>
<p> </p>
<p>1. </p>
<p>Defining all available VSGs for the concrete ECU. </p>
<p>In CANdelaStudio, select the Vehichle System Groups view and add all necessary VSGs </p>
<p>into the VSG pool. </p>
<p> </p>
<p>Figure 8-2 Defining VSGs in CANdelaStudio </p>
<p>The </p>
<p>name </p>
<p>of </p>
<p>the </p>
<p>created </p>
<p>VSG </p>
<p>will </p>
<p>be </p>
<p>used </p>
<p>later </p>
<p>by </p>
<p>CANdesc </p>
<p>for </p>
<p>the </p>
<p>diagnostic </p>
<p>configuration  constants  that  the  CANdesc  application  shall  use  during  the  configuration </p>
<p>activation phase (refer to chapter <i>12.6.2 Multi Variant Configuration Functions</i>). </p>
<p> </p>
<p>Once  all  of  the  required  VSGs  are  created,  you  can  start  with  the  service  to  VSG </p>
<p>assignment. </p>
<p> </p>
<p>2. </p>
<p>Service to VSG assignment </p>
<p>Using CANdelaStudio you can assign any diagnostic instance to none, one or multiple </p>
<p>VSGs. Those services that do belong to a diagnostic instance without a VSG assignment </p>
<p>will be considered as services of the base variant (services that are always available). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>51 / 164 </p>
<p> </p>
<p>Figure 8-3 Setting a VSG for service in CANdelaStudio </p>
<p><b>8.2.4 </b></p>
<p><b>Configuration in GENy </b></p>
<p>In order to put GENy into VSG mode, you have to select it on the CANdesc component </p>
<p>root.  Please  refer  to  the  chapter <i> 6.2.1  Global  CANdesc  Settings </i> for  details  about  the </p>
<p>variant selection option.  </p>
<p>Now import the CDD file, containing the VSGs in GENy as described in chapter <i>6.1 Step </i></p>
<p><i>One – Importing an ECU Diagnostic Description</i>. That is all. </p>
<p> </p>
<p><b>8.3 </b></p>
<p><b>Multi Identity Mode </b></p>
<p> </p>
<p>Multi Identy Mode is not supported by CANdesc. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>52 / 164 </p>
<p><b>9 </b></p>
<p><b>Diagnostic Service Implementation Specifics </b></p>
<p><b>9.1 </b></p>
<p><b>ReadDataByIdentifier (SID $22) </b></p>
<p>This service has the purpose to read some predefined data records (PID). Each PID has a </p>
<p>concrete data structure which is designed by CANdelaStudio.  </p>
<p>As the standard case the request contains a single PID. This results in a single response </p>
<p>containing the data structure of the record. </p>
<p> </p>
<p> </p>
<p>The UDS allows to request multiple PIDs in a single request. This results is also a single </p>
<p>response including the data structure of each requested PID. </p>
<p> </p>
<p> </p>
<p> </p>
<p>CANdesc will hide this multiple PID processing from the application. To do that some minor </p>
<p>limitations in the interface has to be made (see chapter 9.1.2 Single PID mode). To show </p>
<p>the  differences,  we  discuss  first  the  standard  case.  In  the  standard  case  there  is  no </p>
<p>multiple  PID  processing  possible.  The  second  chapter  (9.1.3  Multiple  PID  mode)  is </p>
<p>showing the multiple PID processing.  </p>
<p>Which mode is used depends on the configuration (typically the OEM). </p>
<p> </p>
<p> </p>
<p>$22 $12</p>
<p><b>Single PID mode (well know case) example for PID $1234</b></p>
<p>$34</p>
<p>Tester‘s request:</p>
<p>$62 $12 $34</p>
<p>ECU‘s response:</p>
<p>Data block</p>
<p>$22 $12</p>
<p><b>Single PID mode (well know case) example for PID $1234</b></p>
<p>$34</p>
<p>Tester‘s request:</p>
<p>$62 $12 $34</p>
<p>ECU‘s response:</p>
<p>Data block</p>
<p>$22 $12</p>
<p><b>Multiple PID mode example for PIDs: $1234, $ABCD</b></p>
<p>$34</p>
<p>Tester‘s request:</p>
<p>$62 $12 $34</p>
<p>ECU‘s response:</p>
<p>Data block</p>
<p>$AB$CD</p>
<p>$AB$CD</p>
<p>Data block</p>
<p>$22 $12</p>
<p><b>Multiple PID mode example for PIDs: $1234, $ABCD</b></p>
<p>$34</p>
<p>Tester‘s request:</p>
<p>$62 $12 $34</p>
<p>ECU‘s response:</p>
<p>Data block</p>
<p>$AB$CD</p>
<p>$AB$CD</p>
<p>Data block</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>53 / 164 </p>
<p><b>9.1.1 </b></p>
<p><b>Limitations of the service </b></p>
<p><b>Session management </b></p>
<p>This  service  contains  no  sub-function  identifier  which  means  the  global  state  group </p>
<p>“session”  may  not  be  selected  as  a  “relevant  group”  for  any  instance  of  this  service.  If </p>
<p>there is a need for a PID to be rejected under a certain session, all PIDs must follow this </p>
<p>rule and be specified to be rejected for this session. As a result the whole SID $22 will be </p>
<p>rejected for this session. This behavior is harmonized with the UDS protocol specification, </p>
<p>which allows service identifiers to be rejected in a session but no parameter identifiers. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>54 / 164 </p>
<p><b>9.1.2 </b></p>
<p><b>Single PID mode </b></p>
<p>The  Single  PID  mode  is  configured  automatically,  if  the  number  of  PIDs  that  can  be </p>
<p>requested at the same time, is limited to one PID. If more than one PID is requested, the </p>
<p>request will be rejected with ‘RequestOutOfRange’ (NRC $31).  </p>
<p>If the multiple PID mode of CANdesc is deactivated, the service $22 will be executed and </p>
<p>processed like any other diagnostic service without any additional specifics or limitations. </p>
<p><b>9.1.2.1 </b></p>
<p><b>Sending a positive response using linear buffer access </b></p>
<p> </p>
<p>Figure 9-1: Linearly written positive response on single PID request </p>
<p> </p>
<p> </p>
<p>Tester</p>
<p>CANdesc</p>
<p>Application</p>
<p>SId[$22],Pid[$xxxx]</p>
<p>ApplDescReadDataById_xxxx</p>
<p>DescProcessingDone()</p>
<p>Write data (pMsgContext-&gt;resData)</p>
<p>Set total response data length </p>
<p>(pMsgContext-&gt;resDataLen = N)</p>
<p>RSid[$62], PID[$xxxx], Data[N]</p>
<p>ApplDescPreReadDataById_xxxx</p>
<p>StateGroupsCheck for Pid</p>
<p>Check all states if the </p>
<p>&quot;read PID&quot; service can </p>
<p>be executed.</p>
<p>If available execute the pre-handler and </p>
<p>check if the application rejected the service.</p>
<p>Execute the main-handler </p>
<p>to fill the response data.</p>
<p>The positive response transmission will be </p>
<p>initiated after the DescProcessingDone </p>
<p>gets called.</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>55 / 164 </p>
<p><b>9.1.2.2 </b></p>
<p><b>Sending a positive response using ring buffer access </b></p>
<p> </p>
<p>Figure 9-2: “On the fly” response data writing. </p>
<p> </p>
<p> </p>
<p>Tester</p>
<p>CANdesc</p>
<p>Application</p>
<p>SId[$22],Pid[$xxxx]</p>
<p>FF (RSid[$62], PID[$xxxx], Data[3])</p>
<p>ApplDescReadDataById_xxxx</p>
<p>DescRingBufferStart()</p>
<p>Write data (DescRingBufferWrite())</p>
<p>Set total response data length </p>
<p>(pMsgContext-&gt;resDataLen = N)</p>
<p>Write data (DescRingBufferWrite())</p>
<p>CF(Data[N-3])</p>
<p>StateGroupsCheck for Pid</p>
<p>ApplDescPreReadDataById_xxxx</p>
<p>Check all states if the </p>
<p>&quot;read PID&quot; service may </p>
<p>be executed.</p>
<p>If available execute the pre-handler and check if </p>
<p>the application rejected the service.</p>
<p>Execute the main-handler </p>
<p>to fill the response data.</p>
<p>The positive response transmission will be initiated after </p>
<p>the DescRingBufferStart gets called and there are at </p>
<p>least 7 bytes ready to be transmitted (i.e. 3 data bytes).</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>56 / 164 </p>
<p><b>9.1.2.3 </b></p>
<p><b>Sending a negative response </b></p>
<p>Due to the fact that the negative response handling has changed in the multiple PID mode, </p>
<p>we  recommend  to  do  the  same  handling  in  the  Single  PID  mode,  too.  Please  refer  the </p>
<p>chapter 9.1.3.2 “Ring buffer active configuration” for the recommended negative response </p>
<p>handling. </p>
<p> </p>
<p>Figure 9-3: Negative response on single PID </p>
<p><b>9.1.3 </b></p>
<p><b>Multiple PID mode </b></p>
<p>The  Multiple  PID  mode  is  configured  automatically  if  the  number  of  PIDs,  that  can  be </p>
<p>requested at the same time, is greater than one. If more than this predetermined number </p>
<p>of PIDs is requested, the request will be rejected with ‘RequestOutOfRange’ (NRC $31).  </p>
<p>In  this  configuration  some  minor  limitations  must  be  taken  into  account  while  using  the </p>
<p>CANdesc interfaces.  </p>
<p>For the service “ReadDataByIdentifier” the ring-buffer feature can be used. Depending on </p>
<p>the usage of this feature, there are two main use cases for the multiple PID mode.: </p>
<p> </p>
<p> </p>
<p>Tester</p>
<p>CANdesc</p>
<p>Application</p>
<p>Check all states if the </p>
<p>&quot;read PID&quot; service can </p>
<p>be executed.</p>
<p>If available execute the pre-handler and </p>
<p>check if the application rejected the service.</p>
<p>Execute the main-handler </p>
<p>to fill the response data.</p>
<p>The negative response transmission will be </p>
<p>initiated after the DescProcessingDone </p>
<p>gets called.</p>
<p>SId[$22],Pid[$xxxx]</p>
<p>RSid[$7F], Sid[$22], ErrorCode[errorCode]</p>
<p>StateGroupsCheck for Pid</p>
<p>ApplDescReadDataById_xxxx</p>
<p>DescProcessingDone()</p>
<p>DescSetNegresponse(errorCode)</p>
<p>ApplDescPreReadDataById_xxxx</p>
<p>The main-handler still can </p>
<p>register any errors.</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>57 / 164 </p>
<p><b>9.1.3.1 </b></p>
<p><b>Pure linear buffer configuration </b></p>
<p>The ring-buffer feature is deactivated in general. </p>
<p>If the system doesn’t use any ring buffer access for filling the response, the PID pipeline is </p>
<p>still  quite  simple  and  therefore  with  less  limitations  to  the  CANdesc  API  usage  and </p>
<p>application performance. </p>
<p><b>9.1.3.1.1 </b></p>
<p><b>Sending a positive response </b></p>
<p> </p>
<p>Figure 9-4: Linearly written positive response on multiple PIDs (global ring buffer option is off) </p>
<p> </p>
<p> </p>
<p>Tester</p>
<p>CANdesc</p>
<p>Application</p>
<p>SId[$22],Pid0[$xxxx],Pid1[$yyyy]</p>
<p>FF (RSid[$62], PID0[$xxxx], Data[3])</p>
<p>CF[i](Data[N-3],PID1[$yyyy]Data[M)</p>
<p>ApplDescPreReadDataById_xxxx</p>
<p>Set total response data length </p>
<p>(pMsgContext-&gt;resDataLen = N)</p>
<p>Write data (pMsgContext-&gt;resData)</p>
<p>ApplDescPreReadDataById_yyyy</p>
<p>ApplDescReadDataById_xxxx</p>
<p>DescProcessingDone()</p>
<p>ApplDescReadDataById_yyyy</p>
<p>Write data (pMsgContext-&gt;resData)</p>
<p>Set total response data length </p>
<p>(pMsgContext-&gt;resDataLen = M)</p>
<p>DescProcessingDone()</p>
<p>StateGroupsCheck for PID0[$xxxx]</p>
<p>StateGroupsCheck for PID1[$yyyy]</p>
<p>Before the requested PIDs will be processed, check </p>
<p>all PIDs':</p>
<p>1. States (may be executed)</p>
<p>2. Pre-handlers.</p>
<p>Execute the first PID's </p>
<p>main-handler to fill the response </p>
<p>data.</p>
<p>Once the service execution of </p>
<p>the current PID has been </p>
<p>accomplished...</p>
<p>...execute the next </p>
<p>queued one.</p>
<p>The positive response transmission will be </p>
<p>initiated after all PIDs have called </p>
<p>DescProcessingDone and all the data ...</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>58 / 164 </p>
<p><b>9.1.3.1.2 </b></p>
<p><b>Sending a negative response </b></p>
<p>This example depicts the case where from two requested PIDs the first one may not be </p>
<p>accessible and rejects the service execution. </p>
<p> </p>
<p>Figure 9-5: Negative response on multiple PIDs (global ring buffer option is off) </p>
<p><b>9.1.3.2 </b></p>
<p><b>Ring buffer active configuration </b></p>
<p><b>Attention: </b>The Ring-Buffer in ‘Multiple PID‘ services can be first-time used since CANdesc </p>
<p>version 2.13.00 </p>
<p>Different concepts for the buffer handling were discussed while development. Two </p>
<p>solutions with different pros and cons are discussed here: </p>
<p> </p>
<p></p>
<p> </p>
<p><b>Multiple buffer </b></p>
<p>Normally  each  service  handler  (MainHandler  routine)  has  the  whole  diagnostic  buffer </p>
<p>available (apart from the protocol header bytes hidden by CANdesc). Based on this logic </p>
<p>the service $22 using PID pipelining has the same tasks as the normal service processor: </p>
<p>executing a PID handler and provide him the whole diagnostic buffer for response data. </p>
<p>This will hide the whole process and makes the application’s life easier (no exceptions for </p>
<p>the implementation). To realize this concept means to provide a separate diagnostic buffer </p>
<p>for each PID which size is the same as the main one (configured by GENtool). This is a </p>
<p>fast and quite simple solution but requires too much RAM to be reserved for only the case </p>
<p>that  sometimes  the  testers  would  like  to  use  the  maximum  capacity  of  the  ECU    (i.e. </p>
<p>requests as many PIDs as possible for this ECU in a single request).  </p>
<p>Pros: less ROM usage </p>
<p>Tester</p>
<p>CANdesc</p>
<p>Application</p>
<p>Before requested PIDs will be processed check all </p>
<p>PIDs':</p>
<p>1. States (may be executed)</p>
<p>2. Pre-handlers.</p>
<p>Execute the first PID's </p>
<p>main-handler to fill the response </p>
<p>data.</p>
<p>Once the service execution of </p>
<p>the current PID has been </p>
<p>accomplished...</p>
<p>...stops the further </p>
<p>processing a...</p>
<p>SId[$22],Pid0[$xxxx],Pid1[$yyyy]</p>
<p>RSid[$7F], Sid[$22], ErrorCode[errorCode]</p>
<p>StateGroupsCheck for PID0[$xxxx]</p>
<p>StateGroupsCheck for PID1[$yyyy]</p>
<p>ApplDescPreReadDataById_xxxx</p>
<p>DescSetNegResponse(errorCode)</p>
<p>ApplDescPreReadDataById_yyyy</p>
<p>ApplDescReadDataById_xxxx</p>
<p>DescProcessingDone()</p>
<p>The second PID's </p>
<p>Main-handler will not be </p>
<p>executed.</p>
<p>Skip further processing </p>
<p>of the list</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>59 / 164 </p>
<p>Cons: very high RAM usage </p>
<p><b> </b></p>
<p></p>
<p> </p>
<p><b>virtual multiple buffer </b></p>
<p>This concept is more generically designed and will not have additional ROM overhead if </p>
<p>the pipeline size will be increased. An intelligent buffer concept gives the application the </p>
<p>whole size of the buffer for each MainHandler call.  </p>
<p>Once the whole data for the current PID has been written, the data supplement will stop </p>
<p>(because the next PID handler will not be called). The transmission in the transport layer is </p>
<p>started and some time later it runs into buffer under-run. This ‘signal’ is used to call the </p>
<p>next PID MainHandler. This MainHandler has to provide his data very quick. Otherwise the </p>
<p>response transmission will stop (due to a continuously buffer under-run).  </p>
<p>Pros:  less RAM usage (practically independent of the maximum list size).  </p>
<p>Cons:  moderate  ROM  overhead  /  the  response  data  must  be  composed  very </p>
<p>quickly. </p>
<p>The virtual multiple buffer concept is the implemented solution. The application can choose </p>
<p>for each PID separately to write the data linearly or by using the ring buffer. </p>
<p><b>performance requirements  </b></p>
<p>The application has performance requirements: </p>
<p>-</p>
<p> </p>
<p>If  linear  access has been  chosen,  the  whole  response  data  of  each  MainHandler </p>
<p>must  be  filled  within  the  lower  duration  of  the  P2  time  and  the  TP  confirmation </p>
<p>timeout.  Normally  the  P2  time  is  shorter  than  the  transport  layers  confirmation </p>
<p>timeout  so  just  take  into  account  that  each  Main-Handler  must  be  able  to  fill  its </p>
<p>response data within a time far shorter than the P2 time. </p>
<p>-</p>
<p> </p>
<p>If </p>
<p>ring </p>
<p>buffer </p>
<p>access </p>
<p>has </p>
<p>been </p>
<p>chosen, </p>
<p>the </p>
<p>application </p>
<p>has </p>
<p>to </p>
<p>call </p>
<p> </p>
<p>the </p>
<p>“DescRingBufferWrite” fast enough to keep TP from confirmation timeout. </p>
<p><b>Negative response on PID </b></p>
<p>The  negative  response  handling <b> is  changed </b> in  the  multiple  PID  mode!  This  affects  all </p>
<p>protocol-services  with  a  activated  ‘May  be  combined’  property.  The  UDS  specification </p>
<p>encloses  only  the  SIDs:  $22  and  $2A.  For  all  other  services  the  negative  response </p>
<p>handling is not changed! </p>
<p>If the application has to reject a request (e.g. ignition key check) it has to do that in the </p>
<p>PreHandler.  The  application  is <b> not  allowed </b> to  call  “DescSetNegResponse()”  to  send  a </p>
<p>negative response in any MainHandler.  </p>
<p>This limitation is based on the concept to check all reject conditions in PreHandlers before </p>
<p>starting the transmission. This is necessary because after CANdesc has executed the first </p>
<p>MainHandler (which starts the positive response transmission) there will be no chance to </p>
<p>send a negative response.  </p>
<p>The  usage  of  the  concept:  CANdesc  starts  to  call  all  PreHandlers  of  this  multiple  PID </p>
<p>request.  If  no  negative  response  is  set,  CANdesc  will  start  to  call  the  corresponding </p>
<p>MainHandlers. Within the first call of DescProcessingDone() the transmission is initiated.  </p>
<p><b>Note (for version 3.02.00 of CANdesc and above): </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>60 / 164 </p>
<p>In case the application sets an error code during the main-handler execution in non-debug </p>
<p>(released) version of the component, depending on the situation will lead to: </p>
<p>For service $22: </p>
<p>-</p>
<p> </p>
<p>First DID of the list main-handler: sending a negative response to service $22; </p>
<p>-</p>
<p> </p>
<p>Second or any of the succeeding DIDs in the list: transmission interruption. </p>
<p>For service $2A: </p>
<p>-</p>
<p> </p>
<p>Ignoring the scheduled response. </p>
<p> </p>
<p><b>9.1.3.2.1 </b></p>
<p><b>Sending a positive response </b></p>
<p> </p>
<p>Tester</p>
<p>CANdesc</p>
<p>Application</p>
<p>SId[$22],Pid0[$xxxx],Pid1[$yyyy]</p>
<p>FF (RSid[$62], PID0[$xxxx], Data[3])</p>
<p>CF[i](Data[N-3])</p>
<p>StateGroupsCheck for PID0[$xxxx]</p>
<p>StateGroupsCheck for PID1[$yyyy]</p>
<p>ApplDescPreReadDataById_xxxx</p>
<p>Set total response data length </p>
<p>(pMsgContext-&gt;resDataLen = N)</p>
<p>Write data (pMsgContext-&gt;resData)</p>
<p>ApplDescPreReadDataById_yyyy</p>
<p>ApplDescReadDataById_xxxx</p>
<p>DescProcessingDone()</p>
<p>ApplDescReadDataById_yyyy</p>
<p>Write data (pMsgContext-&gt;resData)</p>
<p>Set total response data length </p>
<p>(pMsgContext-&gt;resDataLen = M)</p>
<p>DescProcessingDone()</p>
<p>CF[j](Data[N-k],PID1[$yyyy]Data[m])</p>
<p>CF[l](Data[M-m])</p>
<p>Before requested PIDs will be processed check all </p>
<p>PIDs':</p>
<p>1. States (may be executed)</p>
<p>2. Pre-handlers.</p>
<p>Execute the first PID's </p>
<p>main-handler to fill the response </p>
<p>data.</p>
<p>With the first called </p>
<p>DescProcessingDone() starts </p>
<p>the response transmission.</p>
<p>Once the whole data of  the current PID has </p>
<p>been sent the next PID main-handler will be </p>
<p>called to supply the response data.</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>61 / 164 </p>
<p>Figure 9-6: Linearly written response data on multiple PIDs (global ring buffer option is on) </p>
<p> </p>
<p><b>9.1.3.2.2 </b></p>
<p><b>Sending a negative response </b></p>
<p> </p>
<p>Figure 9-7: Negative response on multiple PIDs (global ring buffer option is on) </p>
<p> </p>
<p> </p>
<p>Tester</p>
<p>CANdesc</p>
<p>Application</p>
<p>Before requested PIDs will be processed check all </p>
<p>PIDs':</p>
<p>1. States (may be executed)</p>
<p>2. Pre-handlers.</p>
<p>If error has been set - no </p>
<p>main-hadnler processing will </p>
<p>follow.</p>
<p>Send immediately </p>
<p>negative response.</p>
<p>SId[$22],Pid0[$xxxx],Pid1[$yyyy]</p>
<p>RSid[$7F], Sid[$22], ErrorCode[errorCode]</p>
<p>StateGroupsCheck for PID0[$xxxx]</p>
<p>StateGroupsCheck for PID1[$yyyy]</p>
<p>ApplDescPreReadDataById_xxxx</p>
<p>ApplDescPreReadDataById_yyyy</p>
<p>DescSetNegResponse(errorCode)</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>62 / 164 </p>
<p><b>9.1.3.2.3 </b></p>
<p><b>PostHandler execution rule </b></p>
<p>All  PostHandlers  are  executed  after  the  finished  response  transmission  (like  a  normal </p>
<p>PostHandler). </p>
<p>Independent  of  the  ring-buffer option  setting  (enabled  or  disabled),  the  execution  of  the </p>
<p>service  $22  PostHandler(s)  has  the  following  rule  which  has  to  be  taken  into  account: </p>
<p><b>calling the Post-Handler of a specific PID means: either the PreHandler of this PID </b></p>
<p><b>has been previously called or its MainHandler. </b></p>
<p>The following sequence chart depicts this: </p>
<p> </p>
<p>Figure 9-8: Post-Handler execution sequence. </p>
<p> </p>
<p> </p>
<p><b>9.2 </b></p>
<p><b>DynamicallyDefineDataIdentifier (SID $2C) (UDS) </b></p>
<p>The DynamicallyDefineDataIdentifier service allows the client (tester) to dynamically define </p>
<p>in a server (ECU) a data identifier that can be read via the ReadDataByIdentifier service at </p>
<p>a later time. </p>
<p>The intention of this service is to provide the client with the ability to group one or more </p>
<p>data </p>
<p>elements </p>
<p>into </p>
<p>a </p>
<p>data </p>
<p>superset </p>
<p>that </p>
<p>can </p>
<p>be </p>
<p>requested </p>
<p>en </p>
<p>masse </p>
<p>via </p>
<p>the </p>
<p>Tester</p>
<p>CANdesc</p>
<p>Application</p>
<p>Before requested PIDs will be processted check all </p>
<p>PIDs':</p>
<p>1. States (may be executed)</p>
<p>2. Pre-handlers.</p>
<p>If error has been set - no </p>
<p>main-hadnler processing will </p>
<p>follow.</p>
<p>Send immediately </p>
<p>negative response.</p>
<p>SId[$22],Pid0[$xxxx],Pid1[$yyyy],</p>
<p>Pid2[$zzzz]</p>
<p>RSid[$7F], Sid[$22], ErrorCode[errorCode]</p>
<p>StateGroupsCheck for PID0[$xxxx]</p>
<p>StateGroupsCheck for PID1[$yyyy]</p>
<p>ApplDescPreReadDataById_xxxx</p>
<p>ApplDescPreReadDataById_zzzz</p>
<p>DescSetNegResponse(errorCode)</p>
<p>StateGroupsCheck for PID2[$zzzz]</p>
<p>PID1 has no pre-handler </p>
<p>cofigured.</p>
<p>ApplDescPostReadDataById_xxxx</p>
<p>PID0, PID1and PID2 have all </p>
<p>post-handlers configured.</p>
<p>ApplDescPostReadDataById_zzzz</p>
<p>PID1 has a post-handler but since </p>
<p>the application doesn't know about </p>
<p>its reception - no post-handler will </p>
<p>be called.</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>63 / 164 </p>
<p>ReadDataByIdentifier  or  ReadDataByPeriodicIdentifier  service.  The  data  elements  to  be </p>
<p>grouped together can either be referenced by: </p>
<p></p>
<p> </p>
<p>a source data identifier, a position and size or, </p>
<p></p>
<p> </p>
<p>a memory address and a memory length, or, </p>
<p></p>
<p> </p>
<p>a combination of the two methods listed above using multiple requests to define the </p>
<p>single  data  element.  The  dynamically  defined  dataIdentifier  will  then  contain  a </p>
<p>concatenation of the data parameter definitions. </p>
<p> </p>
<p>The  definition  of  the  dynamically  defined  data  identifier  can  either  be  done  via  a  single </p>
<p>request  message  or  via  multiple  request  messages.  This  allows  for  the  definition  of  a </p>
<p>single  data  element  referencing  source  identifier(s)  and  memory  addresses.  The  server </p>
<p>has </p>
<p>to </p>
<p>concatenate </p>
<p>the </p>
<p>definitions </p>
<p>for </p>
<p>the </p>
<p>single </p>
<p>data </p>
<p>element.  A </p>
<p>redefinition </p>
<p>of </p>
<p>a </p>
<p>dynamically defined data identifier can be achieved by clearing the current definition and </p>
<p>start over with the new definition. </p>
<p>At last the dynamically defined data identifier consists of a list of (non-dynamically) defined </p>
<p>data identifiers and memory area ranges that can be used in any combination. </p>
<p>For more information, see /ISO 14229-1/ </p>
<p> </p>
<p><b>9.2.1 </b></p>
<p><b>Feature set </b></p>
<p>These are the supported subfunctions for service $2C (DynamicallyDefineDataIdentifier): </p>
<p><b>Subfunction Name </b></p>
<p><b>Hex Value </b></p>
<p>defineByIdentifier </p>
<p>01 </p>
<p>defineByMemoryAddress </p>
<p>02 </p>
<p>clearDynamicallyDefinedDataIdentifier </p>
<p>03 </p>
<p> </p>
<p><b>9.2.2 </b></p>
<p><b>API Functions </b></p>
<p>The reception of a Service $2C request will either delete a DynamicDataIdentifier (DDID) </p>
<p>or  PeriodicDataIdentifier  (PDID)  by  subfunction  $03  or  build  a  DDID/PDID  by  (several </p>
<p>times) using subfunction $01 and/or $02. </p>
<p>For </p>
<p>subfunction </p>
<p>$02 </p>
<p>(defineByMemoryAddress) </p>
<p>there </p>
<p>is </p>
<p>a </p>
<p>new </p>
<p>application </p>
<p>callback </p>
<p>function (see chapter 12.6.13 “DynamicallyDefineDataIdentifier  ($2C) (UDS) functions”). It </p>
<p>allows the application to permit or deny the extension of the DDID/PDID by accessing the </p>
<p>defined memory range. The callback function must check, if the requested memory area is </p>
<p>readable for the external Tester and if the current security state of the ECU permits the </p>
<p>extension  of  the  DDID/PDID.  See  chapter  12.6.13.2  for  the  full  set  of  checks  to  be </p>
<p>executed. </p>
<p>Please </p>
<p>note </p>
<p>that </p>
<p>later, </p>
<p>when </p>
<p>reading </p>
<p>the </p>
<p>DDID </p>
<p>by </p>
<p>using </p>
<p>service </p>
<p>$22 </p>
<p>(ReadDataByIdentifier),  further  (security)  checks  for each  element  of  the  DDID’s  list  are </p>
<p>executed  to  verify  that  e.g.  the  (then  active)  security  state  permits  the <i> reading </i> of  the </p>
<p>memory area or DID. These checks (of Service $22 and $23) are done in the traditional </p>
<p>sequence of Pre-, Main- and PostHandler. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>64 / 164 </p>
<p>The  reception  of  a  Service  $22  request  starts  a  new  context  in  CANdesc. Typically  the </p>
<p>requested data can not be asked from the application by using one single callback function </p>
<p>but  must  be  constructed  sequentially  by  collecting  data  for  each  part  of  the  DDID’s </p>
<p>definition list: </p>
<p></p>
<p> </p>
<p>A  requested  basic  source  data  identifier  (DID)  is  asked  of  the  application  by  the </p>
<p>respective callback (as for Service $22 request), the result data is stripped down to </p>
<p>the defined position and size </p>
<p></p>
<p> </p>
<p>A memory address is read by its defined function (typically the same as used for a </p>
<p>Service $23 request) and the defined ‘size’ bytes are collected. </p>
<p>As  recommended  from  /ISO 14229-1/  to  prevent  data  consistency  problems a  recursive </p>
<p>definition of DDIDs is NOT supported. </p>
<p>The Service $22 response data is collected by splitting the service request into these basic </p>
<p>tasks, then running the well known internal functions that were defined for them, collect </p>
<p>their results and build up the Service $22 response. Therefore, each of the above tasks </p>
<p>starts </p>
<p>a </p>
<p>new </p>
<p>context, </p>
<p>executes </p>
<p>the </p>
<p>defined </p>
<p>Pre-, </p>
<p>Main- </p>
<p>and </p>
<p>Post-Handler </p>
<p>where </p>
<p>Application-Callbacks get data, delivers its result and finally ends its context. </p>
<p>The recursive evaluation of DDIDs enforces the usage of MultiContext mode.  </p>
<p>We would like to point out that the described operating sequence above is completely run </p>
<p>within  CANdesc  and  totally  transparent  for  the  application  except  for  the  additional API </p>
<p>callback function. Using Service $2C or $2A switches CANdesc to MultiContext mode – if </p>
<p>your application isn’t prepared to support MultiContext mode (by using the defined macros) </p>
<p>you’ll get compiler errors about inconsistent argument lists. </p>
<p> </p>
<p><b>9.2.3 </b></p>
<p><b>Sequence Charts </b></p>
<p><b>Service $2C – Define a DDID </b></p>
<p>The  following  picture  exemplifies  the  sequence  of  defining  a  DDID  by  several  call  of </p>
<p>Service DynamicallyDefineDataIdentifier ($2C). </p>
<p>In  our  example  the  first  Service  $2C  request  defines  the  DDID  $F300  to  return  two </p>
<p>independent </p>
<p>memory </p>
<p>areas. </p>
<p>For </p>
<p>both </p>
<p>areas </p>
<p>the </p>
<p>callback </p>
<p>function </p>
<p>ApplDescCheckDynDidMemoryArea()  is  triggered  and  in  this  example  the  application </p>
<p>permits both accesses. </p>
<p>The consecutive Service $2C request extends the DDID $F300 by (some fragments of) the </p>
<p>existing DID $F010. As the here executed PreHandler does not set a Negative Response </p>
<p>Code,  CANdesc  considers  the  extension  of  the  DDID  valid  and  enlarges  the  DDID </p>
<p>definition. </p>
<p>A third Service $2C request tries to extend the DDID $F300 once more by another memory </p>
<p>area. In our example the call fails, as the specified memory area ($0000) is not valid for </p>
<p>this ECU. The service is negative responded and the previous DDID specification is left </p>
<p>untouched. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>65 / 164 </p>
<p> </p>
<p>Figure 9-9: Defining a DDID. </p>
<p> </p>
<p><b>sd Define a new DDID v ia Serv ice $2C request</b></p>
<p><b>Tester</b></p>
<p><b>CANdesc</b></p>
<p><b>Application</b></p>
<p>Define DDID $F300 as</p>
<p>4-byte memory block at </p>
<p>address $ABCD and</p>
<p>5-byte block at $FEDC</p>
<p>check for</p>
<p>Addr. $ABCD, </p>
<p>Size $04</p>
<p>check for</p>
<p>Addr. $FEDC, </p>
<p>Size $05</p>
<p>Extend the DDID $F300</p>
<p>by using</p>
<p>existing DID $F010</p>
<p>Further extention fails </p>
<p>due invalid address </p>
<p>value ($0000) in </p>
<p>request</p>
<p>check for Addr. </p>
<p>$0000 fails!</p>
<p>No Neg. RCode </p>
<p>set --&gt; success</p>
<p>$2C 02 F300 12 ABCD04 FEDC05</p>
<p>ApplDescCheckDynDidMemoryArea</p>
<p>memBlockOk</p>
<p>ApplDescCheckDynDidMemoryArea</p>
<p>memBlockOk</p>
<p>PosResponse ($6C 02)</p>
<p>$2C 01 F300 F010 ...</p>
<p>PreHandler for DID F010</p>
<p>PosResponse ($6C 01)</p>
<p>$2C 02 F300 12 000004</p>
<p>ApplDescCheckDynDidMemoryArea</p>
<p>memBlockInvAddress</p>
<p>NegResponse ($7F 2C 31)</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>66 / 164 </p>
<p><b>Service $22 – Read a DDID </b></p>
<p>The  above  defined  DDID  is  now  read  by  Service  ReadDataByIdentifier  ($22).  Within </p>
<p>CANdesc  the  DDID  is  disassembled  into  its  elements:  One  (virtual)  request  for  the  first </p>
<p>memory range, another request for the second memory range and finally a request for the </p>
<p>predefined DID $F010. </p>
<p> </p>
<p>Figure 9-10: Reading a DDID. </p>
<p>Between <i> CANdesc </i> and  the <i> application </i> the  sequence  looks  same  as  if  the  tester  would </p>
<p>have  sent  3  requests:  (1)  ReadMemoryByAddress  ($23)  on  first  address  range,  (2) </p>
<p>ReadMemoryByAddress </p>
<p>($23) </p>
<p>on </p>
<p>second </p>
<p>address </p>
<p>range, </p>
<p>and </p>
<p>finally </p>
<p>(3) </p>
<p>ReadDataByIdentifier ($22) on the DID $F010. Keep in mind: this is just a picture for the </p>
<p>succession of events/API-calls - these requests are not real, the messages are never seen </p>
<p>on the bus, the internal sequence is actually slightly different but for the application it looks </p>
<p>the same! </p>
<p><b>sd Read defined DDID v ia Serv ice $22 request</b></p>
<p><b>Tester</b></p>
<p><b>Application</b></p>
<p>Read DDID $F300 that</p>
<p>was defined as:</p>
<p>    Addr ABCD, Size 04</p>
<p> + Addr FEDC, Size 05</p>
<p> + DID F010, Pos .., Size ..</p>
<p><b>CANdesc</b></p>
<p>execute virtual </p>
<p>$23 request</p>
<p>execute virtual </p>
<p>$23 request</p>
<p>execute virtual </p>
<p>$22 request ...</p>
<p>... and cut out the</p>
<p>required bytes </p>
<p>from the result</p>
<p>concatenate </p>
<p>the results</p>
<p>$22 F300</p>
<p>$23 12 ABCD04</p>
<p>PreHandler</p>
<p>MainHandler</p>
<p>PostHandler</p>
<p>$23 12 FEDC05</p>
<p>PreHandler</p>
<p>MainHandler</p>
<p>PostHandler</p>
<p>$22 F010</p>
<p>PreHandler</p>
<p>MainHandler</p>
<p>PostHandler</p>
<p>PosResponse ($62)</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>67 / 164 </p>
<p><b>9.3 </b></p>
<p><b>Read/Write Memory by Address (SID $23/$3D) (UDS) </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>This chapter does not apply to all ECU configurations. Only in special cases the </p>
<p>memory access support will be available! </p>
<p><b> </b></p>
<p>The </p>
<p>services </p>
<p>$23 </p>
<p>(ReadMemoryByAddress) </p>
<p>and </p>
<p>$3D </p>
<p>(WriteMemoryByAddress) </p>
<p>are </p>
<p>handled uniformly in CANdesc. </p>
<p>Basically the memory by address requests look like this: </p>
<p> </p>
<p>The application need not concern itself with the details how the address and length are </p>
<p>formatted.  If  a  valid  FID  is  recognized,  CANdesc  will  extract  the  address  and  length </p>
<p>information from the request and call an appropriate application callback. </p>
<p>See also: </p>
<p> ApplDescReadMemoryByAddress (12.6.14.1) </p>
<p> ApplDescWriteMemoryByAddress (12.6.14.2) </p>
<p><b>9.3.1 </b></p>
<p><b>Tasks performed by CANdesc </b></p>
<p>To a certain degree CANdesc validates the request. </p>
<p>The basic format checks and service level state validation – this means e.g. security and </p>
<p>session validation – are performed before calling the application callback. </p>
<p>Service  level  state  validation  means  that  the  request  will  be  denied  if  all  diagnostic </p>
<p>instances of service $23 or $3D are not allowed in the current state. </p>
<p>In  case  of  WriteMemoryByAddress  the  application  has  linear  access  to  the  whole  data </p>
<p>block to write. </p>
<p><b>9.3.2 </b></p>
<p><b>Task to be performed by the Application </b></p>
<p>CANdesc currently does not provide state validation on format identifier level or memory </p>
<p>address / memory block level. </p>
<p>This means, that for example different memory addresses shall require different security </p>
<p>levels, the application will have to verify that the ECU currently is in an appropriate state to </p>
<p>access the requested memory area. </p>
<p><b>9.3.3 </b></p>
<p><b>Repeated service calls </b></p>
<p>The repeated service call feature is available for the memory access callbacks. </p>
<p>Because  they  have  a  different  prototype  than  a  normal  main  handler,  the  usual  API </p>
<p>‘DescStartRepeatedServiceCall (see 12.6.8.1)’ can not be used with the memory access </p>
<p>callbacks. </p>
<p>$23 </p>
<p>FID </p>
<p><i>length </i></p>
<p><i>address </i></p>
<p>$3D </p>
<p>FID </p>
<p><i>length </i></p>
<p><i>address </i></p>
<p><i>data </i></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>68 / 164 </p>
<p>Instead,  a  new  API  call  ‘DescStartMemByAddrRepeatedCall  (see  12.6.8.2)’  has  been </p>
<p>added. </p>
<p>To abort the repeated service call, use the usual API. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>69 / 164 </p>
<p><b>10  Generic Processing Notifications </b></p>
<p>If CANdesc UDS2012 is used, the feature “Generic Processing Notifications” is provided. </p>
<p>Upon activating this feature, CANdesc will notify the application when the processing of a </p>
<p>request starts and ends. Thereby, the notification mechanism is two-staged. On each </p>
<p>stage there are two application callbacks, one indication and one confirmation callback.  </p>
<p>On the first stage “Manufacturer Notification Support”, CANdesc will notify the application </p>
<p>right before the processing of a fully received request starts, by calling the function </p>
<p><i>ApplDescManufacturerIndication()</i>. When the processing of the request has been finished, </p>
<p>the response has been sent and all PostHandlers were called, CANdesc notifies the </p>
<p>application again by calling the function <i>ApplDescManufacturerConfirmation()</i>. </p>
<p>The application callbacks of the second stage “Supplier Notification Support” are named </p>
<p>accordingly <i>ApplDescSupplierIndication() </i>and <i>ApplDescSupplierConfirmation()</i>. The </p>
<p>indication callback is called by CANdesc after it has verified that the requested service is </p>
<p>supported in the active session, security state and user states. The confirmation callback </p>
<p>is also called after the response has been sent, and all PostHandlers were called, but right </p>
<p>before the call to <i>ApplDescManufacturerConfirmation()</i>. Thus, the manufacturer and </p>
<p>supplier callbacks are called in a nested way. Figure 3-1 illustrates the order of the </p>
<p>notification callbacks related to the processing of a service request. </p>
<p></p>
<p>t</p>
<p><b>CANdesc</b></p>
<p><b>Application</b></p>
<p><b>Request</b></p>
<p><b>negative Response</b></p>
<p><b>Tester</b></p>
<p>Check SID</p>
<p>Check Session/Security</p>
<p><b>Prehandler</b></p>
<p><b>Mainhandler</b></p>
<p><b>positive Response</b></p>
<p><b>Posthandler</b></p>
<p><b>…</b></p>
<p>Check Format</p>
<p><b>Manufacturer </b></p>
<p><b>Indication</b></p>
<p><b>Supplier </b></p>
<p><b>Indication</b></p>
<p><b>Supplier </b></p>
<p><b>Confirmation</b></p>
<p><b>Manufacturer </b></p>
<p><b>Confirmation</b></p>
<p> </p>
<p>Figure 10-1 Call order of Manufacturer- and Supplier-Notficiation </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>70 / 164 </p>
<p><b>10.1 </b></p>
<p><b>Using dynamically defined data Identifier </b></p>
<p>The  Service  DynamicallyDefineDataIdentifier  allows  the  definition  of  data  identifiers  with </p>
<p>other </p>
<p>data </p>
<p>identifiers </p>
<p>or </p>
<p>memory </p>
<p>areas. </p>
<p>These </p>
<p>DDIDs </p>
<p>can </p>
<p>be </p>
<p>read </p>
<p>via </p>
<p>service </p>
<p>ReadDataByIdentifier. When reading a DDID, for each source element a virtual request is </p>
<p>processed </p>
<p>by </p>
<p>CANdesc </p>
<p>to </p>
<p>get </p>
<p>the </p>
<p>information </p>
<p>for </p>
<p>this </p>
<p>source </p>
<p>element </p>
<p>from </p>
<p>the </p>
<p>application(see  chapter  9.2).  Because  CANdesc  processes  the  virtual  requests  equal  to </p>
<p>normal  requests,  the  notification  functions  will  not  only  be  called  for  the  $22  request </p>
<p>containing  the  DDID,  but  also  for  each  virtual  request.  The  application  has  to  consider </p>
<p>these additional calls, in case a DDID is requested.  </p>
<p>Figure 10-2 shows an example of reading a DDID with service $22. </p>
<p> </p>
<p>Figure 10-2 Read out a DDID with generic processing notifications </p>
<p><b> </b></p>
<p><b>sd Read defined DDID v ia Serv ice $22 request with Generic Processing Notifications</b></p>
<p>Tester</p>
<p>Application</p>
<p>CANdesc</p>
<p>Read DDID $F300 that</p>
<p>was defined as:</p>
<p>    Addr ABCD, Size 04</p>
<p>+ Addr FEDC, Size 05</p>
<p>+ DID F010, Pos .., Size ..</p>
<p>execute virtual </p>
<p>$23 request</p>
<p>...</p>
<p>Process further </p>
<p>virtual requests</p>
<p>...</p>
<p>Confirmation calls </p>
<p>for the request to </p>
<p>read the DDID</p>
<p>Nested confirmation </p>
<p>calls for the virtual </p>
<p>request</p>
<p>$22 F300()</p>
<p>Manufacturer Indication()</p>
<p>Supplier Indication()</p>
<p>$23 12 ABCD04()</p>
<p>Manufacturer Indication()</p>
<p>Supplier Indication()</p>
<p>PreHandler()</p>
<p>MainHandler()</p>
<p>PostHandler()</p>
<p>Supplier Confirmation()</p>
<p>Manufacturer Confirmation()</p>
<p>PosResponse ($62)</p>
<p>PostHandler()</p>
<p>Supplier Confirmation()</p>
<p>Manufacturer Confirmation()</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>71 / 164 </p>
<p><b>11  Busy Repeat Responder Support (UDS2006 and UDS2012) </b></p>
<p>Busy  Repeat  Responder  is  a  feature,  that  allowes  CANdesc  to  respond  to  incoming </p>
<p>requests  during  the  processing  of  another  request.  Such  parallel  requests  are  properly </p>
<p>received </p>
<p>and </p>
<p>in </p>
<p>the </p>
<p>next </p>
<p>task </p>
<p>cycle </p>
<p>of </p>
<p>CANdesc </p>
<p>responded </p>
<p>negatively </p>
<p>with </p>
<p>NRC </p>
<p>BusyRepeatRequest (0x21).  </p>
<p>Figure 11-1 illustrates the functionality of the Busy Repeat Responder mechanism. During </p>
<p>the processing of Request 1, Requests 2 and 3 from Tester 2 are responded negatively </p>
<p>with  NRC  BusyRepeatRequest.  After  the  processing  of  request  1  has  finished  and  a </p>
<p>positive response has been sent, Request 4 from Tester 2 can be processed properly. </p>
<p> </p>
<p>Figure 11-1 </p>
<p>Illustration of the feature BusyRepeatResponder </p>
<p>Preconditions that must be fulfilled when using the feature Busy Repeat Responder: </p>
<p><b>&gt; </b></p>
<p>The TP must be a ISO TP from Vector with TP Class “Dynamic Normal Addressing </p>
<p>Multi TP” or “Dynamic Normal Fixed Addressing Multi TP” </p>
<p><b>&gt; </b></p>
<p>In the TP configuration the feature “Extended API – Overrun Reception” must be active </p>
<p><b>&gt; </b></p>
<p>In the TP configuration the number of Rx channels and Tx Channels must be &gt; 1 </p>
<p><b>&gt; </b></p>
<p>In case of Dynamic Normal Addressing Multi TP, a dispatcher needs to be </p>
<p>implemented in the application (for a detailed description see chapter <i>13.12</i>) </p>
<p><b> sd BusyRepeatResponder</b></p>
<p>Tester 1</p>
<p>Tester 2</p>
<p>CANdesc</p>
<p>CANdesc has received a </p>
<p>request from Tester 1 and </p>
<p>starts the processing</p>
<p>Parallel requests from </p>
<p>another tester are responded </p>
<p>negatively with NRC </p>
<p>BusyRepeatRequest</p>
<p>After CANdesc has finished </p>
<p>the processing of the request </p>
<p>from Tester 1, Requests from </p>
<p>Tester 2 can be processed </p>
<p>again.</p>
<p>Request 1()</p>
<p>Request 2()</p>
<p>Neg Response Busy()</p>
<p>Request 3()</p>
<p>Neg Response Busy()</p>
<p>Pos Response for Request 1()</p>
<p>Request 4()</p>
<p>Pos Response for Request 4()</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>72 / 164 </p>
<p>Restrictions when using the feature Busy Repeat Responder: </p>
<p><b>&gt; </b></p>
<p>Only physical parallel requests are responded negatively. Functional parallel requests </p>
<p>will NOT get a negative response. </p>
<p><b>11.1 </b></p>
<p><b>Configuration in GENy </b></p>
<p>To </p>
<p>activate </p>
<p>the </p>
<p>feature </p>
<p>Busy </p>
<p>Repeat </p>
<p>Responder </p>
<p>use </p>
<p>the </p>
<p>setting </p>
<p>in </p>
<p>the </p>
<p>CANdesc </p>
<p>component root (refer to chapter <i>6.2.1 Global CANdesc Settings). </i></p>
<p>Furthermore,  the  feature  requires  additional  configuration  in  the  TP  component.  The </p>
<p>feature “Extended API – Overrun Reception” must be enabled. This setting is available in </p>
<p>the  group  “Advanced Configuration”. To be able  to  receive  another request  while  one  is </p>
<p>under processing, the “Number of Rx Channels” and “Number of Tx Channels” must be at </p>
<p>least two. The number of channels can be configured in the TP Connection Groups: </p>
<p> </p>
<p>Figure 11-2 Example of the “Number of Rx(Tx) Channels” settings </p>
<p>In case of “Dynamic Normal Addressing Multi TP” a dispatcher needs to be implemented in </p>
<p>the  application. The  description  of  the  GENy  configuration  to  integrate  the  dispatcher  is </p>
<p>described  in  chapter <i> 13.12  …use  “Dynamic  Normal  Addressing  Multi  TP”  with </i> multiple </p>
<p>tester<i>. </i></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>73 / 164 </p>
<p><b>12  CANdesc API </b></p>
<p><b>12.1 </b></p>
<p><b>API Categories </b></p>
<p><b>12.1.1 </b></p>
<p><b>Single Context </b></p>
<p>This API category is used if no parallel processing is necessary. This is typical for the ISO </p>
<p>14229 specification. </p>
<p><b>12.1.2 </b></p>
<p><b>Multiple Context (only CANdesc) </b></p>
<p>This  API  category  is  used  if  parallel  processing  is  necessary.  This  means  not  that </p>
<p>CANdesc  can  work  with  multiple  instances,  but  only  one  functional  request  can  be </p>
<p>processed parallel to a working physical request. </p>
<p><b>12.2 </b></p>
<p><b>Data Types </b></p>
<p>The following standard data types are used in this document: </p>
<p><i><b>vuint8 </b></i></p>
<p>Represents 8 bit unsigned integer value. </p>
<p><i><b>vsint8 </b></i></p>
<p>Represents 8 bit signed integer value. </p>
<p><i><b>vuint16 </b></i></p>
<p>Represents 16 bit unsigned integer value. </p>
<p><i><b>vsint16 </b></i></p>
<p>Represents 16 bit signed integer value. </p>
<p><i><b>vuint32 </b></i></p>
<p>Represents 32 bit unsigned integer value. </p>
<p><i><b>vsint32 </b></i></p>
<p>Represents 32 bit signed integer value. </p>
<p>Table 12-1: standard data types </p>
<p> </p>
<p>Additional data types used in this document are described in the corresponding function </p>
<p>description. </p>
<p><b>12.3 </b></p>
<p><b>Global Variables </b></p>
<p>- </p>
<p><b>12.4 </b></p>
<p><b>Constants </b></p>
<p><b>12.4.1 </b></p>
<p><b>Component Version </b></p>
<p>The  version  of  the  CANdesc  component  consist  of  3  parts  in  the  following  format: </p>
<p><b>MM.SS.BB</b>, </p>
<p>Where: </p>
<p></p>
<p> </p>
<p><b>MM </b>is the main version of the component, </p>
<p></p>
<p> </p>
<p><b>SS </b>is the subversion of the component, </p>
<p></p>
<p> </p>
<p><b>BB </b>is the bug-fix version of the component. </p>
<p>To get the current CANdesc version, the application could use the following shared data: </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>74 / 164 </p>
<p><b>Name </b></p>
<p><b>Type </b></p>
<p><b>Description </b></p>
<p>g_descMainVersion </p>
<p>BCD </p>
<p>Contains the main version part. </p>
<p>g_descSubVersion </p>
<p>BCD </p>
<p>Contains the subversion part. </p>
<p>g_descBugFixVersion </p>
<p>BCD </p>
<p>Contains the bug-fix version part. </p>
<p>Table 12-2: Version API data </p>
<p>Note: The version of the module is the same as the version of the generator’s DLL file. </p>
<p><b>12.5 </b></p>
<p><b>Macros </b></p>
<p><b>12.5.1 </b></p>
<p><b>Data exchange </b></p>
<p>The CANdesc provides a generic API for splitting a multi-byte (up to 4 bytes) variable to a </p>
<p>byte sequence with platform transparent access to each byte, and assembling a multi-byte </p>
<p>(up to 4 bytes) variable from a sequence of bytes. </p>
<p><b>12.5.1.1 </b></p>
<p><b>Splitting 16 bit data </b></p>
<p>The </p>
<p>following </p>
<p>function </p>
<p>could </p>
<p>be </p>
<p>used </p>
<p>to </p>
<p>get </p>
<p>platform </p>
<p>independent </p>
<p>access </p>
<p>to </p>
<p>the </p>
<p>corresponding bytes of 16 bit data variable: </p>
<p><b>vuint8 DescGetHiByte(16BitData) </b></p>
<p><b> </b></p>
<p><b>vuint8 DescGetLoByte(16BitData) </b></p>
<p><b> </b></p>
<p><b>12.5.1.2 </b></p>
<p><b>Splitting 32 bit data </b></p>
<p>The </p>
<p>following </p>
<p>function </p>
<p>could </p>
<p>be </p>
<p>used </p>
<p>to </p>
<p>get </p>
<p>platform </p>
<p>independent </p>
<p>access </p>
<p>to </p>
<p>the </p>
<p>corresponding  bytes of 32 bit data variable: </p>
<p><b>vuint8 DescGetHiHiByte(32BitData) </b></p>
<p><b> </b></p>
<p><b>vuint8 DescGetHiLoByte(32BitData) </b></p>
<p><b> </b></p>
<p><b>vuint8 DescGetLoHiByte(32BitData) </b></p>
<p><b> </b></p>
<p><b>vuint8 DescGetLoLoByte(32BitData) </b></p>
<p><b> </b></p>
<p><b>12.5.1.3 </b></p>
<p><b>Assembling 16 bit data </b></p>
<p>The application can create the 16 bit signal from a byte stream using the following API: </p>
<p><b>uint16  DescMake16Bit(hiByte, loByte) </b></p>
<p>where the <b>hiByte, loByte </b>are the corresponding bytes for the returned 16 bit data. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>75 / 164 </p>
<p><b>12.5.1.4 </b></p>
<p><b>Assembling 32 bit data </b></p>
<p>The application can create the 32 bit signal from a byte stream using the following API: </p>
<p><b>uint32 DescMake32Bit(HiHiByte, HiLoByte, LoHiByte, LoLoByte) </b></p>
<p>where the <b>HiHiByte, HiLoByte, LoHiByte, LoLoByte </b>are the corresponding bytes for the </p>
<p>returned 32 bit dat </p>
<p><b>12.6 </b></p>
<p><b>Functions </b></p>
<p><b>12.6.1 </b></p>
<p><b>Administrative Functions </b></p>
<p><b>12.6.1.1 </b></p>
<p><b>DescInitPowerOn() </b></p>
<p><b>DescInitPowerOn </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescInitPowerOn </b>(DescInitParam initParameter) </p>
<p>Multi Context </p>
<p>void <b>DescInitPowerOn </b>(DescInitParam initParameter) </p>
<p><b>Parameter </b></p>
<p>initParameter </p>
<p>Manufacturer specific type, please refer ‘CANdesc: OEM </p>
<p>specifics’ document  </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>PowerOn Initialization of the CANdesc.  </p>
<p>This function has to be called once before all other functions of CANdesc after PowerOn. </p>
<p><b>Pre-conditions </b></p>
<p>Correctly initialized CAN-driver via <b>CanInitPowerOn() </b>and TransportLayer via </p>
<p><b>TpInitPowerOn()</b>. </p>
<p><b>Call context </b></p>
<p>Background-loop level with global disabled interrupts </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p><b>DescInitPowerOn (initParameter) </b>must be called after <b>TpInitPowerOn() </b>was called </p>
<p>(please, refer the /TPMC/ documentation), otherwise the reserved diagnostic </p>
<p>connection will be los </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>76 / 164 </p>
<p><b>12.6.1.2 </b></p>
<p><b>DescInit() </b></p>
<p><b>DescInit </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescInit </b>(DescInitParam initParameter) </p>
<p>Multi Context </p>
<p>void <b>DescInit </b>(DescInitParam initParameter) </p>
<p><b>Parameter </b></p>
<p>initParameter </p>
<p>Manufacturer specific type, please refer ‘CANdesc Part IV: </p>
<p>OEM specifics’ document  </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Re-initialization of CANdesc.  </p>
<p>This function can be called to re-initialize CANdesc (e.g. after WakeUp). All internal states </p>
<p>will be set to default, except the states in this initParameter (e.g. Session or </p>
<p>CommunicationControl). </p>
<p><b>Pre-conditions </b></p>
<p>CANdesc was once initialized via <b>DescInitPowerOn () </b></p>
<p><b>Call context </b></p>
<p>Background-loop level with global disabled </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>77 / 164 </p>
<p><b>12.6.1.3 </b></p>
<p><b>DescTask() </b></p>
<p><b>DescTask </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescTask </b>(void) </p>
<p>Multi Context </p>
<p>void <b>DescTask </b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>-  </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The function <i><b>DescTask() </b></i>has to be called periodically (cycle time T</p>
<p>Desc</p>
<p>CallCycle</p>
<p>) by the </p>
<p>application. </p>
<p>Within the context of this function the interaction with the application is performed. In </p>
<p>addition the monitoring of the timings is done, therefore the accuracy of the timings </p>
<p>depends on the call cycle and on the accuracy of the calls. </p>
<p><b>Pre-conditions </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Background-loop level or OSEK-OS Task. The task should have a lower or equal priority </p>
<p>than all other interaction to the CANdesc component. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>May not be called if the <i><b>DescStateTask() </b></i>and <i><b>DescTimerTask() </b></i>are called. </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>78 / 164 </p>
<p><b>12.6.1.4 </b></p>
<p><b>DescStateTask() </b></p>
<p><b>DescStateTask </b></p>
<p><b>Available since 4.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescStateTask </b>(void) </p>
<p>Multi Context </p>
<p>void <b>DescStateTask </b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>-  </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Motivation: Using a single task function for timers and processing leads either to slow </p>
<p>processing or to faster timers which costs runtime for the ECU. The timers need very </p>
<p>stable cyclical call but the processing tasks may be done “as soon as possible” (i.e. using </p>
<p>OSEK to be assigned to lower priority task). </p>
<p>The function <i><b>DescStateTask() </b></i>has to be called periodically by the application. It is not a </p>
<p>timer task – it has no specific time period. As smaller this tasks call period is, so faster will </p>
<p>be the service processing.  </p>
<p>This task function will process received request and to control the transmission of the </p>
<p>responses. Depending on the ECU requirements it is recommended to call this task as </p>
<p>soon as possible to avoid delays of the response (e.g. dynamically defined DID, </p>
<p>scheduled data, etc.), but <b>take into account that within this task the corresponding </b></p>
<p><b>MainHandler will be executed too. </b></p>
<p><b>Pre-conditions </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Background-loop level or OSEK-OS Task. The Task should have a lower or equal priority </p>
<p>than all other interaction to the CANdesc component. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>May not be called if the <i><b>DescTask() </b></i>is used (reentrancy is forbidden). </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>79 / 164 </p>
<p><b>12.6.1.5 </b></p>
<p><b>DescTimerTask() </b></p>
<p><b>DescTimerTask </b></p>
<p><b>Available since 4.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescTimerTask </b>(void) </p>
<p>Multi Context </p>
<p>void <b>DescTimerTask </b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>-  </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Motivation: Using a single task function for timers and processing leads either to slow </p>
<p>processing or to faster timers which costs runtime for the ECU. The timers need very </p>
<p>stable cyclical call but the processing tasks may be done “as soon as possible” (i.e. using </p>
<p>OSEK to be assigned to lower priority task). </p>
<p>The function <i><b>DescTimerTask() </b></i>has to be called periodically by the application in the </p>
<p>configured task period. It can be called as slow as possible to free run time resources. </p>
<p> </p>
<p><b>Pre-conditions </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Background-loop level or OSEK-OS Task. The Task should have a lower or equal priority </p>
<p>than all other interaction to the CANdesc component. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>May not be called if the <i><b>DescTask() </b></i>is used. This will lead to either reentrancy </p>
<p>(consistency) problems or/and to timing issues. </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>80 / 164 </p>
<p><b>12.6.1.6 </b></p>
<p><b>DescGetActivityState() </b></p>
<p><b>DescGetActivityState </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>DescContextActivity DescGetActivityState (void) </p>
<p>Multi Context </p>
<p>DescContextActivity DescGetActivityState (vuint8 iContext) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>reference to the corresponding request context </p>
<p><b>Return code </b></p>
<p>1. kDescContextIdle </p>
<p>2. kDescContextActiveRxBegin </p>
<p>3. kDescContextActiveRxEnd </p>
<p>4. kDescContextActiveProcess </p>
<p>5. kDescContextActiveProcessEnd </p>
<p>6. kDescContextActiveTxReady </p>
<p>7. kDescContextActiveTx </p>
<p>8. kDescContextActivePostProcess </p>
<p> </p>
<p>1. </p>
<p>There is currently no request processing (even </p>
<p>when scheduler is active). </p>
<p>2. </p>
<p>Currently request reception is active. </p>
<p>3. </p>
<p>Reception finished, request will be processed. </p>
<p>4. </p>
<p>The request was received, is under processing </p>
<p>now </p>
<p>5. </p>
<p>DescProcessingDone called waiting for data </p>
<p>before starting the transmission. </p>
<p>6. </p>
<p>Ready for response transmission. </p>
<p>7. </p>
<p>Transmission of the response is currently active. </p>
<p>8. </p>
<p>Transmission/processing ended. Post-processing  </p>
<p>will be performed. </p>
<p><b>Functional Description </b></p>
<p>Motivation: Sometimes the knowledge about the presence of a tester is necessary. A typical </p>
<p>use-case is to avoid the ECU from going into sleep mode.  </p>
<p>A non-default session indicates that a tester is present. But how can this be done, if the ECU is </p>
<p>in the default session? </p>
<p>Due to that fact  the ECU application can call the function <i><b>DescGetActivityState() </b></i>any time to </p>
<p>check if CANdesc has something to do or is in idle mode. This can be used e.g. to change the </p>
<p>state of the ECU sleep mode.  </p>
<p><b>Note: </b>The return value is bit coded and  any senseful combination of the above mentioned </p>
<p>values is possible (e.g. <i><b>kDescContextActiveRxBegin </b></i>| <i><b>kDescContextActivePostProcess</b></i>). </p>
<p>Please check always with bit test (and operation) and not using the value comparison.   </p>
<p><b>Pre-conditions </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>81 / 164 </p>
<p><b>12.6.2 </b></p>
<p><b>Multi Variant Configuration Functions </b></p>
<p><b>12.6.2.1 </b></p>
<p><b>DescInitConfigVariant() </b></p>
<p><b>DescInitConfigVariant </b></p>
<p><b>Available since 6.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context and Multi Context </p>
<p>void <b>DescInitConfigVariant </b>(DescVariantMask varMask) </p>
<p><b>Parameter </b></p>
<p>varMask </p>
<p>Contains the VSG(s) that shall be active additionally to the base </p>
<p>variant </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>After CANdesc has been initialized via one of the APIs  </p>
<p>DescInitPowerOn  </p>
<p>or  </p>
<p>DescInit; </p>
<p>the base variant will be only active (refer to the chapter <i>8 Multi Identity  </i>for more details). If </p>
<p>additionally other variants shall be activated, this API shall be called with a parameter </p>
<p>value that represents the variants (multiple variants can be OR-ed) that shall be activated. </p>
<p> </p>
<p>The variant values that shall be used for building the API parameter value are located in </p>
<p>the desc.h file. The naming convention is as follows: </p>
<p><b>kDescVariant&lt;variant/VSG qualifier&gt; </b></p>
<p> </p>
<p><b>Pre-conditions </b></p>
<p>-Multi- variant (VSG) mode is activated for CANdesc. </p>
<p><b>Call context </b></p>
<p>-  </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>Shall not interrupt the DescTask function. </p>
<p></p>
<p> </p>
<p>Best place to call this API is immediately after the CANdesc initialization API-call while </p>
<p>the interrupts are still locked. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>82 / 164 </p>
<p><b>12.6.2.2 </b></p>
<p><b>DescGetConfigVariant() </b></p>
<p><b>DescGetConfigVariant </b></p>
<p><b>Available since 6.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context and Multi Context </p>
<p>DescVariantMask <b>DescGetConfigVariant </b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p> </p>
<p><b>Return code </b></p>
<p>Variant mask </p>
<p>Represents the bit-mapped value of the currently active variants </p>
<p>in the ECU. </p>
<p><b>Functional Description </b></p>
<p>This API returns the bit-mapped value of the currently active variants set in CANdesc.  </p>
<p> </p>
<p>The variant values that shall be used for checking the API return value are located in the </p>
<p>desc.h file. The naming convention is as follows: </p>
<p><b>kDescVariant&lt;variant/VSG qualifier&gt; </b></p>
<p> </p>
<p><b>Pre-conditions </b></p>
<p>-Multi- variant (VSG) mode is activated for CANdesc. </p>
<p><b>Call context </b></p>
<p>- This API can be called from any call-context.  </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>- </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>83 / 164 </p>
<p><b>12.6.3 </b></p>
<p><b>Service Functions </b></p>
<p><b>12.6.3.1 </b></p>
<p><b>DescSetNegResponse() </b></p>
<p><b>DescSetNegResponse </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescSetNegResponse </b>(DescNegResCode errorCode) </p>
<p>Multi Context </p>
<p>void <b>DescSetNegResponse </b>(vuint8 iContext, DescNegResCode errorCode) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>reference to the corresponding request context </p>
<p>errorCode </p>
<p>the <b>errorCode </b>is the one of the provided error code constants </p>
<p>of CANdesc in the desc.h file with the following naming </p>
<p>convention: </p>
<p><b>kDescNrc&lt;error name&gt;</b>. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>In the PreHandler or in the MainHandler function the application has the possibility of </p>
<p>forcing negative response with a certain negative response code for the current request </p>
<p>when it is necessary. </p>
<p><b>Pre-conditions </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Within a ‘Service PreHandler’ function and within or after a ‘Service MainHandler’ function </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>Once an error was set it can not be overwritten or reset.  </p>
<p></p>
<p> </p>
<p>This function does not finish the processing of the request. It just sets a certain error </p>
<p>and after that the application must confirm that the request processing was completely </p>
<p>finished by calling DescProcessingDone(). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>84 / 164 </p>
<p><b>12.6.3.2 </b></p>
<p><b>DescProcessingDone() </b></p>
<p><b>DescProcessingDone </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescProcessingDone </b>(void) </p>
<p>Multi Context </p>
<p>void <b>DescProcessingDone </b>(vuint8 iContext) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>reference to the corresponding request context </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>After completing the request execution the application must call the API function. </p>
<p>By calling this function, depending on the previous actions of the application the CANdesc </p>
<p>module will either send a response (positive/negative depending on the error state </p>
<p>machine) or no response will be send if the application/CANdesc decides that there must </p>
<p>be no response (please refer the Part III User Manual) </p>
<p><b>Pre-conditions </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>Within or after a ‘Service MainHandler’ function </p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p><b>12.6.4 </b></p>
<p><b>Service callback functions </b></p>
<p>In CANdesc 6 the naming convention of the service callback function has changed due to </p>
<p>standardization reasons. In Table 12-3, the new naming convention can be found. Earlier </p>
<p>versions of CANdesc (&lt; 6.0) used always Service-Qualifiers and Instance-Qualifiers from </p>
<p>the  CDD  file.  Since  CANdesc  6,  for  Service-Qualifiers  always  standardized  names  are </p>
<p>used,  whereas for Instance-Qualifiers either  a  standardized name  or the  name from  the </p>
<p>CDD file is used. The names of the service callback functions are based on the following </p>
<p>pattern: </p>
<p>ApplDesc[Pre|Post]&lt;ServiceQualifier&gt;&lt;DiagInstanceQualifier&gt; </p>
<p>When migrating to CANdesc 6 the service callbacks have to be renamed according to the </p>
<p>new naming convention. </p>
<p><b>Service </b></p>
<p><b>SubService </b></p>
<p><b>Instance-Qualifier </b></p>
<p><b>Service-Qualifier </b></p>
<p>0x10 </p>
<p>0x01 </p>
<p>Default </p>
<p>StartSession </p>
<p>0x02 </p>
<p>Programming </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>85 / 164 </p>
<p><b>Service </b></p>
<p><b>SubService </b></p>
<p><b>Instance-Qualifier </b></p>
<p><b>Service-Qualifier </b></p>
<p>0x03 </p>
<p>Extended </p>
<p>0x11 </p>
<p>0x01 </p>
<p>Hard </p>
<p>EcuReset </p>
<p>0x02 </p>
<p>KeyOffOn </p>
<p>0x03 </p>
<p>Soft </p>
<p>0x04 </p>
<p>EnableRapidShutDown </p>
<p>0x05 </p>
<p>DisableRapidShutDown </p>
<p>0x14 </p>
<p>None </p>
<p>DiagInfo </p>
<p>Clear </p>
<p>0x19 </p>
<p>0x01 </p>
<p>RNODTCBSM </p>
<p>ReadDtc </p>
<p>0x02 </p>
<p>RDTCBSM </p>
<p>0x03 </p>
<p>RDTCSSI </p>
<p>0x04 </p>
<p>RDTCSSBDTC </p>
<p>0x05 </p>
<p>RDTCSSBRN </p>
<p>0x06 </p>
<p>RDTCEDRBDN </p>
<p>0x07 </p>
<p>RNODTCBSMR </p>
<p>0x08 </p>
<p>RDTCBSMR </p>
<p>0x09 </p>
<p>RSIODTC </p>
<p>0x0A </p>
<p>RSUPDTC </p>
<p>0x0B </p>
<p>RFTFDTC </p>
<p>0x0C </p>
<p>RFCDTC </p>
<p>0x0D </p>
<p>RMRTFDTC </p>
<p>0x0E </p>
<p>RMRCDTC </p>
<p>0x0F </p>
<p>RMMDTCBSM </p>
<p>0x10 </p>
<p>RMDEDRBDN </p>
<p>0x11 </p>
<p>RNOMMDTCBSM </p>
<p>0x12 </p>
<p>RNOOBDDTCBSM </p>
<p>0x13 </p>
<p>ROBDDTCBSM </p>
<p>0x14 </p>
<p>RDTCFDC </p>
<p>0x15 </p>
<p>RDTCWPS </p>
<p>0x16 </p>
<p>RDTCRDIDBDN </p>
<p>0x41 </p>
<p>RWWHOBDNDTCBMR </p>
<p>0x42 </p>
<p>RWWHOBDDTCBMR </p>
<p>0x55 </p>
<p>RWWHOBDDTCWPS </p>
<p>0x22 </p>
<p>Any </p>
<p>Instance-Qualifier from CDD </p>
<p>ReadDid </p>
<p>0x23 </p>
<p>None </p>
<p>MemoryByAddress </p>
<p>Read </p>
<p>0x24 </p>
<p>Any </p>
<p>Instance-Qualifier from CDD </p>
<p>ReadScalingDid </p>
<p>0x27 </p>
<p>Odd Id </p>
<p>Instance-Qualifier from CDD </p>
<p>GetSeed </p>
<p>Even Id </p>
<p>SendKey </p>
<p>0x28 </p>
<p>0x00 </p>
<p>EnableRxEnableTx </p>
<p>CommCtrl </p>
<p>0x01 </p>
<p>EnableRxDisableTx </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>86 / 164 </p>
<p><b>Service </b></p>
<p><b>SubService </b></p>
<p><b>Instance-Qualifier </b></p>
<p><b>Service-Qualifier </b></p>
<p>0x02 </p>
<p>DisableRxEnableTx </p>
<p>0x03 </p>
<p>DisableRxDisableTx </p>
<p>0x2A </p>
<p>0x01 </p>
<p>Instance-Qualifier from CDD </p>
<p>ReadDidSlow </p>
<p>0x02 </p>
<p>ReadDidMed </p>
<p>0x03 </p>
<p>ReadDidFast </p>
<p>0x04 </p>
<p>ReadDidStop </p>
<p>0x2C </p>
<p>0x01 </p>
<p>Instance-Qualifier from CDD </p>
<p>DynDefineByDid </p>
<p>0x02 </p>
<p>DynDefineByAddr </p>
<p>0x03 </p>
<p>DynDefineClear </p>
<p>0x2E </p>
<p>Any </p>
<p>Instance-Qualifier from CDD </p>
<p>WriteDid </p>
<p>0x2F </p>
<p>0x00 </p>
<p>Instance-Qualifier from CDD </p>
<p>IoCtrlRetCtrlToEcu </p>
<p>0x01 </p>
<p>IoCtrlRstToDefault </p>
<p>0x02 </p>
<p>IoCtrlFrzCurrState </p>
<p>0x03 </p>
<p>IoCtrlShortTermAdj </p>
<p>0x31 </p>
<p>0x01 </p>
<p>Instance-Qualifier from CDD </p>
<p>RtnCtrlStart </p>
<p>0x02 </p>
<p>RtnCtrlStop </p>
<p>0x03 </p>
<p>RtnCtrlReqRes </p>
<p>0x34 </p>
<p>None </p>
<p>  </p>
<p>RequestDownload </p>
<p>0x35 </p>
<p>None </p>
<p>  </p>
<p>RequestUpload </p>
<p>0x36 </p>
<p>None </p>
<p>  </p>
<p>TransferData </p>
<p>0x37 </p>
<p>None </p>
<p>  </p>
<p>RequestTransferExit </p>
<p>0x3D </p>
<p>None </p>
<p>MemoryByAddress </p>
<p>Write </p>
<p>0x3E </p>
<p>0x00 </p>
<p>TesterPresent </p>
<p>Send </p>
<p>0x84 </p>
<p>None </p>
<p>  </p>
<p>SecuredDataTransmission </p>
<p>0x85 </p>
<p>0x01 </p>
<p>Enable </p>
<p>ControlDtcSetting </p>
<p>0x02 </p>
<p>Disable </p>
<p>0x86 </p>
<p>0x00 </p>
<p>Stop </p>
<p>Roe </p>
<p>0x01 </p>
<p>OnDtcStatChg </p>
<p>0x02 </p>
<p>OnTmrInt </p>
<p>0x03 </p>
<p>OnChgOfDid </p>
<p>0x04 </p>
<p>ReportActEv </p>
<p>0x05 </p>
<p>Start </p>
<p>0x06 </p>
<p>Clear </p>
<p>0x07 </p>
<p>OnCompOfVal </p>
<p>0x40 </p>
<p>StStop </p>
<p>0x41 </p>
<p>StOnDtcStatChg </p>
<p>0x42 </p>
<p>StOnTmrInt </p>
<p>0x43 </p>
<p>StOnChgOfDid </p>
<p>0x44 </p>
<p>StReportActEv </p>
<p>0x45 </p>
<p>StStart </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>87 / 164 </p>
<p><b>Service </b></p>
<p><b>SubService </b></p>
<p><b>Instance-Qualifier </b></p>
<p><b>Service-Qualifier </b></p>
<p>0x46 </p>
<p>StClear </p>
<p>0x47 </p>
<p>StOnCompOfVal </p>
<p>0x87 </p>
<p>0x01 </p>
<p>VerifyFixedBaudrate </p>
<p>LinkControl </p>
<p>0x02 </p>
<p>VerifySpecificBaudrate </p>
<p>0x03 </p>
<p>TransitionBaudrate </p>
<p>Table 12-3 Naming convention of service callback functions in CANdesc 6 </p>
<p><b>12.6.4.1 </b></p>
<p><b>Service PreHandler </b></p>
<p><b>ApplDescPre&lt;Service-Qualifier + Instance-Qualifier&gt;&gt; </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescPre&lt;Service-Qualifier + Instance-Qualifier&gt; </b>(void) </p>
<p>Multi Context </p>
<p>void <b>ApplDescPre&lt;Service-Qualifier + Instance-Qualifier&gt;  </b>(vuint8 iContext) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>the current request context location </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The PreHandler is executed before the Service MainHandler is called. In the PreHandler, </p>
<p>the application can hook any (especially application-specific) state validations. One </p>
<p>PreHandler implementation may be shared with different service instances (only </p>
<p>CANdesc).  </p>
<p>To allow quite complex operations to take place, the application has access to the request </p>
<p>data using the context data structure (if given).  </p>
<p><b>Pre-conditions </b></p>
<p>Must be configured to ‘User’ in attribute ‘PreHandlerSupport’’ </p>
<p><b>Call context </b></p>
<p>From <b>DescTask() </b></p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>88 / 164 </p>
<p><b>12.6.4.2 </b></p>
<p><b>Service MainHandler </b></p>
<p><b>ApplDesc&lt;Service-Qualifier + Instance-Qualifier&gt; </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDesc&lt;Service-Qualifier + Instance-Qualifier&gt; </b>(DescMsgContext* pMsgContext) </p>
<p>Multi Context </p>
<p>void <b>ApplDesc&lt;Service-Qualifier + Instance-Qualifier&gt; </b>(DescMsgContext* pMsgContext) </p>
<p><b>Parameter </b></p>
<p>pMsgContext </p>
<p>typedef struct  </p>
<p>{ </p>
<p>  DescMsg          reqData; </p>
<p>  DescMsgLen       reqDataLen;  </p>
<p>  DescMsg          resData; </p>
<p>  DescMsgLen       resDataLen;  </p>
<p>  DescMsgAddInfo   msgAddInfo; </p>
<p>  vuint8           iContext; </p>
<p>  t_descUsdtNetBus busInfo;  </p>
<p>} DescMsgContext; </p>
<p>DescMsgAddInfo </p>
<p>  DescBitType reqType   :2; /* 0x01: Phys 0x02: Func */  </p>
<p>  DescBitType resOnReq  :2; /* 0x01: Phys 0x02: Func */  </p>
<p>  DescBitType suppPosRes:1; /* 0x00: No   0x01: Yes  */ </p>
<p>Read access </p>
<p><b>pMsgContext-&gt;reqData   </b></p>
<p>pointer to the first byte of the already extracted request data. </p>
<p><b>pMsgContext-&gt;reqDataLen  </b></p>
<p>length of the extracted request data. </p>
<p><b>pMsgContext-&gt;iContext  </b></p>
<p>the current request context location </p>
<p>(used only as a handle - <i>DO NOT MODIFY</i>). </p>
<p><b>pMsgContext-&gt;msgAddInfo.reqType  </b></p>
<p>the current request addressing method. Could be either </p>
<p>‚kDescFuncReq’ or ‚kDescPhysReq’ (bitmapped). </p>
<p><b>pMsgContext-&gt;msgAddInfo.suppPosRes  </b></p>
<p>if set, no positive response will be sent. (UDS only). </p>
<p><b>pMsgContext-&gt;busInfo </b></p>
<p>the current request communication information (i.e. driver type (CAN, </p>
<p>MOST, FlexRay, etc.), addressing information, communication channel </p>
<p>number, tester address (if applicable) etc. </p>
<p>Write access </p>
<p><b>pMsgContext-&gt;resData  </b></p>
<p>pointer to the first position where the response data can be written. </p>
<p><b>pMsgContext-&gt;resDataLen  </b></p>
<p>length of the written data. </p>
<p><b>pMsgContext-&gt;msgAddInfo.resOnReq  </b></p>
<p>can be used to disable the response transmission on the current </p>
<p>request. If set to ‘0’ no response will be transmitted. Physical and </p>
<p>function can be set separately (bitmapped).  </p>
<p><b>Return  code </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>89 / 164 </p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The MainHandler processes the service request. </p>
<p></p>
<p> </p>
<p>Perform length validation for varying length information of request. </p>
<p></p>
<p> </p>
<p>Disassemble any data received with the request telegram and process it,. </p>
<p></p>
<p> </p>
<p>Assemble any data to be send with the response and update current response </p>
<p>length. </p>
<p></p>
<p> </p>
<p>Confirm that the processing is finished. </p>
<p><b>Pre-conditions </b></p>
<p>Must be configured to ‘User’ in attribute ‘MainHandlerSupport’ </p>
<p><b>Call context </b></p>
<p>From <b>DescTask() </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>If used as MainHandler for Protocol Services, the Protocol-Service-Qualifier is used </p>
<p>instead </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>90 / 164 </p>
<p><b>12.6.4.3 </b></p>
<p><b>Service PostHandler </b></p>
<p><b>ApplDescPost&lt;Service-Qualifier + Instance-Qualifier&gt; </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescPost&lt;Service-Qualifier + Instance-Qualifier&gt; </b>(vuint8 status) </p>
<p>Multi Context </p>
<p>void <b>ApplDescPost&lt;Service-Qualifier + Instance-Qualifier&gt; </b>(vuint8 iContext, </p>
<p>vuint8 status) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>the current request context location </p>
<p>status (bit-coded) </p>
<p><b>kDescPostHandlerStateOk  </b></p>
<p>The positive response was transmitted successfully </p>
<p><b>kDescPostHandlerStateNegResSent  </b></p>
<p>It was a negative response </p>
<p><b>kDescPostHandlerStateTxFailed   </b></p>
<p>A transmission error occurred </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Any state transition may not be performed before the current service is finished </p>
<p>completely (the last frame of the response is sent successfully).  </p>
<p>The PostHandler is executed after a confirmation of the message transmission is received </p>
<p>and is designated for state adaptation – all other things are already done when the </p>
<p>PostHandler is called. </p>
<p><b>Pre-conditions </b></p>
<p>Must be configured to ‘User’ in attribute ‘PostHandlerSupport’ </p>
<p><b>Call context </b></p>
<p>From <b>DescTask() </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>If used as PostHandler for Protocol Services, the Protocol-Service-Qualifier is used </p>
<p>instead </p>
<p></p>
<p> </p>
<p>You can override the given name extension (Service-Qualifier + Instance-Qualifier) by </p>
<p>using the ‘PostHandlerOverrideName’. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>91 / 164 </p>
<p><b>12.6.5 </b></p>
<p><b>User (Unknown) Service Handling </b></p>
<p>In some cases the ECU shall support a service which is not described in the common way </p>
<p>for CANdesc (by means of CANdelaStudio/GENtool). With a little bit more effort inside the </p>
<p>application  than  for  the  “known”  services  the  ECU  is  still  be  able  to  support  those  user </p>
<p>defined services. The effort comes form the fact that CANdesc knows nothing about this </p>
<p>service (e.g. session, security or other states described in the CDD configuring CANdesc, </p>
<p>addressing methods allowed for those services, etc.) and therefore the application must do </p>
<p>this  work  for  each  user  defined  service  by  itself.  In  fact  for  CANdesc  there  is  only  one </p>
<p>“unknown” service and it is up to the application to differentiate between multiple unknown </p>
<p>service(s).  </p>
<p>Attention: This feature is available since version 2.11.00 of CANdesc(Basic). </p>
<p><b>12.6.5.1 </b></p>
<p><b>How it works </b></p>
<p>If  the feature  “Support  Generic  User  Service”  is enabled  in  the  GENtool  CANdesc  uses </p>
<p>following handling: </p>
<p>-</p>
<p> </p>
<p>if  a  service  was  not  recognized  by  its  SID,  before  the  automatic  negative </p>
<p>response </p>
<p>transmission </p>
<p>will </p>
<p>be </p>
<p>sent, </p>
<p>the </p>
<p>application </p>
<p>will </p>
<p>be </p>
<p>called </p>
<p>(see </p>
<p>12.6.5.2  ApplDescCheckUserService)  to  check  this  SID  too.  If  it  can  not </p>
<p>recognize it as a valid one the usual negative response will be sent. </p>
<p>-</p>
<p> </p>
<p>If  the  application  has  accepted  the  SID,  then  a  special  “user  service” </p>
<p>MainHandler will be called (see 12.6.5.4 Generic User Service MainHandler). </p>
<p>-</p>
<p> </p>
<p>If  in  GENtool  “Support  Generic  User  Service  PostHandler”  is  set,  after  the </p>
<p>request </p>
<p>processing </p>
<p>has </p>
<p>been </p>
<p>accomplished, </p>
<p>a </p>
<p>special </p>
<p>“user </p>
<p>service” </p>
<p>PostHandler will be called (see 12.6.5.5 Generic User Service PostHandler). </p>
<p><b>Note: </b></p>
<p>-</p>
<p> </p>
<p>Since CANdesc doesn’t distinguish user defined services, a special API was </p>
<p>designed to get the application the opportunity to dispatch among the SIDs </p>
<p>(in MainHandler and in the PostHandler). </p>
<p>-</p>
<p> </p>
<p>The user defined services are processed on service id level which means the </p>
<p>application shall dispatch and do the whole format check of these requests. </p>
<p>The state management shall be performed bye application, too. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>92 / 164 </p>
<p><b>12.6.5.2 </b></p>
<p><b>ApplDescCheckUserService() </b></p>
<p><b>ApplDescCheckUserService </b></p>
<p><b>Available since 2.11.00 </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>vuint8 <b>ApplDescCheckUserService </b>(DescMsgItem sid) </p>
<p>Multi Context </p>
<p>vuint8 <b>ApplDescCheckUserService </b>(DescMsgItem sid) </p>
<p><b>Parameter </b></p>
<p>sid </p>
<p>The service identifier which is currently under processing. </p>
<p><b>Return  code </b></p>
<p>1.</p>
<p> </p>
<p>kDescOk </p>
<p>2.</p>
<p> </p>
<p>kDescFailed </p>
<p>1. </p>
<p>Return this value if the service id is a “user defined” one. </p>
<p>2. </p>
<p>Return this value if the service id is unknown for the </p>
<p>application too. </p>
<p><b>Functional Description </b></p>
<p>The currently received request contains an unknown for CANdesc service Id. Within this </p>
<p>function the ECU application has to decide immediately if the SID is one of the user </p>
<p>defined or not. Depending on the return value, CANdesc will process further this request </p>
<p>or will reject it by sending negative response ‘ServiceNotSupported’. </p>
<p><b>Pre-conditions </b></p>
<p>The “Support Generic User Service” option was enabled in the GENtool configuration. </p>
<p><b>Call context </b></p>
<p>From <b>DescTask() </b>(in KWP diagnostics also from RxInterrupt). </p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>93 / 164 </p>
<p><b>12.6.5.3 </b></p>
<p><b>DescGetServiceId() </b></p>
<p><b>DescGetServiceId </b></p>
<p><b>Available since 2.11.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>DescMsgItem <b>DescGetServiceId </b>(void) </p>
<p>Multi Context </p>
<p>DescMsgItem <b>DescGetServiceId </b>(vuint8 iContext) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>The current request context location </p>
<p><b>Return  code </b></p>
<p>DescMsgItem </p>
<p>The service id which is currently under processing. </p>
<p><b>Functional Description </b></p>
<p>Reports the service id of the currently processed user-service request. </p>
<p><b>Pre-conditions </b></p>
<p>The “Support Generic User Service” option was enabled in the GENtool configuration. </p>
<p><b>Call context </b></p>
<p>From <b>DescTask() </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function may be called at any time within a diagnostic request life cycle starting at </p>
<p>the call of the MainHandler and ending by the PostHandler (if configured) or (if none </p>
<p>configured) by calling  <b>DescProcessingDon </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>94 / 164 </p>
<p><b>12.6.5.4 </b></p>
<p><b>Generic User Service MainHandler </b></p>
<p><b>ApplDescUserServiceHandler </b></p>
<p><b>Available since 2.11.00 </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescUserServiceHandler </b>(DescMsgContext* pMsgContext) </p>
<p>Multi Context </p>
<p>void <b>ApplDescUserServiceHandler </b>(DescMsgContext* pMsgContext) </p>
<p><b>Parameter </b></p>
<p>pMsgContext </p>
<p>Refer the section 12.6.4.2 Service MainHandler for details about this </p>
<p>parameter. </p>
<p>Read Access </p>
<p><b>pMsgContext-&gt;reqData  </b></p>
<p>pointer to the first byte after the service Id. </p>
<p>The other members of the parameter are described in 12.6.4.2 Service </p>
<p>MainHandler </p>
<p>Write access </p>
<p><b>pMsgContext-&gt;resData  </b></p>
<p>pointer to the first byte after the response SID, where the data (incl. sub-</p>
<p>parameters) will be written. </p>
<p>The other members of the parameter are described in 12.6.4.2 Service </p>
<p>MainHandler </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This MainHandler is called for all unknown service requests at service id level, so the </p>
<p>application has to do following: </p>
<p></p>
<p> </p>
<p>Perform service id dispatching (if more than one user defined service shall be </p>
<p>used). </p>
<p></p>
<p> </p>
<p>Perform length validation for varying length information of request. </p>
<p></p>
<p> </p>
<p>Perform parameter (if any) validation. </p>
<p></p>
<p> </p>
<p>Disassemble any data received with the request telegram and process it. </p>
<p></p>
<p> </p>
<p>Assemble any data to be send with the response and update current response </p>
<p>length </p>
<p></p>
<p> </p>
<p>Confirm that the processing is finished. </p>
<p><b>Pre-conditions </b></p>
<p>The “Support Generic User Service” option was enabled in the GENtool configuration. </p>
<p><b>Call context </b></p>
<p>From <b>DescTask() </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>Refer the section 12.6.4.2 Service MainHandler. </p>
<p></p>
<p> </p>
<p><b>DescGetServiceId() </b>may be called here to dispatch the SID of the currently processed </p>
<p>user service (refer 12.6.5.3 DescGetServiceId </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>95 / 164 </p>
<p><b>12.6.5.5 </b></p>
<p><b>Generic User Service PostHandler </b></p>
<p><b>ApplDescPostUserServiceHandler </b></p>
<p><b>Available since 2.11.00 </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescPostUserServiceHandler </b>(vuint8 status) </p>
<p>Multi Context </p>
<p>void <b>ApplDescPostUserServiceHandler </b>(vuint8 iContext, vuint8 status) </p>
<p><b>Parameter </b></p>
<p>iContext, status </p>
<p>Refer 12.6.4.3 Service PostHandler for information. </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The functionality of the user service PostHandler is the same as the one of the normal </p>
<p>service PostHandler. Refer 12.6.4.3 Service PostHandler for more details. </p>
<p><b>Pre-conditions </b></p>
<p>The “Support Generic User Service PostHandler” option was enabled in the GENtool </p>
<p>configuration. </p>
<p>CANdesc version &gt;= 2.11.00 </p>
<p><b>Call context </b></p>
<p>From <b>DescTask() </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>Refer the section 12.6.4.3 Service PostHandler for information. </p>
<p></p>
<p> </p>
<p><b>DescGetServiceId() </b>may be called here to dispatch the SID of the currently post-</p>
<p>processed user service (refer 12.6.5.3 DescGetServiceId </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>96 / 164 </p>
<p><b>12.6.6 </b></p>
<p><b>Session Handling </b></p>
<p><b>12.6.6.1 </b></p>
<p><b>ApplDescCheckSessionTransition() </b></p>
<p><b>ApplDescCheckSessionTransition </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescCheckSessionTransition </b>(DescStateGroup newState, DescStateGroup </p>
<p>formerState) </p>
<p>Multi Context </p>
<p>void <b>ApplDescCheckSessionTransition </b>(vuint8 iContext, DescStateGroup newState, </p>
<p>DescStateGroup formerState) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>the current request context location </p>
<p>newState </p>
<p>the CANdesc component has change to this session state </p>
<p>formerState </p>
<p>the CANdesc component has change from this session state </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This hook function will be called, while session request is received (SID $10). If the </p>
<p>application wants to discard this request, an error must be set (via </p>
<p><b>DescSetNegResponse() </b>).  </p>
<p>The application always has to confirm this hook function via </p>
<p><b>DescSessionTransitionChecked().  </b></p>
<p>Both above functions can be called also outside of the context of this function (e.g. </p>
<p>application task waiting for results form an I/O port). CANdesc will send RCR-RP </p>
<p>response as long as the application delays the confirmation for the session transition. </p>
<p> </p>
<p>In some cases the application has to know whether the SPRMIB in the request was set or </p>
<p>not. Since this API call does not contain this information, a dedicated API in CANdesc </p>
<p>provides it: <i>DescIsSuppressPosResBitSet ()</i>. </p>
<p><b>Pre-conditions </b></p>
<p>At least one DiagnosticSessionControl service must be configured to ‘OEM’ in attribute </p>
<p>‘MainHandlerSupport’ </p>
<p><b>Call context </b></p>
<p>From <b>DescTask() </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>Call the API function <b>DescSessionTransitionChecked() </b>to end the service processing </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>97 / 164 </p>
<p><b>12.6.6.2 </b></p>
<p><b>DescSessionTransitionChecked() </b></p>
<p><b>DescSessionTransitionChecked </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescSessionTransitionChecked </b>(void) </p>
<p>Multi Context </p>
<p>void <b>DescSessionTransitionChecked </b>(vuint8 iContext) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>the current request context location </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>After the application has finished the processing in the hook function </p>
<p><b>ApplDescCheckSessionTransition() </b>this function must be called.  </p>
<p><b>Pre-conditions </b></p>
<p>At least one DiagnosticSessionControl service must be configured to ‘OEM’ in attribute </p>
<p>‘MainHandlerSupport’ </p>
<p><b>Call context </b></p>
<p>Within or after a ‘<b>ApplDescCheckSessionTransition()</b>’ function </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>If this function will be called late, the CANdesc component sends automatically the </p>
<p>RCR-RP responses </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>98 / 164 </p>
<p><b>12.6.6.3 </b></p>
<p><b>DescIsSuppressPosResBitSet () </b></p>
<p><b>DescIsSuppressPosResBitSet </b></p>
<p><b>Available since 5.07.14 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>DescBool <b>DescIsSuppressPosResBitSet </b>(void) </p>
<p>Multi Context </p>
<p>DescBool <b>DescIsSuppressPosResBitSet </b>(vuint8 iContext) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>the current request context location </p>
<p><b>Return  code </b></p>
<p>kDescTrue </p>
<p>kDescFalse </p>
<p>The SPRMIB is set. </p>
<p>The SPRMIB is NOT set. </p>
<p><b>Functional Description </b></p>
<p>This API can be always called while a diagnostic service processing is ongoing to get the </p>
<p>information about the SPRMIB state. All main-handlers do contain this information already </p>
<p>in the pMsgContext parameter so use it instead of this API.  </p>
<p>In some other cases the application does not have access to the pMsgContext, and there </p>
<p>the API can be used. </p>
<p><b>Pre-conditions </b></p>
<p>Only for UDS configurations. </p>
<p>May be called only while a diagnostic service processing is ongoing. Otherwise invalid </p>
<p>data can be reported. </p>
<p><b>Call context </b></p>
<p>Any. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>99 / 164 </p>
<p><b>12.6.6.4 </b></p>
<p><b>ApplDescOnTransitionSession() </b></p>
<p><b>ApplDescOnTransitionSession </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescOnTransitionSession </b>(DescStateGroup newState,  </p>
<p>                                  DescStateGroup formerState) </p>
<p>Multi Context </p>
<p>void <b>ApplDescOnTransitionSession </b>(DescStateGroup newState,  </p>
<p>                                  DescStateGroup formerState) </p>
<p><b>Parameter </b></p>
<p>newState </p>
<p>the CANdesc component has change to this session state </p>
<p>formerState </p>
<p>the CANdesc component has change from this session state </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>After the positive response of a SessionControl request the session will transit to the </p>
<p>requested session. This function informs the application that such a transition occurs. </p>
<p><b>Pre-conditions </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>From <b>DescTask()  </b></p>
<p>interrupts might be disabled  </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>Only informational function </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>100 / 164 </p>
<p><b>12.6.6.5 </b></p>
<p><b>DescSetStateSession() </b></p>
<p><b>DescSetStateSession </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescSetStateSession </b>(DescStateGroup newSession) </p>
<p>Multi Context </p>
<p>void <b>DescSetStateSession </b>(DescStateGroup newSession) </p>
<p><b>Parameter </b></p>
<p>newSession </p>
<p>the CANdesc component will change to this session state </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>By this function the state of the SessionState-group can be changed by the ECU </p>
<p>application. The transition notification function ‘ApplDescOnTransitionSession’ will be </p>
<p>called to notify the application about the new session.  </p>
<p> </p>
<p><b>Pre-conditions </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>Refer the section 12.6.11.2 &quot;DescSetState&lt;StateGroup&gt;()” for more details. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>101 / 164 </p>
<p><b>12.6.6.6 </b></p>
<p><b>DescGetStateSession() </b></p>
<p><b>DescGetStateSession </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>currentSession <b>DescGetStateSession </b>(void) </p>
<p>Multi Context </p>
<p>currentSession <b>DescGetStateSession </b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p> </p>
<p><b>Return  code </b></p>
<p>currentSession </p>
<p> </p>
<p><b>Functional Description </b></p>
<p>This function returns the current session state. Since the states are bit-coded the </p>
<p>evaluation expressions may be optimized for multiple use cases. </p>
<p>Example: Code execution only when either default or extended session is active. </p>
<p>lState = DescGetStateSession(); </p>
<p>if ( (lState &amp; (kDescStateSession&lt;Default&gt;) | kDescStateSession&lt;Extended&gt;)) != 0 ) </p>
<p>{ </p>
<p> /*execute code*/ </p>
<p>}</p>
<p> </p>
<p><b>Pre-conditions </b></p>
<p><b> </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>Refer the section 12.6.11.1 “DescGetState&lt;StateGroup&gt;()” for more details. </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>102 / 164 </p>
<p><b>12.6.6.7 </b></p>
<p><b>DescGetSessionIdOfSessionState </b></p>
<p><b>DescGetSessionIdOfSessionState  </b></p>
<p><b>Available since 3.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Any Context </p>
<p>DescMsgItem <b>DescGetSessionIdOfSessionState </b>(DescStateGroup sessionState) </p>
<p><b>Parameter </b></p>
<p>sessionState </p>
<p>- Must be one of the valid session states (i.e. the value of the </p>
<p>API <i>DescGetStateSession() </i>). </p>
<p><b>Return code </b></p>
<p>DescMsgItem </p>
<p>- Is the corresponding session identifier value. </p>
<p><b>Functional Description </b></p>
<p>This function provides a conversion from a session state to its corresponding session </p>
<p>identifier (e.g. calling this function with parameter <i><b>kDescStateSessionDefault </b></i>will return </p>
<p><i><b>0x01</b></i>). </p>
<p><b>Pre-conditions </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>103 / 164 </p>
<p><b>12.6.7 </b></p>
<p><b>CommunicationControl Handling </b></p>
<p>This  API  is  provided,  if  the  ECU  supports  the  serviceCommunicationControl  (UDS)  or </p>
<p>service 0x28/0x29 Dis-/EnableNormalMessageTransmission (KWP).  </p>
<p><b>12.6.7.1 </b></p>
<p><b>ApplDescCheckCommCtrl() </b></p>
<p><b>ApplDescCheckCommCtrl </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescCheckCommCtrl </b>(DescOemCommControlInfo* commControlInfo) </p>
<p>Multi Context </p>
<p>void <b>ApplDescCheckCommCtrl </b>(vuint8 iContext,  </p>
<p>                            DescOemCommControlInfo* commControlInfo) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>The current request context location </p>
<p>commControlInfo </p>
<p>OEM dependent </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The execution of this service is completely done within the CANdesc component. This </p>
<p>hook function can be used to permit the application to reject the execution under some </p>
<p>circumstance. If the application wants to discard this request, an error must be set (via </p>
<p><b>DescSetNegResponse()</b>). </p>
<p>The application always has to confirm this hook function (via <b>DescCommCtrlChecked()</b>). </p>
<p><b>Pre-conditions </b></p>
<p>The CommunicationControl service must be activated and the attribute </p>
<p>‘MainHandlerSupport’ has to be set to ‘OEM’ </p>
<p><b>Call context </b></p>
<p>From <b>DescTask() </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>If the API function <b>DescCommCtrlChecked() </b>will be not called, the service processing </p>
<p>will not end </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>104 / 164 </p>
<p><b>12.6.7.2 </b></p>
<p><b>DescCommCtrlChecked() </b></p>
<p><b>DescCommCtrlChecked </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescCommCtrlChecked </b>(void) </p>
<p>Multi Context </p>
<p>void <b>DescCommCtrlChecked </b>(vuint8 iContext) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>the current request context location </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The CANdesc component calls a hook function to check for the execution permission of </p>
<p>the CommunicationControl service. Within or after this hook function </p>
<p>(<b>ApplDescCheckCommCtrl()</b>) the application can set an error </p>
<p>(<b>DescSetNegResponse()</b>) to reject the request. This function is used to terminate the </p>
<p>hook function <b>ApplDescCheckCommCtrl(). </b></p>
<p><b>Pre-conditions </b></p>
<p>The CommunicationControl service must be activated and the attribute </p>
<p>‘MainHandlerSupport’ has to be set to ‘OEM’ </p>
<p><b>Call context </b></p>
<p>Within or after <b>ApplDescCheckCommCtrl() </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>105 / 164 </p>
<p><b>12.6.8 </b></p>
<p><b>Periodic call of ‘Service MainHandler’ </b></p>
<p><b>12.6.8.1 </b></p>
<p><b>DescStartRepeatedServiceCall() </b></p>
<p><b>DescStartRepeatedServiceCall </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescStartRepeatedServiceCall </b>(DescMainHandler descMainHandler) </p>
<p>Multi Context </p>
<p>void <b>DescStartRepeatedServiceCall </b>(</p>
<p>vuint8 iContext</p>
<p>, DescMainHandler descMainHandler) </p>
<p><b>Parameter </b></p>
<p>descMainHandler </p>
<p>Reference to a function. The function prototype must be based </p>
<p>on a ‘Service MainHandler’. </p>
<p>iContext </p>
<p>The current request context location </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The application can use this function to get a periodic call to the specified function (in the </p>
<p>parameter) from the CANdesc component.  </p>
<p>It is possible to use the same ‘Service MainHandler’ function as it is called in. </p>
<p><b>Pre-conditions </b></p>
<p> </p>
<p><b>Call context </b></p>
<p>Within or after a ‘Service MainHandler’ function </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>CANdesc can do no validation, if this pointer is valid. </p>
<p></p>
<p> </p>
<p>Is the parameter NULL, the periodic calls will get stopped. </p>
<p></p>
<p> </p>
<p>The function is called in the same cycle time (context) as the DescTask() </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>106 / 164 </p>
<p><b>12.6.8.2 </b></p>
<p><b>DescStartMemByAddrRepeatedCall() </b></p>
<p><b>DescStartMemByAddrRepeatedCall </b></p>
<p><b>Available since 5.06.04 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescStartMemByAddrRepeatedCall </b>() </p>
<p>Multi Context </p>
<p>void <b>DescStartMemByAddrRepeatedCall </b>(</p>
<p>vuint8 iContext</p>
<p>) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>The current request context location </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The application can use this function to get a periodic call to the current Read/Write </p>
<p>memory by address handler. </p>
<p><b>Pre-conditions </b></p>
<p> </p>
<p><b>Call context </b></p>
<p>Within ApplDescReadMemoryByAddress or ApplDescWriteMemoryByAddress. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>The memory access handler is called in the same cycle time (context) as the </p>
<p>DescTask() </p>
<p> </p>
<p><b>12.6.9 </b></p>
<p><b>Ring Buffer Mechanism </b></p>
<p>The ring-buffer option can be used to save RAM when some responses are quite long and </p>
<p>reserving such space of RAM is impossible. In contrast to the linear responses, where the </p>
<p>response data will be first written and then the transmission to the tester will be initiated, </p>
<p>the ring-buffer concept starts a transmission as soon as it has either the whole data (for </p>
<p>short [single frame] responses) or at least enough data to fill a first-frame of a multi-frame </p>
<p>transmission.  Once  the  ring  buffer  has  been  activated  and  the  response  transmission </p>
<p>initiated, the application must supply enough data to keep the transmission away from lack </p>
<p>of data. In multiple PID mode, the application can decide in each PID main handler to use </p>
<p>the  ring  buffer  or  not.  However,  if  one  of  the  PIDs  has  dynamic  length,  the  ring  buffer </p>
<p>mechanism can not be used for any PID in the list. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>107 / 164 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The ring buffer should only be used for long responses, because using the ring buffer </p>
<p>instead of the linear buffer causes a runtime overhead. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>108 / 164 </p>
<p><b>12.6.9.1 </b></p>
<p><b>DescRingBufferStart() </b></p>
<p><b>DescRingBufferStart </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescRingBufferStart </b>(void) </p>
<p>Multi Context </p>
<p>void <b>DescRingBufferStart </b>(vuint8 iContext) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>reference to the corresponding request context </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>After completing the request validation the application can decide (in runtime), if the ring-</p>
<p>buffer mechanism should be used or not.  </p>
<p>By calling this function, the decision is made to use the ring-buffer. Otherwise </p>
<p>DescProcessingDone() should be called, after filling the response data (in a linear way). </p>
<p>Either DescProcessingDone() or DescRingBufferStart() will finish the response handling. </p>
<p>Depending on the previous actions of the application the CANdesc module will either send </p>
<p>a response (positive/negative depending on the error state machine) or no response will </p>
<p>be send if the application/CANdesc decides that there must be no response (please refer </p>
<p>the Part III User Manual). </p>
<p>The transmission of the positive response will not start immediately. The application has to </p>
<p>fill the ring-buffer first. If the ring-buffer has enough data, the transmission will be started </p>
<p>(internally).  </p>
<p><b>Pre-conditions </b></p>
<p>- ring-buffer has been enabled in the configuration </p>
<p><b>Call context </b></p>
<p>Within or after a ‘Service MainHandler’ function </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This API <b>must not </b>be called from any of the other handler type (Pre- or PostHandlers) </p>
<p></p>
<p> </p>
<p>Either DescProcessingDone() or DescRingBufferStart() must be used to finish the </p>
<p>response handling. </p>
<p></p>
<p> </p>
<p>Total response length must be written before! </p>
<p></p>
<p> </p>
<p>No response data must be written before! </p>
<p></p>
<p> </p>
<p>This function <b>must not </b>be called in interrupt context </p>
<p></p>
<p> </p>
<p><b>Limitation: </b>Until CANdesc version 2.13.00 it was not possible to use the Ring-Buffer in </p>
<p>‘Multiple PID’ services (as described in section 9.1.3 Multiple PID mode) </p>
<p></p>
<p> </p>
<p><b>UDS limitation: </b>Always check the SPRMIB prior starting the ring-buffer. If this bit is </p>
<p>set, the ring-buffer shall not be started. Instead DescProcessingDone() must be called </p>
<p>(see 13.6). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>109 / 164 </p>
<p> </p>
<p><b>12.6.9.2 </b></p>
<p><b>DescRingBufferWrite() </b></p>
<p><b>DescRingBufferWrite </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>vuint8 <b>DescRingBufferWrite </b>(DescMsg data, DescMsgLen dataLength) </p>
<p>Multi Context </p>
<p>vuint8 <b>DescRingBufferWrite </b>(vuint8 iContext, DescMsg data, DescMsgLen dataLength) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>Reference to the corresponding request context </p>
<p>DescMsg </p>
<p>Pointer to application data, which should be copied into ring-</p>
<p>buffer. </p>
<p>DescMsgLen </p>
<p>Amount of data, which should be copied (from pointer data) into </p>
<p>ring-buffer. </p>
<p><b>Return  code </b></p>
<p>vuint8 </p>
<p><b>kDescOk  </b></p>
<p>If the copy process was successful </p>
<p><b>kDescFailed  </b></p>
<p>if the data are <b>not </b>copied into the ring-buffer </p>
<p><b>Functional Description </b></p>
<p>The application writes data into the ring-buffer by this function. It is not necessary that the </p>
<p>application must write the data in the context of a special API function.  </p>
<p>The write order is always linear! The first written byte is the first byte in the response </p>
<p>message.   </p>
<p><b>Pre-conditions </b></p>
<p>-</p>
<p> </p>
<p>ring-buffer has been enabled in the configuration; </p>
<p>-</p>
<p> </p>
<p>DescRingBufferStart() must be called first, to activate the ring-buffer mechanism. </p>
<p><b>Call context </b></p>
<p>- This API shall not interrupt the DescTask. Required for the case the currently ongoing </p>
<p>transmission is interrupted due to a communication error, and the application still writes </p>
<p>into the buffer. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>dataLength</p>
<p> must be lower or equal to the ring-buffer size, else the function will </p>
<p>always fail </p>
<p></p>
<p> </p>
<p>CANdesc has already filled the first bytes (SID, etc.) into the ring-buffer. So in the first </p>
<p>call of DescRingBufferWrite() the dataLength must lower as the buffer size + these </p>
<p>byte </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>110 / 164 </p>
<p><b>12.6.9.3 </b></p>
<p><b>DescRingBufferCancel() </b></p>
<p><b>DescRingBufferCancel </b></p>
<p><b>Available since 5.01.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescRingBufferCancel </b>(void) </p>
<p>Multi Context </p>
<p>void <b>DescRingBufferCancel </b>(vuint8 iContext) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>Reference to the corresponding request context </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The application may call this API once the a data acquisition error has been occurred after </p>
<p>the ring-buffer has been activated via <i>DescRingBufferStart()</i>. </p>
<p> </p>
<p>CANdesc will automatically determine the appropriate action depending on its current </p>
<p>internal state: </p>
<p>-</p>
<p> </p>
<p>if the response data transmission has not been started yet, a negative </p>
<p>response will be sent back. </p>
<p>-</p>
<p> </p>
<p>If the response transmission has been started – a transmission interrupt </p>
<p>will occur – the tester will not get a complete response. </p>
<p><b>Pre-conditions </b></p>
<p>-</p>
<p> </p>
<p>ring-buffer has been enabled in the configuration </p>
<p>-</p>
<p> </p>
<p>DescRingBufferStart() must be called before to activate the ring-buffer mechanism </p>
<p><b>Call context </b></p>
<p>-  </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>111 / 164 </p>
<p><b>12.6.9.4 </b></p>
<p><b>DescRingBufferGetFreeSpace() </b></p>
<p><b>DescRingBufferGetFreeSpace </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>DescMsgLen <b>DescRingBufferGetFreeSpace </b>(void) </p>
<p>Multi Context </p>
<p>DescMsgLen <b>DescRingBufferGetFreeSpace </b>(vuint8 iContext) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>reference to the corresponding request context </p>
<p><b>Return  code </b></p>
<p>DescMsgLen </p>
<p>The amount of free space/bytes in the ring-buffer. </p>
<p><b>Functional Description </b></p>
<p>This function returns the amount of free space/bytes in the ring-buffer.  </p>
<p><b>Pre-conditions </b></p>
<p>-</p>
<p> </p>
<p>ring-buffer has been enabled in the configuration </p>
<p>-</p>
<p> </p>
<p>DescRingBufferStart() must be called before to activate the ring-buffer mechanism </p>
<p><b>Call context </b></p>
<p>- </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>112 / 164 </p>
<p><b>12.6.9.5 </b></p>
<p><b>DescRingBufferGetProgress() </b></p>
<p><b>DescRingBufferGetProgress </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>DescMsgLen <b>DescRingBufferGetProgress </b>(void) </p>
<p>Multi Context </p>
<p>DescMsgLen <b>DescRingBufferGetProgress </b>(vuint8 iContext) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>reference to the corresponding request context </p>
<p><b>Return  code </b></p>
<p>DescRingBufferProgress </p>
<p>Current byte position in the whole response.  </p>
<p><b>Functional Description </b></p>
<p>This function returns the progress of the copy process.  </p>
<p><b>Pre-conditions </b></p>
<p>-</p>
<p> </p>
<p>ring-buffer has been enabled in the configuration </p>
<p>-</p>
<p> </p>
<p>DescRingBufferStart() must be called before to activate the ring-buffer mechanism </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>113 / 164 </p>
<p><b>12.6.10 Signal Interface of CANdesc  </b></p>
<p>CANdesc  will  provide  a  signal  interface  to  the  ECU  application. This  can  help  the  ECU </p>
<p>application </p>
<p>to </p>
<p>assemble </p>
<p>the </p>
<p>response </p>
<p>automatically. </p>
<p>No </p>
<p>further </p>
<p>code </p>
<p>changes </p>
<p>are </p>
<p>necessary, if a signal will move or change its size. </p>
<p>The  current  implementation  has  only  support  for  a  synchronous  signal  interface.  This </p>
<p>means the ECU application has to provide the signal value within the call/context of the </p>
<p>Signal Handler function (while reading) or to write thewithin the call/context of the Signal </p>
<p>Handler function (while writing). </p>
<p><b>12.6.10.1 ApplDesc&lt;Signal-Handler&gt;() </b></p>
<p><b>ApplDesc&lt;Signal-Handler&gt; </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>- <b>ApplDesc&lt;Service-Qualifier + Data-Object-Qualifier + Instance-Qualifier&gt; </b>(-) </p>
<p>Multi Context </p>
<p>- <b>ApplDesc&lt;Service-Qualifier + Data-Object-Qualifier + Instance-Qualifier&gt; </b>(-) </p>
<p><b>Parameter </b></p>
<p>vuint8, vsint8, </p>
<p>vuint16, vsint16,  </p>
<p>vuint32, vsint32, </p>
<p>DescMsg (vuint8*) </p>
<p>Available for write services. </p>
<p>Type depend on signal type </p>
<p>DescMsg (vuint8*) </p>
<p>Available for read services and signals &gt; 32 bit (N bit) </p>
<p><b>Return  code </b></p>
<p>vuint8, vsint8, </p>
<p>vuint16, vsint16,  </p>
<p>vuint32, vsint32 </p>
<p>Available for read services. </p>
<p>Type depend on signal type. </p>
<p><b>Functional Description </b></p>
<p>A Signal Handler is generated if the Service MainHandler is configured to be generated. In </p>
<p>this case, writing Signal Handlers are generated for all dataObjects transported with the </p>
<p>request and reading Signal Handlers are generated for all dataObjects transported with </p>
<p>the response (read/write from application point of view).  </p>
<p>The data type of the Signal Handler argument depends on the dataObject which is to be </p>
<p>processed. </p>
<p><b>Pre-conditions </b></p>
<p>Must be configured to ‘generated’ in attribute ‘MainHandlerSupport’ </p>
<p><b>Call context </b></p>
<p>From <b>DescTask() </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p> You can override the given name extension (Service-Qualifier + Data-Object-Qualifier </p>
<p>+ Instance-Qualifier) by using the SignalHandlerOverrideName. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>114 / 164 </p>
<p><b>12.6.10.2 Configuration of direct signal access </b></p>
<p></p>
<p> </p>
<p>Application variable for direct access (default = not set) </p>
<p>If this variable is specified, an access to the given external (= application) variable is </p>
<p>generated. Nothing has to be done by the application. The external variable must </p>
<p>be defined inside the application. </p>
<p></p>
<p> </p>
<p>SignalHandlerOverrideName (default = not set). </p>
<p>You can adapt the name of the Signal Handler setting this value. By using this </p>
<p>“Override Name” it is also possible to reuse an already existing Signal Handler</p>
<p>  </p>
<p><b>12.6.11 State Handling (CANdesc only) </b></p>
<p><b>12.6.11.1 DescGetState&lt;StateGroup&gt;() </b></p>
<p><b>DescGetState&lt;StateGroup&gt; </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>DescStateGroup <b>DescGetState&lt;StateGroup-Qualifier&gt; </b>(void) </p>
<p>Multi Context </p>
<p>DescStateGroup <b>DescGetState&lt;StateGroup-Qualifier&gt; </b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return  code </b></p>
<p>DescStateGroup </p>
<p>The current state of the state group </p>
<p><b>Functional Description </b></p>
<p>This function returns the current session state. Since the states are bit-coded the </p>
<p>evaluation expressions may be optimized for multiple use cases. </p>
<p>Example: Code execution only when either the current state of this group is either state X </p>
<p>or state Y. </p>
<p>lState = DescGetState&lt; <b>StateGroupQualifier </b>&gt;(); </p>
<p>if ( (lState &amp; (kDescState&lt; <b>StateGroupQualifier </b>&gt;&lt;StateQualifier_X&gt;) |  </p>
<p>                kDescState&lt; <b>StateGroupQualifier </b>&gt;&lt;StateQualifier_Y&gt;)) != 0 ) </p>
<p>{ </p>
<p> /*execute code*/ </p>
<p>}</p>
<p> </p>
<p><b>Pre-conditions </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>- </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>For each state of a state-group a constant is defined in desc.h:  </p>
<p><b>kDescState&lt;StateGroup-Qualifier&gt;&lt;StateQualifier&gt; </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>115 / 164 </p>
<p><b>12.6.11.2 DescSetState&lt;StateGroup&gt;() </b></p>
<p><b>DescSetState&lt;StateGroup&gt; </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescSetState&lt;StateGroup-Qualifier&gt; </b>(DescStateGroup newState) </p>
<p>Multi Context </p>
<p>void <b>DescSetState&lt;StateGroup-Qualifier&gt; </b>(DescStateGroup newState) </p>
<p><b>Parameter </b></p>
<p>DescStateGroup </p>
<p>the state in which the state group should be changed  </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>By this function the state of the state-group can be changed by the ECU application. The transition </p>
<p>notification function ‘ApplDescOnTransition&lt; StateGroupQualifier &gt;’ will be called to notify the </p>
<p>application about the new state.  </p>
<p>Example: </p>
<p> DescSetState&lt;StateGroupQualifier&gt;(kDescState&lt;StateGroupQualifier&gt;&lt;StateQualifier&gt;);  </p>
<p> </p>
<p>This line will force CANdesc to change the state of the given state group to the new one. </p>
<p><b>Pre-conditions </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>-From a task with priority lower or equal to the DescTask. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>For each state of a state-group a constant will be defined in desc.h:  </p>
<p><b>kDescState&lt;StateGroup-Qualifier&gt;&lt;State-Qualifier&gt; </b></p>
<p></p>
<p> </p>
<p>The <b>ApplDescOnTransition&lt;StateGroup-Qualifier&gt;() </b>notification function is called in any </p>
<p>case. Also if the newState is the same as the current stat </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>116 / 164 </p>
<p><b>12.6.11.3 ApplDescOnTransition«StateGroup»() </b></p>
<p><b>ApplDescOnTransition«StateGroup» </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescOnTransition&lt;StateGroup-Qualifier&gt;</b>(DescStateGroup newState, </p>
<p>                                                DescStateGroup formerState) </p>
<p>Multi Context </p>
<p>void <b>ApplDescOnTransition&lt;StateGroup-Qualifier&gt; </b>(DescStateGroup newState, </p>
<p>                                                 DescStateGroup formerState) </p>
<p><b>Parameter </b></p>
<p>newState </p>
<p>the CANdesc component has changed to this session state </p>
<p>formerState </p>
<p>the CANdesc component has changed from this session state </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This notification function will be called each time a transition has happened.  </p>
<p><b>Pre-conditions </b></p>
<p>- </p>
<p><b>Call context </b></p>
<p>From <b>DescTask()  </b></p>
<p>interrupts might be disabled  </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>For each state of a state-group a constant will be defined in desc.h:  </p>
<p><b>kDescState&lt;StateGroup-Qualifier&gt;&lt;StateName-Qualifier&gt; </b></p>
<p></p>
<p> </p>
<p>For some exceptions (e.g. Session) the newState can be the same as the formerState. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>117 / 164 </p>
<p><b>12.6.12 Force “Response Correctly Received - Response Pending” transmission </b></p>
<p>In  some  cases  it  is  useful  for  the  application  to  be  sure  that  it  has  enough  time  to </p>
<p>accomplish a process without causing the tester to get response timeout. In such cases </p>
<p>the  application  can  use  the  “force  RCR-RP”  mechanism  of  CANdesc,  which  prevents </p>
<p>timeout between the tester and the ECU application.  </p>
<p><b>How it works: </b></p>
<p>This feature is mostly applicable when a FlashBootLoader (FBL) is available for the ECU. </p>
<p>Before  starting  it,  the  application  wants  to  assure  that  there  is  enough  time  to  perform </p>
<p>reset </p>
<p>and  activate </p>
<p>the </p>
<p>FBL </p>
<p>before </p>
<p>the </p>
<p>tester </p>
<p>gets </p>
<p>response  timeout.  The </p>
<p>RCR-RP </p>
<p>mechanism notifies the tester that some action is ongoing and so resets the timeout timer </p>
<p>in the tester. </p>
<p>To transmit a ‘Response Correctly Received - Response Pending’ response the application </p>
<p>has </p>
<p>to </p>
<p>call </p>
<p>the </p>
<p>DescForceRcrRpResponse() </p>
<p>function. </p>
<p>To </p>
<p>be </p>
<p>sure </p>
<p>this </p>
<p>response </p>
<p>is </p>
<p>transmitted,  the  application  has  to  wait  for  the  transmission  confirmation  of  this  forced </p>
<p>RCR-RP </p>
<p>response </p>
<p>(the </p>
<p>function </p>
<p>ApplDescRcrRpConfirmation). </p>
<p>Depending </p>
<p>on </p>
<p>its </p>
<p>transmission </p>
<p>status  parameter </p>
<p>the  application </p>
<p>can </p>
<p>decide  how </p>
<p>the  processing </p>
<p>shall </p>
<p>continue (a jump to FBL or to close the request processingth negative response).  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>118 / 164 </p>
<p><b>12.6.12.1 DescForceRcrRpResponse() </b></p>
<p><b>DescForceRcrRpResponse </b></p>
<p><b>Available since 2.11.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescForceRcrRpResponse</b>(void) </p>
<p>Multi Context </p>
<p>void <b>DescForceRcrRpResponse</b>(vuint8 iContext) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>reference to the corresponding request context </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Calling this function the application can force CANdesc to send immediately (not later than </p>
<p>the next call of DescTask() function) a RCR-RP response. </p>
<p><b>Pre-conditions </b></p>
<p>CANdesc was configured to use this option (enabled in the GENtool). </p>
<p><b>Call context </b></p>
<p>Task or interrupt. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function can be called: </p>
<p>after a call of a MainHandler function (e.g. <b>ApplDescCheckSessionTransition()</b>) </p>
<p>and until the call of <b>ApplDescResponsePendingOverrun() </b>or </p>
<p><b>ApplDescResponsePendingOvertimed() </b>or<b>pConfirmation(). </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>119 / 164 </p>
<p><b>12.6.12.2 ApplDescRcrRpConfirmation() </b></p>
<p><b>ApplDescRcrRpConfirmation </b></p>
<p><b>Available since 2.11.00 </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescRcrRpConfirmation</b>(vuint8 status) </p>
<p>Multi Context </p>
<p>void <b>ApplDescRcrRpConfirmation</b>(vuint8 iContext, vuint8 status) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>Reference to the corresponding request context </p>
<p>status </p>
<p>If the transmission was successful, the parameter value will be </p>
<p><i>kDescOk</i>. Otherwise – <i>kDescFailed. </i></p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Once the RCR-RP response has been forced, this function will be called in any case. The </p>
<p>transmission status is reported by the status parameter. </p>
<p><b>Pre-conditions </b></p>
<p>CANdesc was configured to use this option (enabled in the GENtool). </p>
<p><b>Call context </b></p>
<p>CAN Driver TX-ISR </p>
<p></p>
<p> TP Confirmation </p>
<p></p>
<p> this function </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>Be aware of time consuming implementation for this function (interrupt call context). </p>
<p> </p>
<p> </p>
<p><b>12.6.13 DynamicallyDefineDataIdentifier  ($2C) (UDS) functions </b></p>
<p>Since this feature is only for some OEM available, please refer to the OEM specific documentation </p>
<p>to find out if is applicable for your configuration. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>120 / 164 </p>
<p><b>12.6.13.1 DescMayCallStateTaskAgain() </b></p>
<p><b>DescMayCallStateTaskAgain </b></p>
<p><b>Available since 4.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>DescBool <b>DescMayCallStateTaskAgain </b>(void) </p>
<p>Multi Context </p>
<p>DescBool <b>DescMayCallStateTaskAgain </b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>-  </p>
<p><b>Return code </b></p>
<p>kDescTrue </p>
<p>kDescFalse </p>
<p> TRUE if you may call again the state task within this application </p>
<p>task cycle. </p>
<p> FALSE if the DescStateTask() must not be called again. </p>
<p><b>Functional Description </b></p>
<p>Motivation: The <i><b>DescStateTask() </b></i>can be called as fast as possible but it still can not be </p>
<p>enough fast for complex service processing (e.g. DDIDs containing long descriptions) to </p>
<p>match fast timing-performance requirements. This function provides the info if the </p>
<p>application may call again the state-task in the same task context without causing endless </p>
<p>loop (important for non-preemptive OS environments). </p>
<p>Example of the API usage: </p>
<p>void ApplDiagTask(void) /* application function called as fast as possible */ </p>
<p>{ </p>
<p>   do /* pump the state task as long as needed */ </p>
<p>   { </p>
<p>     DescStateTask(); </p>
<p>   } </p>
<p>   while(<b>DescMayCallStateTaskAgain</b>() == kDescTrue); </p>
<p>} </p>
<p><b>Pre-conditions </b></p>
<p>- Preprocessor define “<b>DESC_ENABLE_HIPERFORMANCE_DYNDID_MODE</b>” is </p>
<p>available (using user-config file in GENtool). </p>
<p>- The application uses the split-task concept (i.e. calls <i><b>DescState-/TimerTask() </b></i>instead of </p>
<p><i><b>DescTask()</b></i>). </p>
<p><b>Call context </b></p>
<p>Background-loop level or OSEK-OS Task. The Task should have a lower or equal priority </p>
<p>than all other interaction to the CANdesc component. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>121 / 164 </p>
<p><b>12.6.13.2 ApplDescCheckDynDidMemoryArea() </b></p>
<p><b>ApplDescCheckDynDidMemoryArea</b></p>
<p><b>  </b></p>
<p><b>Available since 3.02.00 </b></p>
<p><b>Must be Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Any Context </p>
<p>DescDynDidMemCheckResult  <b>ApplDescCheckDynDidMemoryArea </b>( </p>
<p> DescDynDidMemBlockAddress srcAddr, </p>
<p> DescDynDidMemBlockSize    len      ); </p>
<p><b>Parameter </b></p>
<p>srcAddr </p>
<p>Start address (Service $2C 02 request parameter ‘memoryAddress’). </p>
<p>len </p>
<p>Length of block to read (Service $2C 02 request parameter </p>
<p>‘memorySize’). </p>
<p><b>Return code </b></p>
<p>memBlockOk </p>
<p>Permit the access to requested memory block and extend the DDID. </p>
<p>memBlockInvAddress</p>
<p> </p>
<p>Forbid the access due invalid requested memory address </p>
<p>(requestOutOfRange). </p>
<p>memBlockInvSize </p>
<p>Forbid the access due invalid requested block length </p>
<p>(requestOutOfRange). </p>
<p>memBlockInvSecurity </p>
<p>Forbid the access due current security mode settings prohibit the DDID </p>
<p>definition (securityAccessDenied). </p>
<p>memBlockInvCondition </p>
<p>Forbid the access due other restrictions (conditionsNotCorrect). </p>
<p>If the memory access if forbidden, the Service $2C Request is negative responded with NRC 22 </p>
<p>(conditionsNotCorrect), 31 (requestOutOfRange) or 33 (securityAccessDenied). </p>
<p><b>Functional Description </b></p>
<p>This callback function is triggered when defining a DDID that shall read bytes from the ECU’s </p>
<p>memory (Service Request $2C 02). The application can permit the (re-)definition of the DDID or </p>
<p>forbid it. </p>
<p>The service request is responded according to this. </p>
<p>The application must check </p>
<p></p>
<p> </p>
<p>if the given </p>
<p>srcAddr</p>
<p> and following </p>
<p>len</p>
<p> bytes are valid ECU addresses and if they are </p>
<p>readable, </p>
<p></p>
<p> </p>
<p>if the current security state allows to define the DDID right now, </p>
<p></p>
<p> </p>
<p>if there are other conditions that may forbid the definition of the DDID. </p>
<p>If all checks allow the DDID definition, the callback function must return </p>
<p>memBlockOk.</p>
<p> </p>
<p>FYI: When later reading the defined DDIDs by service $22, the standard checks [of Service $23 </p>
<p>ReadMemoryByAddress] are executed, that perform security checks before accessing the </p>
<p>memory. </p>
<p>So, above security check with service $2C shall prove that the current security state permits the </p>
<p><i>definition </i>of the DDID, the security check in service $22 (resp. $23) proves [in the context of the </p>
<p>then existing security state] the actual <i>reading </i>of the memory range. </p>
<p><b>Pre-conditions </b></p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>122 / 164 </p>
<p><b>Call context </b></p>
<p>From <b>DescTask() </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p><b>12.6.13.3 Non-volatile memory support </b></p>
<p>For  some  car-manufactures  CANdesc  provides  NVRAM  support  for  the  dynamically </p>
<p>defined DID definitions. There are some APIs that must be operated and some call-backs </p>
<p>to be implemented by the application in order to get the NVRAM support fully operational. </p>
<p> </p>
<p>The following diagrams show the two oeprations on NVRAM – restore (at power on) and st </p>
<p>ore (usuall prior power off) data. </p>
<p> </p>
<p><b>Restore data at ECU power on </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>At each CANdesc initialization (e.g. ECU reset/ power on) the “restore” procedure must </p>
<p>be performed! </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>123 / 164 </p>
<p><b> </b></p>
<p> </p>
<p>Figure 12-1 DynDID definition restore and tester interaction </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>124 / 164 </p>
<p><b>Store data at ECU power down </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>The store operation can be performed at any time not only at power down. </p>
<p><b> </b></p>
<p> </p>
<p>Figure 12-2 Store DynDID definitions </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>125 / 164 </p>
<p><b>12.6.13.3.1 DescDynDefineDidPowerUp() </b></p>
<p><b>DescDynDefineDidPowerUp </b></p>
<p><b>Available since 5.06.09 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescDynDefineDidPowerUp </b>(void) </p>
<p>Multi Context </p>
<p>void <b>DescDynDefineDidPowerUp </b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Once the ECU has been powered one/reset or just need to be reinitialized, this API must </p>
<p>be called to restore the dynamically defined DID content. </p>
<p> </p>
<p>Usually called after the NVRAM manager is initialized. </p>
<p><b>Pre-conditions </b></p>
<p>- Service 0x2C needs to store the DynDID definitions to the NVRAM (OEM specific </p>
<p>requirement) </p>
<p><b>Call context </b></p>
<p>- any  </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>Must be called after DescInitPowerOn(). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>126 / 164 </p>
<p><b>12.6.13.3.2 DescDynIdMemContentRestored () </b></p>
<p><b>DescDynIdMemContentRestored </b></p>
<p><b>Available since 5.06.09 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescDynIdMemContentRestored </b>(DescDynDidStorageInfo storageInfo) </p>
<p>Multi Context </p>
<p>void <b>DescDynIdMemContentRestored </b>(DescDynDidStorageInfo storageInfo) </p>
<p><b>Parameter </b></p>
<p>storageInfo.nvData </p>
<p>storageInfo.nvDataSize </p>
<p>storageInfo.checkSum </p>
<p>Not used </p>
<p>The size (in bytes) of the restored table. </p>
<p>The stored checksum, calculated by CANdesc at store time. </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>After CANdesc has requested the application to restore the DynDID data </p>
<p>(“<i>ApplDescRestoreDynIdMemContent ()</i>”), this API must be called to notify CANdesc that </p>
<p>the DynDID content has been restored and can be used. </p>
<p> </p>
<p><b>Pre-conditions </b></p>
<p>- Service 0x2C needs to store the DynDID definitions to the NVRAM (OEM specific </p>
<p>requirement) </p>
<p><b>Call context </b></p>
<p>- any  </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>none </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>127 / 164 </p>
<p><b>12.6.13.3.3 DescDynDefineDidPowerDown () </b></p>
<p><b>DescDynDefineDidPowerDown </b></p>
<p><b>Available since 5.06.09 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>DescDynDefineDidPowerDown </b>(void) </p>
<p>Multi Context </p>
<p>void <b>DescDynDefineDidPowerDown </b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>If the ECU has to be reset or just power off /shutdown, this API must be called to store the </p>
<p>current DID definitions.  </p>
<p> </p>
<p>In order to save E2PROM write cycles, the application may perform compare to the </p>
<p>current E2PROM content and decide whether to store the table content or not. </p>
<p><b>Pre-conditions </b></p>
<p>- Service 0x2C needs to store the DynDID definitions to the NVRAM (OEM specific </p>
<p>requirement) </p>
<p><b>Call context </b></p>
<p>- any  </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>Shall be called prior power-down/shutdown execution </p>
<p></p>
<p> </p>
<p>May be called any time to store the current content of the DynDID tables. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>128 / 164 </p>
<p><b>12.6.13.3.4 ApplDescStoreDynIdMemContent () </b></p>
<p><b>ApplDescStoreDynIdMemContent </b></p>
<p><b>Available since 5.06.09 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescStoreDynIdMemContent </b>(DescDynDidStorageInfo storageInfo) </p>
<p>Multi Context </p>
<p>void <b>ApplDescStoreDynIdMemContent </b>(DescDynDidStorageInfo storageInfo) </p>
<p><b>Parameter </b></p>
<p>storageInfo.nvData </p>
<p>storageInfo.nvDataSize </p>
<p>storageInfo.checkSum </p>
<p>The pointer to the data to be stored; </p>
<p>The size (in bytes) of the table; </p>
<p>The checksum value, calculated by CANdesc, to be stored. </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Once this API is called by CANdesc, the application must trigger a write E2PROM </p>
<p>procedure to store the data given by CANdesc and the checksum value. </p>
<p> </p>
<p>In order to save E2PROM write cycles, the application may perform compare to the </p>
<p>current E2PROM content and decide whether to store the table content or not. </p>
<p> </p>
<p><b>Pre-conditions </b></p>
<p>- Service 0x2C needs to store the DynDID definitions to the NVRAM (OEM specific </p>
<p>requirement) </p>
<p><b>Call context </b></p>
<p>- any  </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>CANdesc does not keep the data pointed by the parameter pointer during the write </p>
<p>operation! The application must mirror the data if needed! </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>129 / 164 </p>
<p><b>12.6.13.3.5 ApplDescRestoreDynIdMemContent () </b></p>
<p><b>ApplDescRestoreDynIdMemContent </b></p>
<p><b>Available since 5.06.09 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescRestoreDynIdMemContent </b>(DescDynDidStorageInfo storageInfo) </p>
<p>Multi Context </p>
<p>void <b>ApplDescRestoreDynIdMemContent </b>(DescDynDidStorageInfo storageInfo) </p>
<p><b>Parameter </b></p>
<p>storageInfo.nvData </p>
<p>storageInfo.nvDataSize </p>
<p>storageInfo.checkSum </p>
<p>The pointer to the data to where the stored data shall be written </p>
<p>The size (in bytes) of the table expected. </p>
<p>Not used  </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Once this API is called by CANdesc, the application must trigger a read E2PROM </p>
<p>procedure to restore the data for CANdesc and the checksum value. </p>
<p> </p>
<p>Once the read process has completed, the API “<i>DescDynIdMemContentRestored ()</i>” must </p>
<p>be called to acknowledge the operation status to CANdesc. </p>
<p><b>Pre-conditions </b></p>
<p>- Service 0x2C needs to store the DynDID definitions to the NVRAM (OEM specific </p>
<p>requirement) </p>
<p><b>Call context </b></p>
<p>- any  </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>130 / 164 </p>
<p><b>12.6.14 Memory Access Callbacks </b></p>
<p><b>12.6.14.1 ApplDescReadMemoryByAddress() </b></p>
<p><b>ApplDescReadMemoryByAddress </b></p>
<p><b>Available since 5.06.04 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Any Context </p>
<p>void <b>ApplDescReadMemoryByAddress </b>(DescMsgContext* pMsgContext, </p>
<p>t_descMemByAddrInfo* pMemInfo) </p>
<p><b>Parameter </b></p>
<p>pMsgContext </p>
<p>Refer the section 12.6.4.2 Service MainHandler for details </p>
<p>about this parameter. </p>
<p>pMsgContext-&gt;resData </p>
<p>The response buffer pointer </p>
<p>pMsgContext-&gt;resDataLen </p>
<p>The actual response length </p>
<p>pMemInfo-&gt;address </p>
<p>The address to read from </p>
<p>pMemInfo-&gt;length </p>
<p>The number of bytes to read </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This callback is called for read memory by address requests. The application has to do </p>
<p>following: </p>
<p></p>
<p> </p>
<p>Perform memory block validation (negative response can be set by calling </p>
<p><i>DescSetNegResponse()</i>). </p>
<p></p>
<p> </p>
<p>Optional: Perform additional state validations (negative response can be set by </p>
<p>calling <i>DescSetNegResponse()</i>). </p>
<p></p>
<p> </p>
<p>Copy the requested memory contents into the response buffer. </p>
<p></p>
<p> </p>
<p>Set the response data length to the number of bytes copied. </p>
<p></p>
<p> </p>
<p>Confirm that the processing is finished (by calling <i>DescProcessingDone()</i>). </p>
<p><b>Pre-conditions </b></p>
<p></p>
<p> </p>
<p>The read memory by address service is supported. </p>
<p></p>
<p> </p>
<p>Refer to chapter <i>9.3 Read/Write Memory by Address (SID $23/$3D) (UDS) </i>for more </p>
<p>details of the availability of this API. If you don’t see this API provided in desc.h, then </p>
<p>this feature is not supported for your project. </p>
<p><b>Call context </b></p>
<p>From <b>DescTask() </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>To call this handler periodically, ‘DescStartMemByAddrRepeatedCall’ needs to be used </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>131 / 164 </p>
<p><b>12.6.14.2 ApplDescWriteMemoryByAddress() </b></p>
<p><b>ApplDescWriteMemoryByAddress </b></p>
<p><b>Available since 5.06.04 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Any Context </p>
<p>void <b>ApplDescWriteMemoryByAddress </b>(DescMsgContext* pMsgContext, </p>
<p>t_descMemByAddrInfo* pMemInfo) </p>
<p><b>Parameter </b></p>
<p>pMsgContext </p>
<p>Refer the section 12.6.4.2 Service MainHandler for details </p>
<p>about this parameter. </p>
<p>pMsgContext-&gt;reqData </p>
<p>The pointer to the data to store </p>
<p>pMemInfo-&gt;address </p>
<p>The address to write to </p>
<p>pMemInfo-&gt;length </p>
<p>The number of bytes to write </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This callback is called for write memory by address requests. The application has to do </p>
<p>following: </p>
<p></p>
<p> </p>
<p>Perform memory block validation (negative response can be set by calling </p>
<p><i>DescSetNegResponse()</i>). </p>
<p></p>
<p> </p>
<p>Optional: Perform additional state validations (negative response can be set by </p>
<p>calling <i>DescSetNegResponse()</i>). </p>
<p></p>
<p> </p>
<p>Copy the provided data into the memory area. </p>
<p></p>
<p> </p>
<p>Confirm that the processing is finished (by calling <i>DescProcessingDone()</i>). </p>
<p><b>Pre-conditions </b></p>
<p></p>
<p> </p>
<p>The write memory by address service is supported. </p>
<p></p>
<p> </p>
<p>Refer to chapter <i>9.3 Read/Write Memory by Address (SID $23/$3D) (UDS) </i>for more </p>
<p>details of the availability of this API. If you don’t see this API provided in desc.h, then </p>
<p>this feature is not supported for your project. </p>
<p><b>Call context </b></p>
<p>From <b>DescTask() </b></p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>To call this handler periodically, ‘DescStartMemByAddrRepeatedCall’ needs to be used </p>
<p> </p>
<p><b>12.6.15 Flash Boot Loader Support </b></p>
<p>CANdesc provides some features to comply with the HIS flash boot loader procedures.  </p>
<p>These features are not released for all OEMs so if the below listed APIs are not available </p>
<p>in your CANdesc version, then for the OEM, you currently use CANdesc, does not require, </p>
<p>resp. has another FBL procedures. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>132 / 164 </p>
<p><b>12.6.15.1 DescSendPosRespFBL() </b></p>
<p><b>DescSendPosRespFBL </b></p>
<p><b>Available since 4.05.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Any Context </p>
<p>void <b>DescSendPosRespFBL </b>(t_descFblPosRespType posRespSId) </p>
<p><b>Parameter </b></p>
<p>posRespSId </p>
<p>One of the following values are allowed: </p>
<p></p>
<p> </p>
<p>kDescSendFblPosRespEcuHardReset </p>
<p></p>
<p> </p>
<p>kDescSendFblPosRespDscDefault. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The application shall call this function as soon as possible after the initialization of the </p>
<p>CANdesc component is done and the ECU is able to communicate. </p>
<p> </p>
<p>Once this function called, CANdesc will try to send the corresponding positive response </p>
<p>as follows: </p>
<p></p>
<p> </p>
<p>kDescSendFblPosRespEcuHardReset – a positive response to EcuHardReset ($51 </p>
<p>$01) will be sent. </p>
<p></p>
<p> </p>
<p>kDescSendFblPosRespDscDefault – a positive response to DiagnosticSessionControl </p>
<p>Default session ($50 $01 $P2time $P2Star/10) will be sent. </p>
<p> </p>
<p>If CANdesc is currently busy with a new tester request, there will be no response sent by </p>
<p>this API. </p>
<p><b>Pre-conditions </b></p>
<p>The FBL positive response feature is supported. </p>
<p><b>Call context </b></p>
<p>Any. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>See 13.8 </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>133 / 164 </p>
<p><b>12.6.15.2 ApplDescInitPosResFblBusInfo() </b></p>
<p><b>ApplDescInitPosResFblBusInfo </b></p>
<p><b>Available since 5.07.04 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Any Context </p>
<p>vuint8 <b>ApplDescInitPosResFblBusInfo </b>(t_descUsdtNetBus* pBusInfo) </p>
<p><b>Parameter </b></p>
<p>pBusInfo </p>
<p>Reference to the bus information structure that will be </p>
<p>initialized here. </p>
<p>pBusInfo-&gt;busType </p>
<p>The bus driver that will send the response </p>
<p>pBusInfo-&gt;comChannel </p>
<p>The communication channel on which the response will be </p>
<p>sent. (relevant only on multi channel systems) </p>
<p>pBusInfo-&gt;testerId </p>
<p>The tester address which will be respond to. (relevant only on </p>
<p>bus systems with source/target addresses) </p>
<p><b>Return  code </b></p>
<p>kDescOk </p>
<p>Operation was successful, the FBL positive response will be </p>
<p>sent. </p>
<p>kDescFailed </p>
<p>Operation failed – no FBL positive response will be sent. </p>
<p><b>Functional Description </b></p>
<p>This callback is called once the application decided to call the API <i>DescSendPosRespFBL </i></p>
<p>to get the concrete addressing information.  </p>
<p> </p>
<p>The application shall initialize only the parameter described above. The optional ones can </p>
<p>be skipped if not relevant on your system. </p>
<p> </p>
<p><b>Pre-conditions </b></p>
<p>The FBL positive response feature is supported. </p>
<p><b>Call context </b></p>
<p>From <i>DescSendPosRespFBL </i>context. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>- </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>134 / 164 </p>
<p><b>12.6.16 Debug Interface / Assertion </b></p>
<p><b>12.6.16.1 ApplDescFatalError() </b></p>
<p><b>ApplDescFatalError </b></p>
<p><b>Available since 2.00.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescFatalError </b>(vuint8 errorCode, vuint16 lineNumber) </p>
<p>Multi Context </p>
<p>void <b>ApplDescFatalError </b>(vuint8 errorCode, vuint16 lineNumber) </p>
<p><b>Parameter </b></p>
<p>errorCode </p>
<p>The errorCode is a classification of the assertion. The </p>
<p>errorCodes can be also found in file ‘desc.h’. The errorCodes </p>
<p>are listed below: </p>
<p>lineNumber </p>
<p>A line number of file ‘desc.c’ from which this function is called.  </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The CANdesc debug interface is similar to assertion constructof common programming </p>
<p>languages. Assertions are code checks which are written so that they should always </p>
<p>evaluate to true. If an assertion is false, it indicates a possible bug in the program, corrupt </p>
<p>system state or a misoperation of the user-interface.  </p>
<p>CANdesc is calling the function ApplDescFatalError() function to indicate a evaluation of </p>
<p>an assertion to false. If this will happen it is recommended to halt the program's execution </p>
<p>immediately. This could be reach by an endless loop in that call-back. </p>
<p>The assertions can be disabled in the GenTool settings. The resource (ROM and runtime) </p>
<p>consumption can be reduced by disabling the assertions. </p>
<p><b>Error codes </b></p>
<p><b>kDescAssertWrongTpTxChannel </b>(0x00):  </p>
<p>The wrong TP channel is used – verify the TP interface to the CANdesc component </p>
<p> </p>
<p><b>kDescAssertIndexTableInvalidReference </b>(0x02): </p>
<p>Internal generation failure. </p>
<p> </p>
<p><b>kDescAssertSvcTableUnreachableItem </b>(0x03): </p>
<p>Internal generation failure. </p>
<p> </p>
<p><b>kDescAssertSvcTableInvalidReference </b>(0x04): </p>
<p>Internal generation failure. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>135 / 164 </p>
<p><b>kDescAssertSvcTableInconsistentNumber </b>(0x05): </p>
<p>Internal generation failure. </p>
<p> </p>
<p><b>kDescAssertMissingMainHandler </b>(0x06): </p>
<p>Internal generation failure. </p>
<p> </p>
<p><b>kDescAssertInvalidContextId </b>(0x08): </p>
<p>Wrong iContext should be used - Check the consistency of the iContext parameter in the </p>
<p>application. </p>
<p> </p>
<p><b>kDescAssertSvcTableIndexOutOfRange </b>(0x09): </p>
<p>Internal generation failure. </p>
<p> </p>
<p><b>kDescAssertSvcInstTableIndexOutOfRange </b>(0x0A): </p>
<p>Internal generation failure. </p>
<p> </p>
<p><b>kDescAssertContextIdWasModified </b>(0x0B):  </p>
<p>The iContext member of the pMsgContext parameter in the MainHandler functions are </p>
<p>illegal modified – verify the MainHandler functions in the application  </p>
<p> </p>
<p><b>kDescAssertProcessingDoneCallAfterResFlushing </b>(0x0E): </p>
<p>DescProcessingDone() is called at least twice for one request – check the call of </p>
<p>DescProcessingDone() in the application. </p>
<p> </p>
<p><b>kDescAssertTooLongSingleFrameResponse </b>(0x0F): </p>
<p>Response lengthof a periodic DID is exceeding the SingleFrame length – check the </p>
<p>response length for periodic DIDs. </p>
<p> </p>
<p><b>kDescAssertApplLackOfConfirmation </b>(0x11): </p>
<p>The time for response processing is too long – verify if the call of DescProcessingDone() </p>
<p>is done in any case. </p>
<p> </p>
<p><b>kDescAssertZeroStateValue </b>(0x13): </p>
<p>The state parameter is zero – check state handling </p>
<p> </p>
<p><b>kDescAssertInvalidContextMode </b>(0x16): </p>
<p>Internal runtime error </p>
<p> </p>
<p><b>kDescAssertUnexpectedWriteIntoRingBuffer </b>(0x17): </p>
<p>DescRingBufferWrite() is called without activated ring-buffer </p>
<p> </p>
<p><b>kDescAssertRingBufferWriteExceedsTheResLen </b>(0x18): </p>
<p>DescRingBufferWrite() is called to often  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>136 / 164 </p>
<p><b>kDescAssertIllegalUsageOfNegativeResponse </b>(0x1A): </p>
<p>After call of DescProcessingDone() a negative response is set  </p>
<p> </p>
<p><b>kDescAssertDiagnosticBufferOverflow </b>(0x1B): </p>
<p>currently not available </p>
<p> </p>
<p><b>kDescAssertFuncReqWoResMayNotUseRingBuffer </b>(0x1C): </p>
<p>It is not possible to use the ring-buffer feature for functional request (KWP only) </p>
<p> </p>
<p><b>kDescAssertSchedulerTimerEventWithoutAnyPID </b>(0x1E): </p>
<p>Internal runtime error </p>
<p> </p>
<p><b>kDescAssertSchedulerRingBufferIsActivated </b>(0x1F): </p>
<p>For periodic DIDs it is not possible to use the ring-buffer. </p>
<p> </p>
<p><b>kDescAssertUnknownTpTransmissionType </b>(0x21): </p>
<p>Internal runtime error </p>
<p> </p>
<p><b>kDescAssertIllegalAddRequestCount </b>(0x22): </p>
<p>Internal runtime error </p>
<p> </p>
<p><b>kDescAssertNoSidCanBeReportedInIdleMode </b>(0x23): </p>
<p>Call of DescGetSeriveId() while not a user-service is processed </p>
<p> </p>
<p><b>kDescAssertInvalidUsageOfForceRcrRpApi </b>(0x24): </p>
<p>The DescForceRcrRpResponse() function is used illegal. </p>
<p> </p>
<p><b>kDescAssertPidResLenToCddDefNotMatched </b>(0x26): </p>
<p>The response length set by the application do not fit to the response length defined in </p>
<p>CANdela (cdd). </p>
<p> </p>
<p><b>kDescAssertPidResLenToCurrLinearFreeSpace </b>(0x27): </p>
<p>Internal runtime error </p>
<p> </p>
<p><b>kDescAssertMissingDataForTransmission </b>(0x28): </p>
<p>Internal runtime error </p>
<p> </p>
<p><b>kDescAssertSchedulerFreeCellNotFound </b>(0x29): </p>
<p>Internal runtime error </p>
<p> </p>
<p><b>kDescAssertInvalidStateParameterValue </b>(0x2A): </p>
<p>The state parameter value is wrong – check state handling in your application </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>137 / 164 </p>
<p><b>kDescAssertNoFreeICNChannel </b>(0x2B): </p>
<p>Internal runtime error </p>
<p> </p>
<p><b>kDescAssertInvalidDescICNClient </b>(0x2C): </p>
<p>Internal runtime error </p>
<p> </p>
<p><b>kDescAssertNoFreeMsgContext </b>(0x2D): </p>
<p>Internal runtime error </p>
<p> </p>
<p><b>kDescAssertUnExpectedContextWithResponse </b>(0x2E): </p>
<p>A response will be sent out of a wrong context.  </p>
<p> </p>
<p><b>kDescAssertIllegalCallOfRingBufferCancel </b>(0x2F): </p>
<p>The API <i>DescRingBufferCancel() </i>has been called for a response that is not using the ring-</p>
<p>buffer concept (e.g. <i>DescRingBufferStart() </i>was not called). </p>
<p> </p>
<p><b>kDescNetAssertWrongIsoTpRxChannel </b>(0x40): </p>
<p>The wrong TP channel is used – verify the TP interface to the CANdesc component </p>
<p> </p>
<p><b>kDescNetAssertWrongIsoTpTxChannel </b>(0x41): </p>
<p>The wrong TP channel is used – verify the TP interface to the CANdesc component </p>
<p> </p>
<p><b>kDescNetAssertWrongBusType </b>(0x42): </p>
<p>The wrong bus type is used – verify the TP interface to the CANdesc component </p>
<p> </p>
<p><b>kDescAssertDescIcnIllegalTargetPointer </b>(0x50): </p>
<p>Internal runtime assertion  </p>
<p> </p>
<p><b>Pre-conditions </b></p>
<p>At least on type of assertions are activated </p>
<p><b>Call context </b></p>
<p>Form ISR or task level. The interrupts might be disabled </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>After a call of this function the system is not stable anymore. It can not be guaranteed </p>
<p>that this component or the whole system is still working in correct manner.  </p>
<p><b>12.6.17 “Spontaneous Response” transmission </b></p>
<p> </p>
<p>To implement the service $86 (Respone On Event) it is necessary to transmit a message </p>
<p>without a previous request. If the same CAN ID have to be used for this reponse as for the </p>
<p>diagnostics response, CANdesc provides an API to trigger the transmission. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>138 / 164 </p>
<p><b>12.6.17.1 DescApplSendSpontaneousResponse() </b></p>
<p><b>DescApplSendSpontaneousResponse </b></p>
<p><b>Available since 6.09.00 </b></p>
<p><b>Is Reentrant </b></p>
<p><b> </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Any Context </p>
<p>DescBool <b>DescApplSendSpontaneousResponse</b>(DescMsg resData,  </p>
<p>                                         DescMsgLen resLen,  </p>
<p>                                         t_descUsdtNetBus* pBusInfo) </p>
<p><b>Parameter </b></p>
<p>resData </p>
<p>Pointer to an application buffer with response data (including </p>
<p>posive response header). </p>
<p>resLen </p>
<p>Number of bytes to be sent (up to 4095 bytes). </p>
<p>pBusInfo </p>
<p>Reference to the bus information structure that will be initialized </p>
<p>here. </p>
<p>pBusInfo-&gt;busType </p>
<p>The bus driver that will send the response. </p>
<p>pBusInfo-&gt;comChannel </p>
<p>The communication channel on which the response will be sent. </p>
<p>(relevant only on multi channel systems). </p>
<p>pBusInfo-&gt;testerId </p>
<p>The tester address which will be respond to (relevant only on </p>
<p>bus systems with source/target addresses). </p>
<p><b>Return  code </b></p>
<p>kDescTrue </p>
<p>Operation was successful, the response will be sent. </p>
<p>kDescFalse </p>
<p>Operation failed – no response will be sent. </p>
<p><b>Functional Description</b> </p>
<p>Calling this function the application can force CANdesc to send immediately a </p>
<p>spontaneous response. </p>
<p>If CANdesc is currently busy with a tester request, there will be no response sent by this </p>
<p>API and </p>
<p>kDescFalse</p>
<p> will be returned. </p>
<p>If this API returns </p>
<p>kDescTrue</p>
<p>, the application shall wait for the </p>
<p><i>ApplDescSpontaneousResponseConfirmation() </i>prior initiating a new spontaneous </p>
<p>transmission. </p>
<p><b>Pre-conditions </b></p>
<p>CANdesc was configured to use this option (enabled in the GENtool). Only possible to </p>
<p>configure if Service 0x86 is contained in the cdd. </p>
<p><b>Call context </b></p>
<p>Task or interrupt. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>- </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>139 / 164 </p>
<p><b>12.6.17.2 ApplDescSpontaneousResponseConfirmation() </b></p>
<p><b>ApplDescSpontaneousResponseConfirmation </b></p>
<p><b>Available since 6.09.00 </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescSpontaneousResponseConfirmation</b>(vuint8 status) </p>
<p>Multi Context </p>
<p>void <b>ApplDescSpontaneousResponseConfirmation </b>(vuint8 iContext, vuint8 status) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>Will be always “kDescPrimContext”. </p>
<p>status </p>
<p>If the transmission was successful, the parameter value will be </p>
<p><i>kDescOk</i>. Otherwise – <i>kDescFailed. </i></p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Once the spontaneous response has been successfully triggered (ref. </p>
<p><i>DescApplSendSpontaneousResponse()</i>), this function will be called in any case. The </p>
<p>transmission status is reported by the status parameter. </p>
<p> </p>
<p><b>Pre-conditions </b></p>
<p>Only available if the API <i>DescApplSendSpontaneousResponse() </i>is available. </p>
<p><b>Call context </b></p>
<p>CAN Driver TX-ISR </p>
<p></p>
<p> TP Confirmation </p>
<p></p>
<p> this function </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>Be aware of time consuming implementation for this function (interrupt call context). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>140 / 164 </p>
<p><b>12.6.18 Generic Processing Notifications  </b></p>
<p><b>12.6.18.1 ApplDescManufacturerIndication </b></p>
<p><b>ApplDescManufacturerIndication </b></p>
<p><b>Available since 6.13.00 </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescManufacturerIndication</b>(vuint8 sid, </p>
<p>vuint8* data, </p>
<p>vuint16 length, </p>
<p>vuint8 reqType, </p>
<p>t_descUsdtNetBus* pBusInfo) </p>
<p>Multi Context </p>
<p>void <b>ApplDescManufacturerIndication</b>(vuint8 iContext, </p>
<p>vuint8 sid, </p>
<p>vuint8* data, </p>
<p>vuint16 length, </p>
<p>vuint8 reqType, </p>
<p>t_descUsdtNetBus* pBusInfo) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>The current request context location </p>
<p>(used only as a handle - <i>DO NOT MODIFY</i>). </p>
<p>sid </p>
<p>The service identifier of the received service request. </p>
<p>data </p>
<p>Pointer to the first byte of the request data (without service </p>
<p>identifier byte). </p>
<p>length </p>
<p>Length of the request data (without service identifier byte) </p>
<p>reqType </p>
<p>The current request addressing method. Could be either </p>
<p>‚kDescFuncReq’ or ‚kDescPhysReq’ (bitmapped). </p>
<p>pBusInfo </p>
<p>The current request communication information (i.e. driver type </p>
<p>(CAN, MOST, FlexRay, etc.), addressing information, </p>
<p>communication channel number, tester address (if applicable) </p>
<p>etc. </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function is called right before CANdesc starts the processing of a received request. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>141 / 164 </p>
<p><b>Pre-conditions </b></p>
<p>Only available if the feature “Manufacturer Notification Support” is activated and CANdesc </p>
<p>UDS2012 is used. </p>
<p><b>Call context </b></p>
<p>From <b>DescTask() </b></p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p> </p>
<p><b>12.6.18.2 ApplDescManufacturerConfirmation </b></p>
<p><b>ApplDescManufacturerConfirmation </b></p>
<p><b>Available since 6.13.00 </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescManufacturerConfirmation</b>(vuint8 status) </p>
<p>Multi Context </p>
<p>void <b>ApplDescManufacturerConfirmation</b>(vuint8 iContext, </p>
<p>vuint8 status) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>The current request context location </p>
<p>(used only as a handle - <i>DO NOT MODIFY</i>). </p>
<p>status </p>
<p><b>kDescPostHandlerStateOk  </b></p>
<p>The positive response was transmitted successfully </p>
<p><b>kDescPostHandlerStateNegResSent  </b></p>
<p>It was a negative response </p>
<p><b>kDescPostHandlerStateTxFailed   </b></p>
<p>A transmission error occurred </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function is called after the processing of a request has been finished, a response has </p>
<p>been sent (or sending has failed) and all service PostHandlers were called. </p>
<p> </p>
<p><b>Pre-conditions </b></p>
<p>Only available if the feature “Manufacturer Notification Support” is activated and CANdesc </p>
<p>UDS2012 is used. </p>
<p><b>Call context </b></p>
<p>From <b>DescTask () </b></p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>142 / 164 </p>
<p><b>12.6.18.3 ApplDescSupplierIndication </b></p>
<p><b>ApplDescSupplierIndication </b></p>
<p><b>Available since 6.13.00 </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescSupplierIndication</b>(vuint8 sid, </p>
<p>vuint8* data, </p>
<p>vuint16 length, </p>
<p>vuint8 reqType, </p>
<p>t_descUsdtNetBus* pBusInfo) </p>
<p>Multi Context </p>
<p>void <b>ApplDescSupplierIndication</b>(vuint8 iContext, </p>
<p>vuint8 sid, </p>
<p>vuint8* data, </p>
<p>vuint16 length, </p>
<p>vuint8 reqType, </p>
<p>t_descUsdtNetBus* pBusInfo) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>The current request context location </p>
<p>(used only as a handle - <i>DO NOT MODIFY</i>). </p>
<p>sid </p>
<p>The service identifier of the received service request. </p>
<p>data </p>
<p>Pointer to the first byte of the request data (without service </p>
<p>identifier byte). </p>
<p>length </p>
<p>Length of the request data (without service identifier byte) </p>
<p>reqType </p>
<p>The current request addressing method. Could be either </p>
<p>‚kDescFuncReq’ or ‚kDescPhysReq’ (bitmapped). </p>
<p>pBusInfo </p>
<p>The current request communication information (i.e. driver type </p>
<p>(CAN, MOST, FlexRay, etc.), addressing information, </p>
<p>communication channel number, tester address (if applicable) </p>
<p>etc. </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function is called during the processing of a request, after CANdesc has verified that </p>
<p>the requested service is allowed in the active session and security state. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>143 / 164 </p>
<p><b>Pre-conditions </b></p>
<p>Only available if the feature “Supplier Notification Support” is activated and CANdesc </p>
<p>UDS2012 is used. </p>
<p><b>Call context </b></p>
<p>From <b>DescTask() </b></p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p><b>12.6.18.4 ApplDescSupplierConfirmation </b></p>
<p><b>ApplDescSupplierConfirmation </b></p>
<p><b>Available since 6.13.00 </b></p>
<p><b>Is callback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Single Context </p>
<p>void <b>ApplDescSupplierConfirmation</b>(vuint8 status) </p>
<p>Multi Context </p>
<p>void <b>ApplDescSupplierConfirmation</b>(vuint8 iContext, </p>
<p>vuint8 status) </p>
<p><b>Parameter </b></p>
<p>iContext </p>
<p>The current request context location </p>
<p>(used only as a handle - <i>DO NOT MODIFY</i>). </p>
<p>status </p>
<p><b>kDescPostHandlerStateOk  </b></p>
<p>The positive response was transmitted successfully </p>
<p><b>kDescPostHandlerStateNegResSent  </b></p>
<p>It was a negative response </p>
<p><b>kDescPostHandlerStateTxFailed   </b></p>
<p>A transmission error occurred </p>
<p><b>Return  code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function is called after the processing of a request has been finished, a response has </p>
<p>been sent (or sending has failed) and all service PostHandlers were called. It is called </p>
<p>before <i>ApplDescManufacturerConfirmation()</i>. </p>
<p> </p>
<p><b>Pre-conditions </b></p>
<p>Only available if the feature “Supplier Notification Support” is activated and CANdesc </p>
<p>UDS2012 is used. </p>
<p><b>Call context </b></p>
<p>From <b>DescTask () </b></p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>144 / 164 </p>
<p><b>13  How To… </b></p>
<p> </p>
<p><b>13.1 </b></p>
<p><b>…implement a protocol service MainHandler </b></p>
<p> </p>
<p><i>//1. Read ProtocolService </i></p>
<p><i>// - dynamic length </i></p>
<p><i>// - PIDs </i></p>
<p> </p>
<p><b>void</b> DESC_API_CALLBACK_TYPE <b>ApplDescManiOnTimerEvent_storeEvent</b>(DescMsgContext<b>*</b> </p>
<p>pMsgContext) </p>
<p>{ </p>
<p>  <i>/* Check the length */</i> </p>
<p>  <b>if</b>(pMsgContext<b>-&gt;</b>reqDataLen <b>&gt;</b> 2) </p>
<p>  { </p>
<p>    <i>/* Check the sub-parameters */</i> </p>
<p>    vuint16 param; </p>
<p>    <i>/* Compose one parameter combining the HiByte and the LoByte in this order*/</i> </p>
<p>    param <b>=</b> <b>DescMake16Bit</b>(pMsgContext<b>-&gt;</b>reqData[0], pMsgContext<b>-&gt;</b>reqData[1]); </p>
<p> </p>
<p>    <i>/* Dispatch the parameter */</i> </p>
<p>    <b>switch</b>(param) </p>
<p>    { </p>
<p>      <b>case</b> 0xFFFF<b>:</b> </p>
<p>        <b>if</b>(pMsgContext<b>-&gt;</b>reqDataLen <b>!=</b> 0xFFFF) </p>
<p>        { </p>
<p>          <i>/* Write some data (skip the parameter offsets 0 und 1) */</i> </p>
<p>          pMsgContext<b>-&gt;</b>resData[2] <b>=</b> <b>DescGetLoByte</b>(0x1234); </p>
<p>          pMsgContext<b>-&gt;</b>resData[3] <b>=</b> <b>DescGetHiByte</b>(0x1234); </p>
<p>          <i>/* Set the response length */</i> </p>
<p>          pMsgContext<b>-&gt;</b>resDataLen <b>=</b> 4; </p>
<p>        } </p>
<p>        <b>else</b> </p>
<p>        { </p>
<p>          <b>DescSetNegResponse</b>(pMsgContext<b>-&gt;</b>iContext, kDescNrcInvalidFormat); </p>
<p>        } </p>
<p>        <b>break</b>; </p>
<p>      <b>default:</b> </p>
<p>        <i>/* unknown parameter */</i> </p>
<p>        <b>DescSetNegResponse</b>(pMsgContext<b>-&gt;</b>iContext, kDescNrcInvalidFormat); </p>
<p>    } </p>
<p>  } </p>
<p>  <b>else</b> </p>
<p>  { </p>
<p>    <b>DescSetNegResponse</b>(pMsgContext<b>-</b>iContext, kDescNrcInvalidFormat); </p>
<p>  } </p>
<p>  <i>/* In this case we did everything in the main-handler */</i> </p>
<p>  <b>DescProcessingDone</b>(pMsgContext<b>-&gt;</b>iContext); </p>
<p>} </p>
<p> </p>
<p> </p>
<p><i>//2. Read ProtocolService </i></p>
<p><i>// - dynamic length </i></p>
<p><i>// - sub-function </i></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>145 / 164 </p>
<p> </p>
<p><b>void</b> DESC_API_CALLBACK_TYPE <b>ApplDescManiOnTimerEvent_storeEvent</b>(DescMsgContext<b>*</b> </p>
<p>pMsgContext) </p>
<p>{ </p>
<p>  <i>/* Check the length */</i> </p>
<p>  <b>if</b>(pMsgContext<b>-&gt;</b>reqDataLen <b>&gt;</b> 1) </p>
<p>  { </p>
<p>    <i>/* Dispatch the sub-function */</i> </p>
<p>    <b>switch</b>(pMsgContext<b>-&gt;</b>reqData[0]) </p>
<p>    { </p>
<p>      <b>case</b> 0xFF<b>:</b> </p>
<p>        <b>if</b>(pMsgContext<b>-&gt;</b>reqDataLen <b>!=</b> 0xFFFF) </p>
<p>        { </p>
<p>          <i>/* Format check ok: write some data (skip the parameter) */</i> </p>
<p>          pMsgContext<b>-&gt;</b>resData[1] <b>=</b> <b>DescGetLoByte</b>(0x1234); </p>
<p>          pMsgContext<b>-&gt;</b>resData[2] <b>=</b> <b>DescGetHiByte</b>(0x1234); </p>
<p>          <i>/* Set the response length */</i> </p>
<p>          <i>/* Hint: if the response length wasn't set, zero value is assumed! */</i> </p>
<p>          pMsgContext<b>-&gt;</b>resDataLen <b>=</b> 3; </p>
<p>        } </p>
<p>        <b>else</b> </p>
<p>        { </p>
<p>          <i>/* Wrong sub-parameter format */</i> </p>
<p>          <b>DescSetNegResponse</b>(pMsgContext<b>-&gt;</b>iContext, kDescNrcInvalidFormat); </p>
<p>        } </p>
<p>        <b>break</b>; </p>
<p>      <b>default:</b> </p>
<p>        <i>/* Unknown sub-function */</i> </p>
<p>        <b>DescSetNegResponse</b>(pMsgContext<b>-&gt;</b>iContext, </p>
<p>                           kDescNrcSubfunctionNotSupported); </p>
<p>    } </p>
<p>  } </p>
<p>  <b>else</b> </p>
<p>  { </p>
<p>    <b>DescSetNegResponse</b>(pMsgContext<b>-</b>iContext, kDescNrcInvalidFormat); </p>
<p>  } </p>
<p>  <i>/* In this case we did everything in the main-handler */</i> </p>
<p>  <b>DescProcessingDone</b>(pMsgContext<b>-&gt;</b>iContext); </p>
<p>} </p>
<p> </p>
<p><i>//3. Write ProtocolService </i></p>
<p><i>// - dynamic length </i></p>
<p><i>// - PIDs </i></p>
<p> </p>
<p><b>void</b> DESC_API_CALLBACK_TYPE <b>ApplDescManiOnTimerEvent_storeEvent</b>(DescMsgContext<b>*</b> </p>
<p>pMsgContext) </p>
<p>{ </p>
<p>  <i>/* Check the sub-parameters */</i> </p>
<p>  vuint16 param; </p>
<p> </p>
<p>  <i>/* Check the length */</i> </p>
<p>  <b>if</b>(pMsgContext<b>-&gt;</b>reqDataLen <b>&gt;</b> 2) </p>
<p>  { </p>
<p>    <i>/* Compose one parameter combining the HiByte and the LoByte in this order </i></p>
<p><i>*/</i> </p>
<p>    param <b>=</b> <b>DescMake16Bit</b>(pMsgContext<b>-&gt;</b>reqData[0], pMsgContext<b>-&gt;</b>reqData[1]); </p>
<p> </p>
<p>    <i>/* Dispatch the parameter */</i> </p>
<p>    <b>switch</b>(param) </p>
<p>    { </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>146 / 164 </p>
<p>      <b>case</b> 0xFFFF<b>:</b> </p>
<p>        <b>if</b>(pMsgContext<b>-&gt;</b>reqDataLen <b>!=</b> 0xFFFF) </p>
<p>        { </p>
<p>          <i>/* Copy from the request data to your application */</i> </p>
<p>          <i>/* Use the data pointed by: pMsgContext-&gt;reqData[2],  </i></p>
<p><i>             pMsgContext-&gt;reqData[3], etc.*/</i> </p>
<p>        } </p>
<p>        <b>else</b> </p>
<p>        { </p>
<p>          <b>DescSetNegResponse</b>(pMsgContext<b>-&gt;</b>iContext, kDescNrcInvalidFormat); </p>
<p>        } </p>
<p>        <b>break</b>; </p>
<p>      <b>default:</b> </p>
<p>        <i>/* unknown parameter */</i> </p>
<p>        <b>DescSetNegResponse</b>(pMsgContext<b>-&gt;</b>iContext, kDescNrcRequestOutOfRange); </p>
<p>    } </p>
<p>  } </p>
<p>  <b>else</b> </p>
<p>  { </p>
<p>    <b>DescSetNegResponse</b>(pMsgContext<b>-</b>iContext, kDescNrcInvalidFormat); </p>
<p>  } </p>
<p>  <i>/* In this case we did everything in the main-handler */</i> </p>
<p>  <i>/* Hint: if the response length wasn't set, zero value is assumed! */</i> </p>
<p>  <b>DescProcessingDone</b>(pMsgContext<b>-&gt;</b>iContext); </p>
<p>} </p>
<p> </p>
<p><i>//4. Write ProtocolService </i></p>
<p><i>// - dynamic length </i></p>
<p><i>// - Sub-function </i></p>
<p> </p>
<p><b>void</b> DESC_API_CALLBACK_TYPE <b>ApplDescManiOnTimerEvent_storeEvent</b>(DescMsgContext<b>*</b> </p>
<p>pMsgContext) </p>
<p>{ </p>
<p>  <i>/* Check the sub-parameters */</i> </p>
<p>  vuint16 param; </p>
<p> </p>
<p>  <i>/* Check the length */</i> </p>
<p>  <b>if</b>(pMsgContext<b>-&gt;</b>reqDataLen <b>&gt;</b> 2) </p>
<p>  { </p>
<p>    <i>/* Compose one parameter combining the HiByte and the LoByte in this order*/</i> </p>
<p>    param <b>=</b> <b>DescMake16Bit</b>(pMsgContext<b>-&gt;</b>reqData[0], pMsgContext<b>-&gt;</b>reqData[1]); </p>
<p> </p>
<p>    <i>/* Dispatch the parameter */</i> </p>
<p>    <b>switch</b>(param) </p>
<p>    { </p>
<p>      <b>case</b> 0xFFFF<b>:</b> </p>
<p>        <b>if</b>(pMsgContext<b>-&gt;</b>reqDataLen <b>!=</b> 0xFFFF) </p>
<p>        { </p>
<p>          <i>/* Copy from the request data to your application */</i> </p>
<p>          <i>/* Use the data pointed by: pMsgContext-&gt;reqData[2],  </i></p>
<p><i>             pMsgContext-&gt;reqData[3], etc.*/</i> </p>
<p>        } </p>
<p>        <b>else</b> </p>
<p>        { </p>
<p>          <b>DescSetNegResponse</b>(pMsgContext<b>-&gt;</b>iContext, kDescNrcInvalidFormat); </p>
<p>        } </p>
<p>        <b>break</b>; </p>
<p>      <b>default:</b> </p>
<p>        <i>/* unknown sub-function <b>/</i> </b></p>
<p><b>        DescSetNegResponse</b>(pMsgContext-&gt;iContext, </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>147 / 164 </p>
<p>                           kDescNrcSubfunctionNotSupported);  </p>
<p>    } </p>
<p>  } </p>
<p>  <b>else</b> </p>
<p>  { </p>
<p>    <b>DescSetNegResponse</b>(pMsgContext<b>-</b>iContext, kDescNrcInvalidFormat); </p>
<p>  } </p>
<p>  <i>/* In this case we did everything in the main-handler */</i> </p>
<p>  <i>/* Hint: if the response length wasn't set, zero value is assumed! */</i> </p>
<p>  <b>DescProcessingDone</b>(pMsgContext<b>-&gt;</b>iContext); </p>
<p>} </p>
<p> </p>
<p><b>13.2 </b></p>
<p><b>…implement a service MainHandler </b></p>
<p> </p>
<p><i>//5. Read Service </i></p>
<p><i>// - dynamic length </i></p>
<p><i>// - sub-function/PID </i></p>
<p> </p>
<p><b>void</b> DESC_API_CALLBACK_TYPE <b>ApplDescManiOnTimerEvent_storeEvent</b>(DescMsgContext<b>*</b> </p>
<p>pMsgContext) </p>
<p>{ </p>
<p>  <i>/* Check the length */</i> </p>
<p>  <b>if</b>(pMsgContext<b>-&gt;</b>reqDataLen <b>!=</b> 0xFFFF) </p>
<p>  { </p>
<p>    <i>/* Format check ok: write some data */</i> </p>
<p>    pMsgContext<b>-&gt;</b>resData[0] <b>=</b> <b>DescGetLoByte</b>(0x1234); </p>
<p>    pMsgContext<b>-&gt;</b>resData[1] <b>=</b> <b>DescGetHiByte</b>(0x1234); </p>
<p>    <i>/* Set the response length */</i> </p>
<p>    <i>/* Hint: if the response length wasn't set, zero value is assumed! */</i> </p>
<p>    pMsgContext<b>-&gt;</b>resDataLen <b>=</b> 2; </p>
<p>  } </p>
<p>  <b>else</b> </p>
<p>  { </p>
<p>    <i>/* Wrong sub-function format */</i> </p>
<p>    <b>DescSetNegResponse</b>(pMsgContext<b>-&gt;</b>iContext, kDescNrcInvalidFormat); </p>
<p>  } </p>
<p> </p>
<p>  <i>/* In this case we did everything in the main-handler */</i> </p>
<p>  <b>DescProcessingDone</b>(pMsgContext<b>-&gt;</b>iContext); </p>
<p>} </p>
<p> </p>
<p> </p>
<p><i>//6. Read Service </i></p>
<p><i>// - static length </i></p>
<p><i>// - sub-function/PID </i></p>
<p> </p>
<p><b>void</b> DESC_API_CALLBACK_TYPE <b>ApplDescManiOnTimerEvent_storeEvent</b>(DescMsgContext<b>*</b> </p>
<p>pMsgContext) </p>
<p>{ </p>
<p>  <i>/* Format check ok: write some data */</i> </p>
<p>  pMsgContext<b>-&gt;</b>resData[0] <b>=</b> <b>DescGetLoByte</b>(0x1234); </p>
<p>  pMsgContext<b>-&gt;</b>resData[1] <b>=</b> <b>DescGetHiByte</b>(0x1234); </p>
<p>  <i>/* Set the response length */</i> </p>
<p>  <i>/* Hint: if the response length wasn't set, zero value is assumed! */</i> </p>
<p>  pMsgContext<b>-&gt;</b>resDataLen <b>=</b> 2; </p>
<p> </p>
<p>  <i>/* In this case we did everything in the main-handler */</i> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>148 / 164 </p>
<p>  <b>DescProcessingDone</b>(pMsgContext<b>-&gt;</b>iContext); </p>
<p>} </p>
<p> </p>
<p> </p>
<p><i>//7. Write Service </i></p>
<p><i>// - dynamic length </i></p>
<p><i>// - sub-function/PID </i></p>
<p> </p>
<p><b>void</b> DESC_API_CALLBACK_TYPE <b>ApplDescManiOnTimerEvent_storeEvent</b>(DescMsgContext<b>*</b> </p>
<p>pMsgContext) </p>
<p>{ </p>
<p>  <i>/* Check the length */</i> </p>
<p>  <b>if</b>(pMsgContext<b>-&gt;</b>reqDataLen <b>!=</b> 0xFFFF) </p>
<p>  { </p>
<p>    <i>/* Format check ok: write some data */</i> </p>
<p>    <i>/* Copy from the request data to your application */</i> </p>
<p>    <i>/* Use the data pointed by: pMsgContext-&gt;reqData[0],  </i></p>
<p><i>       pMsgContext-&gt;reqData[1], etc.*/</i> </p>
<p>  } </p>
<p>  <b>else</b> </p>
<p>  { </p>
<p>    <i>/* Wrong sub-function format */</i> </p>
<p>    <b>DescSetNegResponse</b>(pMsgContext<b>-&gt;</b>iContext, kDescNrcInvalidFormat); </p>
<p>  } </p>
<p> </p>
<p>  <i>/* In this case we did everything in the main-handler */</i> </p>
<p>  <i>/* Hint: if the response length wasn't set, zero value is assumed! */</i> </p>
<p>  <b>DescProcessingDone</b>(pMsgContext<b>-&gt;</b>iContext); </p>
<p>} </p>
<p> </p>
<p> </p>
<p><i>//8. Write  Service </i></p>
<p><i>// - static length </i></p>
<p><i>// - sub-function/PID </i></p>
<p> </p>
<p><b>void</b> DESC_API_CALLBACK_TYPE <b>ApplDescManiOnTimerEvent_storeEvent</b>(DescMsgContext<b>*</b> </p>
<p>pMsgContext) </p>
<p>{ </p>
<p>  <i>/* Copy from the request data to your application */</i> </p>
<p>  <i>/* Use the data pointed by: pMsgContext-&gt;reqData[0], pMsgContext-&gt;reqData[1],     </i></p>
<p><i>     etc.*/</i> </p>
<p> </p>
<p>  <i>/* In this case we did everything in the main-handler */</i> </p>
<p>  <i>/* Hint: if the response length wasn't set, zero value is assumed! */</i> </p>
<p>  <b>DescProcessingDone</b>(pMsgContext<b>-&gt;</b>iContext); </p>
<p>} </p>
<p> </p>
<p><b>13.3 </b></p>
<p><b>…implement a Signal Handler </b></p>
<p> </p>
<p><i>//1. ReadSignalHandler </i></p>
<p><i>// - length &lt;= 4Byte </i></p>
<p><i>// Limitations: No DescProcessingDone() or DescSetNegResponse() allowed. </i></p>
<p> </p>
<p>vuintx DESC_API_CALLBACK_TYPE <b>ApplDescGetTemp</b>(<b>void</b>) </p>
<p>{ </p>
<p>  <i>/* Return directly the signal value */</i> </p>
<p>  <b>return</b> (vuintx)0xFFFF; </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>149 / 164 </p>
<p>} </p>
<p> </p>
<p> </p>
<p><i>//2. ReadSignalHandler </i></p>
<p><i>// - length &gt; 4Byte </i></p>
<p><i>// Limitations: No DescProcessingDone() or DescSetNegResponse() allowed. </i></p>
<p> </p>
<p>DescMsgLen DESC_API_CALLBACK_TYPE <b>ApplDescGetTemp</b>(DescMsg tgt) </p>
<p>{ </p>
<p>  <i>/* Copy the signal data into the buffer pointed by &quot;tgt&quot;.*/</i> </p>
<p>  <i>/* Return the amount of written bytes */</i> </p>
<p>  <b>return</b> 0; </p>
<p>} </p>
<p> </p>
<p> </p>
<p><i>//3. WriteSignalHandler </i></p>
<p><i>// - length &lt;= 4Byte </i></p>
<p><i>// Limitations: No DescProcessingDone() or DescSetNegResponse() allowed. </i></p>
<p> </p>
<p><b>void</b> DESC_API_CALLBACK_TYPE <b>ApplDescGetTemp</b>(vuintx data) </p>
<p>{ </p>
<p>  <i>/* &quot;data&quot; contains the signal value as-is from the request.  </i></p>
<p><i>     Copy it into your application. */</i> </p>
<p>} </p>
<p> </p>
<p> </p>
<p><i>//4. ReadSignalHandler </i></p>
<p><i>// - length &gt; 4Byte </i></p>
<p><i>// Limitations: No DescProcessingDone() or DescSetNegResponse() allowed. </i></p>
<p> </p>
<p>DescMsgLen DESC_API_CALLBACK_TYPE <b>ApplDescGetTemp</b>(DescMsg src) </p>
<p>{ </p>
<p>  <i>/* Copy the signal data from the buffer pointed by &quot;src&quot;.*/</i> </p>
<p>  <i>/* Return the amount of copied bytes */</i> </p>
<p>  <b>return</b> 0; </p>
<p>} </p>
<p> </p>
<p><i> </i></p>
<p><b>13.4 </b></p>
<p><b>…implement a Packet Handler </b></p>
<p><i>//1. ReadPacketHandler </i></p>
<p><i>// Limitations: No DescProcessingDone() or DescSetNegResponse() allowed. </i></p>
<p> </p>
<p><b>void</b> DESC_API_CALLBACK_TYPE <b>ApplDescGetTemp</b>(DescMsg pMsg) </p>
<p>{ </p>
<p>  <i>/* Copy the signal value into the &quot;pMsg&quot; buffer. */</i> </p>
<p>  pMsg[0] <b>=</b> <b>DescGetLoByte</b>(0x1234); </p>
<p>  pMsg[1] <b>=</b> <b>DescGetLoByte</b>(0x1234); </p>
<p>} </p>
<p> </p>
<p> </p>
<p><i> </i></p>
<p><b>13.5 </b></p>
<p><b>…implement a state transition function  </b></p>
<p> </p>
<p><i>//1. StateTransitionNotification </i></p>
<p><i>// Limitations: No DescProcessingDone() or DescSetNegResponse() allowed. </i></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>150 / 164 </p>
<p> </p>
<p><b>void</b> DESC_API_CALLBACK_TYPE <b>ApplDescOnTransitionSession</b>(DescStateGroup </p>
<p>formerState, DescStateGroup newState) </p>
<p>{ </p>
<p>  <i>/* You are just notified that this state group has performed a transition from  </i></p>
<p><i>   * &quot;formerState&quot; to the &quot;newState&quot;. */</i> </p>
<p>} </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>151 / 164 </p>
<p><b>13.6 </b></p>
<p><b>…work with the ring-buffer mechanism </b></p>
<p><b>13.6.1 </b></p>
<p><b>with asynchronous write </b></p>
<p> </p>
<p><i>//1. Read Service (with asynchronous Ring-Buffer) </i></p>
<p><i>// - static length </i></p>
<p><i>// - sub-function/PID </i></p>
<p> </p>
<p>vuint8 g_iContext; </p>
<p> </p>
<p>TPMC</p>
<p>Desc</p>
<p>Appl_MainHandler</p>
<p>Appl_MainHandler_2</p>
<p>EEPROM </p>
<p>Driver</p>
<p>Appl_PostHandler</p>
<p>call</p>
<p>DescRingBufferWrite(* dataPtr, dataLength)</p>
<p>DescRingBufferWrite(* dataPtr, dataLength)</p>
<p>DescRingBufferWrite(* dataPtr, dataLength)</p>
<p>DescRingBufferGetFreeSpace</p>
<p>return countOfFreeBytesInRingBuffer</p>
<p>DescRingBufferGetProgress</p>
<p>return currentBytePosition</p>
<p>Analyze and validate request</p>
<p>Write response length</p>
<p>DescRingBufferStart()</p>
<p>DescRingBufferWrite(* dataPtr, dataLength)</p>
<p>DescRingBufferGetFreeSpace</p>
<p>return countOfFreeBytesInRingBuffer</p>
<p>Not enough free </p>
<p>bytes to write </p>
<p>new data</p>
<p>Now - it is possibel to </p>
<p>write data to the ring-buffer</p>
<p>It is not possible to write data as in </p>
<p>the standard way if a ring-buffer will </p>
<p>be used (standard way is, to write to </p>
<p>DescMsgContext-&gt;ResData)</p>
<p>StartTransmission</p>
<p>FinishTransmission</p>
<p>TpCopyToCan</p>
<p>TpCopyToCan</p>
<p>TP reads </p>
<p>asynchronous the </p>
<p>data out of the </p>
<p>ring-buffer</p>
<p>Enough data are </p>
<p>stored in the </p>
<p>ring-buffer to start </p>
<p>the transmission</p>
<p>Call of Service Post Handler</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>152 / 164 </p>
<p><b>void</b> DESC_API_CALLBACK_TYPE <b>ApplDescReadDTC</b>(DescMsgContext<b>*</b> pMsgContext) </p>
<p>{ </p>
<p>  vuint8 lData; </p>
<p>  <i>/* Format check already done by CANdesc */</i> </p>
<p> </p>
<p>  <i>/* Analysis of request has to done by ECU application */</i> </p>
<p> </p>
<p>  <i>/* Set the response length */</i> </p>
<p>  pMsgContext<b>-&gt;</b>resDataLen <b>=</b> 16; </p>
<p> </p>
<p>  <i>/* Fill the first data */</i> </p>
<p>  lData <b>=</b> 5; </p>
<p> </p>
<p>  <i>/* Store iContext for further interaction with CANdesc */</i> </p>
<p>  g_iContext <b>=</b> pMsgContext<b>-&gt;</b>iContext; </p>
<p>  <i>/* check only on services with sub-function (e.g. 0x19) */</i> </p>
<p>  if(pMsgContext<b>-&gt;</b>msgAddInfo.suppPosRes != 0) </p>
<p>  { </p>
<p>    <i>/* since no response required – skip further processing */</i> </p>
<p>    <b>DescProcessingDone</b>(pMsgContext<b>-&gt;</b>iContext); </p>
<p>  } </p>
<p>else </p>
<p>  { </p>
<p>   <i>/* Now we have to set CANdesc into the Ring-Buffer mode */</i> </p>
<p>   <b>DescRingBufferStart</b>(pMsgContext<b>-&gt;</b>iContext); </p>
<p>   <i>/* Now it is possible to write into the Ring-Buffer */</i> </p>
<p>   <b>DescRingBufferWrite</b>(pMsgContext<b>-&gt;</b>iContext, &amp;lData, 1); </p>
<p>  </p>
<p>   <i>/* Now trigger e.g. an EEPROM read event */</i> </p>
<p>   <b>... </b></p>
<p><b>  </b>} </p>
<p>} </p>
<p>     </p>
<p><b>EEPROM_TASK</b>(xyz) </p>
<p>{ </p>
<p>  vuint8 lDTC[3]; </p>
<p> </p>
<p>  <b>...</b> </p>
<p>  <i>/* Wait for EEPROM event */</i> </p>
<p>  <i>/* EEPROM event is finished with reading */</i> </p>
<p>  { </p>
<p>    <b>DescRingBufferWrite</b>(g_iContext, &amp;lDTC, 3); </p>
<p> <i> /* Now trigger next EEPROM reading */</i> </p>
<p>  } </p>
<p>} </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>153 / 164 </p>
<p><b>13.6.2 </b></p>
<p><b>with synchronous write </b></p>
<p> </p>
<p><i>//2. Read Service (with synchronous Ring-Buffer) </i></p>
<p><i>// - static length </i></p>
<p><i>// - sub-function/PID </i></p>
<p> </p>
<p><b>extern</b> <b>void</b> <b>ApplDescReadDTC_AddOn</b>(DescMsgContext<b>*</b> pMsgContext); </p>
<p> </p>
<p><b>void</b> DESC_API_CALLBACK_TYPE <b>ApplDescReadDTC</b>(DescMsgContext<b>*</b> pMsgContext) </p>
<p>{ </p>
<p>  vuint8 lData; </p>
<p>  <i>/* Format check already done by CANdesc */</i> </p>
<p> </p>
<p>Desc</p>
<p>Appl_MainHandler</p>
<p>Appl_MainHandler_2</p>
<p>EEPROM </p>
<p>Driver</p>
<p>Appl_PostHandler</p>
<p>call</p>
<p>PostHandler</p>
<p>call</p>
<p>GetEEPROMData</p>
<p>DescRingBufferWrite(* dataPtr, dataLength)</p>
<p>call</p>
<p>DescRingBufferGetFreeSpace</p>
<p>call</p>
<p>DescRingBufferGetFreeSpace</p>
<p>return countOfFreeBytesInRingBuffer</p>
<p>return countOfFreeBytesInRingBuffer</p>
<p>DescRingBufferWrite(* dataPtr, dataLength)</p>
<p>GetEEPROMData</p>
<p>Analyze and validate request</p>
<p>write response length</p>
<p>DescRingBufferStart</p>
<p>DescRingBufferWrite(* dataPtr, dataLength)</p>
<p>DescStartRepeatedServiceCall(&amp;ApplMainHandler_2)</p>
<p>Activate the </p>
<p>multiple service </p>
<p>call to get a </p>
<p>periodic call from </p>
<p>CANdesc</p>
<p>Within this function </p>
<p>call the data can be </p>
<p>written synchronous.</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>154 / 164 </p>
<p>  <i>/* Analysis of request has to done by ECU application */</i> </p>
<p> </p>
<p>  <i>/* Set the response length */</i> </p>
<p>  pMsgContext<b>-&gt;</b>resDataLen <b>=</b> 16; </p>
<p> </p>
<p>  <i>/* Fill the first data */</i> </p>
<p>  lData <b>=</b> 5; </p>
<p> </p>
<p><i>  /* check only on services with sub-function (e.g. 0x19) */</i> </p>
<p>  if(pMsgContext<b>-&gt;</b>msgAddInfo.suppPosRes != 0) </p>
<p>  { </p>
<p>    <i>/* since no response required – skip further processing */</i> </p>
<p>    <b>DescProcessingDone</b>(pMsgContext<b>-&gt;</b>iContext); </p>
<p>  } </p>
<p>else </p>
<p>{ </p>
<p>   <i>/* Now we have to set CANdesc into the Ring-Buffer mode */</i> </p>
<p>   <b>DescRingBufferStart</b>(pMsgContext<b>-&gt;</b>iContext); </p>
<p>   <i>/* Now it is possible to write into the Ring-Buffer */</i> </p>
<p>   <b>DescRingBufferWrite</b>(pMsgContext<b>-&gt;</b>iContext, &amp;lData, 1); </p>
<p> </p>
<p>   <i>/* Use RepeatedSeriveCall feature to poll e.g. EEPROM driver */</i>   </p>
<p>   <b>DescStartRepeatedServiceCall</b>(pMsgContext<b>-&gt;</b>iContext, &amp;ApplDescReadDTC_AddOn); </p>
<p>} </p>
<p>} </p>
<p> </p>
<p><b>void</b> <b>ApplDescReadDTC_AddOn</b>(DescMsgContext<b>*</b> pMsgContext) </p>
<p>{ </p>
<p>  vuint8 lDTC[3]; </p>
<p>  DescMsgLen freeSpace; </p>
<p>  <i>/* Check if enough space is free in ring-buffer */</i> </p>
<p>  freeSpace <b>=</b> <b>DescRingBufferGetFreeSpace</b>(); </p>
<p>  <b>if</b> (freeSpace <b>&gt;=</b> 3) </p>
<p>  <i>/* try to read from EEPROM */</i> </p>
<p>  { </p>
<p> <i> /* Success - result is in lDTC */</i> </p>
<p>    <b>DescRingBufferWrite</b>(pMsgContext<b>-&gt;</b>iContext, &amp;lDTC, 3); </p>
<p>  } </p>
<p>  <b>else</b> </p>
<p>  { </p>
<p>    <i>/* nothing to do, wait for next MainHandler call, ring-buffer is full */</i> </p>
<p>  } </p>
<p>} </p>
<p> </p>
<p> </p>
<p><b>13.7 </b></p>
<p><b>…prevent the ECU going to sleep while diagnostic is active  </b></p>
<p>Most car manufactures have the requirement to keep the ECU alive while the diagnostic </p>
<p>layer is active; including a pending request or a non-default session is currently active. </p>
<p>This requirement is handled by CANdesc for  some car manufactures (see OEM specific </p>
<p>TechnicalReference_CANdesc document for details) </p>
<p>The  following  code  example  shows  all  necessary  steps  to  keep  the  ECU  alive  while </p>
<p>diagnostic jobs are running (e.g. non-default session): </p>
<p>{ </p>
<p>  DescContextActivity lActivity; </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>155 / 164 </p>
<p>  DescStateGroup lState; </p>
<p> </p>
<p>  lAcitvity = DescGetActivityState(); </p>
<p>  lState = DescGetStateSession(); </p>
<p>   </p>
<p>  /* check for a pending request or a non-default session */ </p>
<p>  if ( ((lState &amp; kDescStateSessionDefault) == 0) ||  </p>
<p>       (lActivity != kDescContextIdle) ) </p>
<p>  { </p>
<p>    /* Force to stay alive */ </p>
<p>  } </p>
<p>  else </p>
<p>  { </p>
<p>    /* Ready for sleeping */ </p>
<p>  } </p>
<p>}</p>
<p> </p>
<p><b>13.8 </b></p>
<p><b>…send a positive response without request after FBL flash job </b></p>
<p>According to some specifications the application has to send a positive response either to </p>
<p>“diagnostic </p>
<p>session </p>
<p>control </p>
<p>– </p>
<p>default </p>
<p>session” </p>
<p>or </p>
<p>“ECU </p>
<p>reset </p>
<p>– </p>
<p>hard </p>
<p>reset” </p>
<p>after  a </p>
<p>successful  flash  job  without  a  request.  The  Flash  Boot  Loader  has  to  set  a  flag  (reset </p>
<p>response  flag)  in  RAM  or  EEPROM  which  has  to  be  evaluated  by  the  application  at </p>
<p>startup. </p>
<p>Depending </p>
<p>on </p>
<p>its </p>
<p>value </p>
<p>the </p>
<p>application </p>
<p>has </p>
<p>to </p>
<p>call </p>
<p>the </p>
<p>CANdesc </p>
<p>function </p>
<p><i>DescSendPosRespFBL()</i></p>
<p><i> </i></p>
<p>with the appropriate response ID. </p>
<p>CANdesc provides the API <i>DescSendPosRespFBL()</i></p>
<p><i> </i></p>
<p>for this purpose. </p>
<p>Due to bus communication is necessary to send the positive response; some limitations </p>
<p>have to be handled by the application: </p>
<p>1) Bus communication is to be requested by the application </p>
<p>2) If bus communication is possible, the application has to call</p>
<p> </p>
<p><i>DescSendPosRespFBL()</i></p>
<p>. </p>
<p>CANdescBasic will send the positive response. </p>
<p>3) The application will be called (<i>ApplDescInitPosResFblBusInfo()</i>) to provide the concrete </p>
<p>addressing information of the response. </p>
<p>4) Bus communication can be released by the application. </p>
<p><b>13.9 </b></p>
<p><b>…enforce CANdesc to use ANSI C instead of hardware optimized bit type  </b></p>
<p>CANdesc  uses  per  default  the  bit-type  definition  provided  by  the  CANdriver,  since  it  is </p>
<p>selected  as  optimal  for  the  concrete  CPU.  On  this  way  the  CANdesc  ROM  and  RAM </p>
<p>resource consumption is kept as low as possible. </p>
<p>Due to the complexity of some CANdesc data structures there can be problems on certain </p>
<p>compilers with special bit-structure compiler options.  </p>
<p>If you encounter such problems either at compile or at run-time, you can turn the ANSIC C </p>
<p>bit-type support in CANdesc on. To do that, just add a user configuration file in GENy with </p>
<p>the following content: </p>
<p>#define DESC_USE_ANSI_C_BIT_TYPE </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>156 / 164 </p>
<p><b>13.10  …configure Extended Addressing </b></p>
<p>If Extended Addressing is used as TP Addressing mode some additional settings have to </p>
<p>be done.  “<i>DescCheckTA</i>” has to be set for the “<i>Target Address Message Filter</i>” in GENy. </p>
<p> </p>
<p> </p>
<p>Figure 13-1 GENy TP configuration </p>
<p>Additional  a  user  configuration  file  has  to  be  used  to  configure  the  functional  target </p>
<p>address. An example for the content of the user configuration file is given below.   </p>
<p> </p>
<p>#define kDescOemExtAddrFuncTargetAddr  0xFE   </p>
<p><b>13.11  …use Multiple Addressing  </b></p>
<p>This  chapter  is  a  short  summary  of  additional  information  that  the  application  has  to </p>
<p>provide for CANdesc if the Tp addressing mode is Multiple Addressing. </p>
<p>In the case that a positive response has to be send after FBL flash job of the application, </p>
<p>please </p>
<p>assure </p>
<p>that </p>
<p>the </p>
<p>correct </p>
<p>addressing </p>
<p>information </p>
<p>are </p>
<p>provided </p>
<p>in </p>
<p>the </p>
<p>callback  </p>
<p><i>ApplDescInitPosResFblBusInfo()</i>. </p>
<p>Furthermore, the “Rx Get Buffer” and “Rx Indication” functions have to be redirected to the </p>
<p>application if one of the Tp Addressing modes is Normal Addressing. This can be done in </p>
<p>the  GENy </p>
<p>configuration  of  the  TP, </p>
<p>a </p>
<p>callback  name </p>
<p>different </p>
<p>from  the </p>
<p>one </p>
<p>that </p>
<p>is </p>
<p>implemented in CANdesc has to be entered.  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>157 / 164 </p>
<p> </p>
<p>Figure 13-2 GENy TP callbacks </p>
<p>The  callbacks have  to  be  implemented  in the  application. In  the Get  Buffer function  the </p>
<p>CAN Id has to be set for the FC in the case of Normal Addressing, </p>
<p> </p>
<p>/* Example: A configuration with only CANdesc Tp connections and only one Tp </p>
<p>Tx/Rx channel. */ </p>
<p>TP_MEMORY_MODEL_DATA canuint8* DispatcherDescGetBuffer(canuint8 tpChannel, </p>
<p>canuint16 datLen) </p>
<p>{ </p>
<p>  TP_MEMORY_MODEL_DATA canuint8* retPtr = V_NULL; </p>
<p> </p>
<p>  retPtr = DescGetBuffer(tpChannel, datLen); </p>
<p> </p>
<p>   if(retPtr != V_NULL) </p>
<p>   { </p>
<p>    if((TpRxGetAddressingFormat(tpChannel) == kTpNormalAddressing)) </p>
<p>    { </p>
<p>         /* kApplNormalAddressingTxId, have to defined by the application*/ </p>
<p>        TpRxSetTransmitID(tpChannel, kApplNormalAddressingTxId); </p>
<p>    } </p>
<p>   } </p>
<p>       </p>
<p> return retPtr; </p>
<p>} </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>158 / 164 </p>
<p>The  response  ID  for  Normal  Addressing  has  to  be  set  in  the  Indication  function.  The </p>
<p>response Id has to be set after the call of <i>DescPhysReqInd(). </i></p>
<p> </p>
<p>/* Example: A configuration with only CANdesc Tp connections and only one Tp </p>
<p>Tx/Rx channel. */ </p>
<p>void DispatcherDescPhysReqInd(canuint8 tpChannel, canuint16 datLen) </p>
<p>{ </p>
<p>  vuint8 addressingType = (TpRxGetAddressingFormat(tpChannel)); </p>
<p> </p>
<p>  DescPhysReqInd(tpChannel, datLen); </p>
<p> </p>
<p>  /*Set CAN IDs for the Response*/ </p>
<p>  if(addressingType == kTpNormalAddressing) </p>
<p>  { </p>
<p>/* kApplNormalAddressingTxId and kApplNormalAddressingPhysRxId, have to </p>
<p>defined by     the    application*/ </p>
<p>TpTxSetChannelID(0 /*tpTxChannel*/, kApplNormalAddressingTxId, </p>
<p>kApplNormalAddressingPhysRxId); </p>
<p>/* tpTxChannel = 0 is only possible because only one Tx Channel is </p>
<p>configured.*/ </p>
<p>  } </p>
<p>} </p>
<p> </p>
<p> </p>
<p><b>13.12  …use “Dynamic Normal Addressing Multi TP” with multiple tester </b></p>
<p>This  chapter  is  a  short  summary  of  additional  information  that  the  application  has  to </p>
<p>provide for CANdesc if the Tp addressing mode is “Dynamic Normal Addressing Multi TP” </p>
<p>with more than one tester. </p>
<p>In the case that a positive response has to be send after FBL flash job of the application, </p>
<p>please </p>
<p>assure </p>
<p>that </p>
<p>the </p>
<p>correct </p>
<p>addressing </p>
<p>information </p>
<p>are </p>
<p>provided </p>
<p>in </p>
<p>the </p>
<p>callback  </p>
<p><i>ApplDescInitPosResFblBusInfo()</i>.  </p>
<p>Furthermore, the “Rx Get Buffer” function has to be redirected to the application. This can </p>
<p>be done in the GENy configuration of the TP, a callback name different from the one that is </p>
<p>implemented in CANdesc has to be entered.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>159 / 164 </p>
<p> </p>
<p>Figure 13-3 GENy TP callbacks (physical addressing) </p>
<p> </p>
<p>The </p>
<p>“Get  Buffer” </p>
<p>function </p>
<p>of </p>
<p>the  functional </p>
<p>connection </p>
<p>has </p>
<p>to </p>
<p>be </p>
<p>redirected  to </p>
<p>the </p>
<p>application too. </p>
<p> </p>
<p> </p>
<p>Figure 13-4 GENy TP callbacks (functional addressing) </p>
<p> </p>
<p>The callbacks have to be implemented in the application.  The received CAN ID has to be </p>
<p>mapped to the corresponding transmit CAN ID and the TP connection number has to be </p>
<p>set in the xxxGetBuffer callback: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>160 / 164 </p>
<p>TP_MEMORY_MODEL_DATA canuint8* DispatcherDescGetBuffer(canuint8 tpChannel, </p>
<p>canuint16 datLen) </p>
<p>{ </p>
<p>  TP_MEMORY_MODEL_DATA canuint8* retPtr = V_NULL;  </p>
<p> </p>
<p>  switch(TpRxGetChannelID(tpChannel)) </p>
<p>  { </p>
<p>  case kDispatcherRxDiagPhysCanId: </p>
<p>    TpRxSetTransmitID(tpChannel, kDispatcherTxDiagPhysCanId); </p>
<p>    TpRxSetConnectionNumber(tpChannel, kDescDiagConnection); </p>
<p>    retPtr = DescGetBuffer(tpChannel, datLen); </p>
<p>    break; </p>
<p> </p>
<p>  case kDispatcherRxDiagAddPhysCanId: </p>
<p>    TpRxSetTransmitID(tpChannel, kDispatcherTxDiagAddPhysCanId); </p>
<p>    TpRxSetConnectionNumber(tpChannel, kDescDiagAddConnection); </p>
<p>    retPtr = DescGetBuffer(tpChannel, datLen); </p>
<p>    break; </p>
<p> </p>
<p>  default: </p>
<p>    ; </p>
<p>  } </p>
<p>  return retPtr; </p>
<p>} </p>
<p> </p>
<p> </p>
<p>The  receiced  CAN  ID  has  to  be  mapped  to  the  corresponding  transmit  CAN  ID  in  the </p>
<p>xxxGetFuncBuffer callback. Furthermore it is important, that the physical Rx ID is set for </p>
<p>the response and not the functional one. This CAN ID is used to recognize the FC of the </p>
<p>tester in case of a multiframe response: </p>
<p>TP_MEMORY_MODEL_DATA canuint8* DispatcherDescGetFuncBuffer(vuint16 dataLength) </p>
<p>{ </p>
<p>  TP_MEMORY_MODEL_DATA canuint8* retPtr = V_NULL; </p>
<p> </p>
<p>  switch(TpFuncGetReceiveCanID()) </p>
<p>  { </p>
<p>  case kDispatcherRxDiagFunc: </p>
<p>    TpFuncSetTransmitCanID(kDispatcherTxDiagPhysCanId); </p>
<p>    TpFuncSetReceiveCanID(kDispatcherRxDiagPhysCanId); </p>
<p>    retPtr = DescGetFuncBuffer(dataLength); </p>
<p>    break; </p>
<p> </p>
<p>  case kDispatcherRxDiagAddFunc: </p>
<p>    TpFuncSetTransmitCanID(kDispatcherTxDiagAddPhysCanId); </p>
<p>    TpFuncSetReceiveCanID(kDispatcherRxDiagAddPhysCanId); </p>
<p>    retPtr = DescGetFuncBuffer(dataLength); </p>
<p>    break; </p>
<p> </p>
<p>  default: </p>
<p>    ; </p>
<p>  } </p>
<p> </p>
<p>  return retPtr; </p>
<p>} </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>161 / 164 </p>
<p>The code examples above are for 2 testers, in the example are some defines used that </p>
<p>have to be provided by the application corresponding to the configuration. </p>
<p> </p>
<p><b>Define </b></p>
<p><b>Description </b></p>
<p>kDispatcherRxDiagPhysCanId</p>
<p> </p>
<p>Physical request CAN ID of the first tester </p>
<p>kDispatcherRxDiagFuncCanId</p>
<p> </p>
<p>Functional request CAN ID of the first tester </p>
<p>kDispatcherTxDiagPhysCanId</p>
<p> </p>
<p>Response CAN ID of the first tester </p>
<p>kDispatcherRxDiagAddPhysCanId </p>
<p>Physical request CAN ID of the second tester </p>
<p>kDispatcherRxDiagAddFuncCanId </p>
<p>Functional request CAN ID of the second tester </p>
<p>kDispatcherTxDiagAddPhysCanId </p>
<p>Response CAN ID of the second tester </p>
<p>kDispatcherTxDiagTpChannel </p>
<p>Transmit  Tp  Channel  of  CANdesc.  If  only  one </p>
<p>Tp Channel is used, it is has to be set to zero. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>162 / 164 </p>
<p><b>14  Related documents </b></p>
<p> </p>
<p><b>Abbreviation </b></p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>/KWP2000/ </p>
<p> </p>
<p>Keyword 2000 protocol </p>
<p>/TPMC/ </p>
<p> </p>
<p>User  manual  of  the  multi-connection  transport  layer </p>
<p>module. </p>
<p>The </p>
<p>transport </p>
<p>layer </p>
<p>is </p>
<p>implemented </p>
<p>according to /ISO 15765/ </p>
<p>/ISO 15765/ </p>
<p> </p>
<p>This </p>
<p>ISO </p>
<p>standard </p>
<p>describes </p>
<p>diagnostics </p>
<p>and </p>
<p>diagnostics on CAN.  </p>
<p><b>Note: </b>If no file name is given, the document is not provided by Vector.  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>163 / 164 </p>
<p><b>15  Glossary </b></p>
<p> </p>
<p><b>Abbreviation </b></p>
<p><b>Description  </b></p>
<p><b>CANdb </b></p>
<p><b>CAN d</b>ata<b>b</b>ase by Vector which is used by Vector tools.  </p>
<p><b>CANdesc </b></p>
<p><b>CAN d</b>iagnostics <b>e</b>mbedded <b>s</b>oftware <b>c</b>omponent </p>
<p><b>CDD </b></p>
<p><b>C</b>ANdela <b>D</b>iagnostic <b>D</b>atabase </p>
<p><b>CF </b></p>
<p><b>C</b>onsecutive <b>F</b>rame (transport protocol frame) </p>
<p><b>CCL </b></p>
<p><b>C</b>ommunication <b>C</b>ontrol <b>L</b>ayer </p>
<p><b>DBC </b></p>
<p>CAN database format of the Vector company, which is used by the </p>
<p>GENtool to gather information about the ECUs in the network, their </p>
<p>communication relations, message definitions, signals of </p>
<p>messages, network related information (e.g. manufacturer type, </p>
<p>network management type, etc.). </p>
<p><b>ECU </b></p>
<p><b>E</b>lectronic <b>C</b>ontrol <b>U</b>nit </p>
<p><b>FBL </b></p>
<p><b>F</b>lash <b>B</b>oot <b>L</b>oader </p>
<p><b>KWP 2000 </b></p>
<p><b>K</b>ey<b>w</b>ord <b>P</b>rotocol <b>2000 </b></p>
<p><b>OSEK </b></p>
<p>German  abbreviation,  “<b>O</b>ffene <b> S</b>ysteme  und  deren  Schnittstellen </p>
<p>für die <b>E</b>lektronik im <b>K</b>raftfahrzeug”, means “open systems and the </p>
<p>corresponding interfaces for automotive electronics” </p>
<p><b>RCR-RP </b></p>
<p><b>R</b>equest <b>C</b>orrectly <b>R</b>eceived <b>– R</b>esponse <b>P</b>ending </p>
<p><b>SF </b></p>
<p><b>S</b>ingle <b>F</b>rame </p>
<p><b>SID </b></p>
<p><b>S</b>ervice <b>Id</b>entifier </p>
<p><b>SPRMIB </b></p>
<p><b>S</b>uppress <b>P</b>ositive <b>R</b>esponse <b>M</b>essage <b>I</b>ndication <b>B</b>it </p>
<p><b>TP </b></p>
<p><b>T</b>ransport <b>P</b>rotocol  </p>
<p><b>UDS </b></p>
<p><b>U</b>nified <b>D</b>iagnostic <b>S</b>ervices  </p>
<p><b>VSG </b></p>
<p><b>V</b>ehicle <b>S</b>ystem <b>G</b>roup </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference CANdesc </p>
<p></p>
<p>2013, Vector Informatik GmbH </p>
<p>Version: 3.07.00 </p>
<p>based on template version 5.1.0 </p>
<p>164 / 164 </p>
<p><b>16  Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p><b>&gt; </b> News </p>
<p><b>&gt; </b> Products </p>
<p><b>&gt; </b> Demo software </p>
<p><b>&gt; </b> Support </p>
<p><b>&gt; </b> Training data </p>
<p><b>&gt; </b> Addresses </p>
<p> </p>
<p><b>www.vector.com </b></p>
</body>
</html>
{% endraw %}