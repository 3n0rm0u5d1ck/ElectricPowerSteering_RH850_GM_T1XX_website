---
layout: default
title: TechnicalReference_CANDriver
nav_order: 1
parent: CAN Driver
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>1 / 149</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Vector CAN Driver </b></p>
<p>Technical Reference </p>
<p> </p>
<p>Reference Implementation 1.5 </p>
<p> </p>
<p> </p>
<p>Version 3.01.01 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Authors: </b></p>
<p>H. Honert, K. Emmert </p>
<p><b>Version: </b></p>
<p>3.01.01 </p>
<p><b>Status: </b></p>
<p>released </p>
<p>(in preparation/completed/inspected/released)</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>2 / 149</p>
<p><b>1 </b></p>
<p><b>Document Information </b></p>
<p><b>1.1 </b></p>
<p><b>History </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>Hoffmann </p>
<p>July, 30th 1997 </p>
<p>1.00 </p>
<p>Initial draft </p>
<p>Baudermann, Ebner </p>
<p>Aug, 9th 1999 </p>
<p>2.00 </p>
<p>Reorganization of the document</p>
<p>Hardware related </p>
<p>documentation removed </p>
<p>Ebner </p>
<p>Nov, 2nd 1999 </p>
<p>2.01 </p>
<p>Spelling corrections </p>
<p>Baudermann </p>
<p>Nov, 6th 1999 </p>
<p>2.02 </p>
<p>Restrictions with reentrance </p>
<p>capability for the following CAN </p>
<p>Driver functions: CanInit, </p>
<p>CanReset..., CanSleep, </p>
<p>CanWakeUp and CAN </p>
<p>interrupts </p>
<p>Honert </p>
<p>Dec, 14th 1999 </p>
<p>2.03 </p>
<p>DLC check added </p>
<p>Ebner </p>
<p>Feb, 8th 2000 </p>
<p>2.04 </p>
<p>Configuration by tool support </p>
<p>(CANgen) added </p>
<p>Baudermann, Rein, Honert, </p>
<p>Brändle </p>
<p>May, 23th 2000 </p>
<p>2.10 </p>
<p>Generally reworked </p>
<p>According to reference </p>
<p>implementation, version 1.1 </p>
<p>Honert </p>
<p>Oct, 31th 2000 </p>
<p>2.11 </p>
<p>Description of indexed CAN </p>
<p>Driver added </p>
<p>Honert </p>
<p>Feb, 28th 2001 </p>
<p>2.12 </p>
<p>Extensions according to </p>
<p>reference implementation </p>
<p>version 1.2 </p>
<p>Hardware related </p>
<p>documentation of HC12 and </p>
<p>C16x moved to a separate </p>
<p>document </p>
<p>Honert </p>
<p>Aug, 10th 2001 </p>
<p>2.13 </p>
<p>Description of API extended </p>
<p></p>
<p> </p>
<p>Single Receive Channel CAN </p>
<p>Driver </p>
<p></p>
<p> </p>
<p>CanCancelTransmit and </p>
<p>CanCancelMsgTransmit added </p>
<p></p>
<p> </p>
<p>Access to ErrorCounters added</p>
<p>Honert,  </p>
<p> </p>
<p>Emmert </p>
<p>Aug, 20th 2001 </p>
<p>2.14 </p>
<p>Prototype of UserPrecopy </p>
<p>corrected </p>
<p>Spelling corrections </p>
<p>Modifications for pdf conversion</p>
<p>Emmert </p>
<p>Okt, 9th 2001 </p>
<p>2.15 </p>
<p>Modifications of Figure 4 and 5. </p>
<p>Honert </p>
<p>Mai, 17th 2002 </p>
<p>2.16 </p>
<p>Function name corrected for </p>
<p>indexed driver </p>
<p>Extensions according to </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>3 / 149</p>
<p>reference implementation </p>
<p>version 1.3 </p>
<p>Ebner, Honert, Emmert </p>
<p>Jun, 18th, 2003</p>
<p>2.20 </p>
<p>Macro names corrected in </p>
<p>figure 7. </p>
<p>Extensions according to </p>
<p>reference implementation </p>
<p>version 1.4. </p>
<p>Additional explanation for offline </p>
<p>/ partial offline mode (ch. 5.2.6) </p>
<p>Emmert, Honert </p>
<p>Juli, 29th, 2003 </p>
<p>2.21 </p>
<p>New tables for API descriptions.</p>
<p>Corrections of some </p>
<p>Parameters and API </p>
<p>descriptions. </p>
<p>Stephan Hoffmann, Klaus </p>
<p>Emmert, Heike Honert, </p>
<p>Patrick Markl </p>
<p>May 17nd, </p>
<p>2004 </p>
<p>2.22 </p>
<p>Description of API extended </p>
<p></p>
<p> </p>
<p>Direct Transmit Objects </p>
<p>Cancel in Hardware </p>
<p>Language corrections, New </p>
<p>Layout, Technical revisions </p>
<p>Klaus Emmert </p>
<p>Matthias Fleischmann </p>
<p>2005-12-30 </p>
<p>2.23 </p>
<p>GENy added as Generation </p>
<p>Tool </p>
<p>Added description for: </p>
<p></p>
<p> </p>
<p>Multiple ECU </p>
<p></p>
<p> </p>
<p>Common CAN </p>
<p></p>
<p> </p>
<p>Signal Access Macros </p>
<p></p>
<p> </p>
<p>Rx Queue </p>
<p></p>
<p> </p>
<p>Conditional Message Received </p>
<p></p>
<p> </p>
<p>Variable Datalen </p>
<p>Heike Honert </p>
<p>2006-08-01 </p>
<p>2.30 </p>
<p>Extensions according to </p>
<p>reference implementation 1.5. </p>
<p>Heike Honert </p>
<p>2007-01-09 </p>
<p>3.00 </p>
<p>prepare links to hw specific  </p>
<p>Added description for: </p>
<p></p>
<p> </p>
<p>CAN RAM check </p>
<p></p>
<p> </p>
<p>Standard/HighEnd CAN Driver </p>
<p>Heike Honert </p>
<p>2007-01-29 </p>
<p>3.01 </p>
<p>some corrections </p>
<p></p>
<p> </p>
<p>improve Common CAN </p>
<p></p>
<p> </p>
<p>service functions for conditional </p>
<p>message reception added </p>
<p></p>
<p> </p>
<p>Description for Partial Offline </p>
<p>Mode for GENy modified </p>
<p></p>
<p> </p>
<p>ESCAN00032527: Update </p>
<p>description of </p>
<p>ApplCanAddCanInterruptDisabl</p>
<p>e/Restore call-back function </p>
<p>Heike Honert </p>
<p>2010-06-11 </p>
<p>3.01.01 </p>
<p>Reference to documentation of </p>
<p>VstdLib changed </p>
<p>Table 1-1  </p>
<p>History of the Document </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>4 / 149</p>
<p><b>1.2 </b></p>
<p><b>Reference Documents </b></p>
<p><b>Index and Document Name </b></p>
<p>[1] TechnicalReference_&lt;hardware&gt;.pdf </p>
<p>Table 1-2  </p>
<p>Reference Documents </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Please note </b></p>
<p>We have configured the programs in accordance with your specifications in the </p>
<p>questionnaire. Whereas the programs do support other configurations than the one </p>
<p>specified in your questionnaire, Vector´s release of the programs delivered to your </p>
<p>company is expressly restricted to the configuration you have specified in the </p>
<p>questionnaire. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>5 / 149</p>
<p><b>1.3 </b></p>
<p><b>Contents </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>Document Information ............................................................................................... 2</b></p>
<p> </p>
<p>1.1</p>
<p> </p>
<p>History .......................................................................................................... 2</p>
<p> </p>
<p>1.2</p>
<p> </p>
<p>Reference Documents ................................................................................. 4</p>
<p> </p>
<p>1.3</p>
<p> </p>
<p>Contents ....................................................................................................... 5</p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>About this Document ............................................................................................... 13</b></p>
<p> </p>
<p>2.1</p>
<p> </p>
<p>Documents this one refers to….................................................................. 14</p>
<p> </p>
<p>2.2</p>
<p> </p>
<p>Naming Conventions.................................................................................. 14</p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Reference Implementations..................................................................................... 15</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>Version 1.0 ................................................................................................. 15</p>
<p> </p>
<p>3.1.1</p>
<p> </p>
<p>What's new?............................................................................................... 15</p>
<p> </p>
<p>3.1.2</p>
<p> </p>
<p>What's changed?........................................................................................ 15</p>
<p> </p>
<p>3.2</p>
<p> </p>
<p>Version 1.1 ................................................................................................. 16</p>
<p> </p>
<p>3.2.1</p>
<p> </p>
<p>What's new?............................................................................................... 16</p>
<p> </p>
<p>3.2.1.1</p>
<p> </p>
<p>Mandatory (for all CAN Drivers) ................................................................. 16</p>
<p> </p>
<p>3.2.1.2</p>
<p> </p>
<p>Optional (for some specific CAN Drivers) .................................................. 16</p>
<p> </p>
<p>3.2.2</p>
<p> </p>
<p>What's changed?........................................................................................ 16</p>
<p> </p>
<p>3.3</p>
<p> </p>
<p>Version 1.2 ................................................................................................. 17</p>
<p> </p>
<p>3.3.1</p>
<p> </p>
<p>What’s new?............................................................................................... 17</p>
<p> </p>
<p>3.3.2</p>
<p> </p>
<p>What’s changed? ....................................................................................... 17</p>
<p> </p>
<p>3.4</p>
<p> </p>
<p>Version 1.3 ................................................................................................. 17</p>
<p> </p>
<p>3.4.1</p>
<p> </p>
<p>What’s new?............................................................................................... 17</p>
<p> </p>
<p>3.4.2</p>
<p> </p>
<p>What’s changed? ....................................................................................... 17</p>
<p> </p>
<p>3.5</p>
<p> </p>
<p>Version 1.4 ................................................................................................. 18</p>
<p> </p>
<p>3.5.1</p>
<p> </p>
<p>What’s new?............................................................................................... 18</p>
<p> </p>
<p>3.5.1.1</p>
<p> </p>
<p>Mandatory (for all CAN Drivers) ................................................................. 18</p>
<p> </p>
<p>3.5.1.1.1</p>
<p> </p>
<p>Common features....................................................................................... 18</p>
<p> </p>
<p>3.5.1.1.2</p>
<p> </p>
<p>Transmission features................................................................................ 18</p>
<p> </p>
<p>3.5.1.2</p>
<p> </p>
<p>Optional (for some specific CAN Drivers) .................................................. 18</p>
<p> </p>
<p>3.5.1.2.1</p>
<p> </p>
<p>Transmission features................................................................................ 18</p>
<p> </p>
<p>3.5.1.2.2</p>
<p> </p>
<p>Reception features..................................................................................... 18</p>
<p> </p>
<p>3.5.2</p>
<p> </p>
<p>What’s changed? ....................................................................................... 19</p>
<p> </p>
<p>3.5.2.1</p>
<p> </p>
<p>Transmission features................................................................................ 19</p>
<p> </p>
<p>3.6</p>
<p> </p>
<p>Version 1.5 ................................................................................................. 19</p>
<p> </p>
<p>3.6.1</p>
<p> </p>
<p>What’s new?............................................................................................... 19</p>
<p> </p>
<p>3.6.2</p>
<p> </p>
<p>What’s changed? ....................................................................................... 20</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>6 / 149</p>
<p><b>4</b></p>
<p> </p>
<p><b>Overview ................................................................................................................... 21</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Short Summary of the Functional Scope ................................................... 22</p>
<p> </p>
<p>4.1.1</p>
<p> </p>
<p>Initialization ................................................................................................ 22</p>
<p> </p>
<p>4.1.2</p>
<p> </p>
<p>Transmission .............................................................................................. 22</p>
<p> </p>
<p>4.1.3</p>
<p> </p>
<p>Reception ................................................................................................... 23</p>
<p> </p>
<p>4.1.4</p>
<p> </p>
<p>Bus-Off ....................................................................................................... 23</p>
<p> </p>
<p>4.1.5</p>
<p> </p>
<p>Sleep Mode................................................................................................ 23</p>
<p> </p>
<p>4.1.6</p>
<p> </p>
<p>Special Features ........................................................................................ 23</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Data Structures for CAN Driver Customization .......................................... 24</p>
<p> </p>
<p>4.2.1</p>
<p> </p>
<p>ROM Data .................................................................................................. 25</p>
<p> </p>
<p>4.2.1.1</p>
<p> </p>
<p>Initialization Structures ............................................................................... 25</p>
<p> </p>
<p>4.2.1.2</p>
<p> </p>
<p>Transmit Structures .................................................................................... 26</p>
<p> </p>
<p>4.2.1.3</p>
<p> </p>
<p>Receive Structures..................................................................................... 26</p>
<p> </p>
<p>4.2.2</p>
<p> </p>
<p>RAM Data................................................................................................... 26</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>Detailed Description of the Functional Scope (Standard) .................................... 27</b></p>
<p> </p>
<p>5.1</p>
<p> </p>
<p>Initialization ................................................................................................ 27</p>
<p> </p>
<p>5.1.1</p>
<p> </p>
<p>Power-On Initialization of the CAN Driver .................................................. 27</p>
<p> </p>
<p>5.1.2</p>
<p> </p>
<p>Re-Initialization of the CAN Controller ....................................................... 27</p>
<p> </p>
<p>5.2</p>
<p> </p>
<p>Transmission .............................................................................................. 27</p>
<p> </p>
<p>5.2.1</p>
<p> </p>
<p>Detailed Functional Description ................................................................. 27</p>
<p> </p>
<p>5.2.2</p>
<p> </p>
<p>Transmit Queue.......................................................................................... 32</p>
<p> </p>
<p>5.2.3</p>
<p> </p>
<p>Data Copy Mechanisms ............................................................................. 33</p>
<p> </p>
<p>5.2.3.1</p>
<p> </p>
<p>Internal ....................................................................................................... 33</p>
<p> </p>
<p>5.2.3.2</p>
<p> </p>
<p>User defined (“Pretransmit Function”)........................................................ 34</p>
<p> </p>
<p>5.2.4</p>
<p> </p>
<p>Notification ................................................................................................. 34</p>
<p> </p>
<p>5.2.4.1</p>
<p> </p>
<p>Data Interface (Confirmation Flag)............................................................. 34</p>
<p> </p>
<p>5.2.4.2</p>
<p> </p>
<p>Functional Interface (Confirmation Function for each message) ............... 34</p>
<p> </p>
<p>5.2.4.3</p>
<p> </p>
<p>Functional Interface (Common Confirmation Function for all messages) .. 34</p>
<p> </p>
<p>5.2.5</p>
<p> </p>
<p>Offline Mode............................................................................................... 35</p>
<p> </p>
<p>5.2.6</p>
<p> </p>
<p>Partial Offline Mode.................................................................................... 35</p>
<p> </p>
<p>5.2.6.1</p>
<p> </p>
<p>Partial Offline Mode with GENy.................................................................. 36</p>
<p> </p>
<p>5.2.7</p>
<p> </p>
<p>Passive State ............................................................................................. 39</p>
<p> </p>
<p>5.2.8</p>
<p> </p>
<p>Tx Observe................................................................................................. 40</p>
<p> </p>
<p>5.2.9</p>
<p> </p>
<p>Cancellation of a Transmission .................................................................. 41</p>
<p> </p>
<p>5.2.9.1</p>
<p> </p>
<p>Cancel a Transmission via CanInit............................................................. 41</p>
<p> </p>
<p>5.2.9.2</p>
<p> </p>
<p>Cancel a Transmission via CanCancelTransmit or </p>
<p>CanCancelMsgTransmit............................................................................. 41</p>
<p> </p>
<p>5.2.9.3</p>
<p> </p>
<p>Notification about Cancellation of a message ............................................ 42</p>
<p> </p>
<p>5.2.10</p>
<p> </p>
<p>Overview of Transmit Objects .................................................................... 43</p>
<p> </p>
<p>5.2.11</p>
<p> </p>
<p>Normal Transmit Object ............................................................................. 43</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>7 / 149</p>
<p>5.2.12</p>
<p> </p>
<p>Full CAN Transmit Objects......................................................................... 43</p>
<p> </p>
<p>5.2.13</p>
<p> </p>
<p>Dynamic Transmit Objects ......................................................................... 43</p>
<p> </p>
<p>5.2.14</p>
<p> </p>
<p>Priority of Transmit Objects ........................................................................ 45</p>
<p> </p>
<p>5.3</p>
<p> </p>
<p>Reception ................................................................................................... 46</p>
<p> </p>
<p>5.3.1</p>
<p> </p>
<p>Detailed Functional Description ................................................................. 46</p>
<p> </p>
<p>5.3.2</p>
<p> </p>
<p>Receive Function ....................................................................................... 50</p>
<p> </p>
<p>5.3.3</p>
<p> </p>
<p>Range-Specific Precopy Functions ............................................................ 50</p>
<p> </p>
<p>5.3.4</p>
<p> </p>
<p>Identifier Search Algorithms ....................................................................... 50</p>
<p> </p>
<p>5.3.5</p>
<p> </p>
<p>DLC check.................................................................................................. 51</p>
<p> </p>
<p>5.3.6</p>
<p> </p>
<p>Data Copy Mechanism............................................................................... 51</p>
<p> </p>
<p>5.3.6.1</p>
<p> </p>
<p>Internal ....................................................................................................... 51</p>
<p> </p>
<p>5.3.6.2</p>
<p> </p>
<p>User-defined Precopy Functions................................................................ 52</p>
<p> </p>
<p>5.3.7</p>
<p> </p>
<p>Notification ................................................................................................. 52</p>
<p> </p>
<p>5.3.7.1</p>
<p> </p>
<p>Data Interface (Indication Flag).................................................................. 53</p>
<p> </p>
<p>5.3.7.2</p>
<p> </p>
<p>Functional Interface (Indication Function) .................................................. 53</p>
<p> </p>
<p>5.3.8</p>
<p> </p>
<p>Not-Matched Function................................................................................ 53</p>
<p> </p>
<p>5.3.9</p>
<p> </p>
<p>Overrun Handling....................................................................................... 53</p>
<p> </p>
<p>5.3.10</p>
<p> </p>
<p>Full CAN Overrun Handling........................................................................ 53</p>
<p> </p>
<p>5.3.11</p>
<p> </p>
<p>Conditional Message Received.................................................................. 54</p>
<p> </p>
<p>5.4</p>
<p> </p>
<p>Bus-Off Handling........................................................................................ 54</p>
<p> </p>
<p>5.5</p>
<p> </p>
<p>Sleep Mode................................................................................................ 55</p>
<p> </p>
<p>5.6</p>
<p> </p>
<p>Special Features ........................................................................................ 56</p>
<p> </p>
<p>5.6.1</p>
<p> </p>
<p>Status ......................................................................................................... 56</p>
<p> </p>
<p>5.6.2</p>
<p> </p>
<p>Stop Mode.................................................................................................. 57</p>
<p> </p>
<p>5.6.3</p>
<p> </p>
<p>Remote Frames ......................................................................................... 57</p>
<p> </p>
<p>5.6.4</p>
<p> </p>
<p>Interrupt Control ......................................................................................... 57</p>
<p> </p>
<p>5.6.4.1</p>
<p> </p>
<p>Security Level............................................................................................. 57</p>
<p> </p>
<p>5.6.4.2</p>
<p> </p>
<p>Control of CAN interrupts ........................................................................... 58</p>
<p> </p>
<p>5.6.5</p>
<p> </p>
<p>Assertions .................................................................................................. 59</p>
<p> </p>
<p>5.6.6</p>
<p> </p>
<p>Hardware Loop Check ............................................................................... 62</p>
<p> </p>
<p>5.6.7</p>
<p> </p>
<p>Support of OSEK-Compliant Operating Systems....................................... 63</p>
<p> </p>
<p>5.6.8</p>
<p> </p>
<p>Multiple-Channel CAN Driver ..................................................................... 63</p>
<p> </p>
<p>5.6.8.1</p>
<p> </p>
<p>Indexed CAN Driver ................................................................................... 63</p>
<p> </p>
<p>5.6.9</p>
<p> </p>
<p>Standard Polling Mode ............................................................................... 63</p>
<p> </p>
<p>5.6.9.1</p>
<p> </p>
<p>Application Hints ........................................................................................ 64</p>
<p> </p>
<p>5.6.10</p>
<p> </p>
<p>Handling of different identifier types........................................................... 64</p>
<p> </p>
<p>5.6.11</p>
<p> </p>
<p>Copying Mechanisms................................................................................. 65</p>
<p> </p>
<p>5.6.12</p>
<p> </p>
<p>Common CAN ............................................................................................ 65</p>
<p> </p>
<p>5.6.13</p>
<p> </p>
<p>Multiple ECU .............................................................................................. 65</p>
<p> </p>
<p>5.6.14</p>
<p> </p>
<p>Signal Access Macros................................................................................ 65</p>
<p> </p>
<p>5.6.15</p>
<p> </p>
<p>CAN RAM Check ....................................................................................... 66</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>8 / 149</p>
<p><b>6</b></p>
<p> </p>
<p><b>Detailed Description of the Functional Scope (High End extension) .................. 67</b></p>
<p> </p>
<p>6.1</p>
<p> </p>
<p>Transmission .............................................................................................. 67</p>
<p> </p>
<p>6.1.1</p>
<p> </p>
<p>Low-Level Message Transmit .................................................................... 67</p>
<p> </p>
<p>6.2</p>
<p> </p>
<p>Reception ................................................................................................... 67</p>
<p> </p>
<p>6.2.1</p>
<p> </p>
<p>Multiple Basic CAN .................................................................................... 67</p>
<p> </p>
<p>6.2.2</p>
<p> </p>
<p>Rx Queue................................................................................................... 67</p>
<p> </p>
<p>6.2.2.1</p>
<p> </p>
<p>Handling in Receive Interrupt..................................................................... 68</p>
<p> </p>
<p>6.2.2.2</p>
<p> </p>
<p>Handling on Task Level .............................................................................. 69</p>
<p> </p>
<p>6.2.2.3</p>
<p> </p>
<p>Resetting the Rx Queue............................................................................. 70</p>
<p> </p>
<p>6.3</p>
<p> </p>
<p>Special Features ........................................................................................ 71</p>
<p> </p>
<p>6.3.1</p>
<p> </p>
<p>Individual Polling ........................................................................................ 71</p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>Feature List (Standard and High End) .................................................................... 72</b></p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>Description of the API (Standard) ........................................................................... 75</b></p>
<p> </p>
<p>8.1</p>
<p> </p>
<p>API Categories........................................................................................... 75</p>
<p> </p>
<p>8.1.1</p>
<p> </p>
<p>Single Receive Channel (SRC).................................................................. 75</p>
<p> </p>
<p>8.1.2</p>
<p> </p>
<p>Multiple Receive Channel (MRC)............................................................... 75</p>
<p> </p>
<p>8.2</p>
<p> </p>
<p>Data Types ................................................................................................. 76</p>
<p> </p>
<p>8.3</p>
<p> </p>
<p>Constants ................................................................................................... 77</p>
<p> </p>
<p>8.3.1</p>
<p> </p>
<p>Version Number ......................................................................................... 77</p>
<p> </p>
<p>8.4</p>
<p> </p>
<p>Macros ....................................................................................................... 77</p>
<p> </p>
<p>8.4.1</p>
<p> </p>
<p>Conversion between Logical and Hardware Representation of CAN </p>
<p>Parameter DLC .......................................................................................... 77</p>
<p> </p>
<p>8.4.2</p>
<p> </p>
<p>Direct Access to the CAN Controller Registers .......................................... 78</p>
<p> </p>
<p>8.4.3</p>
<p> </p>
<p>Interpretation of the CAN Status ................................................................ 79</p>
<p> </p>
<p>8.4.4</p>
<p> </p>
<p>Access to low level transmit structure ........................................................ 80</p>
<p> </p>
<p>8.5</p>
<p> </p>
<p>Functions.................................................................................................... 80</p>
<p> </p>
<p>8.5.1</p>
<p> </p>
<p>Service Functions....................................................................................... 81</p>
<p> </p>
<p>8.5.1.1</p>
<p> </p>
<p>CanInitPowerOn ......................................................................................... 81</p>
<p> </p>
<p>8.5.1.2</p>
<p> </p>
<p>CanInit ........................................................................................................ 81</p>
<p> </p>
<p>8.5.1.3</p>
<p> </p>
<p>CanTransmit............................................................................................... 82</p>
<p> </p>
<p>8.5.1.4</p>
<p> </p>
<p>CanTask ..................................................................................................... 83</p>
<p> </p>
<p>8.5.1.5</p>
<p> </p>
<p>CanTxTask ................................................................................................. 83</p>
<p> </p>
<p>8.5.1.6</p>
<p> </p>
<p>CanRxFullCANTask ................................................................................... 84</p>
<p> </p>
<p>8.5.1.7</p>
<p> </p>
<p>CanRxBasicCANTask ................................................................................ 84</p>
<p> </p>
<p>8.5.1.8</p>
<p> </p>
<p>CanErrorTask ............................................................................................. 85</p>
<p> </p>
<p>8.5.1.9</p>
<p> </p>
<p>CanWakeUpTask........................................................................................ 85</p>
<p> </p>
<p>8.5.1.10</p>
<p> </p>
<p>CanOnline .................................................................................................. 86</p>
<p> </p>
<p>8.5.1.11</p>
<p> </p>
<p>CanOffline .................................................................................................. 86</p>
<p> </p>
<p>8.5.1.12</p>
<p> </p>
<p>CanPartOnline............................................................................................ 87</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>9 / 149</p>
<p>8.5.1.13</p>
<p> </p>
<p>CanPartOffline............................................................................................ 87</p>
<p> </p>
<p>8.5.1.14</p>
<p> </p>
<p>CanGetPartMode ....................................................................................... 88</p>
<p> </p>
<p>8.5.1.15</p>
<p> </p>
<p>CanGetStatus ............................................................................................. 88</p>
<p> </p>
<p>8.5.1.16</p>
<p> </p>
<p>CanSleep ................................................................................................... 89</p>
<p> </p>
<p>8.5.1.17</p>
<p> </p>
<p>CanWakeUp ............................................................................................... 90</p>
<p> </p>
<p>8.5.1.18</p>
<p> </p>
<p>CanStart ..................................................................................................... 91</p>
<p> </p>
<p>8.5.1.19</p>
<p> </p>
<p>CanStop ..................................................................................................... 92</p>
<p> </p>
<p>8.5.1.20</p>
<p> </p>
<p>CanGlobalInterruptDisable ......................................................................... 92</p>
<p> </p>
<p>8.5.1.21</p>
<p> </p>
<p>CanGlobalInterruptRestore ........................................................................ 93</p>
<p> </p>
<p>8.5.1.22</p>
<p> </p>
<p>CanCanInterruptDisable............................................................................. 93</p>
<p> </p>
<p>8.5.1.23</p>
<p> </p>
<p>CanCanInterruptRestore ............................................................................ 94</p>
<p> </p>
<p>8.5.1.24</p>
<p> </p>
<p>CanSetPassive........................................................................................... 94</p>
<p> </p>
<p>8.5.1.25</p>
<p> </p>
<p>CanSetActive ............................................................................................. 95</p>
<p> </p>
<p>8.5.1.26</p>
<p> </p>
<p>CanResetBusOffStart ................................................................................. 95</p>
<p> </p>
<p>8.5.1.27</p>
<p> </p>
<p>CanResetBusOffEnd .................................................................................. 96</p>
<p> </p>
<p>8.5.1.28</p>
<p> </p>
<p>CanResetBusSleep .................................................................................... 96</p>
<p> </p>
<p>8.5.1.29</p>
<p> </p>
<p>CanGetDynTxObj ....................................................................................... 97</p>
<p> </p>
<p>8.5.1.30</p>
<p> </p>
<p>CanReleaseDynTxObj ............................................................................... 99</p>
<p> </p>
<p>8.5.1.31</p>
<p> </p>
<p>CanDynTxObjSetId .................................................................................... 99</p>
<p> </p>
<p>8.5.1.32</p>
<p> </p>
<p>CanDynTxObjSetExtId ............................................................................. 100</p>
<p> </p>
<p>8.5.1.33</p>
<p> </p>
<p>CanDynTxObjSetDlc ................................................................................ 100</p>
<p> </p>
<p>8.5.1.34</p>
<p> </p>
<p>CanDynTxObjSetDataPtr ......................................................................... 101</p>
<p> </p>
<p>8.5.1.35</p>
<p> </p>
<p>CanCancelTransmit.................................................................................. 101</p>
<p> </p>
<p>8.5.1.36</p>
<p> </p>
<p>CanCopyFromCan ................................................................................... 101</p>
<p> </p>
<p>8.5.1.37</p>
<p> </p>
<p>CanCopyToCan ........................................................................................ 102</p>
<p> </p>
<p>8.5.1.38</p>
<p> </p>
<p>CanTxGetActHandle ................................................................................ 102</p>
<p> </p>
<p>8.5.1.39</p>
<p> </p>
<p>CanResetMsgReceivedCondition ............................................................ 103</p>
<p> </p>
<p>8.5.1.40</p>
<p> </p>
<p>CanSetMsgReceivedCondition ................................................................ 103</p>
<p> </p>
<p>8.5.1.41</p>
<p> </p>
<p>CanGetMsgReceivedCondition ................................................................ 104</p>
<p> </p>
<p>8.5.2</p>
<p> </p>
<p>User Specific Functions............................................................................ 105</p>
<p> </p>
<p>8.5.2.1</p>
<p> </p>
<p>UserPrecopy ............................................................................................ 105</p>
<p> </p>
<p>8.5.2.2</p>
<p> </p>
<p>UserIndication .......................................................................................... 105</p>
<p> </p>
<p>8.5.2.3</p>
<p> </p>
<p>UserPreTransmit ...................................................................................... 106</p>
<p> </p>
<p>8.5.2.4</p>
<p> </p>
<p>UserConfirmation ..................................................................................... 106</p>
<p> </p>
<p>8.5.3</p>
<p> </p>
<p>Callback Functions................................................................................... 107</p>
<p> </p>
<p>8.5.3.1</p>
<p> </p>
<p>ApplCanBusOff ........................................................................................ 107</p>
<p> </p>
<p>8.5.3.2</p>
<p> </p>
<p>ApplCanWakeUp ...................................................................................... 107</p>
<p> </p>
<p>8.5.3.3</p>
<p> </p>
<p>ApplCanOverrun ...................................................................................... 108</p>
<p> </p>
<p>8.5.3.4</p>
<p> </p>
<p>ApplCanFullCanOverrun .......................................................................... 108</p>
<p> </p>
<p>8.5.3.5</p>
<p> </p>
<p>ApplCanMsgReceived.............................................................................. 109</p>
<p> </p>
<p>8.5.3.6</p>
<p> </p>
<p>ApplCanRangePrecopy............................................................................ 109</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>10 / 149</p>
<p>8.5.3.7</p>
<p> </p>
<p>ApplCanAddCanInterruptDisable ..............................................................110</p>
<p> </p>
<p>8.5.3.8</p>
<p> </p>
<p>ApplCanAddCanInterruptRestore .............................................................110</p>
<p> </p>
<p>8.5.3.9</p>
<p> </p>
<p>ApplCanFatalError .................................................................................... 111</p>
<p> </p>
<p>8.5.3.10</p>
<p> </p>
<p>ApplCanMsgNotMatched .......................................................................... 111</p>
<p> </p>
<p>8.5.3.11</p>
<p> </p>
<p>ApplCanInit................................................................................................112</p>
<p> </p>
<p>8.5.3.12</p>
<p> </p>
<p>ApplCanTxObjStart ...................................................................................113</p>
<p> </p>
<p>8.5.3.13</p>
<p> </p>
<p>ApplCanTxObjConfirmed ..........................................................................113</p>
<p> </p>
<p>8.5.3.14</p>
<p> </p>
<p>ApplCanTimerStart ....................................................................................114</p>
<p> </p>
<p>8.5.3.15</p>
<p> </p>
<p>ApplCanTimerLoop ...................................................................................114</p>
<p> </p>
<p>8.5.3.16</p>
<p> </p>
<p>ApplCanTimerEnd .....................................................................................115</p>
<p> </p>
<p>8.5.3.17</p>
<p> </p>
<p>ApplCanGenericPrecopy...........................................................................115</p>
<p> </p>
<p>8.5.3.18</p>
<p> </p>
<p>ApplCanPreWakeup..................................................................................115</p>
<p> </p>
<p>8.5.3.19</p>
<p> </p>
<p>ApplCanTxConfirmation ............................................................................116</p>
<p> </p>
<p>8.5.3.20</p>
<p> </p>
<p>ApplCanMsgDlcFailed...............................................................................117</p>
<p> </p>
<p>8.5.3.21</p>
<p> </p>
<p>ApplCanCancelNotification .......................................................................117</p>
<p> </p>
<p>8.5.3.22</p>
<p> </p>
<p>ApplCanOnline ..........................................................................................118</p>
<p> </p>
<p>8.5.3.23</p>
<p> </p>
<p>ApplCanOffline ..........................................................................................118</p>
<p> </p>
<p>8.5.3.24</p>
<p> </p>
<p>ApplCanMsgCondReceived ......................................................................118</p>
<p> </p>
<p>8.5.3.25</p>
<p> </p>
<p>ApplCanMemCheckFailed ........................................................................119</p>
<p> </p>
<p>8.5.3.26</p>
<p> </p>
<p>ApplCanCorruptMailbox ............................................................................119</p>
<p> </p>
<p><b>9</b></p>
<p> </p>
<p><b>Description of the API (High End extension) ....................................................... 121</b></p>
<p> </p>
<p>9.1</p>
<p> </p>
<p>Functions.................................................................................................. 121</p>
<p> </p>
<p>9.1.1</p>
<p> </p>
<p>Service Functions..................................................................................... 121</p>
<p> </p>
<p>9.1.1.1</p>
<p> </p>
<p>CanTxObjTask.......................................................................................... 121</p>
<p> </p>
<p>9.1.1.2</p>
<p> </p>
<p>CanRxFullCANObjTask ............................................................................ 122</p>
<p> </p>
<p>9.1.1.3</p>
<p> </p>
<p>CanRxBasicCANObjTask ......................................................................... 122</p>
<p> </p>
<p>9.1.1.4</p>
<p> </p>
<p>CanMsgTransmit ...................................................................................... 123</p>
<p> </p>
<p>9.1.1.5</p>
<p> </p>
<p>CanCancelMsgTransmit........................................................................... 123</p>
<p> </p>
<p>9.1.1.6</p>
<p> </p>
<p>CanHandleRxMsg .................................................................................... 124</p>
<p> </p>
<p>9.1.1.7</p>
<p> </p>
<p>CanDeleteRxQueue ................................................................................. 124</p>
<p> </p>
<p>9.1.2</p>
<p> </p>
<p>Callback Functions................................................................................... 125</p>
<p> </p>
<p>9.1.2.1</p>
<p> </p>
<p>ApplCanMsgTransmitConf ....................................................................... 125</p>
<p> </p>
<p>9.1.2.2</p>
<p> </p>
<p>ApplCanMsgTransmitInit .......................................................................... 125</p>
<p> </p>
<p>9.1.2.3</p>
<p> </p>
<p>ApplCanMsgCancelNotification................................................................ 125</p>
<p> </p>
<p>9.1.2.4</p>
<p> </p>
<p>ApplCanPreRxQueue............................................................................... 126</p>
<p> </p>
<p>9.1.2.5</p>
<p> </p>
<p>ApplCanRxQueueOverrun ....................................................................... 126</p>
<p> </p>
<p><b>10</b></p>
<p> </p>
<p><b>Configuration (Standard and High End)............................................................... 128</b></p>
<p> </p>
<p>10.1</p>
<p> </p>
<p>Network Database – Attribute Definition .................................................. 128</p>
<p> </p>
<p>10.2</p>
<p> </p>
<p>Automatic Configuration by GENy ........................................................... 128</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>11 / 149</p>
<p>10.3</p>
<p> </p>
<p>Automatic Configuration by CANgen ....................................................... 139</p>
<p> </p>
<p>10.4</p>
<p> </p>
<p>Manual configuration via user configuration file....................................... 144</p>
<p> </p>
<p><b>11</b></p>
<p> </p>
<p><b>Glossary .................................................................................................................. 145</b></p>
<p> </p>
<p><b>12</b></p>
<p> </p>
<p><b>Contact .................................................................................................................... 149</b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>12 / 149</p>
<p><b>Illustrations </b></p>
<p>Figure 2-1</p>
<p> </p>
<p>Manuals and References for the CAN Driver ................................................. 14</p>
<p> </p>
<p>Figure 4-1</p>
<p> </p>
<p>Relationship of the individual Software Components.  They are </p>
<p>customized by the Generation Tool................................................................. 21</p>
<p> </p>
<p>Figure 4-2</p>
<p> </p>
<p>Description data, CAN Driver and Application with their interfaces. ............... 25</p>
<p> </p>
<p>Figure 5-1</p>
<p> </p>
<p>Transmission of a CAN message ................................................................... 28</p>
<p> </p>
<p>Figure 5-2</p>
<p> </p>
<p>Transmission with an available transmit object; Using global data buffer....... 30</p>
<p> </p>
<p>Figure 5-3</p>
<p> </p>
<p>Transmission with an available hardware transmit object; Using a </p>
<p>pretransmit function to copy data.................................................................... 31</p>
<p> </p>
<p>Figure 5-4</p>
<p> </p>
<p>Transmit procedure if no hardware transmit object available ......................... 32</p>
<p> </p>
<p>Figure 5-5</p>
<p> </p>
<p>Partial Offline Mode settings in GENy............................................................. 37</p>
<p> </p>
<p>Figure 5-6</p>
<p> </p>
<p>One Single Application Message Selected ..................................................... 38</p>
<p> </p>
<p>Figure 5-7</p>
<p> </p>
<p>User Defined assignment to Offline Modes .................................................... 38</p>
<p> </p>
<p>Figure 5-8</p>
<p> </p>
<p>Overview Messages and Offline Modes ......................................................... 39</p>
<p> </p>
<p>Figure 5-9</p>
<p> </p>
<p>Priority of Transmit Objects............................................................................. 45</p>
<p> </p>
<p>Figure 5-10</p>
<p> </p>
<p>Reception of a CAN messages....................................................................... 46</p>
<p> </p>
<p>Figure 5-11</p>
<p> </p>
<p>Reception of a CAN message: The data is completely processed in the </p>
<p>precopy function ............................................................................................. 48</p>
<p> </p>
<p>Figure 5-12</p>
<p> </p>
<p>Reception of a CAN message: The CAN Driver internal copying </p>
<p>mechanism is used ......................................................................................... 49</p>
<p> </p>
<p>Figure 5-13</p>
<p> </p>
<p>Name of signal access macros....................................................................... 66</p>
<p> </p>
<p>Figure 6-1</p>
<p> </p>
<p>Handling of the Rx queue within the receive routine. ..................................... 69</p>
<p> </p>
<p>Figure 6-2</p>
<p> </p>
<p>Handling of the Rx queue on task level. ......................................................... 70</p>
<p> </p>
<p>Figure 10-1</p>
<p> </p>
<p>Configuration of the common CAN Driver options with GENy...................... 129</p>
<p> </p>
<p>Figure 10-2</p>
<p> </p>
<p>Channel Specific Configuration for GENy..................................................... 135</p>
<p> </p>
<p>Figure 10-3</p>
<p> </p>
<p>Configuration of individual polling with GENy ............................................... 136</p>
<p> </p>
<p>Figure 10-4</p>
<p> </p>
<p>Configuration of a Tx message with GENy................................................... 137</p>
<p> </p>
<p>Figure 10-5</p>
<p> </p>
<p>Configuration of an Rx message with GENy ................................................ 138</p>
<p> </p>
<p>Figure 10-6</p>
<p> </p>
<p>CAN Driver configuration tab ........................................................................ 139</p>
<p> </p>
<p>Figure 10-7</p>
<p> </p>
<p>Configuration of Partial Offline Mode............................................................ 143</p>
<p> </p>
<p> </p>
<p><b>Tables </b></p>
<p>Table 1-1 </p>
<p> </p>
<p>History of the Document ................................................................................... 3</p>
<p> </p>
<p>Table 1-2 </p>
<p> </p>
<p>Reference Documents ...................................................................................... 4</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>13 / 149</p>
<p><b>2 </b></p>
<p><b>About this Document </b></p>
<p>This  document  describes  the  concept,  features, API  and  the  configuration  of  the  Vector </p>
<p>CAN Driver. </p>
<p>The CAN Driver interface to the CAN Controller is designed to use the hardware specific </p>
<p>capabilities in an efficient way. The interface to the higher communication layers is mostly </p>
<p>identical for different CAN Controllers, so that the Interaction Layer, Network Management, </p>
<p>Transport Protocol and especially the user software are independent of the particular CAN </p>
<p>Controller used. Please note that in this document the term Application is not used strictly </p>
<p>for  the  user  software  but  also  for  all  the  higher  communication  layers  as  listed  above. </p>
<p>Therefore, Application refers to any of the software modules using the CAN Driver. </p>
<p>Two different types of CAN Driver are supported. These are the Standard CAN Driver and </p>
<p>the High End CAN Driver. The High End CAN Driver is an extended Standard CAN Driver. </p>
<p>The description of the Standard CAN Driver is also valid for the High End CAN Driver. The </p>
<p>additional features of the High End CAN Driver are described in own chapters. </p>
<p>The API of the functions is described in a separate chapter at the end of this document. </p>
<p>Referred functions are always shown in the Single receive channel mode.  </p>
<p>Hardware </p>
<p>related </p>
<p>special </p>
<p>features </p>
<p>and </p>
<p>implementation </p>
<p>specifics </p>
<p>are </p>
<p>described </p>
<p>in </p>
<p>a </p>
<p>separate document which is named TechnicalReference_CAN_&lt;hardware&gt;.pdf. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>14 / 149</p>
<p><b>2.1 </b></p>
<p><b>Documents this one refers to… </b></p>
<p></p>
<p> </p>
<p>User Manual CAN Driver </p>
<p></p>
<p> </p>
<p>Hardware-specific documentation for the CAN Driver </p>
<p> </p>
<p><b>User Manual</b></p>
<p><b>Technical</b></p>
<p><b>Reference</b></p>
<p><b>General</b></p>
<p>#hw_&lt;xxx&gt;</p>
<p><b>Technical</b></p>
<p><b>Reference</b></p>
<p><b>Hardware</b></p>
<p><b>You are here</b></p>
<p> </p>
<p>Figure 2-1 </p>
<p>Manuals and References for the CAN Driver </p>
<p> </p>
<p><b>2.2 </b></p>
<p><b>Naming Conventions </b></p>
<p>Some  of  the  function  names  are  mandatory,  because  they  are  used  in  the  CAN  Driver. </p>
<p>Other  names  are  placeholders,  and  the Application  can  redefine  or  has  to  select  them </p>
<p>according to its requirements: </p>
<p>Can... </p>
<p>It is mandatory to use all names beginning with Can... as they appear. Can... </p>
<p>stands for CAN Driver. </p>
<p>ApplCan... </p>
<p>The functions, starting with Appl... are so called callback functions. They are </p>
<p>provided by the Application and called by the CAN Driver. They are used to </p>
<p>notify the application about events such as state transitions. </p>
<p>User... </p>
<p>All names starting with User... are placeholders and will be selected by using </p>
<p>the Generation Tool according to the requirements of the Application. User... </p>
<p>stands for user-specific functions. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>15 / 149</p>
<p><b>3 </b></p>
<p><b>Reference Implementations </b></p>
<p>The  reference  implementation  is  a  general  specification  for  all  Vector  CAN  Drivers. The </p>
<p>software  versions  for  specific  CAN  Drivers  differs,  because  there  are  different  source </p>
<p>codes  for  different  CAN  Controllers.  Therefore  another  overall  version  number  exists, </p>
<p>representing the reference implementation. The CAN Drivers are implemented according </p>
<p>to this reference implementation with an identical feature set and Application interface as </p>
<p>well as a harmonized implementation.  </p>
<p> </p>
<p><b>3.1 </b></p>
<p><b>Version 1.0 </b></p>
<p><b>3.1.1 </b></p>
<p><b>What's new? </b></p>
<p></p>
<p> </p>
<p>Identifier  ranges  defined  by  acceptance  code  and  mask  to  receive  a  complete  set  of </p>
<p>several CAN identifiers. This is much more efficient for special requirements with fixed </p>
<p>identifier </p>
<p>ranges </p>
<p>and </p>
<p>can </p>
<p>be </p>
<p>configured </p>
<p>by </p>
<p>the </p>
<p>Application. </p>
<p>Useful </p>
<p>settings </p>
<p>for </p>
<p>Application are selected automatically by the Generation Tool. </p>
<p></p>
<p> </p>
<p>Some parameters are provided by preprocessor defines in the CAN Driver configuration </p>
<p>file instead of global variables. This results in more efficient code. </p>
<p></p>
<p> </p>
<p>Notification  of  a  CAN  receive  message  overrun  condition  is  done  by  the  callback </p>
<p>function ApplCanOverrun(). This is configurable. </p>
<p></p>
<p> </p>
<p>The internal copy mechanism of the CAN Driver is configurable separately for receive </p>
<p>and  transmit  direction.  It  will  be  enabled  automatically  if  an Application  data  buffer  is </p>
<p>selected by the Generation Tool. </p>
<p><b>3.1.2 </b></p>
<p><b>What's changed? </b></p>
<p></p>
<p> </p>
<p>General  interrupt  disable  during  critical  service  functions  is  replaced  by  a  reentrant </p>
<p>solution. </p>
<p></p>
<p> </p>
<p>General assertion categories for the following severe errors in the CAN Driver: </p>
<p></p>
<p> </p>
<p>- User interface (e.g. invalid handles) </p>
<p></p>
<p> </p>
<p>- Generated data (caused by the Generation Tool) </p>
<p></p>
<p> </p>
<p>- Hardware problems (unexpected conditions of the CAN Controller) </p>
<p></p>
<p> </p>
<p>- Internal errors (e.g. inconsistent transmit queue entries) </p>
<p></p>
<p> </p>
<p>The different categories can be configured separately and the name of the callback </p>
<p>function has changed from ApplFatalError(..) to ApplCanFatalError(..). </p>
<p></p>
<p> </p>
<p>Callback function CanMsgReceive() has changed in ApplCanMsgReceived(). </p>
<p></p>
<p> </p>
<p>Plausibility  check  for  configuration  switches  of  the  CAN  Driver  is  optional  and  will  be </p>
<p>done in a separate header file called CAN_CHK.H. </p>
<p></p>
<p> </p>
<p>CanRxActualDLC will be provided as a preprocessor macro. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>16 / 149</p>
<p></p>
<p> </p>
<p>If  the  transmit  queue  is  used  for  CAN  Controllers  with  several  hardware  transmit </p>
<p>objects,  only  one  of  these  register  sets  will  be  used  for  normal  transmission  (in </p>
<p>combination with the transmit queue). The others are reserved for Full CAN Transmit </p>
<p>Objects with fixed CAN identifier and DLC. </p>
<p></p>
<p> </p>
<p>The names of the following global variables have been changed: </p>
<p></p>
<p> </p>
<p>CanEcuNumber to canEcuNumber </p>
<p></p>
<p> </p>
<p>CanRxHandle    to canRxHandle </p>
<p> </p>
<p><b>3.2 </b></p>
<p><b>Version 1.1 </b></p>
<p><b>3.2.1 </b></p>
<p><b>What's new? </b></p>
<p><b>3.2.1.1 </b></p>
<p><b>Mandatory (for all CAN Drivers) </b></p>
<p></p>
<p> </p>
<p>Configurable callback function if software acceptance filtering doesn't match. </p>
<p></p>
<p> </p>
<p>Configurable callback functions to monitor the correct transmit behavior. </p>
<p></p>
<p> </p>
<p>Dynamic transmit objects for variable CAN identifier and DLC </p>
<p></p>
<p> </p>
<p>Security level for the data consistency during the internal copy routines for receive and </p>
<p>transmit data. </p>
<p></p>
<p> </p>
<p>Configurable  callback  functions  to  control  hardware  dependent  loop  break  conditions </p>
<p>(e.g. during the transition to reset, standby or sleep mode). </p>
<p></p>
<p> </p>
<p>For </p>
<p>micros </p>
<p>with </p>
<p>nested </p>
<p>interrupt </p>
<p>levels </p>
<p>the </p>
<p>global </p>
<p>disabling </p>
<p>of </p>
<p>interrupts </p>
<p>by </p>
<p>CanGlobalInterruptDisable/Restore() is replaced by a configurable interrupt lock level. </p>
<p><b>3.2.1.2 </b></p>
<p><b>Optional (for some specific CAN Drivers) </b></p>
<p></p>
<p> </p>
<p>Support  of  extended  CAN  identifiers  in  different  modes  (extended  only  or  mixed  with </p>
<p>standard identifiers) </p>
<p></p>
<p> </p>
<p>Non-interrupt (polling) mode for asynchronous transmission, reception, error and wake-</p>
<p>up notification. </p>
<p></p>
<p> </p>
<p>Dynamic transmit objects (for flexible transmit buffer, pretransmit as well as confirmation </p>
<p>function). </p>
<p></p>
<p> </p>
<p>Full CAN Transmit Objects with fixed CAN identifier and DLC. </p>
<p></p>
<p> </p>
<p>Dynamic hardware acceptance filtering for the reception of different messages. </p>
<p><b>3.2.2 </b></p>
<p><b>What's changed? </b></p>
<p></p>
<p> </p>
<p>Service  functions  for  flexible  CAN  identifier  and  DLC  CanTransmitVarDLC/ID(..)  must </p>
<p>not be used for new developments. It will be replaced by dynamic transmit objects. </p>
<p></p>
<p> </p>
<p>Special macros for the direct access to CAN message information (identifier, DLC, ...) in </p>
<p>the receive function (Dir...) will be removed. The standard macros can be used instead. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>17 / 149</p>
<p></p>
<p> </p>
<p>Configurable  DLC  check  for  the  length  of  the  according  receive  buffer  to  avoid  the </p>
<p>overwriting  of  the  next  receive  buffer:  The  complete  data  will  not  be  copied  and  the </p>
<p>Application will not be notified if an inconsistency is detected. </p>
<p></p>
<p> </p>
<p>The return code data type of the CanGetStatus() service function has changed because </p>
<p>of additional information in the software state of the CAN Driver and the hardware state </p>
<p>of the CAN Controller. </p>
<p><b>3.3 </b></p>
<p><b>Version 1.2 </b></p>
<p><b>3.3.1 </b></p>
<p><b>What’s new? </b></p>
<p></p>
<p> </p>
<p>Hash search algorithm  </p>
<p></p>
<p> </p>
<p>Low level transmit functionality to support e.g. gateways </p>
<p></p>
<p> </p>
<p>Service functions to stop and restart the CAN Controller. </p>
<p></p>
<p> </p>
<p>partial offline to switch dedicated transmit messages off. </p>
<p></p>
<p> </p>
<p>New return code of CanTransmit() in case of partial offline. </p>
<p></p>
<p> </p>
<p>Macros which return 8 bit of a received extended ID for use in precopy functions. </p>
<p></p>
<p> </p>
<p>Access to error counter of the CAN controller </p>
<p></p>
<p> </p>
<p>Service function to cancel transmit requests and confirmations </p>
<p><b>3.3.2 </b></p>
<p><b>What’s changed? </b></p>
<p></p>
<p> </p>
<p>Generic Precopy function is now mandatory </p>
<p></p>
<p> </p>
<p>CanSleep() and CanWakeUp() has now a return value. </p>
<p></p>
<p> </p>
<p>CanGetStatus() is always available. Activation of extended status enables the additional </p>
<p>information in the hardware state of the CAN Controller. </p>
<p></p>
<p> </p>
<p>Passive  mode  can  only  be  activated  for  all  transmit  requests  and  not  for  dedicated </p>
<p>messages. </p>
<p></p>
<p> </p>
<p>The name of some macros to access the ID in a precopy function has changed </p>
<p></p>
<p> </p>
<p>In the indexed CAN Driver, CanGetDynTxObj() has the channel as additional parameter. </p>
<p></p>
<p> </p>
<p>Macro CanRxActualIdHi renamed to CanRxActualIdRawHi </p>
<p></p>
<p> </p>
<p>Macro CanRxActualIdLo renamed to CanRxActualIdRawLo </p>
<p><b>3.4 </b></p>
<p><b>Version 1.3 </b></p>
<p><b>3.4.1 </b></p>
<p><b>What’s new? </b></p>
<p></p>
<p> </p>
<p>New service functions to disable and restore CAN interrupts </p>
<p><b>3.4.2 </b></p>
<p><b>What’s changed? </b></p>
<p></p>
<p> </p>
<p>Function CanInterruptDisable renamed to CanGlobalInterruptDisable </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>18 / 149</p>
<p></p>
<p> </p>
<p>Function CanInterruptRestore renamed to CanGlobalInterruptRestore </p>
<p></p>
<p> </p>
<p>Support of systems with mixed Identifier expanded </p>
<p></p>
<p> </p>
<p>Macro CanRxActualId returns the Identifier always in the logical presentation </p>
<p><b>3.5 </b></p>
<p><b>Version 1.4 </b></p>
<p><b>3.5.1 </b></p>
<p><b>What’s new? </b></p>
<p><b>3.5.1.1 </b></p>
<p><b>Mandatory (for all CAN Drivers) </b></p>
<p><b>3.5.1.1.1 Common features </b></p>
<p></p>
<p> </p>
<p>New functions CanCopyFromCan and CanCopyToCan. Hardware/Compiler dependent </p>
<p>functions  to  optimize  copying  of  data  (provide  for  higher  layers  such  as  TP,  Diag).    </p>
<p>more…   API… </p>
<p></p>
<p> </p>
<p>The </p>
<p>CAN </p>
<p>driver </p>
<p>can </p>
<p>be </p>
<p>configured </p>
<p>to </p>
<p>run </p>
<p>without </p>
<p>any </p>
<p>disabling </p>
<p>of </p>
<p>interrupts. </p>
<p>The application has to take care of reentrancy! To set the Can Driver to this mode, the </p>
<p>security level has to be set to the lowest value.    more… </p>
<p></p>
<p> </p>
<p>The  CAN  Driver  is  more  fault  tolerant  against  unexpected  CAN  interrupts  like  Rx </p>
<p>interrupt of a transmit object. Interrupt in polling mode or interrupts of unused objects </p>
<p>are handled by the driver. </p>
<p></p>
<p> </p>
<p>Callback function ApplCanPreWakeUp which is called immediately after the activation of </p>
<p>the wakeup interrupt.  more...     API… </p>
<p></p>
<p> </p>
<p>The CAN Driver doesn’t use library function of the compiler library (except for intrinsic </p>
<p>functions) </p>
<p></p>
<p> </p>
<p>The Can Driver code is MISRA compliant. </p>
<p><b>3.5.1.1.2 Transmission features </b></p>
<p>A  confirmation  function  common  to  all  transmit  messages  is  supported.  This  function  is </p>
<p>called  after  any  successful  transmission  (except  Direct  Transmit  Objects  but  includes </p>
<p>canceled transmit objects that had been sent although).    more…   API… </p>
<p><b>3.5.1.2 </b></p>
<p><b>Optional (for some specific CAN Drivers) </b></p>
<p><b>3.5.1.2.1 Transmission features </b></p>
<p></p>
<p> </p>
<p>CanDirectTransmit( txHandle ) to support direct transmit objects. </p>
<p>This </p>
<p>transmission </p>
<p>is </p>
<p>completely </p>
<p>independent </p>
<p>of </p>
<p>other </p>
<p>transmit </p>
<p>messages </p>
<p>and </p>
<p>can  </p>
<p>be  sent  e.g.  out  of  a  NMI  (non-maskable  interrupt  service  routine.  (see  also  what’s </p>
<p>changed). </p>
<p><b>3.5.1.2.2 Reception features </b></p>
<p></p>
<p> </p>
<p>For Full CAN controllers polling of Basic CAN is supported (all functionality of the CAN </p>
<p>driver can be used in polling mode).    more… </p>
<p></p>
<p> </p>
<p>A  callback  function  is  called,  if  the  DLC  check  fails  (this  means  if  the  DLC  of  the </p>
<p>received message is shorter than configured for this message).    more…     API… </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>19 / 149</p>
<p></p>
<p> </p>
<p>Support variable data length (for specific OEMs). </p>
<p> </p>
<p><b>3.5.2 </b></p>
<p><b>What’s changed? </b></p>
<p></p>
<p> </p>
<p>The  names  of  the  different  kinds  of  transmission  objects  changed.  To  make  the </p>
<p>differences clear in the following table all kinds of transmission objects are listed even if </p>
<p>nothing changed.    more… </p>
<p><b>Old names (before RI 1.4) </b></p>
<p><b>New names (RI 1.4 and later) </b></p>
<p>Transmit Objects </p>
<p>Normal Transmit Object </p>
<p>Direct Transmit Objects </p>
<p>Full CAN Transmit Object </p>
<p>Dynamic Transmit Objects </p>
<p>Dynamic Transmit Objects </p>
<p>--- </p>
<p>Direct Transmit Objects </p>
<p>Low Level Message Transmit </p>
<p>Low Level Message Transmit </p>
<p> </p>
<p><b>3.5.2.1 </b></p>
<p><b>Transmission features </b></p>
<p></p>
<p> </p>
<p>The  interface  of  the  TxObserve  Callback  functions  has  changed  (parameter  of  the </p>
<p>functions  ApplCanTxObjStart()  and  ApplCanTxObjConfirmed()  and  ApplCanInit().  An </p>
<p>additional parameter is used. This additional parameter is the handle of the hardware </p>
<p>object (a unique number over all hardware transmit objects which starts with 0).  </p>
<p>    </p>
<p>more…   API… </p>
<p></p>
<p> </p>
<p>The  functions  CanCancelTransmit()  and  CanCancelMsgTransmit  can  now  delete  a </p>
<p>message in the hardware transmit buffer as well as in the queue.    more… API… </p>
<p></p>
<p> </p>
<p>To get the tx handle of a pending transmit message, a new Service function is defined: </p>
<p>CanTxGetActHandle(CanObjectHandle logTxHwObject)    more…   API… </p>
<p></p>
<p> </p>
<p>If a CAN controller doesn’t support arbitration by ID, Direct Transmit Objects and Full </p>
<p>CAN Transmit Objects have a higher priority than the Normal Transmit Object. The Low </p>
<p>Level Message transmission has the lowest priority.    more… </p>
<p></p>
<p> </p>
<p>It is not possible/necessary any longer to specify the number of the CAN transmit buffer </p>
<p>for Full CAN Transmit Objects. This will be done by the Generation Tool automatically. </p>
<p></p>
<p> </p>
<p>The functions CanPartOffline and CanPartOnline are designed to be reentrant.    API… </p>
<p><b>3.6 </b></p>
<p><b>Version 1.5 </b></p>
<p><b>3.6.1 </b></p>
<p><b>What’s new? </b></p>
<p></p>
<p> </p>
<p>data size optimized Tx Queue. </p>
<p></p>
<p> </p>
<p>In systems with mixed IDs (standard and extended), each range can be configured to </p>
<p>standard or extended ID individually. </p>
<p></p>
<p> </p>
<p>Each  hardware  objects  can  be  configured  individually  to  polling  or  interrupt  mode.    </p>
<p>more...   API... </p>
<p></p>
<p> </p>
<p>Multiple Basic CAN objects can be defined to optimize the hardware filters.    more... </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>20 / 149</p>
<p></p>
<p> </p>
<p>Rx Queue supports now queuing of messages out of a range. </p>
<p></p>
<p> </p>
<p>Notification about mode change of the CAN driver between offline and online mode. </p>
<p></p>
<p> </p>
<p>New macros to fill structure of Low Level Message Transmit </p>
<p></p>
<p> </p>
<p>distinguish between Standard CAN Driver and High End CAN Driver instead of optional </p>
<p>features </p>
<p><b>3.6.2 </b></p>
<p><b>What’s changed? </b></p>
<p></p>
<p> </p>
<p>Source Address of Range Specific Precopy Messages removed – deviation to HIS CAN </p>
<p>Driver Specification. (EcuNumber isn’t any longer a member of tCanRxInfoStruct) </p>
<p></p>
<p> </p>
<p>Return code of Range Precopy Functions has effect on further reception handling. </p>
<p></p>
<p> </p>
<p>Direct Transmit Objects are not supported any more </p>
<p></p>
<p> </p>
<p>API Categories Single Receive Buffer (SRD) and Multiple Receive Buffer (MRB) are not </p>
<p>supported any more. </p>
<p></p>
<p> </p>
<p>Global  Interrupt  Control  has  been  moved  to  VStdLib  (CanGlobalInterruptDisable(),. </p>
<p>CanGlobalInterruptRestore(),  Interrupt  Control  by  Application,  Interrupt  Lock  Level). </p>
<p>...more information see Application Note AN-ISC-2-1050_VstdLibIntegration.pdf. </p>
<p></p>
<p> </p>
<p>Channel parameter for Hardware Loop Check Callbacks – deviation to HIS CAN Driver </p>
<p>Specification    API... </p>
<p></p>
<p> </p>
<p>The  following  macros  are  not  available  any  more: </p>
<p>MK_EXTID_LO, MK_EXTID_HI, </p>
<p>MK_STDID_LO,  MK_STDID_HI,  CanRxActualIdRaw,  CanRxActualIdRawHi, </p>
<p>CanRxActualIdRawLo</p>
<p> </p>
<p></p>
<p> </p>
<p>The polling Tasks are allowed to be called in Sleep mode, too. </p>
<p></p>
<p> </p>
<p>Improvement of usage of assertions </p>
<p></p>
<p> </p>
<p>Same OSEK OS interrupt category for all CAN interrupts. </p>
<p></p>
<p> </p>
<p>Variable  data  length  replaced  by  copying  data  with  received  DLC  and  DLC  check </p>
<p>against minimum length. </p>
<p></p>
<p> </p>
<p>Description of dynamic pretransmit function, dynamic confirmation function and dynamic </p>
<p>acceptance filtering removed. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>21 / 149</p>
<p><b>4 </b></p>
<p><b>Overview </b></p>
<p>For </p>
<p>error </p>
<p>prevention, </p>
<p>maintainability </p>
<p>and </p>
<p>expandability </p>
<p>of  Application </p>
<p>programs, </p>
<p>it </p>
<p>is </p>
<p>essential </p>
<p>to </p>
<p>have </p>
<p>a </p>
<p>uniform </p>
<p>interface </p>
<p>between  Application </p>
<p>and </p>
<p>CAN </p>
<p>Driver, </p>
<p>mostly </p>
<p>independent  of  the  CAN  Controller  used. The  CAN  Driver  itself  must  be  adapted  to  the </p>
<p>CAN  Controller  for  reasons  of  efficiency.  This  yields  the  following  requirements  for  a </p>
<p>universally applicable CAN Driver: </p>
<p></p>
<p> </p>
<p>Independent of Application </p>
<p></p>
<p> </p>
<p>Driver code optimized for the CAN Controller used </p>
<p></p>
<p> </p>
<p>Uniform interface to the Application for different CAN Controllers </p>
<p></p>
<p> </p>
<p>Efficient usage of hardware resources, especially RAM and run time </p>
<p></p>
<p> </p>
<p>Support  of  special  services  like  Interaction  Layer,  Network  Management,  Transport </p>
<p>Protocol </p>
<p> </p>
<p>Figure 4-1 </p>
<p>Relationship of the individual Software Components.  They are customized by the Generation Tool </p>
<p>The  generic  CAN  Driver  code  is  independent  of  the  Application.  Only  the  callback </p>
<p>functions have to be given by the Application. The Application specific description data are </p>
<p>stored in dedicated data structures. The structure of the description data is fixed; however, </p>
<p>the contents of the structures are defined according to the ECU specific behavior by the </p>
<p>Generation  Tool.  This  is  done  partly  automatically  based  on  information  in  the  CAN </p>
<p>database and partly manually by user specific settings in the Generation Tool. The data </p>
<p>structures  are  specific  for  the  CAN  Controller,  they  are  linked  to  the  CAN  Driver  code </p>
<p>(ROM-capable). </p>
<p>The data to be transmitted or received are exchanged by default via global data buffers. </p>
<p>These  data  buffers  are  CAN  message  based. They  are  also  created  by  the  Generation </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>22 / 149</p>
<p>Tool. </p>
<p>Additionally, </p>
<p>the </p>
<p>Generation </p>
<p>Tool </p>
<p>creates </p>
<p>signal-based </p>
<p>access </p>
<p>macros </p>
<p>and/or </p>
<p>functions. This means the Application does not have to know the location and the structure </p>
<p>of the global data buffers. The names of the access macros/functions are formed from the </p>
<p>signal  names  in  the  CAN  database.  The  detailed  structure  and  features  of  the  access </p>
<p>macros/functions are described in the documentation of the Generation Tool. </p>
<p>The Generation Tool will not be  discussed in this CAN Driver documentation, since it is </p>
<p>irrelevant  for  the  CAN  Driver  functionality.  But  the  generated  data  structures  are  highly </p>
<p>optimized  for  an  efficient  usage  of  each  CAN  Controller.  Therefore  the  usage  of  the </p>
<p>Generation Tool is a must to customize the CAN Driver code to the special needs of the </p>
<p>Application. </p>
<p><b>4.1 </b></p>
<p><b>Short Summary of the Functional Scope </b></p>
<p>In this section the main tasks of the CAN Driver are summarized very briefly: </p>
<p>1. </p>
<p>Initialize the CAN Controller </p>
<p>2. </p>
<p>Transmit a single CAN message </p>
<p>3. </p>
<p>Receive a single CAN messages </p>
<p>4. </p>
<p>Handle Bus-Off  </p>
<p>5. </p>
<p>Support sleep mode </p>
<p>6. </p>
<p>Support special services </p>
<p> </p>
<p><b>4.1.1 </b></p>
<p><b>Initialization </b></p>
<p>There  are  several  CAN  Driver  service  functions  for  initialization  purposes  available. </p>
<p>CanInitPowerOn(..) for the complete initialization of software and hardware after power-on, </p>
<p>CanResetBusOffStart(..)  and  CanResetBusOffEnd(..)  for  the  re-initialization  of  the  CAN </p>
<p>Controller after BusOff. For any other re-initialization the application can call CanInit(..). </p>
<p>Various </p>
<p>initialization </p>
<p>data </p>
<p>structures </p>
<p>can </p>
<p>be </p>
<p>predefined </p>
<p>by </p>
<p>the </p>
<p>Generation  Tool </p>
<p>and </p>
<p>referenced in the Application by means of a specific initialization handle. </p>
<p><b>4.1.2 </b></p>
<p><b>Transmission </b></p>
<p>One of the main services provided by the CAN Driver is to set up a transmit request in the </p>
<p>CAN </p>
<p>Controller </p>
<p>by </p>
<p>the </p>
<p>service </p>
<p>function </p>
<p>CanTransmit(..).  The </p>
<p>reference </p>
<p>to </p>
<p>the </p>
<p>CAN </p>
<p>message  specific  description  data  is  done  by  a  transmit  handle  used  in  the Application. </p>
<p>This information like CAN identifier and DLC is set up by the Generation Tool based on the </p>
<p>CAN Database and additional user specific settings. If the CAN Controller is busy because </p>
<p>all  hardware  transmit  objects  are  currently  reserved,  the  transmit  request  can  be  stored </p>
<p>temporarily in a transmit queue. The number of hardware transmit objects depends on the </p>
<p>CAN Controller or CAN Driver configuration. For details please refer to the CAN Controller </p>
<p>specific  documentation  TechnicalReference_CAN_&lt;hardware&gt;.pdf  [#hw_comObj].  If  the </p>
<p>CAN  Controller  is  ready,  data  can  be  copied  by  different  mechanism  to  the  hardware </p>
<p>transmit registers. The return code of the transmit function informs whether the transmit </p>
<p>request  was  accepted  by  the  CAN  Driver  or  not.  If  it  was  rejected  by  an  error  and  no </p>
<p>transmit  queue  is  used,  the Application  is  responsible  for  the  repetition  of  the  transmit </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>23 / 149</p>
<p>request until the message is in the CAN Controller. A successful transmission is signaled </p>
<p>by a confirmation. Special features like offline or passive mode are available to control the </p>
<p>transmit path of the CAN Driver by the Network Management or Diagnostics. </p>
<p><b>4.1.3 </b></p>
<p><b>Reception </b></p>
<p>If a message on the CAN bus was accepted by the hardware and software acceptance </p>
<p>filtering, data can be read by different mechanism and this asynchronous event is notified </p>
<p>to </p>
<p>the </p>
<p>application </p>
<p>by </p>
<p>an </p>
<p>indication. </p>
<p>Additionally </p>
<p>a </p>
<p>special </p>
<p>callback </p>
<p>function </p>
<p>ApplCanMsgReceived() allows the user to access receive data directly in the scope of a </p>
<p>receive interrupt before the software acceptance filtering. The algorithm for the software </p>
<p>acceptance filtering is configurable because in some Applications a lot of irrelevant CAN </p>
<p>identifiers are passing the hardware acceptance filter and an efficient software filtering is </p>
<p>very important. </p>
<p><b>4.1.4 </b></p>
<p><b>Bus-Off </b></p>
<p>The  CAN  Driver  notifies  a  detected  BusOff  state  to  the Application  by  calling  a  special </p>
<p>callback  function  ApplCanBusOff().  Further  processing  like  re-initialization  of  the  CAN </p>
<p>Controller and additional customer-specific requirements like disabling transmissions for a </p>
<p>certain time have to be done by the Application. </p>
<p><b>4.1.5 </b></p>
<p><b>Sleep Mode </b></p>
<p>Some </p>
<p>CAN </p>
<p>Controller </p>
<p>are </p>
<p>supporting </p>
<p>a </p>
<p>so </p>
<p>called </p>
<p>sleep </p>
<p>mode </p>
<p>with </p>
<p>reduced </p>
<p>power </p>
<p>consumption. </p>
<p>The </p>
<p>CAN </p>
<p>Driver </p>
<p>provides </p>
<p>the </p>
<p>service </p>
<p>functions </p>
<p>CanSleep() </p>
<p>and </p>
<p>CanWakeUp() to enter and leave this special mode on request of the Application.  </p>
<p>If </p>
<p>the </p>
<p>CAN </p>
<p>Controller </p>
<p>is </p>
<p>also </p>
<p>wakeable </p>
<p>by </p>
<p>the </p>
<p>CAN </p>
<p>bus, </p>
<p>the </p>
<p>callback </p>
<p>function </p>
<p>ApplCanWakeUp() is called if this condition is detected. In some cases this leads to the </p>
<p>situation that the CAN controller is initialized (CanWakeUp) before the application will be </p>
<p>notified.  </p>
<p>In  case  of  changing  the  PLL  (SLEEP  =  slow  speed  /  ACTIVE  =  normal  speed)  the </p>
<p>application must be informed immediately. Otherwise the “long” interrupt execution causes </p>
<p>a watchdog reset. Therefore the callback function ApplCanPreWakeUp is called just after </p>
<p>the activation of the wakeup interrupt. The configuration is done via the Generation Tool or </p>
<p>user configuration file. </p>
<p> </p>
<p><b>4.1.6 </b></p>
<p><b>Special Features </b></p>
<p>There is additional support for special features like </p>
<p></p>
<p> </p>
<p>Status of CAN Driver and CAN Controller </p>
<p></p>
<p> </p>
<p>Interrupt control </p>
<p></p>
<p> </p>
<p>Assertions </p>
<p></p>
<p> </p>
<p>Hardware loop check </p>
<p></p>
<p> </p>
<p>Support of OSEK compliant operating systems </p>
<p></p>
<p> </p>
<p>Multiple-channel CAN Driver </p>
<p></p>
<p> </p>
<p>Polling mode </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>24 / 149</p>
<p></p>
<p> </p>
<p>Handling of Extended Identifiers </p>
<p></p>
<p> </p>
<p>Stop mode </p>
<p><b>4.2 </b></p>
<p><b>Data Structures for CAN Driver Customization </b></p>
<p>The description data created by the Generation Tool are split into initialization structures </p>
<p>for </p>
<p>the </p>
<p>CAN </p>
<p>Controller </p>
<p>as </p>
<p>well </p>
<p>as </p>
<p>transmission </p>
<p>and </p>
<p>reception </p>
<p>structures </p>
<p>for </p>
<p>CAN </p>
<p>messages. They are located in the ROM memory of the microprocessor. The receive and </p>
<p>transmit buffers are mapped in RAM data and will be referenced by the description data. </p>
<p>The description data also contains references (pointers) to user-specific functions of the </p>
<p>Application. The CAN Driver accesses all the structures in the description data. The CAN </p>
<p>Driver is independent of the Application but the generated description data depends on the </p>
<p>particular Application. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>25 / 149</p>
<p> </p>
<p>Figure 4-2 </p>
<p>Description data, CAN Driver and Application with their interfaces. </p>
<p><b>4.2.1 </b></p>
<p><b>ROM Data </b></p>
<p><b>4.2.1.1 </b></p>
<p><b>Initialization Structures </b></p>
<p>The  CAN  Controller  is  initialized  with  the  description  data  stored  in  the  initialization </p>
<p>structures.  They  consist  of  the  register  values  for  the  CAN  Controller.  They  are  highly </p>
<p>dependent on the particular used CAN Controller.  </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>26 / 149</p>
<p><b>4.2.1.2 </b></p>
<p><b>Transmit Structures </b></p>
<p>The structures listed below are used by the CAN Driver internally.  </p>
<p>ID  </p>
<p>Identifier of the messages to be transmitted. The format is CAN </p>
<p>Controller dependent for efficiency reasons. </p>
<p>DLC  </p>
<p>Number of data bytes to be transmitted (Data Length Code). </p>
<p>The format is CAN Controller dependent for efficiency reasons.</p>
<p>DataPtr  </p>
<p>Pointer to the CAN message based global transmit buffer. </p>
<p>UserPreTransmitPtr  </p>
<p>Pointer to the user specific pretransmit function (must be a </p>
<p>NULL pointer if not used). </p>
<p>UserConfirmationPtr  </p>
<p>Pointer to the user specific confirmation function (must be a </p>
<p>NULL pointer if not used). </p>
<p>ConfirmationOffset/Mask </p>
<p>Byte offset and bit mask for the CAN Driver access to the </p>
<p>corresponding confirmation flag. </p>
<p> </p>
<p><b>4.2.1.3 </b></p>
<p><b>Receive Structures </b></p>
<p>The structures listed below are used by the CAN Driver internally.  </p>
<p>ID </p>
<p>Identifier of the messages to be received. The format is CAN </p>
<p>Controller dependent for efficiency reasons. </p>
<p>DataLen </p>
<p>Number of data bytes to be copied. The value may be different </p>
<p>from the DLC of the message received. The driver then only </p>
<p>copies the number of bytes stored in this structure. The other </p>
<p>bytes are ignored. </p>
<p>DataPtr </p>
<p>Pointer to the CAN message based global receive buffer. </p>
<p>UserPrecopyPtr </p>
<p>Pointer to the user specific precopy function (must be a NULL </p>
<p>pointer if not used). </p>
<p>UserIndicationPtr </p>
<p>Pointer to the user specific indication function (must be a NULL </p>
<p>pointer if not used). </p>
<p>IndicationOffset/Mask </p>
<p>Byte offset and bit mask for the CAN Driver access to the </p>
<p>corresponding indication flag. </p>
<p> </p>
<p><b>4.2.2 </b></p>
<p><b>RAM Data </b></p>
<p>The RAM data consist of transmit and receive buffers for the CAN messages. </p>
<p>In the data buffers, the first byte transmitted or received is located at the least significant </p>
<p>address of the data array (Note: Bit 7 is transmitted first).  </p>
<p>For </p>
<p>some </p>
<p>microprocessors </p>
<p>there </p>
<p>are </p>
<p>memory </p>
<p>areas </p>
<p>which </p>
<p>can </p>
<p>be </p>
<p>accessed </p>
<p>more </p>
<p>efficiently  (e.g.  internal  RAM  or  bit  addressable  segments).  The  data  buffers  can  be </p>
<p>mapped by the Generation Tool. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p> </p>
<p>27 / 149</p>
<p><b>5 </b></p>
<p><b>Detailed Description of the Functional Scope (Standard) </b></p>
<p><b>5.1 </b></p>
<p><b>Initialization </b></p>
<p><b>5.1.1 </b></p>
<p><b>Power-On Initialization of the CAN Driver </b></p>
<p>The  following  service  function  must  be  called  once  after  power-on  to  initialize  the  CAN </p>
<p>Driver: </p>
<p>void CanInitPowerOn( void ); </p>
<p> </p>
<p>This call initializes the CAN Controller for each channel and all CAN Driver variables (local </p>
<p>and global), i.e. the CAN Driver is set to online and active state. </p>
<p>This  service  function  has  to  be  called  for  a  proper  initialization  before  any  other  CAN </p>
<p>Driver function and before the global interrupts are enabled. </p>
<p><b>5.1.2 </b></p>
<p><b>Re-Initialization of the CAN Controller </b></p>
<p>The CAN Controller is completely re-initialized by the service function call: </p>
<p>void CanInit( CanInitHandle initObject ); </p>
<p> </p>
<p>The parameter initObject means a handle for a specific initialization structure. </p>
<p>It is a must to bring the CAN Driver into offline state before this service function is called. </p>
<p>By this service function only the CAN Controller and the corresponding internal variables </p>
<p>will be initialized. Software states like online/offline or active/passive remain unchanged. </p>
<p>Changes  of  individual  registers  of  the  CAN  Controller  are  only  possible  by  means  of  a </p>
<p>complete  re-initialization,  i.e.  an  entire  initialization  structure  must  be  provided  for  each </p>
<p>register change (e.g. bit timing, acceptance filtering, .. ). </p>
<p><b>5.2 </b></p>
<p><b>Transmission </b></p>
<p><b>5.2.1 </b></p>
<p><b>Detailed Functional Description </b></p>
<p>This section shows the transmission of a CAN message using different methods. For the </p>
<p>general processing first a flow chart is used. The gray decision symbols branch to features </p>
<p>that can be removed from the CAN Driver using the configuration options (see Figure 5-1). </p>
<p>In a second step sequence charts are used to show how the different objects of the CAN </p>
<p>Driver, description data and Application program work together.  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p> </p>
<p>28 / 149 </p>
<p><b>Application</b></p>
<p><b>CanTransmit</b></p>
<p><b>CAN offline</b></p>
<p>Pretransmit Function</p>
<p>kCanCopyData</p>
<p><b>Pretransmit Function </b></p>
<p><b>defined</b></p>
<p><b>Configured</b></p>
<p><b>Not configured</b></p>
<p><b>No</b></p>
<p><b>Yes</b></p>
<p><b>Copy Data</b></p>
<p><b>Initiate Transmit</b></p>
<p><b>Use Queue</b></p>
<p><b>Use</b></p>
<p><b>Use not</b></p>
<p>Queue</p>
<p>Queue</p>
<p><b>ACKNOWLEDGE</b></p>
<p><b>(sent message received)</b></p>
<p><b>Interrupt Enabled</b></p>
<p><b>No</b></p>
<p>TxObserve Started</p>
<p><b>Use TxObserve</b></p>
<p><b>Use</b></p>
<p><b>Use not</b></p>
<p><b>Enter Transmit Interrupt</b></p>
<p>Confirm TxObserve</p>
<p><b>Use TxObserve</b></p>
<p>Confirmation Function</p>
<p><b>Confirmation Function </b></p>
<p><b>Defined</b></p>
<p><b>Yes</b></p>
<p>Queue Empty</p>
<p><b>Transmit Queue</b></p>
<p><b>Yes</b></p>
<p><b>Leave Transmit Interrupt</b></p>
<p><b>CanTransmitQueuedObj</b></p>
<p>Confirm Transmission</p>
<p><b>Confirmation of </b></p>
<p><b>Transmission</b></p>
<p>Confirmation Flag</p>
<p><b>Confirmation Flag</b></p>
<p><b>Defined</b></p>
<p>end</p>
<p><b>Transmit</b></p>
<p>CAN Message</p>
<p><b>No</b></p>
<p><b>Yes</b></p>
<p><b>No</b></p>
<p><b>Yes</b></p>
<p><b>Configured</b></p>
<p><b>Not configured</b></p>
<p><b>Use</b></p>
<p><b>Use not</b></p>
<p><b>Configured</b></p>
<p><b>Not configured</b></p>
<p><b>Use</b></p>
<p><b>Use not</b></p>
<p><b>No</b></p>
<p><b>Use</b></p>
<p><b>Use not</b></p>
<p><b>Part  offline</b></p>
<p><b>check</b></p>
<p><b>No</b></p>
<p><b>Yes</b></p>
<p><b>CAN offline</b></p>
<p><b>Yes</b></p>
<p>Transmit Buffer Full</p>
<p><b>No</b></p>
<p><b>Part  offline</b></p>
<p><b>Configured</b></p>
<p><b>Not configured</b></p>
<p><b>STARTING POINT</b></p>
<p><b>Switches in the Generation Tool for </b></p>
<p><b>optional features of the CAN Driver</b></p>
<p><b>Decisions in the code, if the feature is selected.</b></p>
<p><b>Optional or mandatory functions of the CAN Driver</b></p>
<p><b>Mandatory path through the CAN Driver</b></p>
<p><b>Optional path through the CAN Driver</b></p>
<p><b>Direction of work flow</b></p>
<p> </p>
<p>Figure 5-1 </p>
<p>Transmission of a CAN message  </p>
<h1 style="page-break-before:always; "></h1>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>29 / 149</p>
<p>The main service function to initiate a transmit request is  </p>
<p>vuint8 CanTransmit( CanTransmitHandle txObject ); </p>
<p> </p>
<p>The  function  parameter  is  a  transmit  message  handle.  It  represents  an  index  in  the </p>
<p>generated transmit description data. The return code contains the following information: </p>
<p>kCanTxOk </p>
<p>Successful transmit request. The message is sent out by the </p>
<p>CAN Controller without any further action required. For CAN </p>
<p>Drivers with transmit queue, this return code is also used if the </p>
<p>transmit request has been accepted in the queue, even if it was </p>
<p>already in queue. </p>
<p>kCanTxFailed </p>
<p>CAN transmit request failed. In this case the calling application </p>
<p>has to repeat the transmit request later. </p>
<p> </p>
<p>kCanTxPartOffline </p>
<p>Error code because CAN Driver’s transmit path is in partial </p>
<p>offline mode for this transmit object. </p>
<p> </p>
<p>The left path (see Figure 5-1) time flows from top to bottom. This path shows the program </p>
<p>flow calling the service function CanTransmit(..). First the CAN Driver checks whether the </p>
<p>transmit path is switched to offline state. If so the function returns with an error code. Then </p>
<p>the Driver checks (if configured) the partial offline mode. If the specified message is offline, </p>
<p>the function will return an error code.  </p>
<p>In the next step the CAN Driver checks the availability of a hardware transmit object. If no </p>
<p>object is available the transmit request is stored in the transmit queue (if configured to be </p>
<p>used) and the CAN Driver returns to the Application with the return code kCanTxOk. If no </p>
<p>transmit queue is used the CAN Driver returns with an error code kCanTxFailed. </p>
<p>If a transmit object is available the CAN identifier and the data length code will be set in </p>
<p>accordance  to  the  description  data.  Now,  if  a  pretransmit  function  is  configured,  this </p>
<p>pretransmit  function  will  be  called.  Within  this  user  specific  function  the Application  may </p>
<p>copy the data to be transmitted directly to the CAN Controller hardware registers. If the </p>
<p>data is completely copied, the pretransmit function returns kCanNoCopyData to the CAN </p>
<p>Driver.  </p>
<p> </p>
<p>The  data  has  to  be  copied  by  the  CAN  Driver  itself,  if  there  is  no  pretransmit  function </p>
<p>defined or this function returns kCanCopyData. In this case the CAN Driver copies the data </p>
<p>from the global data buffer associated with the message to the CAN Controller hardware </p>
<p>registers. </p>
<p>Then  the  transmission  of  the  CAN  message  is  started  in  the  CAN  Controller  and  the </p>
<p>function returns the code kCanTxOk to the Application. </p>
<p>Dependent on the configuration, the TxObserve function is now started. </p>
<p>In the right path of the figure below, the time flows from bottom to top. This path shows the </p>
<p>program  flow  in  the  interrupt  service  routine  after  a  successfully  transmission  of  the </p>
<p>message  to  the  CAN  bus.  In  the  transmit  interrupt  routine,  the  confirmation  actions  are </p>
<p>performed.  If  configured,  first  the  TxObservation  is  confirmed,  then  (if  configured)  a </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>30 / 149</p>
<p>confirmation function for all messages is called. Afterwards the confirmation flag is set and </p>
<p>then the message-specific confirmation function is called.  </p>
<p>If the CAN Driver is configured to use a transmit queue, after processing the confirmation </p>
<p>actions the CAN Driver checks if the transmit queue is empty. If so the transmit interrupt </p>
<p>routine is finished. If there are entries in the queue the highest priority CAN message is </p>
<p>removed from the queue and the transmission of this message is requested. This is also </p>
<p>done on interrupt level. </p>
<p>In  the  middle  of  the  picture  we  see  the  transmit  queue  which  is  used  if  all  hardware </p>
<p>transmit objects are busy, when CanTransmit(..) is called. </p>
<p>The next sections describe the transmission of a CAN message using sequence charts. </p>
<p>The vertical lines within these diagrams represent program objects like interrupt routines, </p>
<p>functions (thick lines) or data objects (thin lines). The horizontal lines represent program </p>
<p>flow or data access within the program. Flow control and program instances are described </p>
<p>using thick lines, data access is described using thin lines. Time flows from the top of a </p>
<p>chart downwards so that sequence „1“ is performed before sequence „2“. The description </p>
<p>of the sequence charts is given in the tables following the charts.  </p>
<p> </p>
<p>The first sequence chart in Figure 5-2 shows the behavior if a hardware transmit object is </p>
<p>available, a global data buffer is associated to the message and the copy mechanism of </p>
<p>the CAN Driver is used.  </p>
<p> </p>
<p>CAN</p>
<p>CAN Data</p>
<p>Buffer</p>
<p>TX Interrupt</p>
<p>Routine</p>
<p>Can-</p>
<p>Transmit</p>
<p>Driver</p>
<p>Parameters</p>
<p>Global Data</p>
<p>Buffer</p>
<p>Conf. Flag</p>
<p>Pretransmit</p>
<p>Conf.</p>
<p>Function</p>
<p>Application</p>
<p>2</p>
<p> 5</p>
<p>3</p>
<p>6</p>
<p>1</p>
<p>8</p>
<p>9</p>
<p>7</p>
<p>10</p>
<p>4</p>
<p> </p>
<p>Figure 5-2 </p>
<p>Transmission with an available transmit object; Using global data buffer </p>
<p><b>No </b></p>
<p><b>Description </b></p>
<p>1 </p>
<p>The Application writes the data to the global data buffer </p>
<p>2 </p>
<p>The Application calls CanTransmit(..) service function  </p>
<p>3 </p>
<p>Function uses description data (CAN identifier, DLC, etc...) </p>
<p>4 </p>
<p>Global data buffer is read and copied; the transmit process is started </p>
<p>5 </p>
<p>CanTransmit(..) service function is finished, the return code is kCanTxOk </p>
<p>6 </p>
<p>The message is successfully sent to the CAN bus. Transmit interrupt routine is </p>
<p>started </p>
<p>7 </p>
<p>Transmit confirmation flag is set (cleared by the Application) </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>31 / 149</p>
<p>8 </p>
<p>Confirmation function is called </p>
<p>9 </p>
<p>Confirmation functions returns to transmit interrupt routine </p>
<p>10 </p>
<p>Transmit interrupt routine is left </p>
<p> </p>
<p>The next sequence chart in shows the behavior if a hardware transmit object is available </p>
<p>and a pretransmit function is used to copy the data to be sent. </p>
<p> </p>
<p> </p>
<p>CAN</p>
<p>CAN Data</p>
<p>Buffer</p>
<p>TX Interrupt</p>
<p>Routine</p>
<p>Can-</p>
<p>Transmit</p>
<p>Driver</p>
<p>Parameters</p>
<p>Global Data</p>
<p>Buffer</p>
<p>Conf. Flag</p>
<p>Pretransmit</p>
<p>Conf.</p>
<p>Function</p>
<p>Application</p>
<p>1</p>
<p>9</p>
<p>7</p>
<p>3</p>
<p>6</p>
<p>8</p>
<p>2</p>
<p>11</p>
<p>5</p>
<p>4</p>
<p>10</p>
<p> </p>
<p>Figure 5-3 </p>
<p>Transmission with an available hardware transmit object; Using a pretransmit function to copy data </p>
<p> </p>
<p><b>No </b></p>
<p><b>Description </b></p>
<p>1 </p>
<p>CanTransmit(..) service function is called by the Application </p>
<p>2 </p>
<p>Function reads the description data (CAN identifier, DLC, etc.) </p>
<p>3 </p>
<p>Call of the pretransmit function </p>
<p>4 </p>
<p>Pretransmit function writes data to the CAN Controller </p>
<p>5 </p>
<p>Pretransmit function returns to CanTransmit(..) </p>
<p>6 </p>
<p>Start transmission; CanTransmit(..) service function is finished and the return code </p>
<p>is kCanTxOk </p>
<p>7 </p>
<p>The message is successfully sent to the CAN bus. Transmit interrupt routine is </p>
<p>started </p>
<p>8 </p>
<p>Transmit confirmation flag is set (cleared by the Application) </p>
<p>9 </p>
<p>Confirmation function is called </p>
<p>10 </p>
<p>Confirmation function returns to transmit interrupt routine </p>
<p>11 </p>
<p>Transmit interrupt routine is left </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>32 / 149</p>
<p>The next sequence chart in shows the behavior, if no hardware transmit object is available. </p>
<p>This sequence chart is valid only if the CAN Driver is configured to use a transmit queue. </p>
<p>The data is copied by the CAN Driver itself. </p>
<p> </p>
<p> </p>
<p>Figure 5-4 </p>
<p>Transmit procedure if no hardware transmit object available </p>
<p><b>No </b></p>
<p><b>Description </b></p>
<p>1 </p>
<p>The Application writes the data to the global data buffer </p>
<p>2 </p>
<p>The Application calls CanTransmit() service function. No hardware transmit objects </p>
<p>available. Request is stored in the transmit queue. </p>
<p>3 </p>
<p>Function returns kCanTxOk </p>
<p>4 </p>
<p>Transmit interrupt: A (previous) CAN message was successfully sent, transmit object </p>
<p>is available again </p>
<p>5 </p>
<p>Confirmation flag of the previous CAN message is set (cleared by the Application)  </p>
<p>6 </p>
<p>Confirmation function of the previous CAN message is called </p>
<p>7 </p>
<p>Confirmation function return </p>
<p>8 </p>
<p>The transmit queue is checked for requests. The pending transmit request is found. </p>
<p>The description data are evaluated (CAN identifier, DLC, etc...) </p>
<p>9 </p>
<p>Global data buffer is read and copied; the transmit process is started </p>
<p>10 </p>
<p>Transmit interrupt routine is left </p>
<p> </p>
<p><b>5.2.2 </b></p>
<p><b>Transmit Queue </b></p>
<p>The  normal  Tx  object  can  be  configured  to  use  a  transmit  queue  or  not.  The  Transmit </p>
<p>Queue  is  not  available  for  Full  CAN  Objects  and  the  Low  Level  Transmit  Object.  If  no </p>
<p>transmit  queue  is  used,  the Application  is  responsible  to  restart  a  transmit  request  if  it </p>
<p>wasn’t accepted by the CAN Driver. In case of using a transmit queue, a transmit request </p>
<p>is always accepted (if the driver is online). But the transmit queue holds only the transmit </p>
<p>CAN</p>
<p> </p>
<p>CAN Data</p>
<p>Buffe</p>
<p>r</p>
<p>TX Interrupt</p>
<p>Routine</p>
<p>Can-</p>
<p>Transmit</p>
<p>Driver</p>
<p>Parameters</p>
<p>Global Data</p>
<p>Buffe</p>
<p>r</p>
<p>Conf. Flag</p>
<p>Pretransmit</p>
<p>Conf.</p>
<p> </p>
<p>Function</p>
<p>Application</p>
<p>2</p>
<p>1</p>
<p>3</p>
<p>8</p>
<p> </p>
<p>9</p>
<p> </p>
<p>10</p>
<p> </p>
<p>6</p>
<p>4</p>
<p> </p>
<p>5</p>
<p>7</p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>33 / 149</p>
<p>request  of  a  CAN  message.  It  doesn’t  store  the  data  to  be  sent.  Please  note  the  same </p>
<p>message can be queued only once. The CAN Driver sets a transmit request in the transmit </p>
<p>queue,  if  no  hardware  transmit  object  is  available  after  CanTransmit(..)  is  called.  On  a </p>
<p>transmit  interrupt,  i.  e.  when  a  message  has  been  sent  successfully,  the  CAN  Driver </p>
<p>checks whether transmit requests are stored in the queue. If so, one requests is removed </p>
<p>from the queue and the transmit request is executed. The search algorithm in the queue is </p>
<p>priority  based,  there  is  no  FIFO  strategy. This  means  the  CAN  identifier  with  the  lowest </p>
<p>number is removed first from the queue. </p>
<p>If the CAN Driver is configured to use a transmit queue, the internal data copy mechanism </p>
<p>will  be  initiated  and/or  the  pretransmit  function  will  be  called  in  the  scope  of  a  transmit </p>
<p>interrupt  after  the  completion  of  a  previous  transmit  request.  Therefore  the  user  has  to </p>
<p>guarantee  the  data  consistency,  because  an Application  write  access  to  the  global  data </p>
<p>buffer may be interrupted by such a transmit interrupt. If within this interrupt the associated </p>
<p>message is requested to be transmitted on the CAN bus, inconsistent data may be sent. </p>
<p>The Application must ensure data consistency by one of the following mechanisms: </p>
<p></p>
<p> </p>
<p>Disable Interrupts while writing data to the global data buffer </p>
<p></p>
<p> </p>
<p>Use  the  message  based  confirmation  flag  to  manage  the  data  access  handling.  On </p>
<p>startup the access right is on Application side. Calling CanTransmit(..) this access right </p>
<p>is given to the CAN Driver. As soon as the confirmation flag is set by the CAN Driver, </p>
<p>the access right is given back to the Application. </p>
<p></p>
<p> </p>
<p>In  polling  mode  the  service  function  CanTxTask()  must  be  used  to  transmit  queued </p>
<p>messages. The transmission of a CAN message is only started if the CanTxTask() is </p>
<p>called. In polling mode every message is queued in the transmit queue. To ensure that </p>
<p>every message was send the CanTxTask() may be called cyclic. </p>
<p><b>5.2.3 </b></p>
<p><b>Data Copy Mechanisms </b></p>
<p>There are two different methods for the Application to pass the data to be transmitted to </p>
<p>the CAN Driver. The CAN Driver selects the method for each message depending on the </p>
<p>CAN Driver description data. If no pretransmit function is defined, the usage of a global </p>
<p>data buffer is a prerequisite and the CAN Drivers internal data copy mechanism is always </p>
<p>used.  If  a  pretransmit  function  is  defined,  the  data  to  be  transmitted  may  be  stored </p>
<p>anywhere  in  the  Applications  memory  and  the  user  defined  copy  mechanism  in  the </p>
<p>pretransmit function is used. </p>
<p><b>5.2.3.1 </b></p>
<p><b>Internal </b></p>
<p>With the internal data copy mechanism, the Application writes the data to be transmitted to </p>
<p>a  global  data  buffer  associated  with  the  transmit  message.  The  global  data  buffer  is </p>
<p>defined by the Generation Tool. The access to the global data buffer is done by means of </p>
<p>access  macros  and/or  functions  which  are  also  defined  by  the  Generation  Tool.  After </p>
<p>passing the data to the global data buffer, the Application initiates the transmit request by </p>
<p>calling CanTransmit(..) and the data is copied internally to the CAN Controller hardware </p>
<p>registers. </p>
<p> </p>
<p><b>Important </b></p>
<p>Data consistency of CAN messages has to be guaranteed by the Application if </p>
<p>CanTransmit(..) is called on a higher interrupt or task level, or the transmit queue is </p>
<p>used. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>34 / 149</p>
<p><b>5.2.3.2 </b></p>
<p><b>User defined (“Pretransmit Function”) </b></p>
<p>Using  the  pretransmit  function  to  pass  the  data  to  be  transmitted  to  the  CAN  bus,  the </p>
<p>Application  first  initiates  the  transmit  request  by  calling  CanTransmit(..).  Just  before  the </p>
<p>message is put in the CAN chip, the CAN Driver calls a user defined pretransmit function. </p>
<p>For  each  transmit  message  a  separate  pretransmit  function  may  be  defined.  Within  this </p>
<p>user specific function the user can write the data directly to the hardware registers of the </p>
<p>CAN Controller, but other tasks can also be performed. The return code of the pretransmit </p>
<p>function indicates to the CAN Driver whether the data are to be copied by the CAN Driver </p>
<p>internally from the global data buffer to the CAN Controller hardware registers or not (if it is </p>
<p>already done within the pretransmit function). </p>
<p> </p>
<p> </p>
<p><b>Important </b></p>
<p>Be careful if a pretransmit function is used. Interrupts are not disabled during the call of </p>
<p>this user specific function by the CAN Driver, therefore the restrictions for security level 0 </p>
<p>are valid. If the interrupts are not disabled before and restored after the copy process by </p>
<p>the Application, data consistency of a CAN messages cannot be guaranteed if the </p>
<p>transmit queue is used. </p>
<p><b>5.2.4 </b></p>
<p><b>Notification </b></p>
<p>After the successful transmission of a message on the CAN bus (i.e. at least one other </p>
<p>CAN bus node received the CAN message correctly with an acknowledge), the Application </p>
<p>can be notified by different confirmation mechanisms: </p>
<p><b>5.2.4.1 </b></p>
<p><b>Data Interface (Confirmation Flag) </b></p>
<p>If  a  confirmation  flag  is  used,  this  message  related  flag  is  set  by  the  CAN  Driver,  if  the </p>
<p>associated  CAN  message  was  sent  on  the  CAN  bus.  This  is  done  in  the  scope  of  the </p>
<p>transmit interrupt. The flag must be cleared by the Application. </p>
<p> </p>
<p> </p>
<p><b>Important </b></p>
<p>Interrupts have to be disabled while the confirmation flags are being cleared, because of </p>
<p>the read-modify-write conflict if this operation is interrupted by a CAN transmit interrupt </p>
<p>routine. This can result in the loss of events.  </p>
<p><b>5.2.4.2 </b></p>
<p><b>Functional Interface (Confirmation Function for each message) </b></p>
<p>In parallel or instead of the data interface a functional interface can be configured, i.e. user </p>
<p>specific function is called if the associated CAN message was sent on the CAN bus. This </p>
<p>is also done in the scope of the transmit interrupt and therefore special care of the run time </p>
<p>of this function has to be taken. </p>
<p><b>5.2.4.3 </b></p>
<p><b>Functional Interface (Common Confirmation Function for all messages) </b></p>
<p>A common confirmation function informs the application via ApplCanTxConfirmation about </p>
<p>a  successful  transmission  of  a  message.  Any  message  is  confirmed  via  this  callback </p>
<p>function. </p>
<p> </p>
<p> </p>
<p><b>Info</b> </p>
<p>A canceled transmission will provoke a notification if the message was send on the bus. </p>
<p>If the message had been deleted out of the hardware, the application will not be notified. </p>
<p>More… </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>35 / 149</p>
<p><b>5.2.5 </b></p>
<p><b>Offline Mode </b></p>
<p>The CAN Driver's transmit path can be switched to the offline state, i.e. disabled. In this </p>
<p>state  no  CAN  messages  are  sent  to  the  CAN  bus.  On  each  transmit  request  the  CAN </p>
<p>Driver  checks  the  internal  flag  which  indicates  whether  the  transmission  is  currently </p>
<p>disabled and the transmit service function returns an error code. This flag is set and reset </p>
<p>by the following CAN Driver service functions </p>
<p>void CanOnline( void ); </p>
<p>void CanOffline( void ); </p>
<p> </p>
<p>These  CAN  Driver  service  functions  are  called  by  the  Network  Management  or  by  the </p>
<p>Application (only if there is no Network Management available on a specific CAN channel). </p>
<p> </p>
<p>The Application can be notified about the mode change (e.g. if the Network Management </p>
<p>calls </p>
<p>CanOnline()</p>
<p> or </p>
<p>CanOffline()</p>
<p>). This is done with the following callback functions: </p>
<p> </p>
<p>void ApplCanOnline( void ); </p>
<p>void ApplCanOffline( void ); </p>
<p> </p>
<p><b>5.2.6 </b></p>
<p><b>Partial Offline Mode </b></p>
<p>The partial Offline Mode enables the application to prevent the transmission of groups of </p>
<p>CAN messages. CanTransmit() returns a special code, if the requested message cannot </p>
<p>be sent because of the active partial offline mode. The partial offline mode is implemented </p>
<p>by the following functions: </p>
<p>void   CanPartOnline ( vuint8 sendGroup ); </p>
<p>void   CanPartOffline( vuint8 sendGroup ); </p>
<p>vuint8 CanGetPartMode( void ); </p>
<p> </p>
<p>The partial offline mode can handle up to eight different groups of messages. The function </p>
<p>parameter sendGroup decides about this group. CanPartOffline() switches all messages of </p>
<p>one  ore  more  send  groups  to  the  offline  state.  Earlier  calls  of  CanPartOffline()  are  not </p>
<p>affected. CanPartOnline() switches one or more send groups back to online state.  </p>
<p>Each message might be assigned to one or more send groups. The names of the send </p>
<p>groups are configurable. Each send group can be switched to offline or online by using the </p>
<p>generated define: </p>
<p>C_SEND_GRP_&lt;name&gt; </p>
<p>C_SEND_GRP_ALL </p>
<p> </p>
<p> </p>
<p> </p>
<p>can be used to switch all groups together to offline or online. </p>
<p> </p>
<p> </p>
<p><b>Example</b> </p>
<p>The following table shows, which message is assigned to which send group (CANgen </p>
<p>concept. For GENy concept, go to the next chapter.). </p>
<p><b>send group name </b></p>
<p><b> </b></p>
<p>7 </p>
<p>6 </p>
<p>5 </p>
<p>4 </p>
<p>3 </p>
<p>User2 </p>
<p>User1 </p>
<p>User0</p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>36 / 149</p>
<p>MESSAGE1 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>x </p>
<p>x </p>
<p>x </p>
<p> </p>
<p>MESSAGE2 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>x </p>
<p> </p>
<p>x </p>
<p>MESSAGE3 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>x </p>
<p>x </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Example</b> </p>
<p>for a possible program flow: </p>
<p>CanPartOffline(C_SEND_GRP_User0);  MESSAGE2 is stopped to be send </p>
<p>CanPartOffline(C_SEND_GRP_User1);  MESSAGE1 is stopped to be send </p>
<p>   </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>   MESSAGE2 is still stopped to be send </p>
<p>status = CanGetPartMode(); </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>status is equal to ( C_SEND_GRP_User0 </p>
<p>|   </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>C_SEND_GRP_User1) </p>
<p>CanPartOnline(C_SEND_GRP_User0); </p>
<p>MESSAGE1 is still stopped to be sent </p>
<p>   </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>   MESSAGE2 can be sent again </p>
<p>CanPartOffline(C_SEND_GRP_User0 | C_SEND_GRP_3);  </p>
<p>   MESSAGE1 is stopped to be sent     </p>
<p>   MESSAGE2 is stopped to be sent    </p>
<p>   MESSAGE3 is stopped to be sent </p>
<p>CanPartOnline(C_SEND_GRP_ALL); </p>
<p>    All send groups are online again. All    </p>
<p>  messages can be sent now. </p>
<p> </p>
<p><b>Info</b> </p>
<p>If the offline mode and partial offline mode are used in parallel the offline </p>
<p>mode has ‘higher priority’. This means if the offline mode is set the function </p>
<p>CanTransmit always returns ‘kCanTxFailed’ independent of the current </p>
<p>partial offline state. </p>
<p> </p>
<p> </p>
<p><b>5.2.6.1 </b></p>
<p><b> Partial Offline Mode with GENy </b></p>
<p>In GENy there are  </p>
<p></p>
<p> </p>
<p>8 Offline Modes (SendGroups) </p>
<p></p>
<p> </p>
<p>Default name is UserX, but can be changed as shown in the illustration below. There </p>
<p><b>Offline mode 4 </b>is changed to <b>MyGroup4</b>. </p>
<p></p>
<p> </p>
<p>5 Message Classes for </p>
<p></p>
<p> </p>
<p>Default (0) </p>
<p></p>
<p> </p>
<p>Appl </p>
<p></p>
<p> </p>
<p>Nm </p>
<p></p>
<p> </p>
<p>Tp </p>
<p></p>
<p> </p>
<p>Diag </p>
<p></p>
<p> </p>
<p>Il </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>37 / 149</p>
<p>All </p>
<p>messages </p>
<p>are </p>
<p>assigned </p>
<p>automatically </p>
<p>to </p>
<p>a </p>
<p>message </p>
<p>class </p>
<p>using </p>
<p>their </p>
<p>attribute </p>
<p>information from the DBC file.  </p>
<p> </p>
<p>Figure 5-5 </p>
<p>Partial Offline Mode settings in GENy </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>You find this information in the configuration view of the CAN Driver.  </p>
<p><b> </b></p>
<p>With  the  checked  checkbox  for  OfflineMode4  (Message  Class  1  (APPL)  all  application </p>
<p>messages are assigned to the Offline Mode 4.  </p>
<p>If you select an application message, you will find the following:  </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>38 / 149</p>
<p> </p>
<p>Figure 5-6 </p>
<p>One Single Application Message Selected </p>
<p>At the Message Class entry you see this is an application message and below you see </p>
<p>your MyGroup4 and a checked checkbox. I.e. this message is assigned to MyGroup4. </p>
<p> </p>
<p>Figure 5-7 </p>
<p>User Defined assignment to Offline Modes </p>
<p>For any message you can decide whether to assign the message to another Offline Mode </p>
<p>or to additionally assign the message to another Offline Mode. In the example above, the </p>
<p>messate  DummyTransmit  (application  message)  is  not  assigned  to  MyGroup4  anymore. </p>
<p>Now this message is assigned to USER2.  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>39 / 149</p>
<p> </p>
<p>Figure 5-8 </p>
<p>Overview Messages and Offline Modes </p>
<p><b> </b></p>
<p> </p>
<p><b>Info</b> </p>
<p>If you cannot find any information concerning Offline Modes you should use the </p>
<p>Customize Grid functionality. Activate the view below via: <b>View|Customize Grid </b>and </p>
<p>then select <b>Offline Modes</b>.  </p>
<p> </p>
<p><b> </b></p>
<p>To  get  an  overall  view  of  which  message  is  assigned  to  which  group,  or  to  do  the </p>
<p>necessary assignments having a good overview, select all <b>TxMessages </b>in the tree view </p>
<p>and activate the Offline Modes via Customize Grid (described at the top of this chapter). </p>
<p><b>5.2.7 </b></p>
<p><b>Passive State </b></p>
<p>The CAN Driver's transmit path can be switched to the passive state. In passive state no </p>
<p>transmit request is passed to the CAN bus, i.e. no CAN message is sent. However, there </p>
<p>is only the CAN bus activity affected but not the Application interface because there is no </p>
<p>error  code  returned  and  the  notification  is  done  in  the  normal  way,  i.e.  the Application </p>
<p>software runs in normal operating mode. This is the main difference to the offline mode. </p>
<p>The  passive  state  may  be  used  to  localize  errors  in  a  CAN  bus  and  is  realized  by  the </p>
<p>following CAN Driver service functions </p>
<p>void CanSetActive ( void ); </p>
<p>void CanSetPassive( void ); </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>40 / 149</p>
<p> </p>
<p>The passive state of the CAN Driver is usually used during the development phase of the </p>
<p>CAN bus. If an Application might disturb the other nodes, it can be switched to passive </p>
<p>state  temporarily  and  simulated  by  an  appropriated  tool.  This  is  usually  done  by  a </p>
<p>Diagnostics. </p>
<p> </p>
<p> </p>
<p><b>Info</b> </p>
<p>To use the Passive State efficiently there must be a special support by the network </p>
<p>designer. An external tool must be able to take over the tasks of the ECU simultaneously </p>
<p>when the ECU is switched to passive state. </p>
<p> </p>
<p>The passive state of the CAN Driver must not be mixed up with the passive state of </p>
<p>OSEK Network Management. If the OSEK Network Management is put into passive </p>
<p>state (service functions SilentNM / TalkNM) only Network Management messages are </p>
<p>affected. The passive state of the CAN Driver prevents any CAN messages (including </p>
<p>Network Management messages) from being sent on the CAN bus. </p>
<p> </p>
<p>Also note the following hints for the usage of the passive state: </p>
<p></p>
<p> </p>
<p>If  the  passive  function  is  enabled  the  corresponding  code  in  CanSetPassive()  and </p>
<p>CanSetActive() is activated, otherwise only dummy macros will be provided. This results </p>
<p>in  less  CAN  Driver  code  and  an  easy  way  to  switch  off  this  service  function  without </p>
<p>changing the Application software. </p>
<p></p>
<p> </p>
<p>The Application calls the service function CanSetPassive() to prevent transmission. In </p>
<p>case of a transmit queue it is cleared, i.e. confirmation activities may be lost during the </p>
<p>transition  from  active  to  passive  state.  Beginning  with  the  next  CanTransmit()  the </p>
<p>messages are not sent on the CAN bus until CanSetActive() is called. </p>
<p>In case of a transmit queue, the service function CanSetPassive() has to be called in </p>
<p>the confirmation function of the last message to be sent on the CAN bus. If there is no </p>
<p>such request, CanSetPassive() can be called at any time. </p>
<p>In passive mode, the result seems to be successful, i.e. the code kCanTxOk is returned </p>
<p>from CanTransmit(), and all configured flags (cleared by the Application) are set and the </p>
<p>functions </p>
<p>are </p>
<p>called </p>
<p>(Common </p>
<p>Confirmation </p>
<p>Function, </p>
<p>Confirmation </p>
<p>Flag </p>
<p>and/or </p>
<p>Confirmation Function). Tx Observation is not used in passive state. </p>
<p></p>
<p> </p>
<p>To  restart  transmission,  the  service  function  CanSetActive()  has  to  be  called.  Starting </p>
<p>with  the  next  call  of  CanTransmit(),  the  messages  are  transmitted  again  on  the  CAN </p>
<p>bus. </p>
<p> </p>
<p><b>Important </b></p>
<p>If the CAN Driver is switched from active to passive state, the transmit queue will be </p>
<p>cleared and therefore some confirmations may be lost. </p>
<p> </p>
<p><b>5.2.8 </b></p>
<p><b>Tx Observe </b></p>
<p>This  functionality  is  used  to  check  the  transmit  path  of  the  CAN  Driver  by  the  following </p>
<p>way: After a successful transmit request in the CAN Controller a specific function is called: </p>
<p> void ApplCanTxObjStart( logTxHwObject ); </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>41 / 149</p>
<p> </p>
<p>If  the  message  was  sent  on  the  CAN  network  successfully  another  callback  function  is </p>
<p>called in the scope of the transmit interrupt: </p>
<p>void ApplCanTxObjConfirmed( logTxHwObject ); </p>
<p> </p>
<p>This functionality can be used to observe any transmission. As the CAN Driver is not time </p>
<p>triggered, </p>
<p>the </p>
<p>call </p>
<p>back </p>
<p>functions </p>
<p>offer </p>
<p>the </p>
<p>application </p>
<p>a </p>
<p>way </p>
<p>to </p>
<p>start </p>
<p>a </p>
<p>timer </p>
<p>with </p>
<p>ApplCanTxObjStart and stop this timer with ApplCanTxObjConfirmed. In case of exceeding </p>
<p>a predefined time for transmission, the message can be deleted or any other reaction can </p>
<p>be done.  </p>
<p>In  case  of  a  well  working  system,  these  callback  functions  are  normally  called  in  a </p>
<p>symmetric way within the maximum specified delay time which is allowed in the existing </p>
<p>run time environment after a transmit request until the CAN message is sent to the CAN </p>
<p>bus successfully. In case of a transmit error a time-out supervision can be implemented by </p>
<p>these  callback  functions  and  error  recovery  can  be  done.  If  more  than  one  hardware </p>
<p>transmit object is used, these callback functions can be called in a nested way and so an </p>
<p>additional counter is necessary. That counter has to be reset after each re-initialization of </p>
<p>the CAN Controller. This can be done in the following callback function: </p>
<p>void ApplCanInit( logTxHwObjectFirstUsed, </p>
<p>logTxHwObjectFirstUnused); </p>
<p><b>5.2.9 </b></p>
<p><b>Cancellation of a Transmission </b></p>
<p>There are several ways to cancel a requested transmission.  </p>
<p><b>5.2.9.1 </b></p>
<p><b>Cancel a Transmission via CanInit </b></p>
<p>CanInit initializes the CAN controller hardware and can therefore be used to cancel any </p>
<p>current transmission. (see Re-Initialization of the CAN Controller). Some controllers do not </p>
<p>stop  their  transmission  immediately,  so  it  is  possible  that  the  Cancellation  via  CanInit() </p>
<p>could lead to an errorframe on the bus. </p>
<p><b>5.2.9.2 </b></p>
<p><b>Cancel a Transmission via CanCancelTransmit or CanCancelMsgTransmit </b></p>
<p>Both functions work the same way, except that CanCancelTransmit cancels a transmission </p>
<p>initiated via CanTransmit and CanCancelMsgTransmit cancels a transmission initiated via </p>
<p>CanMsgTransmit. </p>
<p>The call of the confirmation function or the setting of the confirmation flag are suppressed, </p>
<p>if this message is already in the transmit buffer of the CAN Controller. If the transmit queue </p>
<p>is enabled, a pending transmit request in the queue is canceled.  </p>
<p>These functions also delete messages in the hardware transmit buffer if configured. But </p>
<p>this  feature  is  strongly  dependent  of  the  hardware.  Some  CAN  Driver  /  CAN  Controller </p>
<p>require the call of CanRxTask() / CanTxTask() to be able to continue. </p>
<p>Using the cancel functions out of the Tx observe functionality (see above) the handle for </p>
<p>the functions must be obtained via the function CanTxGetActHandle(CanObjectHandle </p>
<p>logTxHwObject). The return code decides whether it was a CanTransmit or a </p>
<p>CanMsgTransmit which causes a CanCancelTransmit or a CanCancelMsgTransmit. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>42 / 149</p>
<p>CanTransmitHandle Hdl; </p>
<p>Hdl = CanTxGetActHandle(logTxHwObject); </p>
<p> </p>
<p>if(Hdl == kCanBufferMsgTransmit) </p>
<p>{ </p>
<p>  CanCancelMsgTransmit(Hdl); </p>
<p>} </p>
<p>else if(Hdl &lt; kCanBufferMsgTransmit) </p>
<p>{ </p>
<p>  CanCancelTransmit(Hdl); </p>
<p>} </p>
<p>else if(Hdl &gt; kCanBufferMsgTransmit) </p>
<p>{ </p>
<p>  /* The Tx request was confirmed or cancelled, or no Tx request is pending. */ </p>
<p>}</p>
<p> </p>
<p> </p>
<p><b>5.2.9.3 </b></p>
<p><b>Notification about Cancellation of a message </b></p>
<p>The application can be notified each time the transmit request or the pending confirmation </p>
<p>is  cancel.    That  means  either  the  message  based  confirmation  (flag  or  function)  or  the </p>
<p>cancel </p>
<p>notification </p>
<p>will </p>
<p>be </p>
<p>executed </p>
<p>after </p>
<p>successful </p>
<p>call </p>
<p>of </p>
<p>CanTransmit() </p>
<p>or </p>
<p>CanMsgTransmit().  </p>
<p>To enable the notification the flag “CAN Cancel Notification” in the Generation Tool must </p>
<p>be  selected.  If  this  flag  is  set  a  Callback  function  informs  the  Application  about  that  a </p>
<p>message was cancelled. ApplCanCancelNotification() will be called if the transmit request </p>
<p>was  initiated  via  CanTransmit(),  ApplCanMsgCancelNotification()  will  be  called  if  the </p>
<p>request was set up via CanMsgTransmit(). </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>43 / 149</p>
<p><b>5.2.10 </b></p>
<p><b>Overview of Transmit Objects </b></p>
<p>The table shows the naming for different RI versions. Some of the features of the column </p>
<p>are hardware dependent. </p>
<p><b>Names before RI 1.4 </b></p>
<p><b>Names RI 1.4 </b></p>
<p><b>Names RI 1.5 and later </b></p>
<p>Transmit Object </p>
<p>Normal Transmit Object </p>
<p>Normal Transmit Object </p>
<p>Direct Transmit Objects </p>
<p>Full CAN Transmit Object </p>
<p>Full CAN Transmit Object </p>
<p>--- </p>
<p>Direct Transmit Objects </p>
<p>--- </p>
<p>Dynamic Transmit Objects </p>
<p>Dynamic Transmit Objects </p>
<p>Dynamic Transmit Objects </p>
<p>Low Level Message Transmit </p>
<p>Low Level Message Transmit </p>
<p>Low Level Message Transmit </p>
<p> </p>
<p><b>5.2.11 </b></p>
<p><b>Normal Transmit Object </b></p>
<p>A Normal Transmit Object is the hardware transmit object supported by all CAN Drivers. All </p>
<p>transmit messages that are not assigned to a Full CAN Transmit Object will be transmitted </p>
<p>via  this  Normal  Transmit  Object.  The  transmit  queue  works  only  on  this  object  and  the </p>
<p>Dynamic Transmit Objects can only be transmitted via this object, too. </p>
<p><b>5.2.12 </b></p>
<p><b>Full CAN Transmit Objects </b></p>
<p>Each Full CAN Transmit Object has its own Hardware Transmit Object. This means a Full </p>
<p>CAN Transmit Object holds exactly one CAN message with a specific CAN identifier and </p>
<p>DLC. These CAN messages are statically assigned by the Generation Tool. Changes of </p>
<p>this  reference  during  run  time  are  not  possible.  There  are  two  reasons  for  Full  CAN </p>
<p>Transmit Object: </p>
<p>1. </p>
<p>The associated CAN message object is never occupied by another transmit request </p>
<p>2. </p>
<p>There is no need to copy the CAN identifier and the DLC. The message data can also </p>
<p>be  stored  directly  in  the  CAN  Controller  and  the  transmit  request  can  be  initiated </p>
<p>directly.  </p>
<p> </p>
<p><b>Info</b> </p>
<p>Full CAN objects are sent via CanTransmit() function. </p>
<p> </p>
<p><b>5.2.13 </b></p>
<p><b>Dynamic Transmit Objects </b></p>
<p>The CAN Driver supports the transmission of CAN messages with dynamic parameters. </p>
<p>These messages must not be specified in the CAN database. This feature can be used in </p>
<p>gateways, for example. </p>
<p>These dynamic objects can consist of mixed dynamic and static parts. CAN identifier, DLC </p>
<p>and data pointer can be selected separately as dynamic or static. The selection is common </p>
<p>for all dynamic objects. Pretransmit functions and confirmation functions are always static. </p>
<p>The CAN identifier priority for dynamic objects is lost if a transmit queue is used. Dynamic </p>
<p>objects have a higher internal priority than static objects, independent of their current CAN </p>
<p>identifier. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>44 / 149</p>
<p>Before  the Application  can  use  a  dynamic  object,  the Application  needs  to  reserve  one. </p>
<p>This can be done by the following service function: </p>
<p>CanTransmitHandle CanGetDynTxObj( CanTransmitHandle txHandle); </p>
<p> </p>
<p>The next step is to set all dynamic parameters of this object. This will be done by calling </p>
<p>the service functions: </p>
<p>void CanDynTxObjSetId             ( ... ); </p>
<p>void CanDynTxObjSetExtId          ( ... ); </p>
<p>void CanDynTxObjSetDlc            ( ... ); </p>
<p>void CanDynTxObjSetDataPtr        ( ... ); </p>
<p> </p>
<p>After this, the dynamic object can be transmitted by calling CanTransmit(..) with the handle </p>
<p>of the dynamic object. The Application is allowed to use a dynamic object several times. If </p>
<p>the Application  doesn’t  need  the  dynamic  objects  any  more,  it  can  be  released  by  the </p>
<p>service function </p>
<p>vuint8 CanReleaseDynTxObj( CanTransmitHandle txHandle ); </p>
<p>There are two macros to allow a call of CanReleaseDynTxObj() in a confirmation function. </p>
<p>Both macros are only allowed to be called in the context of the user confirmation function </p>
<p>of this Dynamic Object. </p>
<p><b>CanConfirmStart(txHand</b></p>
<p><b>le) </b></p>
<p>This macro enables release of dynamic objects in a confirmation </p>
<p>function. </p>
<p>txHandle has to be equal to the parameter of the confirmation </p>
<p>function. </p>
<p><b>CanConfirmEnd() </b></p>
<p>This macro restores security mechanism for release of dynamic </p>
<p>Objects. </p>
<p> </p>
<p>Example: </p>
<p>void Confirm_ResDynTxObj ( CanTransmitHandle txHandle ) </p>
<p>{ </p>
<p>  … </p>
<p>  CanConfirmStart(txHandle); </p>
<p>  if (CanReleaseDynTxObj( txHandle )== kCanDynNotReleased) </p>
<p>  { //error handling } </p>
<p>  CanConfirmEnd(); </p>
<p>  … </p>
<p>} </p>
<p> </p>
<p>If  a  dynamic  object  is  used  several  times,  the Application  has  to  take  care  to  use  the </p>
<p>confirmation flag / function.  </p>
<p>The  maximum  number  of  Dynamic  Transmit  Objects  must  be  defined  statically  in  the </p>
<p>Generation Tool. </p>
<p>Messages of dynamic transmit objects can not be sent via Full CAN Transmit Objects. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>45 / 149</p>
<p><b>5.2.14 </b></p>
<p><b>Priority of Transmit Objects </b></p>
<p> </p>
<p>Full CAN Transmit Objects</p>
<p>Normal Transmit Object</p>
<p>Low Level Transmit Object</p>
<p>(High End)</p>
<p><b>Priority</b></p>
<p>Low 0</p>
<p>High n</p>
<p><b>Message ID</b></p>
<p> </p>
<p>Figure 5-9 </p>
<p>Priority of Transmit Objects </p>
<p>  </p>
<p> </p>
<p>Full CAN Objects have the highest priority and they are sorted according to their ID. This is </p>
<p>automatically done by the Generation Tool. </p>
<p>There is only one Normal Transmit Object with a lower priority than the Full CAN Objects. </p>
<p>Dynamic Transmit Objects are transmitted via the Normal Transmit Object. </p>
<p>The Low Level Message Transmit Object has the lowest priority.  </p>
<p>This priority is only valid, if the hardware is not able to arbitrate according the IDs. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>46 / 149</p>
<p><b>5.3 </b></p>
<p><b>Reception </b></p>
<p><b>5.3.1 </b></p>
<p><b>Detailed Functional Description </b></p>
<p> </p>
<p><b>Enter</b></p>
<p><b>Receive Interrupt</b></p>
<p>Receive Function</p>
<p>Generic</p>
<p>PreCopy Function</p>
<p>Precopy Function</p>
<p><b>Copy Data</b></p>
<p>Indication Flag</p>
<p>Indication Function</p>
<p><b>Leave</b></p>
<p><b>Receive Interrupt</b></p>
<p><b>Interrupt Enabled</b></p>
<p>kCanCopyData</p>
<p><b>Software</b></p>
<p><b>Acceptance Filter</b></p>
<p>kCanCopyData</p>
<p>kCanCopyData</p>
<p><b>Use Receive Function</b></p>
<p>Interrupt Request</p>
<p>is stored</p>
<p><b>Hardware</b></p>
<p><b>Acceptance Filter</b></p>
<p><b>Receive</b></p>
<p>CAN Message</p>
<p><b>Use</b></p>
<p><b>Use not</b></p>
<p><b>No</b></p>
<p><b>Yes</b></p>
<p><b>Use Generic Precopy</b></p>
<p><b>Precopy defined</b></p>
<p><b>Use</b></p>
<p><b>No</b></p>
<p><b>Yes</b></p>
<p><b>No</b></p>
<p><b>Yes</b></p>
<p><b>Defined</b></p>
<p><b>Not defined</b></p>
<p><b>Indication Flag </b></p>
<p><b>defined</b></p>
<p><b>Indication Function</b></p>
<p><b>defined</b></p>
<p><b>Defined</b></p>
<p><b>Not defined</b></p>
<p><b>Defined</b></p>
<p><b>Not defined</b></p>
<p><b>Use not</b></p>
<p><b>No</b></p>
<p><b>Yes</b></p>
<p>No Action</p>
<p><b>Message not accepted</b></p>
<p><b>Message accepted</b></p>
<p><b>Message not matched</b></p>
<p><b>Message accepted</b></p>
<p>end</p>
<p>DLC Check</p>
<p><b>Check DLC</b></p>
<p><b>Use</b></p>
<p><b>Failed</b></p>
<p><b>Ok</b></p>
<p><b>Use not</b></p>
<p>Message Not Matched</p>
<p><b>UseMessage</b></p>
<p><b>NotMatched</b></p>
<p><b>Use</b></p>
<p><b>Use not</b></p>
<p>DLC Failed</p>
<p><b>UseDlcFailed</b></p>
<p><b>Use</b></p>
<p><b>Use not</b></p>
<p><b>Switches in the Generation Tool for</b></p>
<p><b>optional features of the CAN Driver</b></p>
<p><b>Decisions in the code, if the feature is selected.</b></p>
<p><b>Optional or mandatory functions of the CAN Driver</b></p>
<p><b>Mandatory path through the CAN Driver</b></p>
<p><b>Optional path through the CAN Driver</b></p>
<p><b>Direction of work flow</b></p>
<p><b>Range</b></p>
<p><b>Filter</b></p>
<p>Range/Component</p>
<p>PreCopy Function</p>
<p><b>kCanNoCopyData</b></p>
<p><b>Use</b></p>
<p>Match?</p>
<p><b>No</b></p>
<p><b>Yes</b></p>
<p> </p>
<p>Figure 5-10 Reception of a CAN messages </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>47 / 149</p>
<p>  </p>
<p>CAN messages are received asynchronously and without any explicit service function call. </p>
<p>Normally, the CAN Driver is informed by the CAN Controller via interrupt of the reception of </p>
<p>a  CAN  message.  That  means  the  received  CAN  identifier  has  passed  the  hardware </p>
<p>acceptance filtering of the CAN Controller and the entire message is stored in a receive </p>
<p>register. In case of a Basic CAN object, the message has to be retrieved and processed as </p>
<p>fast as possible. If a feature is only in Basic CAN or Full CAN available if is mentioned in </p>
<p>the text. </p>
<p>The gray decision symbols branch to features that can be removed from the CAN Driver </p>
<p>using the configuration options of the Generation Tool. Disabled features cannot be used </p>
<p>for  any  messages.  The  code  for  these  features  is  completely  removed.  If  a  feature  is </p>
<p>enabled, it can be determined for each message whether it is used or not. </p>
<p>The  receive  callback  function ApplCanMsgReceived(..)  is  called  on  every  reception  of  a </p>
<p>CAN  message  after  the  hardware  acceptance  filter  is  passed.  Within  this  function  the </p>
<p>Application  may  preprocess  the  received  message  in  any  way  (ECU  specific  dynamic </p>
<p>filtering mechanisms, gateway functionality, etc...). If the function returns kCanCopyData, </p>
<p>the  CAN  Driver  continues  the  processing.  If  the  function  returns  kCanNoCopyData,  the </p>
<p>CAN Driver terminates the message reception. </p>
<p>During the software acceptance filtering (only available for Basic CAN) the CAN Driver first </p>
<p>checks  for  range  specific  identifiers.  For  the  range  specific  identifiers  special  precopy </p>
<p>functions may be defined. Afterwards the single CAN identifier based filtering is performed. </p>
<p>The CAN Drivers support different mechanisms like linear search, hash search or an index </p>
<p>search. </p>
<p>In </p>
<p>any </p>
<p>case </p>
<p>the </p>
<p>filtering </p>
<p>capabilities </p>
<p>of </p>
<p>the </p>
<p>CAN </p>
<p>Controller </p>
<p>are </p>
<p>used.  The </p>
<p>corresponding  receive  object  has  to  be  determined  by  comparing  the  generated  CAN </p>
<p>identifier in the data description tables with the received CAN identifier in the Basic CAN </p>
<p>object. </p>
<p>If  the  result  of  the  software  acceptance  filtering  is  negative  (only  done  for  a  Basic  CAN </p>
<p>object), </p>
<p>the </p>
<p>callback </p>
<p>function  ApplCanMsgNotMatched() </p>
<p>is </p>
<p>called. </p>
<p>Then </p>
<p>the </p>
<p>receive </p>
<p>interrupt is terminated immediately after the CAN Controller hardware is serviced. </p>
<p>After a CAN identifier match, the DLC will be checked. In case of a failed DLC check there </p>
<p>can be a configured callback function to notify the application.  </p>
<p>In case of a successful DLC check the generic precopy function is called (if configured). </p>
<p>Generic  precopy  means  that  a  common  function  named  ApplCanGenericPrecopy()  is </p>
<p>called </p>
<p>for </p>
<p>all </p>
<p>identifiers. </p>
<p>If </p>
<p>this </p>
<p>function </p>
<p>returns </p>
<p>kCanNoCopyData </p>
<p>the </p>
<p>CAN </p>
<p>Driver </p>
<p>terminates  further  processing.  If  this  function  returns  kCanCopyData,  the  CAN  Driver </p>
<p>continues to work on the message received.  </p>
<p>After  the  generic  precopy  if  configured  a  precopy  function  separate  for  each  message </p>
<p>according to the entry in the description data is called. Within this user specific function </p>
<p>any processing of the message received may occur (complete processing of a message or </p>
<p>special  storage  methods  like  ring  buffers,  FIFOs,  ...).  If  the  precopy  function  returns </p>
<p>kCanNoCopyData  the  CAN  Driver  terminates  further  processing.  If  the  precopy  function </p>
<p>returns kCanCopyData, the CAN Driver continues to work on the message received. </p>
<p>In the next step the data is copied to the global data buffer. The CAN Driver copies only </p>
<p>the number of bytes from the CAN receive buffer that is stored in the array CanRxDataLen. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>48 / 149</p>
<p>Then  the  indication  actions  defined  for  this  message  are  performed.  This  means  the </p>
<p>indication flag is set and/or the indication function is called. The Application has to reset </p>
<p>the indication flag before or after data processing. </p>
<p>In the following sections the processing steps are described using sequence charts. The </p>
<p>vertical  directed  lines  within  these  diagrams  represent  program  objects  like  interrupt </p>
<p>routines,  functions  or  data  objects.  The  horizontal  lines  represent  program  flow  or  data </p>
<p>access  within  the  program.  Within  the  sequence  charts  below  flow  control  and  program </p>
<p>instances are described using thick lines, data access is described using thin lines. Time </p>
<p>flows  from  the  top  of  a  chart  downwards  so  that  sequence  „1“  is  performed  before </p>
<p>sequence „2“. The description of the sequence charts is given in the tables following the </p>
<p>charts.  </p>
<p> </p>
<p>CAN</p>
<p>CAN Data</p>
<p>Buffer</p>
<p>RX Interrupt</p>
<p>Routine</p>
<p>Driver</p>
<p>Parameters</p>
<p>Global Data</p>
<p>Buffer</p>
<p>Indication</p>
<p>Flag</p>
<p>Precopy</p>
<p>Indication</p>
<p>ApplCan-</p>
<p>MsgReceived</p>
<p>Application</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>7</p>
<p>8</p>
<p>6</p>
<p> </p>
<p>Figure 5-11 Reception of a CAN message: The data is completely processed in the precopy function </p>
<p><b>No  </b></p>
<p><b>Description </b></p>
<p>1 </p>
<p>A CAN message has passed the hardware acceptance filtering, the receive interrupt </p>
<p>routine is triggered </p>
<p>2 </p>
<p>If configured, the ApplCanMsgReceived() callback function is called </p>
<p>3 </p>
<p>The ApplCanMsgReceived() callback function returns kCanCopyData </p>
<p>4 </p>
<p>Software acceptance filtering and identification of the received CAN message </p>
<p>5 </p>
<p>If configured, the precopy function is called. The Application is able to take control over </p>
<p>the receive process immediately after the software acceptance filtering and direct access </p>
<p>to the CAN Controller receive register is possible. </p>
<p>6 </p>
<p>Within the precopy function the data in the CAN Controller hardware registers are read </p>
<p>and completely processed. </p>
<p>7 </p>
<p>The precopy function returns kCanNoCopyData. No further processing (copying of data, </p>
<p>indication actions) occurs in the CAN Driver </p>
<p>8 </p>
<p>After servicing the CAN Controller hardware (the receive registers of the CAN Controller </p>
<p>are released), the receive interrupt routine is left. </p>
<p> </p>
<p> </p>
<p><b>Info</b> </p>
<p>1. If the ApplCanMsgReceived() callback function returns kCanNoCopyData, the </p>
<p>received message is ignored. This means no further software filtering, no precopy, no </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>49 / 149</p>
<p>copying of data and no indication actions are performed. </p>
<p> </p>
<p>2. If the precopy function returns kCanNoCopyData, no copying of data and no </p>
<p>indication actions are performed. </p>
<p> </p>
<p>CAN</p>
<p>CAN Data</p>
<p>Buffer</p>
<p>RX</p>
<p>Interrupt</p>
<p>Routine</p>
<p>Driver</p>
<p>Parameters</p>
<p>Global Data</p>
<p>Buffer</p>
<p>Indication</p>
<p>Flag</p>
<p>Precopy</p>
<p>Indication</p>
<p>ApplCanMsg</p>
<p>Receive</p>
<p>Application</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>11</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p> </p>
<p>Figure 5-12 Reception of a CAN message: The CAN Driver internal copying mechanism is used </p>
<p> </p>
<p><b>No </b></p>
<p><b>Description </b></p>
<p>1 </p>
<p>A CAN message has passed the hardware acceptance filtering, the receive interrupt </p>
<p>routine is triggered </p>
<p>2 </p>
<p>If configured, the ApplCanMsgReceived(..) callback function is called </p>
<p>3 </p>
<p>The ApplCanMsgReceived(..) callback function returns kCanCopyData </p>
<p>4 </p>
<p>Software acceptance filtering and identification of the received CAN message </p>
<p>5 </p>
<p>If  configured,  the  precopy  function  is  called. The Application  is  able  to  take  control </p>
<p>over the receive process immediately after the software acceptance filtering and the </p>
<p>direct access to the CAN Controller receive register is possible. </p>
<p>6 </p>
<p>The  precopy  function  returns  kCanCopyData. The  CAN  Driver  continues  its  normal </p>
<p>processing. </p>
<p>7 </p>
<p>The received data are copied from the CAN Controller receive register to the global </p>
<p>data buffer associated to the CAN message </p>
<p>8 </p>
<p>If configured, the indication flag is set (must be reset by the Application) </p>
<p>9 </p>
<p>If  configured,  the  indication  function  is  called;  any  user  actions  can  be  performed </p>
<p>within this user specific function </p>
<p>10 </p>
<p>Indication function returns to the receive interrupt routine </p>
<p>11 </p>
<p>Receive interrupt routine is left </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>50 / 149</p>
<p><b>5.3.2 </b></p>
<p><b>Receive Function </b></p>
<p>Before </p>
<p>the </p>
<p>software </p>
<p>filtering </p>
<p>is </p>
<p>done, </p>
<p>the </p>
<p>Application </p>
<p>optionally </p>
<p>may </p>
<p>use </p>
<p>the </p>
<p>ApplCanMsgReceived() callback function called by the CAN Driver. Within this function the </p>
<p>Application can define whether to process the message received or not. </p>
<p><b>5.3.3 </b></p>
<p><b>Range-Specific Precopy Functions </b></p>
<p>The  CAN  Driver's  receive  path  can  be  configured  to  filter  special  identifier  ranges  and </p>
<p>associated precopy functions will be called directly. Up to four ranges are supported by the </p>
<p>CAN Driver. The ranges must be defined by a start address (e.g. 0x400) and a mask (e.g. </p>
<p>0x1F, i.e. if a bit is set it means don’t care) and leads to a specific range (in our example it </p>
<p>is from 0x400 to 0x 41F). The ranges are typically predefined by the Generation Tool for </p>
<p>special functions. If these are not used they are available for the application: </p>
<p> </p>
<p>Network </p>
<p>Management </p>
<p>If the usage of a Network Management is configured </p>
<p>Range 0 </p>
<p>Application </p>
<p>Application specific. May be used by the Application </p>
<p>Diagnostics </p>
<p>If extended addressing mode of the Transport Protocol is configured </p>
<p>Range 1 </p>
<p>Application  </p>
<p>Application specific. May be used by the Application </p>
<p>Special usage </p>
<p>Car manufacturer specific </p>
<p>Range 2 </p>
<p>Application  </p>
<p>Application specific. May be used by the Application </p>
<p>Range 3 </p>
<p>Application </p>
<p>Application specific. May be used by the Application </p>
<p> </p>
<p> </p>
<p>Special capabilities of some CAN Controllers with several hardware acceptance filters may </p>
<p>also be used for the range specific filtering. </p>
<p><b>5.3.4 </b></p>
<p><b>Identifier Search Algorithms </b></p>
<p>The following software filtering mechanisms are supported: All mechanisms but linear are </p>
<p>optional in the different hardware implementations. </p>
<p>Linear Search: </p>
<p>The  identifier  of  the  incoming  message  is  compared  to  all  CAN </p>
<p>identifiers in a table (if found, the search stops). The average search </p>
<p>time is proportional to the number of receive messages. </p>
<p>Hash Search: </p>
<p>An optimized search algorithm with a small known number of search </p>
<p>steps. The Generation tool calculates an optimized search table and </p>
<p>some parameters used at run time. The number of search steps can </p>
<p>be defined by the user. The less search steps the bigger the resulting </p>
<p>hash tables. </p>
<p>Table Search:  </p>
<p>This  is  a  kind  of  hash  mechanism.  The  last  three  bits  of  a  CAN </p>
<p>identifier  are  used  as  a  selector  for  the  search  table.  There  are  8 </p>
<p>different  tables  for  each  of  the  hardware  acceptance  filters  in  the </p>
<p>CAN Controller. Within the table a linear search is implemented. </p>
<p>Index Search: </p>
<p>A  table  with  2048  entries  (one  entry  for  each  identifier)  is  used  for </p>
<p>software filtering. Index Search is used for Standard ID only. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>51 / 149</p>
<p><b>5.3.5 </b></p>
<p><b>DLC check </b></p>
<p>The  Data  Length  Code  of  a  received  message  will  be  compared  to  the  length  of  the </p>
<p>Application  receive  buffer  of  this  message.  If  the  DLC  is  smaller  than  the  Application </p>
<p>receive buffer, data will not be copied. The length of the received message buffer is the </p>
<p>maximum  length  which  is  necessary  to  treat  all  signals  for  this  ECU.  To  inform  the </p>
<p>application </p>
<p>the </p>
<p>callback </p>
<p>function </p>
<p>ApplCanMsgDlcFailed </p>
<p>will </p>
<p>be </p>
<p>called.  The </p>
<p>reception </p>
<p>process will be terminated afterwards.  </p>
<p>Depending on the OEM the length of the received data bytes can be different at run time. It </p>
<p>is  also  possible  to  compare  the  length  of  the  received  message  with  a  minimum  length </p>
<p>which can be smaller than the Application receive buffer. </p>
<p>The </p>
<p>behavior </p>
<p>can </p>
<p>be </p>
<p>configured </p>
<p>via </p>
<p>generation </p>
<p>tool </p>
<p>and </p>
<p>the </p>
<p>database </p>
<p>attribute </p>
<p>GenMsgMinAcceptLength. </p>
<p><b>5.3.6 </b></p>
<p><b>Data Copy Mechanism </b></p>
<p>There are two different methods for the Application to access the data received from the </p>
<p>CAN bus. </p>
<p><b>5.3.6.1 </b></p>
<p><b>Internal </b></p>
<p>Using the internal data copy mechanism, the CAN Driver copies the contents of the CAN </p>
<p>controller receive registers to a global data buffer associated to the receive message. The </p>
<p>Application can access the signal values in the message specific data buffer using access </p>
<p>macros  or  functions.  The  access  macros  are  generated  by  the  Generation  Tool  using </p>
<p>information  in  the  CAN  database.  The  signal  access  macros  always  return <b> unsigned </b></p>
<p><b>values</b>. </p>
<p>The Application itself is responsible for the data consistency of signals in a CAN message </p>
<p>which  cannot  be  handled  in  atomic  operations  because  the  receive  buffer  may  be </p>
<p>overwritten asynchronously by a CAN receive interrupt. Different mechanisms can be used </p>
<p>to guarantee data consistency: </p>
<p> </p>
<p>1. </p>
<p>Disabling of the CAN receive interrupt. </p>
<p>2. </p>
<p>Read  the  receive  signal.  Compare  the  signal  value  with  the  signal  in  the  hardware </p>
<p>buffer. Repeat the read operation if the values differ. </p>
<p>3. </p>
<p>Usage of the message based indication flag: </p>
<p>3.1 </p>
<p>Clear the message indication flag </p>
<p>3.2 </p>
<p>Read the data (one or more signals of a message) </p>
<p>3.3 </p>
<p>Check the message indication flag: If set then return to 3.1 </p>
<p> </p>
<p>Depending on the OEM the length of the received data bytes can be different at run time. </p>
<p>Instead  of  copying  all  needed  bytes  (equal  to  the  length  of  the  global  data  buffer </p>
<p>associated to the receive message) the CAN Driver can be configured to copy the number </p>
<p>of  received  bytes.  In  case  the  number  of  received  bytes  exceed  the  length  of  the  data </p>
<p>buffer, the CAN Driver takes care to copy at maximum the length of the data buffer. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>52 / 149</p>
<p> </p>
<p><b>Info</b> </p>
<p>The signal access macros are not affected. The application has to make sure, that it </p>
<p>does not access data via access macros that is not copied now because of a change of </p>
<p>the data length. </p>
<p> </p>
<p><b>5.3.6.2 </b></p>
<p><b>User-defined Precopy Functions </b></p>
<p>The user can define specific precopy functions for each receive object in the Generation </p>
<p>Tool.  If  defined,  the  CAN  Driver  calls  this  user-specific  function  immediately  after  the </p>
<p>software filtering. Within this precopy function the Application can access the data directly </p>
<p>in  the  CAN  Controller  receive  registers. The  precopy  function  indicates  this  to  the  CAN </p>
<p>Driver by the appropriate return code kCanNoCopyData and the further processing will be </p>
<p>terminated immediately. On the other side the CAN Driver can be forced to continue with </p>
<p>normal  processing  of  the  message  after  the  precopy  function  by  using  the  return  code </p>
<p>kCanCopyData. </p>
<p>The parameter of the precopy function is a pointer to a structure. This structure includes </p>
<p>the handle of the received message and a pointer to the received data. </p>
<p>A separate user-specific function may be defined for each receive message. But it is also </p>
<p>possible to use the same function for different messages. </p>
<p>If no such function is defined, a NULL pointer is written to the corresponding description </p>
<p>data by the Generation Tool. </p>
<p>The user has to note that these user-specific functions are called in the receive interrupt. </p>
<p>Only short receive actions should be done to avoid negative influence on the Application </p>
<p>task by a long interrupt disable time. </p>
<p>The precopy mechanism can be used to handle only a small number of receive signals in </p>
<p>an efficient way, if there is a CAN receive message with 8 bytes but the receiving ECU for </p>
<p>example only needs the 6th bit of the 7th byte. The standard copy routine starts always at </p>
<p>the  beginning  of  the  receive  data  buffer  and  copies  all  data  up  to  the  last  byte  with </p>
<p>significant signals for the dedicated node (the 7th byte in the example above). This results </p>
<p>in some overhead in RAM and run time, particularly if these signals are mapped in the rear </p>
<p>part  of  the  message.  The  precopy  function  can  therefore  be  used  to  implement  a  user </p>
<p>specific copy routine and has to return the return code kCanNoCopyData.  </p>
<p>Another  example  for  a  precopy  function  is  a  compare  mechanism  between  the  CAN </p>
<p>Controller  receive  register  and  the  global  Application  buffer.  If  both  are  matching,  data </p>
<p>have  not  to  be  copied  and  the  indication  is  not  necessary,  i.e.  kCanNoCopyData  is </p>
<p>returned. </p>
<p>Otherwise </p>
<p>the </p>
<p>return </p>
<p>code </p>
<p>kCanCopyData </p>
<p>leads </p>
<p>to </p>
<p>the </p>
<p>standard </p>
<p>copy </p>
<p>mechanism of the CAN Driver and notification to the Application using indications. </p>
<p>The precopy function can also be used to implement receive queues (FIFO, FILO or ring </p>
<p>buffer). </p>
<p><b>5.3.7 </b></p>
<p><b>Notification </b></p>
<p>After  the  reception  of  a  message  from  the  CAN  bus  and  the  successful  hardware  and </p>
<p>software </p>
<p>acceptance </p>
<p>filtering, </p>
<p>the  Application </p>
<p>can </p>
<p>be </p>
<p>notified </p>
<p>by </p>
<p>different </p>
<p>indication </p>
<p>mechanisms: </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>53 / 149</p>
<p><b>5.3.7.1 </b></p>
<p><b>Data Interface (Indication Flag) </b></p>
<p>If  an  indication  flag  is  used,  this  message  related  flag  is  set  by  the  CAN  Driver,  if  the </p>
<p>associated CAN message was received. This is done in the scope of the receive interrupt. </p>
<p>The flag must be cleared by the Application. </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>Interrupts have to be disabled during reset of the indication flags because of the read-</p>
<p>modify-write conflict if this operation is interrupted by a CAN receive interrupt routine. </p>
<p>This can result in the loss of events. </p>
<p> </p>
<p><b>5.3.7.2 </b></p>
<p><b>Functional Interface (Indication Function) </b></p>
<p>In parallel or instead of the data interface a functional interface can be configured, i.e. a </p>
<p>user-specific function is called if the associated CAN message was received. This is also </p>
<p>done in the scope of the receive interrupt and therefore special care on the run time of this </p>
<p>user-specific function has to be taken. A special notification mechanism for the Application </p>
<p>can be implemented in such an indication function. </p>
<p><b>5.3.8 </b></p>
<p><b>Not-Matched Function </b></p>
<p>If  a  CAN  message  has  passed  the  hardware  acceptance  filtering  but  is  rejected  by  the </p>
<p>software acceptance filtering (in case of a Basic CAN receive object) a special callback </p>
<p>function will be called (if configured): </p>
<p>void ApplCanMsgNotMatched( ... ); </p>
<p> </p>
<p><b>5.3.9 </b></p>
<p><b>Overrun Handling </b></p>
<p>An Overrun appears if a CAN message is lost in the Basic CAN receive object, because </p>
<p>the other was not treated yet entirely. There are two possibilities how a message could be </p>
<p>lost. In some cases the old message was overwritten with a new message. In other cases </p>
<p>a new message couldn’t be received. </p>
<p>If enabled, the Application has to provide an overrun callback function: </p>
<p>void ApplCanOverrun( void ); </p>
<p> </p>
<p>The overrun handling itself is done by the CAN Driver. </p>
<p><b>5.3.10 </b></p>
<p><b>Full CAN Overrun Handling </b></p>
<p>A  Full  CAN  Overrun  appears  if  a  CAN  message  is  lost  in  the  Full  CAN  receive  object, </p>
<p>because the other was not treated yet entirely. There are two possibilities how a message </p>
<p>could be lost. In some cases the old message was overwritten with a new message. In </p>
<p>other cases a new message couldn’t be received. </p>
<p>If  enabled,  the  Application  has  to  provide  an  overrun  callback  function  for  Full  CAN </p>
<p>objects: </p>
<p>void ApplCanFullCanOverrun( void ); </p>
<p> </p>
<p>The overrun handling itself is done by the CAN Driver </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>54 / 149</p>
<p><b>5.3.11 </b></p>
<p><b>Conditional Message Received </b></p>
<p>The </p>
<p>Conditional </p>
<p>Message </p>
<p>Received </p>
<p>function </p>
<p>ApplCanMsgCondReceived() </p>
<p>will </p>
<p>be </p>
<p>conditional called for each reception of a CAN message. The condition can be set / reset </p>
<p>and </p>
<p>read </p>
<p>by </p>
<p>application </p>
<p>via </p>
<p>CanResetMsgReceivedCondition(), </p>
<p>CanSetMsgReceivedCondition(),  and  CanGetMsgReceivedCondition().  The  condition  is </p>
<p>automatically set by CanInitPowerOn() and CanSleep().  </p>
<p> </p>
<p><b>5.4 </b></p>
<p><b>Bus-Off Handling </b></p>
<p>There are several functions provided by the CAN Driver to handle a BusOff state of the </p>
<p>CAN Controller after severe transmit errors. For some CAN Controllers a re-initialization </p>
<p>must be done to satisfy the hardware requirements others are changing automatically to </p>
<p>the 'Error Active' state after 128 x 11 recessive bits on the CAN bus as it is specified in the </p>
<p>CAN protocol. Nevertheless it is recommended by most of the customer specific CAN bus </p>
<p>specifications to re-initialize the CAN Controller in every case, because the transmit error </p>
<p>might be caused by a faulty bit in the CAN Controller registers, e.g. bus timing registers, in </p>
<p>case </p>
<p>of </p>
<p>EMC </p>
<p>influences. </p>
<p>The </p>
<p>following </p>
<p>service </p>
<p>functions </p>
<p>have </p>
<p>to </p>
<p>be </p>
<p>used </p>
<p>by </p>
<p>the </p>
<p>Application to handle a BusOff error: </p>
<p>void CanResetBusOffStart( CanInitHandle initObject ); </p>
<p>void CanResetBusOffEnd( CanInitHandle initObject ); </p>
<p> </p>
<p>Typically an extension (compared to the CAN protocol specific requirements) of the error </p>
<p>recovery time for the CAN bus is implemented. This is done by switching the CAN Driver's </p>
<p>transmit path to off using the service function CanOffline(). Because of recursive calls of </p>
<p>some CAN Driver service functions, CanResetBusOffStart(..) and CanResetBusOffEnd(..) </p>
<p>are only allowed to be called in the offline mode of the CAN Driver, i.e. CanOffline() has to </p>
<p>be called before. </p>
<p>Typically  the  Network  Management  handles  BusOff  errors.  In  such  case  there  are  no </p>
<p>additional activities necessary by the Application. If no Network Management is used, the </p>
<p>Application has to provide a callback function </p>
<p>void ApplCanBusOff( void ); </p>
<p> </p>
<p>This callback function is called by the CAN Driver in case of BusOff. The error handling as </p>
<p>described above has to be done in this function. CanOnline has to be called outside of this </p>
<p>function on task level. </p>
<p> </p>
<p> </p>
<p><b>Important </b></p>
<p>For CAN controller which has autorecovery after BusOff detection we don’t recommend </p>
<p>to use the status polling. If using status polling with autorecovery it could happen, that </p>
<p>the application doesn’t detect a BusOff because a transmit request was detected first </p>
<p>and the application wasn’t informed about the BusOff. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>55 / 149</p>
<p><b>5.5 </b></p>
<p><b>Sleep Mode </b></p>
<p>Some </p>
<p>CAN </p>
<p>Controllers </p>
<p>support </p>
<p>a </p>
<p>special </p>
<p>power-down </p>
<p>mode </p>
<p>with </p>
<p>reduced </p>
<p>power </p>
<p>consumption  which  is  typically  called  sleep  mode.  This  mode  will  be  entered  by  the </p>
<p>following service: </p>
<p>vuint8 CanSleep( void ); </p>
<p> </p>
<p><b>Important </b></p>
<p>Before entering the sleep mode, some hardware specific preconditions have to be </p>
<p>ensured, e.g. the CAN Controller transmit registers have to be empty. It has to be </p>
<p>guaranteed, that the following service functions are called before CanSleep(): </p>
<p>void CanOffline( void ); </p>
<p>void CanResetBusSleep( CanInitHandle initObject );. </p>
<p> </p>
<p>The return to normal mode will be initiated by an explicit request of the Application: </p>
<p>vuint8 CanWakeUp( void ); </p>
<p> </p>
<p>Sleep mode is not supported by all CAN Controllers. If not, both related service functions </p>
<p>are provided to guarantee a unified service function interface for all CAN Drivers and to </p>
<p>make the Application mostly hardware independent. However, the functions itself have no </p>
<p>effect on the CAN Controller. </p>
<p>A subset of CAN Controllers, which are supporting a sleep mode in principle, are able to </p>
<p>be awakened by any CAN bus activity, i.e. a dominant level on the CAN bus. This wake-up </p>
<p>by CAN is an asynchronous event, normally detected by a special wake-up interrupt. The </p>
<p>Application will be notified by the following callback function: </p>
<p>void ApplCanWakeUp( void ); </p>
<p> </p>
<p>This callback function has to be provided by the Application. CanWakeUp() doesn't have to </p>
<p>be called in this case, because the CAN Controller returns to normal mode automatically </p>
<p>or initiated by the CAN Driver before this function call. Other communication related issues </p>
<p>like the activation of the bus transceiver hardware used or the return to the online mode </p>
<p>(see CanOnline()) have to be done in this callback function or as a consequence of this </p>
<p>event. </p>
<p>If </p>
<p>a </p>
<p>CAN </p>
<p>Controller </p>
<p>doesn't </p>
<p>support </p>
<p>a </p>
<p>wake-up </p>
<p>by </p>
<p>the </p>
<p>CAN </p>
<p>bus, </p>
<p>other </p>
<p>hardware </p>
<p>substitutions like an external interrupt based on the CAN Controller's Rx line have to be </p>
<p>implemented. </p>
<p>The  application  should  check  the  return  value  of </p>
<p>CanSleep()</p>
<p>  and </p>
<p>CanWakeUp() </p>
<p>in </p>
<p>every case to get the status of the CAN Controller. If </p>
<p>CanSleep()</p>
<p> returns </p>
<p>kCanFailed</p>
<p> </p>
<p>the CAN controller hasn’t entered into sleep mode. If </p>
<p>CanWakeUp()</p>
<p> returns </p>
<p>kCanFailed</p>
<p> </p>
<p>the CAN controller has not woken up. The application has to decide how to react on this </p>
<p>behavior.  </p>
<p>If sleep mode is not entered, no CAN wake-up interrupt will be generated on detection of </p>
<p>any message on the CAN bus. The callback function ApplCanWakeUp() will not be called </p>
<p>and  as  a  consequence  the  bus  transceiver  will  not  be  initialized.  This  may  lead  to  a </p>
<p>deadlock.  Therefore  it  is  necessary  to  call  CanSleep()  successfully  to  build  a  wake-up </p>
<p>capable system.  </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>56 / 149</p>
<p>There is a limitation in the access to the API in Sleep mode. </p>
<p> </p>
<p>The  implementation  of  this  functionality  is  very  hardware  dependent.  See  also  CAN </p>
<p>controller specific documentation TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_sleep]. </p>
<p><b>5.6 </b></p>
<p><b>Special Features </b></p>
<p><b>5.6.1 </b></p>
<p><b>Status </b></p>
<p>Some  internal  software  states  of  the  CAN  Driver  and  hardware  states  of  the  CAN </p>
<p>Controller can be read by the return code of the following service function: </p>
<p>vuint8 CanGetStatus( void ); </p>
<p> </p>
<p>In detail this is the following information: </p>
<p></p>
<p> </p>
<p>CAN Controller is in sleep mode (CanSleep() was called) </p>
<p></p>
<p> </p>
<p>CAN Controller is in stop mode ( CanStop() was called ) </p>
<p></p>
<p> </p>
<p>CAN Driver transmit path is in offline mode(CanOffline() was called) </p>
<p></p>
<p> </p>
<p>current error states of the CAN Controller (Error-Active, Warning, Error-Passive or Bus-</p>
<p>Off) </p>
<p>Not all of the CAN protocol specific bus states are supported by each CAN Driver. Please </p>
<p>refer  to  the  CAN  Controller  related  section  of  the  CAN  Driver  documentation  for  details </p>
<p>TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_status]. </p>
<p>There  are  special  macros  to  provide  an  easier  access  on  the  single  information  in  the </p>
<p>return code. These macros are true (not equal to 0) if the specific condition is valid and </p>
<p>false (equal to 0) if not. The parameter of this macros is the status, i.e. the return code of </p>
<p>CanGetStatus(): </p>
<p>vuint8 CanHwIsOk     ( vuint8 status ); </p>
<p>vuint8 CanHwIsWarning( vuint8 status ); </p>
<p>vuint8 CanHwIsPassive( vuint8 status ); </p>
<p>vuint8 CanHwIsBusOff ( vuint8 status ); </p>
<p>vuint8 CanHwIsSleep  ( vuint8 status ); </p>
<p>vuint8 CanHwIsWakeUp ( vuint8 status ); </p>
<p>vuint8 CanHwIsStop   ( vuint8 status ); </p>
<p>vuint8 CanHwIsStart  ( vuint8 status ); </p>
<p>vuint8 CanHwIsOffline( vuint8 status ); </p>
<p>vuint8 CanHwIsOnline ( vuint8 status ); </p>
<p> </p>
<p>If the hardware status information isn’t used by the Application this part of the functionality </p>
<p>can be disabled. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>57 / 149</p>
<p><b>5.6.2 </b></p>
<p><b>Stop Mode </b></p>
<p>The function CanStop() switches the CAN controller hardware to a state in which the CAN </p>
<p>controller doesn’t influence the communication of other nodes on the bus. For example no </p>
<p>hardware acknowledge is given, messages can’t be transmitted or received. In this state </p>
<p>the Can controller can’t be activated by activities on the CAN bus.  </p>
<p>The function CanStart() reactivates the CAN controller hardware again. </p>
<p>The  implementation  of  this  functionality  is  very  hardware  dependent.  See  also  CAN </p>
<p>controller specific documentation TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_stop]. </p>
<p><b>5.6.3 </b></p>
<p><b>Remote Frames </b></p>
<p>The CAN Driver ignores remote frames and doesn’t answer on a remote request.  </p>
<p><b>5.6.4 </b></p>
<p><b>Interrupt Control </b></p>
<p>The interrupt control of the CAN Driver is done by the service functions </p>
<p>void CanGlobalInterruptDisable( void ); </p>
<p>void CanGlobalInterruptRestore( void ); </p>
<p> </p>
<p>These functions have been moved to VstdLib. Only macros for compatibility reasons are </p>
<p>still provided in the CAN Driver:  </p>
<p>#define  CanGlobalInterruptDisable            VStdSuspendAllInterrupts </p>
<p>#define  CanGlobalInterruptRestore            VStdResumeAllInterrupts </p>
<p> </p>
<p>...more </p>
<p>information </p>
<p>see </p>
<p>in </p>
<p>the </p>
<p>technical </p>
<p>reference </p>
<p>of </p>
<p> </p>
<p>the </p>
<p>VStdLib. </p>
<p>(TechnicalReference_VstdLib.pdf). </p>
<p><b>5.6.4.1 </b></p>
<p><b>Security Level </b></p>
<p>The  security  levels  can  be  used  to  guarantee  the  data  consistency  of  a  complete  CAN </p>
<p>message during the copy process (this is a must, because the CAN Driver does not know </p>
<p>anything about the signal structure of the message) and the access to the notification flags </p>
<p>(indication and confirmation). During these operations the interrupt lock time is as short as </p>
<p>possible. </p>
<p>Depending </p>
<p>on </p>
<p>the </p>
<p>program </p>
<p>scope </p>
<p>with </p>
<p>access </p>
<p>to </p>
<p>CAN </p>
<p>message </p>
<p>signals, </p>
<p>indication or confirmation flags in the Application the following actions in the CAN Driver </p>
<p>have to be realized without any interruption: </p>
<p></p>
<p> </p>
<p>Copy process for receive messages (in the scope of the receive interrupt) </p>
<p></p>
<p> </p>
<p>Copy process for transmit messages (in the scope of CanTransmit(..) or in a pretransmit </p>
<p>function) </p>
<p></p>
<p> </p>
<p>Set  of  indication  and  confirmation  flags  (in  the  scope  of  the  receive  and  transmit </p>
<p>interrupt) </p>
<p></p>
<p> </p>
<p>Some internal mechanisms for data consistency. </p>
<p>Therefore different security levels are supported: </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>58 / 149</p>
<p><b>Level </b></p>
<p><b>CAN </b></p>
<p><b>Driver </b></p>
<p><b>prevention </b></p>
<p><b>Restrictions for the Application </b></p>
<p>         </p>
<p>00 </p>
<p>None </p>
<p>No consistency mechanisms at all. The CAN </p>
<p>driver has to be configured to polling mode. </p>
<p>CAN interrupts are not allowed. All CAN driver </p>
<p>tasks, all calls to service functions, all data and </p>
<p>flag access must be performed from the same </p>
<p>level.  </p>
<p>10 </p>
<p>No Flag and Copy </p>
<p>Security </p>
<p>No usage of CAN transmit and receive signals </p>
<p>in the interrupt context. Usage of the TxQueue </p>
<p>is allowed in Tx polling mode only. </p>
<p>No reset of notification flags in the interrupt </p>
<p>context </p>
<p>If a fully-preemptive operating system is used, </p>
<p>the access to the transmit data and </p>
<p>transmission of the data has to be done on the </p>
<p>same priority level. (data consistency). </p>
<p>20 </p>
<p>Interrupts are </p>
<p>disabled during the </p>
<p>copy process of </p>
<p>transmit messages </p>
<p>a)  Interrupt-Mode: </p>
<p>No usage of CAN receive signals and no </p>
<p>reset of notification flags in the interrupt </p>
<p>context </p>
<p>b)  Polling-Mode </p>
<p>Access  to  CAN  receive  signals,  indication </p>
<p>and confirmation flags is only allowed at the </p>
<p>same level or at lower level than CanTask(). </p>
<p>30 </p>
<p>(default) </p>
<p>Interrupts are </p>
<p>disabled during the </p>
<p>copy process of </p>
<p>transmit and </p>
<p>receive messages </p>
<p>and during the </p>
<p>access to the </p>
<p>notification flags </p>
<p>No restrictions for the Application, neither on </p>
<p>the usage of CAN receive or transmit signals </p>
<p>nor on the reset of notifications flags, can i.e. </p>
<p>both be done at any time. </p>
<p>Figure 1: Security levels </p>
<p> </p>
<p><b>Important </b></p>
<p>Be careful if a pretransmit function is used. Interrupts are not disabled during the call of </p>
<p>this user specific function by the CAN Driver, therefore the restrictions for security level </p>
<p>10 are valid. If the interrupts are not disabled before and restored after the copy process </p>
<p>by the Application, data consistency of a CAN messages cannot be guaranteed if the </p>
<p>transmit queue is used.. </p>
<p> </p>
<p><b>5.6.4.2 </b></p>
<p><b>Control of CAN interrupts </b></p>
<p>The interrupt control of the CAN Interrupts is done by the service functions </p>
<p>void CanCanInterruptDisable( void ); </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>59 / 149</p>
<p>void CanCanInterruptRestore( void ); </p>
<p> </p>
<p>These service functions control the CAN Interrupts. CanCanInterruptDisable disables the </p>
<p>CAN  interrupts  and  CanCanInterruptRestore  restores  the  state  of  the  CAN  interrupts </p>
<p>before the call of CanCanInterruptDisable. This mechanism is accompanied with a counter </p>
<p>to  recognize  the  number  of  calls.  A  “disable”  increments  the  counter  and  a  “restore” </p>
<p>decrements the counter to allow nested calls of these functions. </p>
<p>These </p>
<p>functions </p>
<p>could </p>
<p>only </p>
<p>be </p>
<p>called </p>
<p>as </p>
<p>pair. </p>
<p>That </p>
<p>means </p>
<p>that </p>
<p>on </p>
<p>a </p>
<p>CanCanInterruptDisable  must  follow  a  CanCanInterruptRestore.  Otherwise  the  selected </p>
<p>interrupt(s) are always disabled. </p>
<p>Additionally </p>
<p>refer </p>
<p>to </p>
<p>the </p>
<p>hardware </p>
<p>description </p>
<p>for </p>
<p>the </p>
<p>specific </p>
<p>platform </p>
<p>TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_int] especially concerning the handling of </p>
<p>the  wake-up  interrupt.  It  depends  on  the  hardware  whether  the  wake-up  interrupt  is </p>
<p>included or not. </p>
<p>There are two call back functions for the application. After the CanCanInterruptDisable the </p>
<p>function ApplCanAddCanInterruptDisable  is  called  and  after  the  CanCanInterruptRestore </p>
<p>the function ApplCanAddCanInterruptRestore is called. </p>
<p>Use these two functions to handle the wake-up interrupt if the hardware treats this interrupt </p>
<p>separately or if the Driver runs in Polling Mode disable the polling tasks. </p>
<p>To activate the call back functions refer to the API description of the functions. </p>
<p><b>5.6.5 </b></p>
<p><b>Assertions </b></p>
<p>To  detect  some  incorrect  internal  conditions  of  the  CAN  Driver  during  development, </p>
<p>integration </p>
<p>and </p>
<p>software </p>
<p>test, </p>
<p>there </p>
<p>are </p>
<p>different </p>
<p>categories </p>
<p>of </p>
<p>so </p>
<p>called </p>
<p>assertions </p>
<p>configurable: </p>
<p> </p>
<p></p>
<p> </p>
<p>User interface (for example input parameters, reentrance if not allowed) </p>
<p></p>
<p> </p>
<p>Fatal hardware errors </p>
<p></p>
<p> </p>
<p>Generated data </p>
<p></p>
<p> </p>
<p>Internal software errors (for example inconsistent internal states) </p>
<p>Each type of assertion can be configured independently. </p>
<p>These assertions will help in different development phases to deal with unexpected </p>
<p>problems which cannot be handled by the CAN Driver internally. In such case the following </p>
<p>callback function will be called by the CAN Driver: </p>
<p>void ApplCanFatalError( vuint8 errorNumber ); </p>
<p> </p>
<p>This callback function has to be provided by the Application. The function parameter </p>
<p>errorNumber gives more detailed information about the kind of error which is occurred.  </p>
<p>Generally, the error number has to be checked to solve the underlying problem. </p>
<p> </p>
<p><b>Important </b></p>
<p>This callback function must not return to the CAN Driver afterwards. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>60 / 149</p>
<p> </p>
<p>The recommended usage of the different assertion categories is explained in the following </p>
<p>table: </p>
<p> </p>
<p>User Interface </p>
<p>Development of Application software </p>
<p>Fatal hardware errors </p>
<p>Development of Application software  </p>
<p>New CAN Controller used </p>
<p>Generated Data </p>
<p>New version of the Generation Tool used </p>
<p>Test of software changes in the Generation Tool or CAN Driver </p>
<p>(Vector internal) </p>
<p>Internal software errors </p>
<p>Test of software changes in the CAN Driver (Vector internal) </p>
<p> </p>
<p>These  checks  could  be  very  run-time  intensive  and  should  only  be  activated  for  the </p>
<p>development phase of the CAN Driver </p>
<p>The call back function <i>ApplCanFatalError() </i>is called with the following error codes: </p>
<p><b>In case of a user assertion: </b></p>
<p>kErrorTxDlcTooLarge </p>
<p><i>CanTransmitVarDlc() </i>or <i>CanDynTxObjSetDlc() </i>called </p>
<p>with DLC &gt; 8. </p>
<p>kErrorTxHdlTooLarge </p>
<p>service function called with transmit handle too large </p>
<p>kErrorIntRestoreTooOften </p>
<p><i>CanCanInterruptRestore() </i>called too often </p>
<p>kErrorIntDisableTooOften </p>
<p><i>CanCanInterruptDisable() </i>called too often </p>
<p>kErrorChannelHdlTooLarge </p>
<p>service function called with channel handle too large </p>
<p>kErrorInitObjectHdlTooLarge </p>
<p><i>CanInit() </i>called with parameter “initObject” too large   </p>
<p>kErrorTxHwHdlTooLarge </p>
<p><i>CanTxGetActHandle() </i>called with logical hardware </p>
<p>handle too large  </p>
<p>kErrorHwObjNotInPolling </p>
<p><i>CanTxObjTask(), CanRxFullCANObjTask() </i>or </p>
<p><i>CanRxBasicCANObjTask() </i>called for hardware object </p>
<p>which is configured to interrupt mode. </p>
<p>kErrorHwHdlTooSmall </p>
<p><i>CanTxObjTask(), CanRxFullCANObjTask() </i>or </p>
<p><i>CanRxBasicCANObjTask() </i>called for hardware object </p>
<p>handle too small </p>
<p>kErrorHwHdlTooLarge </p>
<p><i>CanTxObjTask(), CanRxFullCANObjTask() </i>or </p>
<p><i>CanRxBasicCANObjTask() </i>called for hardware object </p>
<p>handle too large </p>
<p>kErrorAccessedInvalidDynObj </p>
<p><i>CanGetDynTxObj(),CanReleaseDynTxObj()  </i>or </p>
<p><i>CanDynTxObjSet...() </i>is called with wrong transmit </p>
<p>handle (transmit handle too large) </p>
<p>kErrorAccessedStatObjAsDyn </p>
<p><i>CanGetDynTxObj(),CanReleaseDynTxObj()  </i>or </p>
<p><i>CanDynTxObjSet...() </i>is called with wrong transmit </p>
<p>handle (transmit handle belongs to a static object) </p>
<p>kErrorDynObjReleased </p>
<p><i>UserConfirmation() </i>or <i>UserPreTransmit() </i>is called for a </p>
<p>dynamic object which is already released. </p>
<p>kErrorPollingTaskRecursion </p>
<p>CAN Driver Polling tasks (<i>Can...Task()</i>) are called </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>61 / 149</p>
<p>recursive or interrupt each other. </p>
<p>kErrorDisabledChannel </p>
<p>Service function called for disabled channel on systems </p>
<p>with multiple configurations. </p>
<p>kErrorDisabledTxMessage </p>
<p><i>CanCancelTransmit() or CanTransmit() </i>called with </p>
<p>txHandle that is not active in the current configuration. </p>
<p>(Physical multiple ECU) </p>
<p>kErrorDisabledCanInt </p>
<p><i>CanSleep() </i>or <i>CanWakeUp() </i>is called with disabled </p>
<p>CAN Interrupts (via <i>CanCanInterruptDisable()</i>). </p>
<p>kErrorCanSleep </p>
<p><i>CanStop(), CanCanInterruptDisable() </i>or </p>
<p><i>CanCanInterruptRestore() </i>called during Sleep mode, or </p>
<p>offline mode is not active during sleep mode. </p>
<p>kErrorCanOnline </p>
<p><i>CanSleep() </i>or <i>CanStop() </i>is called without offline mode<i>. </i></p>
<p>kErrorCanStop </p>
<p><i>CanSleep() </i>is called during Stop mode or offline mode </p>
<p>is not active during Stop mode. </p>
<p>kErrorWrongMask </p>
<p><i>CanSetTxIdExtHi() </i>is called with illegal mask (mask </p>
<p>higher than 0x1F). </p>
<p>kErrorWrongId </p>
<p><i>CanDynTxObjSetId() or CanDynTxObjSetExtid() </i>is </p>
<p>called with illegal ID (standard ID higher than 0x7ff or </p>
<p>extended ID higher than 0x1FFFFFFF). </p>
<p><b>In case of a generation assertion: </b></p>
<p>kErrorTxROMDLCTooLarge </p>
<p>Error in generated table of transmit DLCs </p>
<p><b>In case of a hardware assertion: </b></p>
<p>kErrorTxBufferBusy </p>
<p>HW transmit object is busy, but this is not expected </p>
<p><b>In case of a internal assertion: </b></p>
<p>kErrorTxHandleWrong </p>
<p>saved transmit handle has an unexpected value </p>
<p>kErrorInternalTxHdlTooLarge </p>
<p>internal function called with parameter tx handle too </p>
<p>large </p>
<p>kErrorRxHandleWrong </p>
<p>The variable rx handle has an illegal value. </p>
<p>kErrorTxObjHandleWrong </p>
<p>The handle of the hardware transmit object has an </p>
<p>illegal value. </p>
<p>kErrorReleasedUnusedDynObj </p>
<p><i>CanReleaseDynTxObj() </i>is called for an object which is </p>
<p>already released. </p>
<p>kErrorTxQueueToManyHandle </p>
<p>The data type of the Tx Queue cannot handle all tx </p>
<p>messages. </p>
<p>kErrorInternalChannelHdlTooLarge </p>
<p>Static function called with channel handle too large or </p>
<p>calculated channel handle too large. </p>
<p>kErrorInternalDisabledChannel </p>
<p>Static function called for disabled channel on systems </p>
<p>with multiple configurations. </p>
<p>kErrorInternalDisabledTxMessage </p>
<p>Confirmation called with txHandle that is not active in </p>
<p>the current configuration. (Physical multiple ECU) </p>
<p> </p>
<p>See the CAN Controller specific part of the CAN Driver documentation </p>
<p>TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_assert] to get the list of additional </p>
<p>hardware specific error numbers for each CAN Driver. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>62 / 149</p>
<p><b>5.6.6 </b></p>
<p><b>Hardware Loop Check </b></p>
<p>There are two kinds of handling loops in the CAN Driver internally. The first one uses a </p>
<p>counter or other mathematics algorithms to abort the loop. The second one uses hardware </p>
<p>information from the CAN Controller to abort the loop. </p>
<p>Some of these state transitions have to be done by two steps: </p>
<p>1. </p>
<p>Request </p>
<p>2. </p>
<p>Acknowledge </p>
<p>In the first step the request for a specific action (e.g. re-initialization of the CAN Controller) </p>
<p>is set but generally it cannot be entered immediately because of the prerequisite that the </p>
<p>CAN  bus  has  to  be  in  idle  state,  i.e.  waiting  for  a  recessive  CAN  bus  level.  In  normal </p>
<p>operation the described behavior is non-critical. However, an exception is a malfunction of </p>
<p>the hardware. If the hardware is damaged or disturbed for a longer time, this loop may be </p>
<p>too  long  or  even  endless  and  is  finally  stopped  by  a  watchdog  reset.  Because  of  this </p>
<p>restrictive  error  recovery  the  complete  software  functionality  is  affected,  nothing  can  be </p>
<p>done to prevent the repetition and additionally it is not possible to store any error specific </p>
<p>diagnostic information, i.e. the problem cannot be checked later. </p>
<p>To avoid those kinds of endless loops, the user can configure a special loop control. This </p>
<p>has to be handled by the Application. It cannot be done by the CAN Driver itself because it </p>
<p>is hardware dependent. </p>
<p>Therefore  the  Application  is  informed  once  by  the  following  callback  function  if  such  a </p>
<p>critical loop is entered: </p>
<p>void ApplCanTimerStart( vuint8 timerIdentification ); </p>
<p> </p>
<p>This callback function starts a timer realized by the Application. The recommended timer </p>
<p>handling is counting downwards to zero because of faster code on most microprocessors. </p>
<p>The parameter identifies the timer, i.e. the kind of loop. It is necessary to identify the loop </p>
<p>type because the corresponding start value has to be set. Beside of this, different (not the </p>
<p>same) loops can be started re-entrant and so the Application has to provide one timer for </p>
<p>each  kind  of  loop.  The  list  of  necessary  timers  is  pre-defined  by  the  CAN  Driver  and </p>
<p>depends on the CAN Controller. Please refer to CAN Controller specific documentation for </p>
<p>a detailed list TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_loop]. </p>
<p>During  the  loop  wait  state  a  second  callback  function  is  called  repeatedly  to  control  the </p>
<p>break condition for the loop by the Application: </p>
<p>vuint8 ApplCanTimerLoop( vuint8 timerIdentification ); </p>
<p> </p>
<p>This callback function returns the status of the corresponding timer to the CAN Driver. The </p>
<p>return code must be TRUE (not equal to 0) if the timer is still running and FALSE (equal to </p>
<p>0) if the timer has expired. In this case the CAN Driver loop will be left immediately. The </p>
<p>Application must be aware of a serious problem in the hardware and the following actions </p>
<p>have to be done: </p>
<p></p>
<p> </p>
<p>Store diagnostics information </p>
<p></p>
<p> </p>
<p>Switch off transmit (CanOffline()) and receive path of the CAN Driver </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>63 / 149</p>
<p></p>
<p> </p>
<p>Re-initialization  of  the  CAN  Driver  (CanInit()).  This  may  lead  to  the  next  loop  control </p>
<p>failure,  therefore  it  has  to  be  limited  and  in  case  of  a  permanent  severe  hardware </p>
<p>problem a special limp home state has to be foreseen. </p>
<p>If the loop is terminated, a third callback function is provided to stop the previously started </p>
<p>loop control timer: </p>
<p>void ApplCanTimerEnd( vuint8 timerIdentification ); </p>
<p> </p>
<p> </p>
<p><b>Important </b></p>
<p>Be aware of the priorities of the timer interrupt routine and the CAN interrupt routine. If </p>
<p>the priority of the timer interrupt is below the CAN Interrupt priority the timer value for the </p>
<p>loop check may not be changed anymore while a CAN interrupt routine is running. </p>
<p> </p>
<p><b>5.6.7 </b></p>
<p><b>Support of OSEK-Compliant Operating Systems </b></p>
<p>If an OSEK operating system is used (ISR category 2), the hard-coded interrupt routines </p>
<p>for receiving, transmitting, error and wake-up are replaced by the ISR macro. In this case </p>
<p>an OSEK-specific header has to be included in can_inc.h to provide this macro. </p>
<p><b>5.6.8 </b></p>
<p><b>Multiple-Channel CAN Driver </b></p>
<p>There  are  two  different  kinds  of  multiple-channel  CAN  Drivers:  Sometimes  two  CAN </p>
<p>Controllers are used by one ECU on the same CAN bus, to increase the number of receive </p>
<p>and  transmit  objects.  Logically,  they  can  be  conceived  as  a  single  CAN  Controller. This </p>
<p>behavior is described in the chapter Common CAN.     more... </p>
<p>Usually,  two  (or  more)  CAN  Controllers  are  used  to  serve  different  CAN  networks,  for </p>
<p>example in gateways.  </p>
<p> </p>
<p><b>5.6.8.1 </b></p>
<p><b>Indexed CAN Driver </b></p>
<p>Indexed CAN Drivers work on more than one CAN bus without doubling of code. Function </p>
<p>names are equal to single channel (standard) CAN Driver. Function parameter are different </p>
<p>in many cases.  </p>
<p>Switches in can_cfg.h are without a suffix but with effect to all CAN channels. </p>
<p> </p>
<p><b>5.6.9 </b></p>
<p><b>Standard Polling Mode </b></p>
<p>In  polling  mode  no  interrupts  are  used.  Instead  of  interrupts  the Application  has  to  call </p>
<p>cyclic service functions in the CAN Driver, to work on transmit and receive messages as </p>
<p>well as other asynchronous events. This cyclic service function is </p>
<p>void CanTask ( void ); </p>
<p> </p>
<p>and calls all needed service functions for transmission, reception, error and wake-up which </p>
<p>can also be polled separately by the following service functions: </p>
<p>void CanRxBasicCANTask  ( void ); </p>
<p>void CanRxFullCANTask   ( void ); </p>
<p>void CanTxTask      ( void ); </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>64 / 149</p>
<p>void CanErrorTask   ( void ); </p>
<p>void CanWakeUpTask  ( void );  </p>
<p> </p>
<p>The transmission and the reception of CAN messages can be served by interrupt or by </p>
<p>polling separately. Several configurations for polling are available: </p>
<p></p>
<p> </p>
<p>Full CAN Receive objects (for Full CAN Controllers only) </p>
<p></p>
<p> </p>
<p>Basic CAN Receive Objects </p>
<p></p>
<p> </p>
<p>Transmit objects  </p>
<p></p>
<p> </p>
<p>Errors </p>
<p></p>
<p> </p>
<p>Wake-Up </p>
<p> </p>
<p><b>5.6.9.1 </b></p>
<p><b>Application Hints </b></p>
<p>Concerning  the  transmit  polling  the  handling  depends  on  the  configuration  of  transmit </p>
<p>queue and the confirmation notification: </p>
<p></p>
<p> </p>
<p>No transmit queue but confirmation flags and/or confirmation functions are configured: </p>
<p>The CanTxTask() has to be called cyclically as  fast as the confirmation notification is </p>
<p>needed  or  before  CanTransmit()  is  called  to  release  the  CAN  Controller  hardware </p>
<p>transmit register. </p>
<p></p>
<p> </p>
<p>Transmit  queue  is  configured:  CanTransmit()  puts  only  a  transmit  request  into  the </p>
<p>transmit  queue.  CanTxTask()  transmits  the  messages  on  the  CAN  bus  and  does  the </p>
<p>confirmation as well. Therefore CanTxTask() has to be called as fast as confirmation is </p>
<p>needed and the messages should be transmitted.  </p>
<p><b>5.6.10 </b></p>
<p><b>Handling of different identifier types </b></p>
<p>Every Vector CAN Driver supports per default only the standard mode using 11 bits for a </p>
<p>CAN identifier. In addition to this standard mode, some Vector CAN Drivers also support </p>
<p>the feature of extended mode using 29 bits for a CAN identifier. </p>
<p>Depending on the selected mode (standard or extended CAN identifiers) the Generation </p>
<p>Tool switches to the correct initialization structures used for the corresponding mode. The </p>
<p>type  and  number  of  supported  search  algorithms  depends  on  the  mode.  Four  different </p>
<p>CAN Driver configurations are possible: </p>
<p> </p>
<p></p>
<p> </p>
<p>Standard mode (only 11 bit CAN identifier) </p>
<p></p>
<p> </p>
<p>Extended mode for the normal receive path of single CAN messages (only 29 bit CAN </p>
<p>identifier) </p>
<p></p>
<p> </p>
<p>Mixed mode (11 bit and 29 bit CAN identifier mixed on one CAN bus) </p>
<p></p>
<p> </p>
<p>For indexed drivers a bus dependent mode (11 bit CAN identifier on one and 29 bit CAN </p>
<p>identifier on the other CAN bus). </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>65 / 149</p>
<p><b>5.6.11 </b></p>
<p><b>Copying Mechanisms </b></p>
<p>CanCopyToCan or CanCopyFromCan are hardware/compiler dependent functions that are </p>
<p>provided to optimize copying of data from/to the CAN hardware buffer. </p>
<p> </p>
<p><b>Info</b> </p>
<p>CanCopyFromCan should only be used within a precopy function. CanCopyToCan </p>
<p>should only be used within a pretransmit function. </p>
<p> </p>
<p><b>5.6.12 </b></p>
<p><b>Common CAN </b></p>
<p>Common CAN is a special feature which is available only on request and on systems with </p>
<p>2 or more CAN controllers. The idea of this feature is to map different HW channels into </p>
<p>one application channel. </p>
<p>When Common CAN is activated additional receive FullCAN messages can be configured </p>
<p>on a channel. This is realized by using a second CAN controller for the same channel. The </p>
<p>first CAN controller (CAN A) supports Tx, Rx Full CAN and Rx Basic CAN. The second </p>
<p>CAN controller (CAN B) supports Rx Full CAN. Both CAN controllers have to be connected </p>
<p>to the same CAN bus. The API is always ‘Multiple Receive Channel’. </p>
<p> </p>
<p>To enable the Common CAN feature activate the corresponding checkbox in the channel </p>
<p>settings. </p>
<p> </p>
<p>First  select  the  messages  handled  in  Full  CAN  objects.  Then  select  the  “Hardware </p>
<p>Channel” to be used to receive the full CAN message. </p>
<p> </p>
<p>Please note that the messages received on CAN B of the Common CAN must be filtered </p>
<p>out with the Basic CAN mask. </p>
<p> </p>
<p> </p>
<p><b>5.6.13 </b></p>
<p><b>Multiple ECU </b></p>
<p>The feature Multiple ECU is usually used for nodes that exist more than once in a car with </p>
<p>only a few differences. At power up the application decides which node should be realized, </p>
<p>e.g. left passenger door, or right driver door.  </p>
<p>To  reduce  the  memory  consumption  messages  that  are  sent  exclusively  from  one  node </p>
<p>can be overlapped with the exclusively sent messages from the other nodes. The result of </p>
<p>this  overlapping  is  that  all  these  messages  share  a  common  memory  location  for  the </p>
<p>transmit data. </p>
<p> </p>
<p><b>5.6.14 </b></p>
<p><b>Signal Access Macros </b></p>
<p>Signal access macros are function like macros, to access signals within a message. They </p>
<p>can  be  used  by  the  application  for  an  easy  access  to  signals. The  generation  of  signal </p>
<p>value </p>
<p>access </p>
<p>macros </p>
<p>can </p>
<p>be </p>
<p>enabled </p>
<p>or </p>
<p>disabled. </p>
<p>If </p>
<p>enabled, </p>
<p>the </p>
<p>Generation  Tool </p>
<p>generates access macros using the signal names from the communication data base with </p>
<p>respect to prefixes or post-fixes defined in the Names tab. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>66 / 149</p>
<p> </p>
<p>Figure 5-13 Name of signal access macros </p>
<p>For each signal an access macro is formed from the signal name in the CAN database, a </p>
<p>signal  variable  prefix  (access  via  signal  structures  or  byte/word  commands),  a  signal </p>
<p>prefix,  a  signal  postfix,  and  a  signal  variable  postfix.  Prefixes  and  postfixes  can  be </p>
<p>configured  by  the  user  in  the  generator  program.  To  assure  better  readability,  it  is </p>
<p>advisable not to use all four prefixes and postfixes simultaneously. </p>
<p>The  access  macros  for  the  CAN  receive  buffer  get  an  extended  prefix </p>
<p>CAN_</p>
<p>.  Within </p>
<p>Precopy and Pretransmit routines these macros serve to access the CAN controller's CAN </p>
<p>receive and transmit buffer on a signal basis. </p>
<p> </p>
<p><b>5.6.15 </b></p>
<p><b>CAN RAM Check </b></p>
<p>The CAN driver supports a check of the CAN controller’s mailboxes. The CAN controller </p>
<p>RAM check is called internally every time the function CanInit() is called. The CAN driver </p>
<p>verifies that no used mailboxes is corrupt. A mailbox is considered corrupt if a predefined </p>
<p>pattern  is  written  to  the  appropriate  mailbox  registers  and  the  read  operation  does  not </p>
<p>return </p>
<p>the </p>
<p>expected </p>
<p>pattern. </p>
<p>If </p>
<p>a </p>
<p>corrupt </p>
<p>mailbox </p>
<p>is </p>
<p>found </p>
<p>the </p>
<p>function </p>
<p>ApplCanCorruptMailbox()  is  called.  This  function  tells  the  application  which  mailbox  is </p>
<p>corrupt.  </p>
<p>After </p>
<p>the </p>
<p>check </p>
<p>of </p>
<p>all </p>
<p>mailboxes </p>
<p>the </p>
<p>CAN </p>
<p>driver </p>
<p>calls </p>
<p>the </p>
<p>callback </p>
<p>function </p>
<p>ApplCanMemCheckFailed()  if  at  least  one  corrupt  mailbox  was  found.  The  application </p>
<p>must  decide  if  the  CAN  driver  disables  communication  or  not  by  means  of  the  callback </p>
<p>function’s return value. If the application has decided to disable the communication there is </p>
<p>no possibility to enable the communication again until the next call to CanInitPowerOn(). </p>
<p>The CAN RAM check functionality itself can be activated via Generation Tool. This include </p>
<p>the callback ApplCanMemCheckFailed(). The callback ApplCanCorruptMailbox() can only </p>
<p>be activated via a user configuration file.  </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>67 / 149</p>
<p><b>6 </b></p>
<p><b>Detailed Description of the Functional Scope (High End extension) </b></p>
<p><b>6.1 </b></p>
<p><b>Transmission </b></p>
<p><b>6.1.1 </b></p>
<p><b>Low-Level Message Transmit </b></p>
<p>Using  a  multiple  channel  CAN  Driver  the  routing  of  complete  CAN  messages  from  one </p>
<p>CAN Bus to another one is supported by the function </p>
<p>vuint8 CanMsgTransmit(...); </p>
<p>This function has a parameter with a pointer to a CAN Message Buffer. So it is possible to </p>
<p>route the whole buffer from one CAN chip to the other one. To prevent a conflict with the </p>
<p>functional  messages,  this  function  uses  an  own  send  buffer  (If  an  additional  buffer  is </p>
<p>available in the CAN Controller).  </p>
<p>A special confirmation function and an initialization callback function are called. </p>
<p>void ApplCanMsgTransmitConf(...); within confirmation interrupt </p>
<p>void ApplCanMsgTransmitInit(...); within CanInit </p>
<p>These functions can be used by the application to implement a data queue mechanism. </p>
<p>There is no internal transmit queue for this transmit object available. </p>
<p> </p>
<p>CanMsgTransmit() can also be used for dynamic transmission. Therefore the CAN driver </p>
<p>supports macros to write standard ID or extended ID, DLC and data to the structure: </p>
<p> </p>
<p>CanMsgTransmitSetStdId (...) </p>
<p>CanMsgTransmitSetExtId (...) </p>
<p>CanMsgTransmitSetDlc (...) </p>
<p>CanMsgTransmitSetData (...) </p>
<p> </p>
<p><b>6.2 </b></p>
<p><b>Reception </b></p>
<p><b>6.2.1 </b></p>
<p><b>Multiple Basic CAN </b></p>
<p>To improve efficiency of the hardware filtering and reduce the interrupt load produced by </p>
<p>reception  of  unwanted  messages,  the  number  of  Hardware  Basic  CAN  objects  can  be </p>
<p>changed in the Generation Tool. Each Hardware Basic CAN object has it’s own filter. </p>
<p>Increasing the number of Basic CAN objects will reduce the number of available Full CAN </p>
<p>objects (Rx and Tx). </p>
<p>This feature is only available for Full CAN controllers. </p>
<p><b>6.2.2 </b></p>
<p><b>Rx Queue </b></p>
<p>The Rx Queue is a data queue which stores receive messages if the application does not </p>
<p>want to process them within the interrupt context. In some applications it may happen that </p>
<p>the  run  time  in  the  receive  interrupt  becomes  too  long.  This  leads  to  long  interrupt </p>
<p>latencies and possible loss of messages. The Rx Queue may help in these cases. If the </p>
<p>Rx Queue is configured the received messages are copied into this queue in the interrupt </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>68 / 149</p>
<p>context. The handling of the queued messages is done on task level. Messages which are </p>
<p>received by means of a RangePrecopy can also be copied into the queue or handled in </p>
<p>the interrupt context. </p>
<p>In order to handle the queued messages the application has to call cyclically a CAN Driver </p>
<p>function which checks for queued messages and processes them. </p>
<p>If Precopy and Indication functions are used for application messages, be aware that they </p>
<p>are not called in interrupt context any more. </p>
<p>By using the Rx Queue the runtime in the Rx interrupt is decreased. The average runtime </p>
<p>of the application is increased because of the overhead for handling the queue. </p>
<p> </p>
<p><b>Please note </b></p>
<p>In case a range is configured to be handled via the Rx Queue, the return code of the </p>
<p>RangePrecopy for this range is ignored. </p>
<p><b>6.2.2.1 </b></p>
<p><b>Handling in Receive Interrupt </b></p>
<p>During </p>
<p>the </p>
<p>receive </p>
<p>interrupt </p>
<p>the </p>
<p>CAN </p>
<p>Driver </p>
<p>calls </p>
<p>the </p>
<p>callback </p>
<p>function </p>
<p>ApplCanPreRxQueue()  after  the  range  or  search  algorithm  match  in  order  to  let  the </p>
<p>application decide whether the received message is processed within the interrupt or has </p>
<p>to  be  entered  into  the  Rx  queue.  The  function  ApplCanPreRxQueue()  is  only  called  if </p>
<p>configured.  Otherwise  all  received  messages  are  handled  by  the  Rx  queue.  If  the  Rx </p>
<p>Queue  is  full  the  CAN  Driver  notifies  the  application  by  calling  the  callback  function </p>
<p>ApplCanRxQueueOverrun() (if configured) and discards the received message. After the </p>
<p>message was copied into the Rx queue the Rx interrupt is terminated. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>69 / 149</p>
<p>Receive message</p>
<p>(hardware filtering)</p>
<p><b>Write FIFO</b></p>
<p>Handle</p>
<p>Id</p>
<p>DLC</p>
<p>Data</p>
<p><b>Exit</b></p>
<p>Return</p>
<p>kCanCopyData</p>
<p>yes</p>
<p>normal receive-interrupt</p>
<p>with Message Precopy,</p>
<p>data copy mechanism,</p>
<p>Indication Function / Flags</p>
<p><b>Rx Interrupt Level Start</b></p>
<p>Hardware Level</p>
<p>SW Range</p>
<p>entered</p>
<p>yes</p>
<p>Queue</p>
<p>configured</p>
<p>yes</p>
<p>no</p>
<p>no</p>
<p>Range Precopy</p>
<p>Function</p>
<p>ApplCanPreRxQueue</p>
<p>(CanRxInfoStructPtr)</p>
<p><b>Write FIFO</b></p>
<p>Handle</p>
<p>Id</p>
<p>DLC</p>
<p>Data</p>
<p>Normal receive-interrupt</p>
<p>with SW message search</p>
<p>ApplCanPreRxQueue</p>
<p>(CanRxInfoStructPtr)</p>
<p>no</p>
<p>Indexed,</p>
<p>Hash,</p>
<p>Linear</p>
<p>yes</p>
<p><b>Rx Interrupt Level End</b></p>
<p>Return</p>
<p>kCanCopyData</p>
<p>yes</p>
<p>no</p>
<p>ApplCanMsgReceived</p>
<p>(CanRxInfoStructPtr)</p>
<p>Enter</p>
<p>Receive Interrupt</p>
<p> </p>
<p>Figure 6-1 </p>
<p>Handling of the Rx queue within the receive routine. </p>
<p><b>6.2.2.2 </b></p>
<p><b>Handling on Task Level </b></p>
<p>In order to process the messages pending in the Rx queue the application has to call the </p>
<p>function  CanHandleRxMsg().  This  function  processes  all  messages  in  the  queue.  The </p>
<p>processing of the messages is done in the same way like in the Rx interrupt. That means </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>70 / 149</p>
<p>for  each  message  the  Generic  Precopy  and  the  UserPrecopy  are  called. After  that  the </p>
<p>message data are copied into the RAM buffer and than the Indication Flag is set and the </p>
<p>UserIndication function is called. The last step is to delete the processed message from </p>
<p>the Rx queue. </p>
<p>CanHandleRxMsg()</p>
<p><b>Task Level Start</b></p>
<p><b>Read FIFO</b></p>
<p>Handle</p>
<p>Id</p>
<p>DLC</p>
<p>Data</p>
<p><b>Clear FIFO</b></p>
<p>Handle</p>
<p>Id</p>
<p>DLC</p>
<p>Data</p>
<p><b>Exit</b></p>
<p>normal receive-interrupt</p>
<p>with Message Precopy,</p>
<p>data copy mechanism</p>
<p>SW Range</p>
<p>entered</p>
<p>yes</p>
<p>no</p>
<p><b>Clear FIFO</b></p>
<p>Handle</p>
<p>Id</p>
<p>DLC</p>
<p>Data</p>
<p>Range Precopy</p>
<p>Function</p>
<p><b>Task Level End</b></p>
<p>Indication Function / Flags</p>
<p> </p>
<p>Figure 6-2 </p>
<p>Handling of the Rx queue on task level. </p>
<p><b>6.2.2.3 </b></p>
<p><b>Resetting the Rx Queue   </b></p>
<p>The  CAN  Driver  provides  the  function  CanDeleteRxQueue()  to  delete  all  messages </p>
<p>pending in the Rx Queue </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>71 / 149</p>
<p><b>6.3 </b></p>
<p><b>Special Features </b></p>
<p><b>6.3.1 </b></p>
<p><b>Individual Polling </b></p>
<p>Each mailbox (BasicCAN Rx, FullCAN Rx, FullCAN Tx, low level Tx and normal Tx) can be </p>
<p>selected to be polled or treat in interrupt context. This also provides the possibility to use </p>
<p>interrupt mode on one channel and polling mode on the other. </p>
<p>The polling tasks of the standard polling mode are still available. The CAN Driver provides </p>
<p>additional service functions to poll each mailbox individual. </p>
<p>void CanRxBasicCANObjTask  ( ... ); </p>
<p>void CanRxFullCANObjTask   ( ... ); </p>
<p>void CanTxObjTask      ( ... ); </p>
<p>These functions have the number of the mailbox and the hardware channel as parameter. </p>
<p>For both parameters, symbolic names are generated. </p>
<p>CanTask()</p>
<p>, </p>
<p>CanErrorTask()</p>
<p>  and </p>
<p>CanWakeUpTask()</p>
<p>  are  available  in  this  polling </p>
<p>mode, too. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>72 / 149</p>
<p><b>7 </b></p>
<p><b>Feature List (Standard and High End) </b></p>
<p>This general feature list describes the overall feature set of Vector CAN Drivers. Not all of </p>
<p>these  features  are  mandatory  for  all  CAN  Drivers.  Please  refer  to  the  CAN  Controller </p>
<p>dependent </p>
<p>CAN </p>
<p>Driver </p>
<p>manual </p>
<p>for </p>
<p>details </p>
<p>TechnicalReference_CAN_&lt;hardware&gt;.pdf </p>
<p>[#hw_feature]. </p>
<p> </p>
<p> </p>
<p><b>CAN Driver Functionality </b></p>
<p> </p>
<p><b>Standard </b></p>
<p><b>HighEnd </b></p>
<p><b>Functions </b></p>
<p><b>Initialization </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>Power-On Initialization </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanInitPowerOn </p>
<p>Re-Initialization </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanInit </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Transmission </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>Transmit Request </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanTransmit </p>
<p>Transmit Request Queue </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Internal data copy mechanism </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Pretransmit functions </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>UserPreTransmit </p>
<p>Common confirmation function </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ApplCanTxConfirmation </p>
<p>Confirmation flag </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Confirmation function </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>UserConfirmation </p>
<p>Offline Mode </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanOnline, CanOffline </p>
<p>Partial Offline Mode </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanOnline, CanPartOffline, </p>
<p>CanGetPartMode </p>
<p>Passive-Mode </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanSetActive, </p>
<p>CanSetPassive </p>
<p>Tx Observe mode </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ApplCanInit, </p>
<p>ApplCanTxObjStart, </p>
<p>ApplCanTxObjConfirmed </p>
<p>Dynamic TxObjects </p>
<p>ID </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanDynTxSet(Ext)Id </p>
<p> </p>
<p>DLC </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanDynTxSetDlc </p>
<p> </p>
<p>Data-Ptr </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanDynTxSetDataPtr </p>
<p>Full CAN Tx Objects </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>Cancellation in Hardware </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>CanCancelTransmit, </p>
<p>CanCancelMsgTransmit </p>
<p>Low Level Message Transmit </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanMsgTransmit </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Reception </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>Receive function </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ApplCanMsgReceived </p>
<p>Search algorithms </p>
<p>Linear </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Table </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Index </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Hash </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>73 / 149</p>
<p>Range specific precopy functions </p>
<p>4 </p>
<p>4 </p>
<p>ApplCanRangeXxxPrecopy </p>
<p>Xxx .. 0,1,2,3 </p>
<p>DLC check </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ApplCanMsgDlcFailed </p>
<p>Internal data copy mechanism </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Generic precopy function </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ApplCanGenericPrecopy </p>
<p>Precopy function </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>UserPrecopy </p>
<p>Indication flag </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Indication function </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>UserIndication </p>
<p>Message not matched function </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ApplCanMsgNotMatched </p>
<p>Overrun Notification </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ApplCanOverrun </p>
<p>Full-CAN overrun notification </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>ApplCanFullCanOverrun </p>
<p>Multiple Basic CAN </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Rx Queue </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanHandleRxMsg, </p>
<p>CanDeleteRxQueue </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Bus off </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>Notification function </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ApplCanBusOff </p>
<p>Nested Recovery functions </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanResetBusOffStart, </p>
<p>CanResetBusOffEnd </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Sleep Mode </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>Mode Change </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>CanSleep, CanWakeUp </p>
<p>Preparation </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanResetBusSleep </p>
<p>Notification function </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>ApplCanWakeUp </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Special Feature </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>Status </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanGetStatus </p>
<p>Security Level </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Assertions </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ApplCanFatalError </p>
<p>Hardware loop check </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ApplCanTimerStart </p>
<p>ApplCanTimerLoop </p>
<p>ApplCanTimerEnd </p>
<p>Stop Mode </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>CanStart, CanStop </p>
<p>Support of OSEK operating system </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Standard Polling Mode </p>
<p>Tx  </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanTxTask </p>
<p> </p>
<p>Rx(Full CAN objects) </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>CanRxFullCANTask </p>
<p> </p>
<p>Rx(Basic CAN objects) </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanRxBasicCANTask </p>
<p> </p>
<p>Error </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanErrorTask </p>
<p> </p>
<p>Wakeup </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>CanWakeUpTask </p>
<p>Individual Polling </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanTxObjTask, </p>
<p>CanRxFullCANObjTask, </p>
<p>CanRxBasicCANObjTask </p>
<p>Multi-channel </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Support extended ID addressing mode </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Support mixed ID addressing mode </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Support access to error counters </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanRxActualErrorCounter </p>
<p>CanTxActualErrorCounter </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>74 / 149</p>
<p>Copy functions </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CanCopyFromCan, </p>
<p>CanCopyToCan </p>
<p>CAN RAM check </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ApplCanMemCheckFailed </p>
<p>Figure 2: Feature List </p>
<p> </p>
<p> </p>
<p>feature is supported in general (exceptions might be possible if a CAN controller is not able to support a </p>
<p>feature. </p>
<p></p>
<p> </p>
<p>feature  is  not  implemented  for  each  hardware  because  different  CAN  controller  doesn’t  support  this </p>
<p>feature.</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>75 / 149</p>
<p><b>8 </b></p>
<p><b>Description of the API (Standard) </b></p>
<p>The complete Standard CAN Driver API is described in this section. </p>
<p><b>8.1 </b></p>
<p><b>API Categories </b></p>
<p>Depending  on  the  number  of  supported  channels,  i.e.  the  number  of  connected  CAN </p>
<p>networks  to  one  ECU,  the  API  of  the  CAN  Driver  is  realized  as  &quot;Single  Channel&quot;  or </p>
<p>&quot;Multiple Channel&quot; with additional channel specific information. </p>
<p><b>8.1.1 </b></p>
<p><b>Single Receive Channel (SRC) </b></p>
<p>A “Single Receive Channel” CAN Driver supports one CAN channel. </p>
<p><b>8.1.2 </b></p>
<p><b>Multiple Receive Channel (MRC) </b></p>
<p>A  &quot;Single  Receive  Channel&quot;  CAN  Driver  is  typically  extended  for  multiple  channels  by </p>
<p>adding </p>
<p>an </p>
<p>index </p>
<p>to </p>
<p>the </p>
<p>function </p>
<p>parameter </p>
<p>list </p>
<p>(e.g. </p>
<p>CanOnline() </p>
<p>becomes </p>
<p>to </p>
<p>CanOnline(channel)) </p>
<p>or </p>
<p>by </p>
<p>using </p>
<p>the </p>
<p>handle </p>
<p>as </p>
<p>a </p>
<p>channel </p>
<p>indicator </p>
<p>(e.g. </p>
<p>CanTransmit(txHandle)). </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>76 / 149</p>
<p><b>8.2 </b></p>
<p><b>Data Types </b></p>
<p>The following general data types are defined by the CAN Driver: </p>
<p> </p>
<p>vbittype  </p>
<p>canbittype </p>
<p>Single bit information </p>
<p>vuint8  </p>
<p>canuint8 </p>
<p>unsigned 8 bit (byte) value </p>
<p>vuint16  </p>
<p>canuint16 </p>
<p>unsigned 16 bit (word) value </p>
<p>vuint32  </p>
<p>canuint32 </p>
<p>unsigned 32 bit (dword) value </p>
<p>vsint8 </p>
<p>cansint8 </p>
<p>signed 8 bit (byte) value </p>
<p>vsint16  </p>
<p>cansint16 </p>
<p>signed 16 bit (word) value </p>
<p>vsint32  </p>
<p>cansint32 </p>
<p>signed 32 bit (dword) value </p>
<p> </p>
<p>There are special data types to reference specific generated data structures: </p>
<p>CanInitHandle </p>
<p>Initialization parameters </p>
<p>CanReceiveHandle </p>
<p>Receive parameters </p>
<p>CanTransmitHandle </p>
<p>Transmit parameters </p>
<p>CanChannelHandle </p>
<p>Channel parameters ( only available in indexed CAN Drivers ) </p>
<p> </p>
<p><b>Some data types are referencing the CAN Controller registers </b></p>
<p>CanChipDataPtr </p>
<p>Receive and transmit data register of the CAN Controller </p>
<p>CanChipMsgPtr </p>
<p>Complete receive and transmit message objects including CAN </p>
<p>identifier and DLC </p>
<p><b>Some data types are only available in Single Receive Channel and Multiple Receive </b></p>
<p><b>Channel CAN Drivers </b></p>
<p>typedef volatile struct </p>
<p>{ </p>
<p>  CanChipDataPtr      </p>
<p>pChipData; </p>
<p>  CanTransmitHandle  Handle; </p>
<p>} CanTxInfoStruct; </p>
<p> </p>
<p>Structure with transmit information. </p>
<p> </p>
<p>pChipData is the pointer to the transmit data bytes </p>
<p>in the CAN controller. </p>
<p>Handle of the transmit message. </p>
<p>typedef volatile struct </p>
<p>{ </p>
<p>  CanChannelHandle   Channel; </p>
<p>  CanChipMsgPtr      </p>
<p>pChipMsgObj; </p>
<p>  CanChipDataPtr      </p>
<p>pChipData; </p>
<p>  CanReceiveHandle   Handle; </p>
<p>} tCanRxInfoStruct; </p>
<p> </p>
<p>Structure with receive information: </p>
<p>Channel from which the precopy is called. </p>
<p>pChipMsgObj is the pointer to the CAN Controller </p>
<p>Receive Register. If there are several receive </p>
<p>objects with different memory addresses available, </p>
<p>pChipMsgObj contains the pointer to the dedicated </p>
<p>receive object to get some information like CAN </p>
<p>identifier or DLC of the received message directly </p>
<p>out of the CAN Controller registers. </p>
<p>pChipData is the pointer to the received data bytes.</p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>77 / 149</p>
<p>Handle of the received message. </p>
<p>CanRxInfoStructPtr </p>
<p>Pointer to structure with receive information. </p>
<p> </p>
<p> </p>
<p><b>8.3 </b></p>
<p><b>Constants </b></p>
<p>This information is stored in ROM. </p>
<p><b>8.3.1 </b></p>
<p><b>Version Number </b></p>
<p>kCanMainVersion  and  kCanSubVersion  contains  the  BCD  coded  version  of  the  CAN </p>
<p>Driver: </p>
<p> </p>
<p>kCanMainVersion </p>
<p>Main version of the CAN Driver (BCD coded in a vuint8 constant </p>
<p>variable) </p>
<p>kCanSubVersion </p>
<p>Sub version of the CAN Driver (BCD coded in a vuint8 constant </p>
<p>variable) </p>
<p>kCanBugFixVersion</p>
<p>Release version of the CAN Driver (BCD coded in a vuint8 </p>
<p>constant variable) </p>
<p> </p>
<p> </p>
<p><b>Example</b> </p>
<p>A version number 2.31.00 is coded as 0x02 in kCanMainVersion, 0x31 in </p>
<p>kCanSubVersion and 0x00 in kCanBugFixVersion. </p>
<p> </p>
<p><b>8.4 </b></p>
<p><b>Macros </b></p>
<p><b>8.4.1 </b></p>
<p><b>Conversion </b></p>
<p><b>between </b></p>
<p><b>Logical </b></p>
<p><b>and </b></p>
<p><b>Hardware </b></p>
<p><b>Representation </b></p>
<p><b>of </b></p>
<p><b>CAN </b></p>
<p><b>Parameter DLC </b></p>
<p>These macros are used to convert the CAN protocol specific parameter DLC between the </p>
<p>logical presentation (DLC: 0..8) and the CAN Controller dependent, internal register layout </p>
<p>of different CAN Controllers. </p>
<p>They are normally used by the Generation Tool  for the initialization of the node specific </p>
<p>control structures but they are available also for the Application, if necessary. </p>
<p>The  MK_...  macros  are  converting  from  the  logical  to  the  CAN  Controller  dependent </p>
<p>representation: </p>
<p>MK_TX_DLC(dlc) </p>
<p>Conversion  of  transmit  DLC,  if  associated  CAN  message  has </p>
<p>standard identifier </p>
<p> </p>
<p>The following macro is only allowed to be used if extended CAN identifiers are used: </p>
<p>MK_TX_DLC_EXT(dlc) </p>
<p>Conversion of transmit DLC if associated CAN message has an </p>
<p>extended identifier </p>
<p> </p>
<p>The XT_... macro is converting from the CAN Controller dependent to the logical </p>
<p>presentation: </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>78 / 149</p>
<p>XT_TX_DLC(dlc) </p>
<p>Conversion of transmit DLC independent of identifier type </p>
<p> </p>
<p><b>8.4.2 </b></p>
<p><b>Direct Access to the CAN Controller Registers </b></p>
<p>These macros are defined by the CAN Driver to provide the access on CAN protocol </p>
<p>specific parameters like CAN identifier and DLC currently available in the CAN Controller. </p>
<p>To assign these information to a previously received message they are only valid in the </p>
<p>callback function ApplCanMsgReceived() or in user specific precopy functions. Only in this </p>
<p>scope there is a clear reference on receive messages possible and data in the CAN </p>
<p>Controller receive registers are still locked. They are referencing either on the CAN </p>
<p>Controller register or on the software shadow buffer of the CAN Driver, if used. The </p>
<p>parameter rxStruct is only available for Single Receive Channel and Multiple Receive </p>
<p>Channel Drivers and is the pointer to the receive information structure. </p>
<p>CanRxActualId(rxStruct) </p>
<p>Read identifier in logical presentation (0h..7FFh for </p>
<p>standard identifier or 0h..1FFFFFFFh for extended </p>
<p>identifier). </p>
<p>In case of mixed identifier, the macro </p>
<p>CanRxActualIdType can be used to decide whether </p>
<p>the CAN identifier is in standard or extended </p>
<p>format. </p>
<p>CanRxActualIdType(rxStruct)</p>
<p>Read the format type of the CAN identifier </p>
<p> </p>
<p>kCanIdTypeStd   </p>
<p>standard format </p>
<p> </p>
<p>kCanIdTypeExt   </p>
<p>extended format </p>
<p>CanRxActualDLC(rxStruct) </p>
<p>Read DLC in logical presentation (0..8) </p>
<p>CanRxActualData(rxStruct,i)</p>
<p>Read Data in logical presentation. i is the position </p>
<p>of the byte (0..7). </p>
<p>CanRxActualErrorCounter( </p>
<p>channel) </p>
<p>Read current status of the receive error counter. In </p>
<p>use of microcontrollers without an readable error </p>
<p>counter, this macro returns always 0. </p>
<p>CanTxActualErrorCounter( </p>
<p>channel) </p>
<p>Read current status of the transmit error counter. In </p>
<p>use of microcontrollers without an readable error </p>
<p>counter, this macro returns always 0. </p>
<p> </p>
<p>The following macros are only available if extended CAN identifiers are used: </p>
<p>CanRxActualIdExtHi( </p>
<p>rxStruct) </p>
<p>Read the bit 24 to 29 of the extended identifier in </p>
<p>logical presentation </p>
<p>CanRxActualIdExtMidHi( </p>
<p>rxStruct) </p>
<p>Read the bit 16 to 23 of the extended identifier in </p>
<p>logical presentation </p>
<p>CanRxActualIdExtMidLo( </p>
<p>rxStruct) </p>
<p>Read the bit 8 to 15 of the extended identifier in </p>
<p>logical presentation </p>
<p>CanRxActualIdExtLo( </p>
<p>rxStruct) </p>
<p>Read the bit 0 to 7 of the extended identifier in </p>
<p>logical presentation </p>
<p> </p>
<p>To  write  CAN  protocol  specific  parameters  like  CAN  identifier  and  DLC  the  to  the  CAN </p>
<p>controller  there  are  some  macros  available. The  parameter  txStruct  is  only  available  for </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>79 / 149</p>
<p>Single Receive Channel and Multiple Receive  Channel Drivers and is the pointer to the </p>
<p>transmit information structure. </p>
<p>CanTxWriteActId(txStruct, </p>
<p>id) </p>
<p>Write the parameter id in standard format and in </p>
<p>logical presentation to the hardware. </p>
<p>CanTxWriteActDLC(rxStruct, </p>
<p>dlc) </p>
<p>Write the DLC in logical presentation (0..8) </p>
<p> </p>
<p>The following macro is only available if extended CAN identifiers are used: </p>
<p>CanTxWriteActExtId( </p>
<p>txStruct,id) </p>
<p>Write the parameter id in extended format and in </p>
<p>logical presentation to the hardware. </p>
<p> </p>
<p><b>8.4.3 </b></p>
<p><b>Interpretation of the CAN Status </b></p>
<p>The following macros are used to decode the return code of CanGetStatus() (TRUE </p>
<p>means not equal to zero): </p>
<p>CanHwIsOk(state) </p>
<p>This macro returns TRUE, if the status of the CAN </p>
<p>Controller is Error-Active. </p>
<p>CanHwIsWarning(state) </p>
<p>This macro returns TRUE, if the status of the CAN </p>
<p>Controller is Warning (at least one error counter is equal or </p>
<p>higher than 96). </p>
<p>CanHwIsPassive(state) </p>
<p>This macro returns TRUE, if the status of the CAN </p>
<p>Controller is Error-Passive. </p>
<p>CanHwIsBusOff(state) </p>
<p>This macro returns TRUE, if the status of the CAN </p>
<p>Controller is Bus-Off. This information is only temporary. The </p>
<p>time when this status changes from TRUE to FALSE </p>
<p>depends on the CAN controller.  This could be after the CAN </p>
<p>controller has resynchronized on the bus regardless of the </p>
<p>Busoff recovery by the Application. This could also be after </p>
<p>CanResetBusoffStart() is called or after </p>
<p>CanResetBusoffEnd() is called.  </p>
<p>Hint:  Busoff detection has to be performed with </p>
<p>ApplCanBusoff(). </p>
<p>CanHwIsWakeup(state) </p>
<p>This macro returns TRUE, if the CAN Controller is not in </p>
<p>sleep mode. </p>
<p>CanHwIsSleep(state) </p>
<p>This macro returns TRUE, if the CAN Controller is in sleep </p>
<p>mode. </p>
<p>CanHwIsStart(state) </p>
<p>This macro returns TRUE, if the CAN Controller is not in </p>
<p>stop mode. </p>
<p>CanHwIsStop(state) </p>
<p>This macro returns TRUE, if the CAN Controller is in stop </p>
<p>mode. </p>
<p>CanIsOnline(state) </p>
<p>This macro returns TRUE, if the CAN Driver is online. </p>
<p>CanIsOffline(state) </p>
<p>This macro returns TRUE, if the CAN Driver is offline. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>80 / 149</p>
<p>Not all CAN Controllers support all of the hardware dependent states. Please refer to the </p>
<p>CAN </p>
<p>Controller </p>
<p>specific </p>
<p>documentation </p>
<p>TechnicalReference_CAN_&lt;hardware&gt;.pdf </p>
<p>[#hw_status] for details. </p>
<p><b>8.4.4 </b></p>
<p><b>Access to low level transmit structure </b></p>
<p>These macros are defined by the CAN driver to fill the set the data to be transmitted with </p>
<p>CanMsgTransmit()</p>
<p>: </p>
<p>CanMsgTransmitSetStdId( </p>
<p>tCanMsgTransmitStruct </p>
<p>*txData, vuint16 id) </p>
<p>Write the parameter id in standard format and in logical </p>
<p>presentation to the structure txData. </p>
<p>CanMsgTransmitSetExtId( </p>
<p>tCanMsgTransmitStruct </p>
<p>*txData, vuint32 id) </p>
<p>Write the parameter id in extended format and in logical </p>
<p>presentation to the structure txData. </p>
<p>CanMsgTransmitSetDlc( </p>
<p>tCanMsgTransmitStruct </p>
<p>*txData, vuint8 dlc) </p>
<p>Write the DLC in logical presentation (0..8) </p>
<p>CanMsgTransmitSetData( </p>
<p>tCanMsgTransmitStruct </p>
<p>*txData, vuint8 </p>
<p>nrDataByte, vuint8 </p>
<p>*txDataBytes) </p>
<p>Write the data bytes to be transmitted to the structure </p>
<p>txData. nrDataBytes specifies the number of bytes to be </p>
<p>copied (e.g. same as the DLC, max. 8). txDataBytes </p>
<p>points to the current location where the data has to be </p>
<p>copied from. </p>
<p> </p>
<p><b>8.5 </b></p>
<p><b>Functions </b></p>
<p>This chapter contains a description of the CAN Driver functions (services, callbacks and </p>
<p>user specifics) and the appropriate parameters and return codes. The function declarations </p>
<p>are given in C syntax as explained below: </p>
<p>vuint8 CanTransmit( CanTransmitHandle txObject ); </p>
<p></p>
<p> </p>
<p>vuint8 is the type of the return code </p>
<p></p>
<p> </p>
<p>CanTransmit is the name of the function </p>
<p></p>
<p> </p>
<p>CanTransmitHandle is the type of the function parameter </p>
<p></p>
<p> </p>
<p>txObject is the function parameter. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>81 / 149</p>
<p><b>8.5.1 </b></p>
<p><b>Service Functions </b></p>
<p><b>8.5.1.1 </b></p>
<p><b>CanInitPowerOn </b></p>
<p><b>CanInitPowerOn</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanInitPowerOn </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanInitPowerOn()</p>
<p> initializes the CAN Controller and the CAN Drivers internal </p>
<p>variables. The CAN Driver is always set to online mode and active operating state. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service function has to be called before any other CAN Driver function. The interrupts have to </p>
<p>be disabled during this service function is called. </p>
<p></p>
<p> </p>
<p>For indexed CAN Drivers every channel is initialized with kCanInitObj0. </p>
<p> </p>
<p><b>8.5.1.2 </b></p>
<p><b>CanInit </b></p>
<p><b>CanInit</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanInit </b>( CanInitHandle initObject ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanInit </b>( CanChannelHandle channel, CanInitHandle    </p>
<p>                initObject ) </p>
<p><b>Parameter </b></p>
<p>initObject </p>
<p>Handle of an initialization structure. The generated macros should be </p>
<p>used:  </p>
<p>kCanInitObjX</p>
<p>  </p>
<p>(with X = 1 ... Number of generated initialization structures)</p>
<p> </p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Initialization of the CAN Controller hardware. It is used to cancel pending transmit requests in the CAN </p>
<p>Controller transmit register and to change the baud rate or the hardware acceptance filters. </p>
<p>Online/Offline mode and Active/Passive state will not be changed. </p>
<p><b>Particularities and Limitations </b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>82 / 149</p>
<p></p>
<p> </p>
<p>During the call of </p>
<p>CanInit(..)</p>
<p>, the CAN Driver has to be in offline mode. </p>
<p></p>
<p> </p>
<p>CanInit(..)</p>
<p> is not reentrant and therefore must not be called recursively. </p>
<p></p>
<p> </p>
<p>CanInit(..)</p>
<p> must not be interrupted by </p>
<p>CanReset...(..)</p>
<p>, </p>
<p>CanSleep(..)</p>
<p>, </p>
<p>CanWakeUp(..)</p>
<p> </p>
<p>or by any CAN interrupt service routine and vice versa. </p>
<p></p>
<p> </p>
<p>CanInit(..)</p>
<p> must not interrupt the confirmation interrupt and must not be called in the </p>
<p>confirmation or indication function. </p>
<p> </p>
<p><b>8.5.1.3 </b></p>
<p><b>CanTransmit </b></p>
<p><b>CanTransmit</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>CanTransmit </b>( CanTransmitHandle txObject ) </p>
<p><b>Parameter </b></p>
<p>txObject </p>
<p>Handle of the transmit object </p>
<p><b>Return code </b></p>
<p>kCanTxOk  </p>
<p>The transmit request was accepted by the CAN Driver  </p>
<p>kCanTxFailed </p>
<p>Error code because one of the following conditions: </p>
<p></p>
<p> </p>
<p>Transmit request could not be passed to the CAN Controller because </p>
<p>the transmit registers are busy (only if  there is no transmit queue </p>
<p>used) </p>
<p></p>
<p> </p>
<p>CAN Driver's transmit path is in offline mode </p>
<p></p>
<p> </p>
<p>Special hardware conditions of the CAN Controller (e.g. the sleep </p>
<p>mode was entered; failed synchronization on the CAN bus) </p>
<p>kCanTxPartOffline </p>
<p>Error code because the transmit path of the CAN driver is in partial </p>
<p>offline mode for this transmit object. </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanTransmit(..)</p>
<p> checks if a transmit register in the CAN Controller is </p>
<p>available. If so, the transmit process is initiated in the CAN Controller and </p>
<p>kCanTxOk</p>
<p> is returned. If not </p>
<p>and if there is no transmit queue configured, the function call returns with the error code </p>
<p>kCanTxFailed</p>
<p> or </p>
<p>kCanTxPartOffline</p>
<p>. For a CAN Driver with a configured transmit queue; the </p>
<p>transmit request is marked in the queue and </p>
<p>kCanTxOk</p>
<p> is returned. Only the transmit request is saved </p>
<p>but not the associated data. As soon as one of the CAN Controller transmit registers becomes </p>
<p>available (successful transmission of the previous transmit request), the next transmit request with the </p>
<p>highest priority (lowest CAN identifier) in the transmit queue will be serviced. </p>
<p>By the parameter </p>
<p>txObject</p>
<p> all information for transmission (CAN identifier, DLC, location and length </p>
<p>of data, etc...) can be taken from the CAN Driver description data. They will be copied to the CAN </p>
<p>Controller and the transmit process is started. The message will be actually transmitted on the CAN </p>
<p>bus after a successful arbitration of the CAN protocol. </p>
<p>After a successful transmission a CAN message (at least one other CAN bus node gives an </p>
<p>acknowledge) the confirmation notification (a flag will be set or a user specific function will be called) </p>
<p>are executed in the scope of the CAN transmit interrupt routine. </p>
<p><b>Particularities and Limitations </b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>83 / 149</p>
<p></p>
<p> </p>
<p>CanTransmit(..)</p>
<p> supports the Network Management which can enable or disable the CAN </p>
<p>Driver's transmit path by means of the CAN Driver service functions </p>
<p>CanOnline()</p>
<p> and </p>
<p>CanOffline()</p>
<p>. No distinction is made between Network Management and Application messages. </p>
<p>In the offline mode, the transmit request is rejected with an error code. </p>
<p></p>
<p> </p>
<p>For CAN Controllers with priority controlled transmit queue (hardware or software) the sequence of </p>
<p>transmission may deviate from the call sequence of </p>
<p>CanTransmit(..)</p>
<p> because the transmit </p>
<p>queues are handled according to priorities (lowest CAN identifier first) and not according to the </p>
<p>chronological order of the entries in the queue (FIFO). </p>
<p></p>
<p> </p>
<p>The generated handles should be used to reference the transmit objects. The names consist of the </p>
<p>message symbol, a prefix and a postfix. Fixed rules are used to build these names. For more </p>
<p>details please refer to the user manual of the Generation Tool </p>
<p> </p>
<p><b>8.5.1.4 </b></p>
<p><b>CanTask </b></p>
<p><b>CanTask</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanTask </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanTask()</p>
<p> does polling of error events, receive objects, transmit objects and </p>
<p>wake-up events in the CAN Controller according to the configured polling mode. In multiple channel </p>
<p>drivers the </p>
<p>CanTask()</p>
<p> handles all channels. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>CanTask()</p>
<p> must not run on higher priority than other CAN functions. </p>
<p></p>
<p> </p>
<p>CanTask()</p>
<p> is available, if any polling mode is configured for the CAN Driver</p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>CanTask()</p>
<p> is also available for some CAN Controllers if cancellation in hardware is configured. </p>
<p>See more about that in the CAN Controller specific documentation </p>
<p>TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_cancel]  . </p>
<p> </p>
<p><b>8.5.1.5 </b></p>
<p><b>CanTxTask </b></p>
<p><b>CanTxTask</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanTxTask </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanTxTask </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>84 / 149</p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanTxTask()</p>
<p> does polling of transmit objects in the CAN Controller. </p>
<p>Confirmation functions will be called and confirmation flags will be set. If the transmit queue is </p>
<p>configured, this service function additionally transmits the queued messages. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>CanTxTask()</p>
<p> is available, if the general polling mode or the transmit polling mode is configured. </p>
<p></p>
<p> </p>
<p>CanTxTask()</p>
<p> is also available for some CAN Controllers if cancellation in hardware is configured. </p>
<p>See more about that in the CAN Controller specific documentation </p>
<p>TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_cancel]  . </p>
<p> </p>
<p><b>8.5.1.6 </b></p>
<p><b>CanRxFullCANTask </b></p>
<p><b>CanRxFullCanTask</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanRxFullCANTask </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanRxFullCANTask </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanRxFullCanTask()</p>
<p> does polling of Full CAN receive objects (if available) </p>
<p>according to the configured polling mode. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>CanRxFullCanTask()</p>
<p> must not run on higher priority than other CAN functions. </p>
<p></p>
<p> </p>
<p>CanRxFullCanTask()</p>
<p> is available if the Full CAN receive polling mode is configured. </p>
<p> </p>
<p><b>8.5.1.7 </b></p>
<p><b>CanRxBasicCANTask </b></p>
<p><b>CanRxBasicCANTask</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanRxBasicCANTask </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanRxBasicCANTask </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanRxBasicCANTask()</p>
<p> does polling of Basic CAN receive objects according to </p>
<p>the configured polling mode. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>85 / 149</p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>CanRxBasicCANTask()</p>
<p> must not run on higher priority than other CAN functions. </p>
<p></p>
<p> </p>
<p>CanRxBasicCANTask()</p>
<p> is available if the Basic CAN receive polling mode is configured. </p>
<p> </p>
<p> </p>
<p><b>8.5.1.8 </b></p>
<p><b>CanErrorTask </b></p>
<p><b>CanErrorTask</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanErrorTask </b>( void ) </p>
<p> </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanErrorTask </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanErrorTask()</p>
<p> does polling of error events in the CAN Controller. In case of a </p>
<p>BusOff, the callback function </p>
<p>ApplCanBusOff()</p>
<p> is called by this service function. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>CanErrorTask()</p>
<p> is available if the error polling is enabled. </p>
<p> </p>
<p><b>8.5.1.9 </b></p>
<p><b>CanWakeUpTask </b></p>
<p><b>CanWakeUpTask</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanWakeUpTask </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanWakeUpTask </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanWakeUpTask()</p>
<p> does polling of the wake-up events in the CAN Controller </p>
<p>according to the enabled polling mode. In case of a wake-up event on the CAN bus, the callback </p>
<p>function </p>
<p>ApplCanWakeUp()</p>
<p> will be called by this service function. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>CanWakeUpTask()</p>
<p> is available if the wakeup polling is enabled. </p>
<p></p>
<p> </p>
<p>A wake-up by the CAN bus is not supported by all CAN Controllers. Please refer to the CAN </p>
<p>controller specific documentation TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_sleep]. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>86 / 149</p>
<p> </p>
<p><b>8.5.1.10 </b></p>
<p><b>CanOnline </b></p>
<p><b>CanOnline</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanOnline </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanOnline </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanOnline()</p>
<p> enables the CAN Driver's transmit path for all subsequent transmit </p>
<p>requests of </p>
<p>CanTransmit(..)</p>
<p>. This is prerequisite to transmit any CAN message. </p>
<p>The current status of the transmit path can be queried by </p>
<p>CanGetStatus()</p>
<p>. </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN channel. </p>
<p><b>Particularities and Limitations </b></p>
<p>If a Network Management is used, the service function </p>
<p>CanOnline()</p>
<p> may only be used by the </p>
<p>Network Management. </p>
<p>It is only allowed to call </p>
<p>CanOnline()</p>
<p> </p>
<p>on Task level. No other CAN Driver service function is allowed </p>
<p>to be interrupted by </p>
<p>CanOnline().</p>
<p> </p>
<p> </p>
<p><b>8.5.1.11  CanOffline </b></p>
<p><b>CanOffline</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanOffline </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanOffline </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanOffline() </p>
<p>disables the CAN Driver's transmit path for all subsequent </p>
<p>transmit requests of </p>
<p>CanTransmit(..)</p>
<p>. </p>
<p>While the transmit path is blocked, transmit requests by </p>
<p>CanTransmit(..)</p>
<p> are rejected with an </p>
<p>error. This can be determined by evaluating the return code. </p>
<p>The current status of the transmit path can be queried </p>
<p>by CanGetStatus()</p>
<p>.  </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN channel. </p>
<p><b>Particularities and Limitations </b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>87 / 149</p>
<p>If the CAN Driver is configured to use a transmit queue, all queue entries will be cleared, i.e. transmit </p>
<p>requests will be lost. </p>
<p>If a Network Management is used, the service functions </p>
<p>CanOffline()</p>
<p> may only be used by the </p>
<p>Network Management. </p>
<p> </p>
<p><b>8.5.1.12 </b></p>
<p><b>CanPartOnline </b></p>
<p><b>CanPartOnline</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanPartOnline </b>( vuint8 sendGroup ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanPartOnline </b>( CanChannelHandle channel, vuint8     </p>
<p>                     sendGroup ) </p>
<p><b>Parameter </b></p>
<p>sendGroup </p>
<p>Send group or groups to be switched to online. </p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanPartOnline()</p>
<p> enables the CAN Driver's transmit path for the selected send </p>
<p>groups.  </p>
<p>The current status of the partial offline mode can be queried by </p>
<p>CanGetPartMode()</p>
<p>. </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN channel. </p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p> </p>
<p><b>8.5.1.13 </b></p>
<p><b>CanPartOffline </b></p>
<p><b>CanPartOffline</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanPartOffline </b>( vuint8 sendGroup ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanPartOffline </b>( CanChannelHandle channel, vuint8    </p>
<p>                      sendGroup ) </p>
<p><b>Parameter </b></p>
<p>sendGroup </p>
<p>Send group or groups to be switched to offline. </p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>88 / 149</p>
<p>The service function </p>
<p>CanPartOffline()</p>
<p> disables the CAN Driver's transmit path for the selected </p>
<p>send groups.  </p>
<p>While the transmit path is blocked for a selected group, transmit requests of a message assigned to </p>
<p>this group by </p>
<p>CanTransmit(..)</p>
<p> are rejected with </p>
<p>kCanPartOffline</p>
<p>. This can be determined by </p>
<p>evaluating the return code. </p>
<p>The current status of the partial offline mode can be queried by </p>
<p>CanGetPartMode()</p>
<p>. </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN channel. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>A queued message will be still send after the function </p>
<p>CanPartOffline()</p>
<p> was called.</p>
<p> </p>
<p> </p>
<p><b>8.5.1.14 </b></p>
<p><b>CanGetPartMode  </b></p>
<p><b>CanGetPartMode</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>vuint8 <b>CanGetPartMode </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>CanGetPartMode </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p>Send groups which are in partial offline mode.  </p>
<p></p>
<p> </p>
<p>C_SEND_GRP_NONE (if the partial mode is inactive) </p>
<p></p>
<p> </p>
<p>C_SEND_GRP_ALL (if the partial mode is active for all groups.) </p>
<p>NOTE:  predefined  macros  can  be  used  to  check  for  all  or  none </p>
<p>send groups. </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN </p>
<p>channel.  </p>
<p>See also 5.2.6 Partial Offline Mode page 35 </p>
<p><b>Functional Description </b></p>
<p>Reads the current partial offline status of the CAN Driver. </p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p> </p>
<p><b>8.5.1.15 </b></p>
<p><b>CanGetStatus </b></p>
<p><b>CanGetStatus</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>vuint8 <b>CanGetStatus </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>CanGetStatus </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>89 / 149</p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p>Software status of the CAN Driver. The following information is coded in </p>
<p>the return code: </p>
<p></p>
<p> </p>
<p>CAN Driver is offline (</p>
<p>CanOffline()</p>
<p> was called) </p>
<p>If extended status is enabled, this function also returns the hardware </p>
<p>status of the CAN Controller. The following additional information are </p>
<p>coded in the return code: </p>
<p></p>
<p> </p>
<p>Warning level, Error-Active/-Passive state and Bus-Off of the CAN </p>
<p>Controller </p>
<p></p>
<p> </p>
<p>CAN Controller is in sleep mode (</p>
<p>CanSleep()</p>
<p> was called) </p>
<p></p>
<p> </p>
<p>CAN Controller is in stop mode (</p>
<p>CanStop()</p>
<p> was called) </p>
<p>There are special macros to get this information in the return code. </p>
<p>These macros are </p>
<p>TRUE</p>
<p> (not equal to 0) if the specific condition is valid </p>
<p>and </p>
<p>FALSE</p>
<p> (equal to 0) if not. The parameter of these macros is the </p>
<p>status, i.e. the return code of </p>
<p>CanGetStatus()</p>
<p>: </p>
<p></p>
<p> </p>
<p>CanHwIsWarning(..), CanHwIsPassive(..), </p>
<p>CanHwIsBusOff(..), </p>
<p></p>
<p> </p>
<p>CanHwIsOk(..) </p>
<p></p>
<p> </p>
<p>CanHwIs Sleep(..), CanHwIsWakeup(..) </p>
<p></p>
<p> </p>
<p>CanHwIsStop(..), CanHwIsStart(..) </p>
<p></p>
<p> </p>
<p>CanIsOffline(..), CanIsOnline(..)</p>
<p> </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN </p>
<p>channel. </p>
<p><b>Functional Description </b></p>
<p>Reads the current status of the CAN Driver and the CAN Controller. </p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p> </p>
<p><b>8.5.1.16 </b></p>
<p><b>CanSleep </b></p>
<p><b>CanSleep</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>vuint8 <b>CanSleep </b>(void ) </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>CanSleep </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>Result of the sleep request: </p>
<p>kCanFailed </p>
<p>Sleep mode not entered  </p>
<p>kCanOk </p>
<p>Sleep mode entered </p>
<p>kCanNotSupported </p>
<p>The function </p>
<p>CanSleep</p>
<p> is not supported by this driver </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanSleep()</p>
<p> puts the CAN Controller into sleep mode. This reduces the power </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>90 / 149</p>
<p>consumption of the CAN Controller and enables the wake up behavior if the CAN Controller supports </p>
<p>this functionality. For indexed CAN Driver, this functionality is related to the specified CAN channel. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This functionality is not supported for all CAN Controllers. In such case the function is provided by </p>
<p>the CAN Driver but without any effect on the CAN Controller. This is done to enable the Application </p>
<p>to realize an orthogonal software structure. </p>
<p></p>
<p> </p>
<p>If it is supported by the CAN Controller, on a wake-up by the CAN bus, the callback function </p>
<p>ApplCanWakeUp()</p>
<p> is called. </p>
<p></p>
<p> </p>
<p>If a message is currently transmitted or received during the call of this service function, a direct </p>
<p>wake-up interrupt occurs or the CAN Driver remains in this function until the sleep mode is entered. </p>
<p>This behavior of the CAN Controller has to be considered in implementing the Application or the </p>
<p>Network Management. (This behavior is hardware dependent and described more detailed in the </p>
<p>CAN controller specific documentation TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_sleep]) </p>
<p></p>
<p> </p>
<p>If the sleep mode is not entered, no CAN wake-up interrupt occurs on the detection of any </p>
<p>message on the CAN bus. The callback function </p>
<p>ApplCanWakeUp()</p>
<p> will not be called and in </p>
<p>consequence the bus transceiver will not be initialized. This leads to CAN bus errors. Therefore it is </p>
<p>necessary to call a set of functions to realize a wake-up capable system. The order of the function </p>
<p>calls is very important. more… </p>
<p></p>
<p> </p>
<p>During the call of </p>
<p>CanSleep()</p>
<p> the CAN Driver has to be offline. </p>
<p></p>
<p> </p>
<p>CanSleep()</p>
<p> must not be interrupted by </p>
<p>CanInit()</p>
<p>, </p>
<p>CanReset...()</p>
<p>, </p>
<p>CanWakeUp()</p>
<p> or any </p>
<p>CAN interrupt routine and vice versa. </p>
<p></p>
<p> </p>
<p>CanSleep(..)</p>
<p> is not reentrant and therefore must not be called recursively. </p>
<p></p>
<p> </p>
<p>It isn’t allowed to call </p>
<p>CanSleep()</p>
<p> out of any callback function. </p>
<p></p>
<p> </p>
<p>CAN Interrupts should be disabled during the call of </p>
<p>CanSleep()</p>
<p>. To disable the Can Interrupts </p>
<p>the function </p>
<p>CanCanInterruptDisable()</p>
<p> should not be used. If this function is used no CAN </p>
<p>wake-up interrupt occurs on the detection of any message on the CAN bus. The callback function </p>
<p>ApplCanWakeUp() </p>
<p>will not be called. </p>
<p></p>
<p> </p>
<p>In Sleep mode the service functions </p>
<p>CanGetStatus()</p>
<p>, </p>
<p>CanWakeUp()</p>
<p>, </p>
<p>CanTransmit(), </p>
<p>CanTask() and all Can...Task() </p>
<p>are allowed to be called. </p>
<p> </p>
<p><b>8.5.1.17 </b></p>
<p><b>CanWakeUp </b></p>
<p><b>CanWakeUp</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>vuint8 <b>CanWakeUp </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>CanWakeUp </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>Result of the wakeup request </p>
<p>kCanFailed </p>
<p>wakeup was not successful </p>
<p>kCanOk </p>
<p>Sleep mode left </p>
<p>kCanNotSupported </p>
<p>The function </p>
<p>CanWakeUp</p>
<p> is not supported by this driver. </p>
<p><b>Functional Description </b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>91 / 149</p>
<p>The service function </p>
<p>CanWakeUp()</p>
<p> enters the normal operating mode of the CAN Controller. </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN channel. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This functionality is not supported for all CAN Controllers. In such case the function is provided by </p>
<p>the CAN Driver but without any effect on the CAN Controller. This is done to enable the Application </p>
<p>to realize an orthogonal software structure. </p>
<p></p>
<p> </p>
<p>During the call of </p>
<p>CanWakeUp()</p>
<p> the CAN Driver has to be offline. </p>
<p></p>
<p> </p>
<p>No wake-up interrupt is generated by the call of </p>
<p>CanWakeUp()</p>
<p>. </p>
<p></p>
<p> </p>
<p>CanWakeUp()</p>
<p> must not be interrupted by </p>
<p>CanInit()</p>
<p>, </p>
<p>CanReset...()</p>
<p>, </p>
<p>CanSleep()</p>
<p> or any </p>
<p>CAN interrupt routine and vice versa. </p>
<p></p>
<p> </p>
<p>CanWakeUp(..)</p>
<p> is not reentrant and therefore must not be called recursively. </p>
<p> </p>
<p><b>8.5.1.18 </b></p>
<p><b>CanStart </b></p>
<p><b>CanStart</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>vuint8 <b>CanStart </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>CanStart </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>Result of the stop request </p>
<p>kCanFailed </p>
<p>Restart of the CAN controller was not successful. </p>
<p>kCanOk </p>
<p>Stop mode left </p>
<p>kCanNotSupported </p>
<p>The function </p>
<p>CanStart()</p>
<p> is not supported by this driver. </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanStart()</p>
<p> enters the normal operating mode of the CAN Controller. </p>
<p>CanStart()</p>
<p> may not be called in sleep mode. </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN channel. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This functionality is not supported for all CAN Controllers. In such case the function is provided by </p>
<p>the CAN Driver but without any effect on the CAN Controller. This is done to enable the Application </p>
<p>to realize an orthogonal software structure. </p>
<p></p>
<p> </p>
<p>During the call of </p>
<p>CanStart()</p>
<p> the CAN Driver has to be offline. </p>
<p></p>
<p> </p>
<p>CanStart()</p>
<p> must not be interrupted by </p>
<p>CanInit()</p>
<p>, </p>
<p>CanReset...()</p>
<p>, </p>
<p>CanWakeUp()</p>
<p> or any </p>
<p>CAN interrupt routine and vice versa. </p>
<p></p>
<p> </p>
<p>CanStart(..)</p>
<p> is not reentrant and therefore must not be called recursively. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>92 / 149</p>
<p><b>8.5.1.19 </b></p>
<p><b>CanStop </b></p>
<p><b>CanStop</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>vuint8 <b>CanStop </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>CanStop </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>Result of the stop request: </p>
<p>kCanFailed </p>
<p>Stop mode not entered </p>
<p>kCanOk </p>
<p>Stop mode entered </p>
<p>kCanNotSupported </p>
<p>The function </p>
<p>CanStop</p>
<p> is not supported by this driver. </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanStop()</p>
<p> puts the CAN Controller into stop or hold mode. This does not </p>
<p>reduces the power consumption of the CAN Controller. The stop mode can only be left by calling </p>
<p>CanStart()</p>
<p>. </p>
<p>CanStop()</p>
<p> must not be called in sleep mode. </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN channel. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This functionality is not supported for all CAN Controllers. In such case the function is provided by </p>
<p>the CAN Driver but without any effect on the CAN Controller. This is done to enable the Application </p>
<p>to realize an orthogonal software structure. </p>
<p></p>
<p> </p>
<p>During the call of </p>
<p>CanStop()</p>
<p> the CAN Driver has to be offline. </p>
<p></p>
<p> </p>
<p>CanStop()</p>
<p> must not be interrupted by </p>
<p>CanInit()</p>
<p>, </p>
<p>CanReset...()</p>
<p>, </p>
<p>CanWakeUp()</p>
<p> or any </p>
<p>CAN interrupt routine and vice versa. </p>
<p></p>
<p> </p>
<p>CanStop(..)</p>
<p> is not reentrant and therefore must not be called recursively. </p>
<p> </p>
<p><b>8.5.1.20 </b></p>
<p><b>CanGlobalInterruptDisable </b></p>
<p><b>CanGlobalInterruptDisable</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanGlobalInterruptDisable </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanGlobalInterruptDisable()</p>
<p> disables interrupts, either by changing the </p>
<p>global interrupt control flag of the microprocessor or the interrupt level of the interrupt controller. In the </p>
<p>later case, the interrupt level is configurable. All levels where the CAN API (CAN interrupt, Flags, </p>
<p>service functions) is used have to be disabled. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>93 / 149</p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function has been moved to VstdLib. For more information refer to Application note-ISC-2-</p>
<p>1050_VstdLibIntegration.pdf </p>
<p> </p>
<p><b>8.5.1.21 </b></p>
<p><b>CanGlobalInterruptRestore </b></p>
<p><b>CanGlobalInterruptRestore</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanGlobalInterruptRestore </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanGlobalInterruptRestore()</p>
<p> restores the initial interrupt state which was </p>
<p>saved temporarily by </p>
<p>CanGlobalInterruptDisable()</p>
<p>. If </p>
<p>CanGlobalInterruptDisable()</p>
<p> is </p>
<p>called in a nested way, the initial interrupt state is not restored until </p>
<p>CanGlobalInterruptRestore()</p>
<p> has been called as many times. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This function has been moved to VstdLib. For more information refer to Application note AN-ISC-2-</p>
<p>1050_VstdLibIntegration.pdf  </p>
<p> </p>
<p><b>8.5.1.22 </b></p>
<p><b>CanCanInterruptDisable </b></p>
<p><b>CanCanInterruptDisable</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanCanInterruptDisable </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanCanInterruptDisable </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanCanInterruptDisable()</p>
<p> disables all CAN interrupts of one CAN channel, </p>
<p>either by changing the CAN interrupt control flags of the interrupt controller or of the CAN controller. In </p>
<p>case of separately implemented wake-up interrupt routines they have to be disabled by the </p>
<p>application. Therefore the callback function </p>
<p>ApplCanAddCanInterruptDisable()</p>
<p> can be </p>
<p>activated. </p>
<p><b>Particularities and Limitations </b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>94 / 149</p>
<p></p>
<p> </p>
<p>The CAN Drivers differ in the implementation of this service function. Please refer to the CAN </p>
<p>Controller specification documentation TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_int] for </p>
<p>details. </p>
<p></p>
<p> </p>
<p>This service function is not allowed to be called during Sleep-Mode. </p>
<p> </p>
<p><b>8.5.1.23 </b></p>
<p><b>CanCanInterruptRestore </b></p>
<p><b>CanCanInterruptRestore</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanCanInterruptRestore </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanCanInterruptRestore </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanCanInterruptRestore()</p>
<p> restores the initial interrupt state which was </p>
<p>saved temporarily by </p>
<p>CanCanInterruptDisable()</p>
<p>. If </p>
<p>CanCanInterruptDisable()</p>
<p> is called in </p>
<p>a nested way, the initial interrupt state is not restored until </p>
<p>CanCanInterruptRestore() </p>
<p>has been </p>
<p>called as many times. In case of separately implemented wake-up interrupt routines they have to be </p>
<p>restored by the application. Therefore the callback function </p>
<p>ApplCanAddCanInterruptRestore()</p>
<p> </p>
<p>can be activated</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>The CAN Drivers differ in the implementation of this service function. Please refer to the CAN </p>
<p>Controller specification documentation TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_int] for </p>
<p>details. </p>
<p></p>
<p> </p>
<p>This service function is not allowed to be called during Sleep-Mode. </p>
<p> </p>
<p><b>8.5.1.24 </b></p>
<p><b>CanSetPassive </b></p>
<p><b>CanSetPassive</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanSetPassive </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanSetPassive </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanSetPassive(..)</p>
<p> switches the CAN Driver to the passive state. </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN channel. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>95 / 149</p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>If the CAN Driver is configured to use a transmit queue, all queue entries will be cleared, i.e. </p>
<p>transmit requests and subsequent confirmations will be lost. </p>
<p></p>
<p> </p>
<p>The passive state of the CAN Driver will have an effect only if it is enabled by the CAN Driver </p>
<p>configuration. Nevertheless this service function is available at any time </p>
<p> </p>
<p><b>8.5.1.25 </b></p>
<p><b>CanSetActive </b></p>
<p><b>CanSetActive</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanSetActive </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanSetActive </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanSetActive()</p>
<p> switches the CAN Driver back to the active state. </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN channel. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>The passive state of the CAN Driver will have an effect only if it is enabled by the CAN Driver </p>
<p>configuration. Nevertheless this service function is available at any time. </p>
<p> </p>
<p><b>8.5.1.26 </b></p>
<p><b>CanResetBusOffStart </b></p>
<p><b>CanResetBusOffStart</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanResetBusOffStart </b>( CanInitHandle initObject ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanResetBusOffStart </b>( CanChannelHandle channel,       </p>
<p>                             CanInitHandle initObject ) </p>
<p><b>Parameter </b></p>
<p>initObject </p>
<p>Handle of an initialization structure. The generated macros should be </p>
<p>used:  </p>
<p>kCanInitObjX</p>
<p> </p>
<p>(with X = 1 ... Number of generated initialization structures)</p>
<p> </p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>96 / 149</p>
<p>This service function starts error recovery of the CAN Controller directly after BusOff. Usually a re-</p>
<p>initialization of the CAN Controller is done. The correct handling of a BusOff depends on the used </p>
<p>CAN Controller. Please refer to the CAN Controller specification documentation </p>
<p>TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_busoff] for details. </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN channel. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>During the call of </p>
<p>CanResetBusOffStart(..)</p>
<p>, the CAN Driver has to be in offline mode. </p>
<p></p>
<p> </p>
<p>CanResetBusOffStart(..)</p>
<p> is not reentrant and therefore must not be called recursively. </p>
<p></p>
<p> </p>
<p>CanResetBusOffStart()</p>
<p> must not be interrupted by </p>
<p>CanInit()</p>
<p>, </p>
<p>CanResetBusOffEnd()</p>
<p>, </p>
<p>CanResetBusSleep()</p>
<p>, </p>
<p>CanSleep()</p>
<p>, </p>
<p>CanWakeUp()</p>
<p> or by any CAN interrupt service routine </p>
<p>and vice versa. </p>
<p></p>
<p> </p>
<p>This service function can be realized as a preprocessor macro. </p>
<p> </p>
<p><b>8.5.1.27 </b></p>
<p><b>CanResetBusOffEnd </b></p>
<p><b>CanResetBusOffEnd</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanResetBusOffEnd </b>( CanInitHandle initObject ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanResetBusOffEnd </b>( CanChannelHandle channel,         </p>
<p>                           CanInitHandle initObject ) </p>
<p><b>Parameter </b></p>
<p>initObject </p>
<p>Handle of an initialization structure. The generated macros should be </p>
<p>used:  </p>
<p>kCanInitObjX</p>
<p> </p>
<p>(with X = 1 ... Number of generated initialization structures)</p>
<p> </p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Completes the error recovery after BusOff. For most of the CAN Drivers this service function has no </p>
<p>effect. </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN channel. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>During the call of </p>
<p>CanResetBusOffEnd(..)</p>
<p>, the CAN Driver has to be in offline mode. </p>
<p></p>
<p> </p>
<p>CanResetBusOffEnd(..)</p>
<p> is not reentrant and therefore must not be called recursively. </p>
<p></p>
<p> </p>
<p>CanResetBusOffEnd()</p>
<p> must not be interrupted by </p>
<p>CanInit()</p>
<p>, </p>
<p>CanResetBusOffStart()</p>
<p>, </p>
<p>CanResetBusSleep()</p>
<p>, </p>
<p>CanSleep()</p>
<p>, </p>
<p>CanWakeUp()</p>
<p> or by any CAN interrupt service routine </p>
<p>and vice versa. </p>
<p></p>
<p> </p>
<p>This service function can be realized as a preprocessor macro. </p>
<p> </p>
<p><b>8.5.1.28 </b></p>
<p><b>CanResetBusSleep </b></p>
<p><b>CanResetBusSleep</b></p>
<p><b>Prototype </b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>97 / 149</p>
<p>Single Receive Channel </p>
<p>void <b>CanResetBusSleep </b>( CanInitHandle initObject ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanResetBusSleep </b>( CanChannelHandle channel,         </p>
<p>                          CanInitHandle initObject ) </p>
<p><b>Parameter </b></p>
<p>initObject </p>
<p>Handle of an initialization structure. The generated macros should be </p>
<p>used:  </p>
<p>kCanInitObjX</p>
<p>  </p>
<p>(with X = 1 ... Number of generated initialization structures)</p>
<p> </p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p>  </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This service function aborts pending transmit requests in the CAN Controller before the sleep mode of </p>
<p>the CAN Controller is entered. This can be done by different ways, depending on CAN Controller </p>
<p>specific features: </p>
<p></p>
<p> </p>
<p>Complete re-initialization of the CAN Controller (using the service function </p>
<p>CanInit()</p>
<p> ) </p>
<p></p>
<p> </p>
<p>Cancel of the transmit requests </p>
<p>Please refer to the CAN Controller specific documentation for details. </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN channel. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>During the call of </p>
<p>CanResetBusSleep(..)</p>
<p>, the CAN Driver has to be in offline mode. </p>
<p></p>
<p> </p>
<p>CanResetBusSleep(..)</p>
<p> is not reentrant and therefore must not be called recursively. </p>
<p></p>
<p> </p>
<p>CanResetBusSleep()</p>
<p> must not be interrupted by </p>
<p>CanInit()</p>
<p>, </p>
<p>CanResetBusOffStart()</p>
<p>, </p>
<p>CanResetBusOffEnd()</p>
<p>, </p>
<p>CanSleep()</p>
<p>, </p>
<p>CanWakeUp()</p>
<p> or by any CAN interrupt service routine </p>
<p>and vice versa. </p>
<p></p>
<p> </p>
<p>This service function can be realized as a preprocessor macro. </p>
<p> </p>
<p><b>8.5.1.29 </b></p>
<p><b>CanGetDynTxObj </b></p>
<p><b>CanGetDynTxObj</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>CanTransmitHandle <b>CanGetDynTxObj </b>( CanTransmitHandle </p>
<p>txObject ) </p>
<p><b>Parameter </b></p>
<p>txObject </p>
<p>Handle of the dynamic transmit object. </p>
<p><b>Return code </b></p>
<p>CanTransmitHandle </p>
<p>Handle of the dynamic transmit object or </p>
<p>kCanNoTxDynObjAvailable</p>
<p> </p>
<p>if no dynamic transmit object is available or the specific dynamic object </p>
<p>is already used. </p>
<p><b>Functional Description </b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>98 / 149</p>
<p>Reserves a dynamic transmit object. </p>
<p>To use dynamic transmit objects an Application must reserve a dynamic transmit object from the CAN </p>
<p>Driver. </p>
<p>Before transmission, the Application must set all configured dynamic parameters of the dynamic </p>
<p>transmit object. </p>
<p>The Application can use a dynamic transmit object for one or many transmissions, but finally it must </p>
<p>release the dynamic transmit object by calling </p>
<p>CanReleaseDynTxObj(..)</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service function is only available, if dynamic transmit objects are configured. </p>
<p></p>
<p> </p>
<p>The generated handles should be used to reference the transmit objects. The names consist of the </p>
<p>message symbol, a prefix and a postfix. Fixed rules are used to build these names. For more </p>
<p>details please refer to the online help of the Generation Tool. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>99 / 149</p>
<p><b>8.5.1.30 </b></p>
<p><b>CanReleaseDynTxObj </b></p>
<p><b>CanReleaseDynTxObj</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>CanReleaseDynTxObj </b>( CanTransmitHandle txObject ) </p>
<p><b>Parameter </b></p>
<p>txObject </p>
<p>Handle of the dynamic transmit object which was returned by </p>
<p>CanGetDynTxObj(..)</p>
<p> </p>
<p><b>Return code </b></p>
<p>kCanDynReleased </p>
<p>Dynamic object is released </p>
<p>kCanDynNotReleased </p>
<p>Dynamic transmit object couldn’t be released because the object is still </p>
<p>in the transmit queue or in the transmit register of the CAN Controller. </p>
<p>CanReleaseDynTxObj(..)</p>
<p> has to be called later again. </p>
<p><b>Functional Description </b></p>
<p>Release a dynamic transmit object, which was reserved before by calling </p>
<p>CanGetDynTxObj(..)</p>
<p>. </p>
<p>The dynamic transmit object is referenced by </p>
<p>txObject</p>
<p>. </p>
<p>After a transmission of one or more messages is finished, the Application has to release the reserved </p>
<p>resource, because the number of dynamic transmit objects is limited and the Application should not </p>
<p>keep reserved dynamic transmit objects for a longer time. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service function is only available, if dynamic transmit objects are configured. </p>
<p></p>
<p> </p>
<p>The parameter </p>
<p>txObject</p>
<p> was reserved before by a call to </p>
<p>CanGetDynTxObj(..)</p>
<p>. </p>
<p> </p>
<p><b>8.5.1.31 </b></p>
<p><b>CanDynTxObjSetId </b></p>
<p><b>CanDynTxObjSetId</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanDynTxObjSetId </b>( CanTransmitHandle txObject, vuint16 </p>
<p>id ) </p>
<p><b>Parameter </b></p>
<p>txObject </p>
<p>Handle of the dynamic transmit object which was returned by </p>
<p>CanGetDynTxObj(..)</p>
<p>. </p>
<p>id </p>
<p>CAN identifier in standard format </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Sets the CAN identifier in standard format of a dynamic transmit object. The dynamic transmit object is </p>
<p>referenced by txObject. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service function is only available, if dynamic transmit objects are configured. </p>
<p></p>
<p> </p>
<p>The parameter txObject was reserved before by a call </p>
<p>to CanGetDynTxObj(..)</p>
<p>. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>100 / 149</p>
<p><b>8.5.1.32 </b></p>
<p><b>CanDynTxObjSetExtId </b></p>
<p><b>CanDynObjSetExtId</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanDynTxObjSetExtId </b>( CanTransmitHandle txObject,    </p>
<p>                             vuint16 idExtHi,  </p>
<p>                             vuint16 idExtLo) </p>
<p><b>Parameter </b></p>
<p>txObject </p>
<p>Handle of the dynamic transmit object which was returned by </p>
<p>CanGetDynTxObj(..)</p>
<p> </p>
<p>idExtHi </p>
<p>Upper 16 bit of the CAN identifier in extended format </p>
<p>idExtLo </p>
<p>Lower 16 bit of the CAN identifier in extended format </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Sets the CAN identifier in extended format of a dynamic transmit object. The dynamic transmit object </p>
<p>is referenced by txObject </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service function is only available, if dynamic transmit objects are configured. </p>
<p></p>
<p> </p>
<p>The parameter txObject was reserved before by a call to </p>
<p>CanGetDynTxObj(..)</p>
<p>. </p>
<p> </p>
<p><b>8.5.1.33 </b></p>
<p><b>CanDynTxObjSetDlc </b></p>
<p><b>CanDynTxObjSetDlc</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanDynTxObjSetDlc </b>( CanTransmitHandle txObject, </p>
<p>                           vuint8 dlc ) </p>
<p><b>Parameter </b></p>
<p>txObject </p>
<p>Handle of the dynamic transmit object which was returned by </p>
<p>CanGetDynTxObj(..)</p>
<p> </p>
<p>dlc </p>
<p>Data Length Code of the dynamic transmit object </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Sets the Data Length Code of a dynamic transmit object. The dynamic transmit object is referenced by </p>
<p>txObject. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service function is only available, if dynamic transmit objects are configured. </p>
<p></p>
<p> </p>
<p>The parameter txObject was reserved before by a call to </p>
<p>CanGetDynTxObj(..)</p>
<p>. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>101 / 149</p>
<p><b>8.5.1.34 </b></p>
<p><b>CanDynTxObjSetDataPtr </b></p>
<p><b>CanDynTxObjSetDataPtr</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanDynTxObjSetDataPtr </b>( CanTransmitHandle txObject,  </p>
<p>                               vuint8 *pData ) </p>
<p><b>Parameter </b></p>
<p>txObject </p>
<p>Handle of the dynamic transmit object which was returned by </p>
<p>CanGetDynTxObj(..)</p>
<p> </p>
<p>*pData </p>
<p>Data reference of the application specific data buffer referenced by the </p>
<p>dynamic transmit object </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Sets the data pointer of a dynamic transmit object. The dynamic transmit object is referenced by </p>
<p>txObject. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This service function is only available, if dynamic transmit objects are configured. </p>
<p></p>
<p> </p>
<p>The parameter txObject was reserved before by a call to </p>
<p>CanGetDynTxObj(..)</p>
<p>. </p>
<p> </p>
<p><b>8.5.1.35 </b></p>
<p><b>CanCancelTransmit </b></p>
<p><b>CanCancelTransmit</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanCancelTransmit </b>( CanTransmitHandle txObject ) </p>
<p><b>Parameter </b></p>
<p>txObject </p>
<p>Handle of the transmit object </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The call of the confirmation function resp. setting of the confirmation flag associated with txObject are </p>
<p>suppressed, if this message is already in the transmit buffer of the CAN controller.  </p>
<p>If the transmit queue is enabled, a pending transmit request in the queue is canceled. </p>
<p><b>Particularities and Limitations </b></p>
<p>The function call of </p>
<p>CanCancelTransmit()</p>
<p> must not interrupt the transmit ISR, </p>
<p>CanTransmit()</p>
<p> or </p>
<p>the </p>
<p>CanTxTask()</p>
<p>. </p>
<p>Though a transmission is canceled it will be sent if the request has been already in the hardware </p>
<p>object. Only if activated and highly dependent on hardware and vehicle manufacturer the transmit </p>
<p>request can be deleted in the hardware transmit object, too. </p>
<p> </p>
<p><b>8.5.1.36 </b></p>
<p><b>CanCopyFromCan </b></p>
<p><b>CanCopyFromCan</b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>102 / 149</p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanCopyFromCan </b>(void *dst, CanChipDataPtr src, vuint8 </p>
<p>len) </p>
<p><b>Parameter </b></p>
<p>dst </p>
<p>Pointer to the destination in default memory. This pointer is available in </p>
<p>the Precopy Function. </p>
<p>src </p>
<p>Pointer to the source CAN buffer or temporary buffer </p>
<p>len </p>
<p>number of bytes which have to be copied </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function copies data from the CAN data buffer to the RAM. </p>
<p><b>Particularities and Limitations </b></p>
<p>This function can only be used within precopy functions. </p>
<p> </p>
<p><b>8.5.1.37 </b></p>
<p><b>CanCopyToCan </b></p>
<p><b>CanCopyToCan</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanCopyToCan </b>( CanChipDataPtr dst, void *src, vuint8 </p>
<p>len) </p>
<p><b>Parameter </b></p>
<p>dst </p>
<p>Pointer to the destination CAN buffer or temporary buffer. This pointer is </p>
<p>available in the Pretransmit Function. </p>
<p>src </p>
<p>Pointer to the source in default memory.  </p>
<p>len </p>
<p>number of bytes which have to be copied </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function copies data from the RAM into the CAN data buffer. </p>
<p><b>Particularities and Limitations </b></p>
<p>This function can only be used within pretransmit functions. </p>
<p> </p>
<p><b>8.5.1.38 </b></p>
<p><b>CanTxGetActHandle </b></p>
<p><b>CanTxGetActHandle</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>CanTransmitHandle <b>CanTxGetActHandle </b>(CanObjectHandle </p>
<p>logTxHwObject) </p>
<p><b>Parameter </b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>103 / 149</p>
<p>logTxHwObject </p>
<p>Handle of the CAN hardware transmit object. For indexed drivers this is </p>
<p>a unique number over all CAN channels. </p>
<p><b>Return code </b></p>
<p>txObject </p>
<p>Handle of the transmit object which is currently in the hardware transmit </p>
<p>object. In case of enabled LowLevelMessageTransmit, this could also be </p>
<p>a handle of such a message  </p>
<p>kCanBufferMsgTransmit</p>
<p>: </p>
<p>CanCancelMsgTransmit</p>
<p> </p>
<p>kCanTxHandleNotUsed</p>
<p>: Handle is not valid </p>
<p><b>Functional Description </b></p>
<p>This service functions returns the handle of the transmit message, which has been transmitted in a </p>
<p>certain CAN hardware transmit object. The return value can be used as a parameter for </p>
<p>CanCancelTransmit()</p>
<p>. If the return value is </p>
<p>kCanBufferMsgTransmit</p>
<p>, </p>
<p>CanCancelMsgTransmit()</p>
<p> has to be called in stead of </p>
<p>CanCancelTransmit()</p>
<p>. </p>
<p>CanCancelTransmit()</p>
<p> ignores invalid handle and </p>
<p>kCanBufferMsgTransmit</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p>This function is only allowed to be called in or after </p>
<p>ApplCanTxObjStart()</p>
<p> and before </p>
<p>ApplCanTxObjConfirmed()</p>
<p> of a certain CAN buffer. </p>
<p> </p>
<p><b>8.5.1.39 </b></p>
<p><b>CanResetMsgReceivedCondition </b></p>
<p><b>CanResetMsgReceivedCondition</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanResetMsgReceivedCondition </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanResetMsgReceivedCondition </b>( CanChannelHandle </p>
<p>channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX  </p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanResetMsgReceivedConditional()</p>
<p> disables the calling of </p>
<p>ApplCanMsgCondReceived(). </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN channel. </p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p> </p>
<p><b>8.5.1.40 </b></p>
<p><b>CanSetMsgReceivedCondition </b></p>
<p><b>CanSetMsgReceivedCondition</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanSetMsgReceivedCondition </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanSetMsgReceivedCondition </b>( CanChannelHandle channel </p>
<p>) </p>
<p><b>Parameter </b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>104 / 149</p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX  </p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanSetMsgReceivedConditional()</p>
<p> enables the calling of </p>
<p>ApplCanMsgCondReceived(). </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN channel. </p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p> </p>
<p><b>8.5.1.41 </b></p>
<p><b>CanGetMsgReceivedCondition </b></p>
<p><b>CanGetMsgReceivedCondition</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanGetMsgReceivedCondition </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanGetMsgReceivedCondition </b>( CanChannelHandle channel </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX  </p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanGetMsgReceivedConditional()</p>
<p>returns the status of the condition for </p>
<p>calling </p>
<p>ApplCanMsgCondReceived(). </p>
<p>For indexed CAN Driver, this functionality is related to the specified CAN channel. </p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>105 / 149</p>
<p><b>8.5.2 </b></p>
<p><b>User Specific Functions </b></p>
<p>The user specific functions listed in this section are called by the CAN Driver and provided </p>
<p>by the Application when certain events occur. The user can define user specific functions </p>
<p>specifically for each message. The names in this section are only placeholders. The name </p>
<p>could be set in the generation tool. The type of the particular user specific message must </p>
<p>agree with the function types listed here. </p>
<p><b>8.5.2.1 </b></p>
<p><b>UserPrecopy </b></p>
<p><b>UserPrecopy</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>UserPrecopy </b>( CanRxInfoStructPtr rxStruct ) </p>
<p><b>Parameter </b></p>
<p>rxStruct </p>
<p>Pointer to the receive structure </p>
<p><b>Return code </b></p>
<p>kCanCopyData </p>
<p>Received data will be copied using the CAN Driver 's internal copy </p>
<p>mechanism </p>
<p>kCanNoCopyData</p>
<p> </p>
<p>CAN Driver doesn’t copy data and doesn’t perform indication </p>
<p><b>Functional Description </b></p>
<p>User specific function of the CAN Driver, which is called in the receive interrupt of a CAN message </p>
<p>before copying the data from the CAN Controller receive register to the application specific global data </p>
<p>buffer. </p>
<p>Depending on the function's return code, the CAN Driver will either terminate the processing of the </p>
<p>received message (</p>
<p>kCanNoCopyData</p>
<p>) or resume normal processing (</p>
<p>kCanCopyData</p>
<p>). </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>For each CAN message a separate precopy function may be defined. </p>
<p> </p>
<p><b>8.5.2.2 </b></p>
<p><b>UserIndication </b></p>
<p><b>UserIndication</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>UserIndication</b>( CanReceiveHandle rxObject) </p>
<p><b>Parameter </b></p>
<p>rxObject </p>
<p>Handle of the received message </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>User specific function which is called in the receive interrupt of a CAN message after data has been </p>
<p>copied and the CAN Controller receive register have been released. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>For each CAN message a separate indication function may be defined. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>106 / 149</p>
<p> </p>
<p><b>8.5.2.3 </b></p>
<p><b>UserPreTransmit </b></p>
<p><b>UserPreTransmit</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>vuint8  <b>UserPreTransmit</b>( CanTxInfoStruct txStruct ) </p>
<p><b>Parameter </b></p>
<p>txStruct </p>
<p>Transmit structure </p>
<p>Return code </p>
<p>kCanCopyData  </p>
<p>After the return of this user specific function, the CAN Driver copies the </p>
<p>data to be transmitted from the application specific global data buffer </p>
<p>associated to the corresponding message to the CAN Controller transmit </p>
<p>register </p>
<p>kCanNoCopyData </p>
<p>The CAN Driver does not copy data but starts the transmit request in the </p>
<p>CAN Controller immediately </p>
<p><b>Functional Description </b></p>
<p>User specific function which is called before the message is copied from the application specific data </p>
<p>buffer to the transmit register of the CAN Controller. This is done in the scope of the Tx interrupt or the </p>
<p>CanTxTask()</p>
<p> via </p>
<p>CanTransmit(..)</p>
<p>. The usage of the internal copy mechanism of the CAN Driver </p>
<p>is controlled by the return code. </p>
<p>A possible usage is the acquiring and copying of existing data which are spread in the Application. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>For each CAN message a separate pretransmit function may be defined. </p>
<p> </p>
<p><b>8.5.2.4 </b></p>
<p><b>UserConfirmation </b></p>
<p><b>UserConfirmation</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>UserConfirmation</b>( CanTransmitHandle txObject ) </p>
<p><b>Parameter </b></p>
<p>txObject </p>
<p>Handle of the transmit object </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>User specific function which is called in the scope of the CAN transmit interrupt routine or the </p>
<p>CanTxTask()</p>
<p> after the message has been sent on the CAN bus successfully </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>For each CAN message a separate confirmation function may be defined. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>107 / 149</p>
<p><b>8.5.3 </b></p>
<p><b>Callback Functions </b></p>
<p>Callback functions are called by the CAN Driver on certain events and have to be provided </p>
<p>by  the  Application.  In  contrast  to  the  user  specific  functions  in  the  section  before  the </p>
<p>callback functions are not message related but only event related. Their name can also be </p>
<p>reconfigured. </p>
<p><b>8.5.3.1 </b></p>
<p><b>ApplCanBusOff </b></p>
<p><b>ApplCanBusOff</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanBusOff </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanBusOff </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p>  (with X = 0 ... Number of generated channel index) </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This callback function is called if the CAN Controller enters BusOff state. The function is called in the </p>
<p>error interrupt, </p>
<p>CanTask()</p>
<p> or </p>
<p>CanErrorTask()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p>If no Network Management is used which provides a BusOff error handling, the Application has to do </p>
<p>the subsequent error handling (usually the re-initialization of the CAN Controller) by the CAN Driver </p>
<p>service function </p>
<p>CanResetBusOffStart()</p>
<p> and </p>
<p>CanResetBusOffEnd()</p>
<p> itself. </p>
<p> </p>
<p><b>8.5.3.2 </b></p>
<p><b>ApplCanWakeUp </b></p>
<p><b>ApplCanWakeUp</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanWakeUp </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanWakeUp </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX </p>
<p> </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This callback function is called if a wake-up condition on the CAN bus is detected during sleep mode </p>
<p>of the CAN Controller. The function is called in the wakeup interrupt, in the </p>
<p>CanTask() </p>
<p>or in the </p>
<p>CanWakeupTask()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>108 / 149</p>
<p></p>
<p> </p>
<p>If the CAN Controller was put into sleep mode by calling the service function </p>
<p>CanSleep()</p>
<p>, and </p>
<p>afterwards there is a dominant level at the receive input of the CAN Controller, CAN Controller </p>
<p>generates a wake-up interrupt. The CAN Driver calls the callback function </p>
<p>ApplCanWakeUp()</p>
<p> to </p>
<p>handle further wake-up call activities, e.g. starting the Network Management. </p>
<p></p>
<p> </p>
<p>The Application must assure that the CAN transmit path is restored to its normal operating state, </p>
<p>typically by the activation of the bus transceiver. </p>
<p></p>
<p> </p>
<p>This wake-up functionality is not supported by all CAN Controllers. If there is no power-down mode </p>
<p>of the CAN Controller or if the microprocessor cannot detect an external wake-up condition by the </p>
<p>CAN bus, this callback function will never be called. </p>
<p> </p>
<p><b>8.5.3.3 </b></p>
<p><b>ApplCanOverrun </b></p>
<p><b>ApplCanOverrun</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanOverrun </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanOverrun </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p>  </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This callback function is called if an overrun in a Basic CAN receive object was detected. It indicates a </p>
<p>possible loss of receive data. The function is called in the error interrupt, in the receive interrupt, in the </p>
<p>CanTask()</p>
<p>,</p>
<p> in the</p>
<p> </p>
<p>CanRxTask(),</p>
<p> </p>
<p>or in the </p>
<p>CanErrorTask().</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p>The overrun is completely handled by the CAN Driver. This callback function only notifies the </p>
<p>Application about such a condition. </p>
<p> </p>
<p><b>8.5.3.4 </b></p>
<p><b>ApplCanFullCanOverrun </b></p>
<p><b>ApplCanFullCanOverrun</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanFullCanOverrun </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanFullCanOverrun </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p>  </p>
<p>(with X = 0 ... Number of generated channel index)</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This callback function is called if an overrun of a Full CAN receive object was detected. It indicates a </p>
<p>possible loss of receive data. The function is called in the error interrupt, in the receive interrupt, in the </p>
<p>CanTask()</p>
<p>, in the </p>
<p>CanRxTask()</p>
<p> or in the </p>
<p>CanErrorTask()</p>
<p>. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>109 / 149</p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>The overrun is completely handled by the CAN Driver. This callback function only notifies the </p>
<p>Application about an overrun. </p>
<p> </p>
<p><b>8.5.3.5 </b></p>
<p><b>ApplCanMsgReceived </b></p>
<p><b>ApplCanMsgReceived</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>ApplCanMsgReceived</b>( CanRxInfoStructPtr rxStruct ) </p>
<p><b>Parameter </b></p>
<p>rxStruct </p>
<p>Pointer to receive information structure </p>
<p><b>Return code </b></p>
<p>kCanCopyData </p>
<p>Receive processing will be continued </p>
<p>kCanNoCopyData </p>
<p>Receive processing will be terminated </p>
<p><b>Functional Description </b></p>
<p>This callback function is called on every reception of a CAN message when the hardware acceptance </p>
<p>filter is passed. The function is called in the receive interrupt, in the </p>
<p>CanTask() </p>
<p>or in the </p>
<p>CanRxTask()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>The callback function may be used for gateway functionality or any other purpose. </p>
<p></p>
<p> </p>
<p>There are preprocessor macros available to read the CAN identifier, the Data Length Code and the </p>
<p>data in the CAN Controller receive register. </p>
<p> </p>
<p><b>8.5.3.6 </b></p>
<p><b>ApplCanRangePrecopy </b></p>
<p><b>ApplCanRangePrecopy</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>ApplCanRangePrecopy</b>( CanRxInfoStructPtr rxStruct) </p>
<p><b>Parameter </b></p>
<p>rxStruct </p>
<p>Pointer to the receive structure </p>
<p><b>Return code </b></p>
<p>kCanCopyData </p>
<p>The CAN receive interrupt routine is continued with verifying a match to </p>
<p>the next range and ID search. </p>
<p>kCanNoCopyData</p>
<p> </p>
<p>The CAN receive interrupt routine is terminated immediately after the </p>
<p>CAN Controller is serviced </p>
<p><b>Functional Description </b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>110 / 149</p>
<p>This precopy function is not called on a specific message CAN identifier but on a complete CAN </p>
<p>identifier range. The function is called in the receive interrupt, in the </p>
<p>CanTask(),</p>
<p> in the </p>
<p>CanRxTask()</p>
<p> or in </p>
<p>CanHandleRxMsg()</p>
<p>. The return code is not taken into account, if the range is </p>
<p>handled via the RX Queue. In this case, the handling of the received message will be terminated after </p>
<p>calling the range specific precopy function. </p>
<p>The name of this function is only a placeholder. The name could be set in the generation tool. </p>
<p>Up to four ranges with individual precopy functions can be specified per CAN channel. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>Ranges are normally used for Network Management or Transport Protocol services only </p>
<p></p>
<p> </p>
<p>In case a range configured to be handled via the Rx Queue, the return code of this function is </p>
<p>ignored. </p>
<p> </p>
<p><b>8.5.3.7 </b></p>
<p><b>ApplCanAddCanInterruptDisable </b></p>
<p><b>ApplCanAddCanInterruptDisable</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanAddCanInterruptDisable </b>( CanChannelHandle </p>
<p>channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p>  (with X = 0 ... Number of generated channel index) </p>
<p>In case of Single Receive Channel </p>
<p>channel</p>
<p> is always 0. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Disabling of additional CAN interrupts (like separately implemented Wake-Up interrupts and Polling </p>
<p>Tasks) can be added to the standard mechanism of the CAN by this callback function.</p>
<p> </p>
<p>The function is </p>
<p>called on interrupt and task level.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>ApplCanAddCanInterruptDisable()</p>
<p> is only called if configured </p>
<p> </p>
<p><b>8.5.3.8 </b></p>
<p><b>ApplCanAddCanInterruptRestore </b></p>
<p><b>ApplCanAddCanInterruptRestore</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanAddCanInterruptRestore </b>( CanChannelHandle </p>
<p>channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p>  (with X = 0 ... Number of generated channel index) </p>
<p>In case of Single Receive Channel </p>
<p>channel</p>
<p> is always 0. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>111 / 149</p>
<p>Complementary callback function for </p>
<p>ApplCanAddCanInterruptDisable()</p>
<p>.The function is called </p>
<p>on interrupt and task level. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>ApplCanAddCanInterruptRestore() </p>
<p>is only called if configured. </p>
<p> </p>
<p><b>8.5.3.9 </b></p>
<p><b>ApplCanFatalError </b></p>
<p><b>ApplCanFatalError</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanFatalError </b>( vuint8 errorNumber ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanFatalError </b>( CanChannelHandle channel, vuint8 </p>
<p>errorNumber ) </p>
<p><b>Parameter </b></p>
<p>errorNumber </p>
<p>Error identification: There is a predefined list with supported assertion </p>
<p>checks for each CAN Driver. All the function parameters starting with </p>
<p>kError.... Please refer to chapter Assertions and the CAN Controller </p>
<p>Specific documentation TechnicalReference_CAN_&lt;hardware&gt;.pdf </p>
<p>[#hw_assert] for details. </p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p>  (with X = 0 ... Number of generated channel index) </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>If assertions are configured, the callback function </p>
<p>ApplCanFatalError(..)</p>
<p> is called in case of </p>
<p>invalid user conditions (Application interface, reentrance), inconsistent generated data, hardware </p>
<p>errors or internal errors (queue). An error number is passed by the parameter. The function is called on </p>
<p>interrupt and task level. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>This callback function does not have to return to the CAN Driver. </p>
<p> </p>
<p><b>8.5.3.10 </b></p>
<p><b>ApplCanMsgNotMatched </b></p>
<p><b>ApplCanMsgNotMatched</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanMsgNotMatched </b>( CanRxInfoStructPtr rxStruct ) </p>
<p><b>Parameter </b></p>
<p>rxStruct </p>
<p>Pointer to the receive structure </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This callback function is called if a CAN message passes the hardware acceptance filter, but not the </p>
<p>software filter (inclusive the identifier specific predefined ranges). The function is called in the receive </p>
<p>interrupt, in the </p>
<p>CanTask()</p>
<p> </p>
<p>or in the </p>
<p>CanRxTask()</p>
<p>. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>112 / 149</p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p> </p>
<p><b>8.5.3.11 </b></p>
<p><b>ApplCanInit </b></p>
<p><b>ApplCanInit</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanInit</b>( CanObjectHandle logTxHwObjectFirstUsed, </p>
<p>                  CanObjectHandle logTxHwObjectFirstUnused) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanInit</b>( CanChannelObject channel, </p>
<p>                  CanObjectHandle logTxHwObjectFirstUsed, </p>
<p>                  CanObjectHandle logTxHwObjectFirstUnused) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX </p>
<p> (with X = 0 ... Number of generated channel index) </p>
<p>logTxHwObjectFirstUsed </p>
<p>Handle of the first CAN hardware transmit object of the current channel. </p>
<p>logTxHwObjectFirstUnused </p>
<p>Handle of the first unused CAN hardware transmit object of the current </p>
<p>channel. </p>
<p>example:  </p>
<p>for ( i = logTxHwObjectFirstUsed; i &lt; </p>
<p>logTxHwObjectFirstUnused; i++) </p>
<p>{ </p>
<p> /* loop over all used hardware transmit buffer of </p>
<p>the current </p>
<p>    channel */ </p>
<p>}</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This callback function is called in </p>
<p>CanInit()</p>
<p> for general purposes. In </p>
<p>CanInit()</p>
<p> transmit requests in </p>
<p>the CAN Controller are canceled. This means the corresponding confirmation notification will never </p>
<p>occur. User defined actions started in </p>
<p>ApplCanTxObjStart()</p>
<p> have to be stopped in </p>
<p>ApplCanInit()</p>
<p>.The function is called on interrupt and task level. </p>
<p><b>Particularities and Limitations </b></p>
<p>This callback is active only if ‘Tx observe’ functionality is activated. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>113 / 149</p>
<p><b>8.5.3.12 </b></p>
<p><b>ApplCanTxObjStart </b></p>
<p><b>ApplCanTxObjStart</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanTxObjStart</b>( CanObjectHandle logTxHwObject) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanTxObjStart</b>( CanChannelHandle channel, </p>
<p>CanObjectHandle logTxHwObject) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p>  (with X = 0 ... Number of generated channel index) </p>
<p>logTxHwObject</p>
<p> </p>
<p>Handle of the CAN buffer transmit object. For indexed drivers this is a </p>
<p>unique number over all CAN channels. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This callback function is called every time, a transmit request is initiated in the CAN Controller. This is </p>
<p>done in the service </p>
<p>CanTransmit(..)</p>
<p>.The function is called in the transmit interrupt, in the </p>
<p>CanTask()</p>
<p> or in the </p>
<p>CanTxTask()</p>
<p>, if the transmit queue is enabled. </p>
<p><b>Particularities and Limitations </b></p>
<p>This callback is active only if ‘Tx observe’ functionality is activated. </p>
<p> </p>
<p><b>8.5.3.13 </b></p>
<p><b>ApplCanTxObjConfirmed </b></p>
<p><b>ApplCanTxObjConfirmed</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanTxObjConfirmed</b>( CanObjectHandle logTxHwObject) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanTxObjConfirmed </b>(CanChannelHandle channel, </p>
<p>CanObjectHandle logTxHwObject) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p>  (with X = 0 ... Number of generated channel index) </p>
<p>logTxHwObject </p>
<p>Handle of the CAN buffer transmit object. For indexed drivers this is a </p>
<p>unique number over all CAN channels. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This callback function is called every time, a successful transmission is confirmed by the CAN </p>
<p>Controller in the scope of a transmit interrupt, in the </p>
<p>CanTask()</p>
<p> or in the </p>
<p>CanTxTask()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p>This callback is active only if ‘Tx observe’ functionality is activated. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>114 / 149</p>
<p><b>8.5.3.14 </b></p>
<p><b>ApplCanTimerStart </b></p>
<p><b>ApplCanTimerStart</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanTimerStart</b>(vuint8 timerIdentification) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanTimerStart</b>(CanChannelObject channel, vuint8 </p>
<p>timerIdentification) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p>  (with X = 0 ... Number of generated channel index) </p>
<p>timerIdentification </p>
<p>Identifier for the hardware dependent loop timer </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This callback function is called before a CAN Controller dependent loop is started</p>
<p>.  </p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p> </p>
<p><b>8.5.3.15 </b></p>
<p><b>ApplCanTimerLoop </b></p>
<p><b>ApplCanTimerLoop</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>vuint8 <b>ApplCanTimerLoop</b>(vuint8 timerIdentification) </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>ApplCanTimerLoop</b>(CanChannelObject channel, vuint8 </p>
<p>timerIdentification) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p>  (with X = 0 ... Number of generated channel index) </p>
<p>timerIdentification </p>
<p>Identifier for the hardware dependent loop timer </p>
<p><b>Return code </b></p>
<p>FALSE (equal to 0) </p>
<p>Exit loop, even if hardware is not correct  </p>
<p>TRUE (not equal to 0) </p>
<p>Continue with waiting for hardware condition </p>
<p><b>Functional Description </b></p>
<p>This callback function is called once in every loop cycle, i.e. multiple times for a specific condition.</p>
<p> </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>115 / 149</p>
<p><b>8.5.3.16 </b></p>
<p><b>ApplCanTimerEnd </b></p>
<p><b>ApplCanTimerEnd</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanTimerEnd</b>(vuint8 timerIdentification) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanTimerEnd</b>(CanChannelObject channel, vuint8 </p>
<p>timerIdentification) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p>  (with X = 0 ... Number of generated channel index) </p>
<p>timerIdentification </p>
<p>Identifier for the hardware dependent loop timer </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This callback function is called after a hardware dependent loop is finished, due to return value also of </p>
<p>ApplCanTimerLoop or hardware condition met. </p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p> </p>
<p><b>8.5.3.17 </b></p>
<p><b>ApplCanGenericPrecopy </b></p>
<p><b>ApplCanGenericPrecopy</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>ApplCanGenericPrecopy</b>(CanRxInfoStructPtr rxStruct) </p>
<p><b>Parameter </b></p>
<p>rxStruct </p>
<p>Pointer to the receive structure </p>
<p><b>Return code </b></p>
<p>kCanCopyData </p>
<p>The UserPrecopy function will be called and the Received data will be </p>
<p>copied using the CAN Driver’s internal copy mechanism. </p>
<p>kCanNoCopyData </p>
<p>CAN Driver doesn’t copy data and doesn’t perform indication </p>
<p><b>Functional Description </b></p>
<p>This precopy function is common to all receive messages. It will be called immediately after the DLC-</p>
<p>check. The call of the </p>
<p>UserPrecopy</p>
<p> functions or copy of data are influenced by </p>
<p>ApplCanGenericPrecopy()</p>
<p>. The function is called in the receive interrupt, in the </p>
<p>CanTask() </p>
<p>or in </p>
<p>the </p>
<p>CanRxTask()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p> </p>
<p><b>8.5.3.18 </b></p>
<p><b>ApplCanPreWakeup </b></p>
<p><b>ApplCanPreWakeup</b></p>
<p><b>Prototype </b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>116 / 149</p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanPreWakeUp</b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanPreWakeUp</b>(CanChannelHandle channel) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p>  (with X = 0 ... Number of generated channel index) </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Is called just after the activation of the wakeup interrupt.  </p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p> </p>
<p><b>8.5.3.19 </b></p>
<p><b>ApplCanTxConfirmation </b></p>
<p><b>ApplCanTxConfirmation</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanTxConfirmation</b>( CanTxInfoStructPtr txStruct) </p>
<p><b>Parameter </b></p>
<p>txStruct </p>
<p>Pointer to transmit structure </p>
<p> </p>
<p>typedef struct  </p>
<p>{ </p>
<p>  CanChannelHandle   Channel; </p>
<p>  CanTransmitHandle  Handle; </p>
<p>} tCanTxConfInfoStruct; </p>
<p> </p>
<p>typedef tCanTxConfInfoStruct      </p>
<p>*CanTxInfoStructPtr; </p>
<p>Handle:</p>
<p>  </p>
<p>- 0 ... (kCanNumberOfTxMessages-1): the handle of the Tx message. </p>
<p>- </p>
<p>kCanBufferMsgTransmit</p>
<p>, </p>
<p>in case the message was sent via </p>
<p>CanCancelMsgTransmit(). </p>
<p>- </p>
<p>((CanTransmitHandle)0xFFFFFFFEU) </p>
<p>in case the message was cancel by CanCanTransmit() or </p>
<p>CanCancelMsgTransmit() but sent on the bus </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This confirmation function is common to all transmit messages. It will be called after the successful </p>
<p>transmission. The function is called in the transmit interrupt, in the </p>
<p>CanTask()</p>
<p> </p>
<p>or in the </p>
<p>CanTxTask()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>117 / 149</p>
<p> </p>
<p><b>8.5.3.20 </b></p>
<p><b>ApplCanMsgDlcFailed </b></p>
<p><b>ApplCanMsgDlcFailed</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanMsgDlcFailed</b>( CanRxInfoStructPtr rxStruct ) </p>
<p><b>Parameter </b></p>
<p>rxStruct </p>
<p>Pointer to the receive structure </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This callback function is called, if the DLC check fails. To activate this callback function the switch </p>
<p>C_ENABLE_DLC_FAILED_FCT</p>
<p> has to be set in a user configuration file. The function is called in the </p>
<p>receive interrupt, in the </p>
<p>CanTask()</p>
<p> or in the </p>
<p>CanRxTask()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p>It depends on the OEM if ApplCanMsgDlcFailed()</p>
<p> is available. </p>
<p> </p>
<p><b>8.5.3.21 </b></p>
<p><b>ApplCanCancelNotification </b></p>
<p><b>ApplCanCancelNotification</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanCancelNotification</b>(CanTransmitHandle txHandle) </p>
<p><b>Parameter </b></p>
<p>txHandle </p>
<p>Handle of cancelled transmit object </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function will be called if a transmit message is deleted (CanCancelTransmit, CanOffline or </p>
<p>CanInit). This function could be called in Interrupt or Task context. </p>
<p><b>Particularities and Limitations </b></p>
<p>ApplCanCancelNotification()</p>
<p> is only called if configured. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>118 / 149</p>
<p><b>8.5.3.22 </b></p>
<p><b>ApplCanOnline </b></p>
<p><b>ApplCanOnline</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanOnline</b>(CanChannelHandle channel) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>CAN Channel on which the CAN driver was switched to online mode. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>-  </p>
<p><b>Functional Description </b></p>
<p>This callback function indicates that the CAN driver is switched to online mode. This function is called </p>
<p>by the CAN Driver if the mode change is initiated via </p>
<p>CanOnline()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>Call context</b></p>
<p>: This function is called within </p>
<p>CanOnline()</p>
<p>. This service function is only allowed to be </p>
<p>called on task level. </p>
<p> </p>
<p><b>8.5.3.23 </b></p>
<p><b>ApplCanOffline </b></p>
<p><b>ApplCanOffline</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanOffline</b>(CanChannelHandle channel) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>CAN Channel on which the CAN driver was switched to offline mode. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>-  </p>
<p><b>Functional Description </b></p>
<p>This callback function indicates that the CAN driver is switched to offline mode. This function is called </p>
<p>by the CAN Driver if the mode change is initiated via </p>
<p>CanOffline()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>Call context</b></p>
<p>: This function is called within </p>
<p>CanOffline()</p>
<p>. This service function is allowed to be </p>
<p>called on task level or on interrupt level. </p>
<p> </p>
<p><b>8.5.3.24 </b></p>
<p><b>ApplCanMsgCondReceived </b></p>
<p><b>ApplCanMsgCondReceived</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanMsgCondReceived </b>(CanRxInfoStructPtr rxStruct) </p>
<p><b>Parameter </b></p>
<p>rxStruct </p>
<p>Pointer to the receive information structure </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>119 / 149</p>
<p><b>Return code </b></p>
<p>- </p>
<p>-  </p>
<p><b>Functional Description </b></p>
<p>This callback function is conditionally called on every reception of a CAN message when the hardware </p>
<p>acceptance filter is passed. </p>
<p>There are preprocessor macros available to read the CAN identifier, the Data Length Code and the </p>
<p>data in the CAN Controller receive register. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>Call context</b></p>
<p>: The function is called in the receive interrupt, in the </p>
<p>CanTask() </p>
<p>or in the </p>
<p>CanRxTask()</p>
<p>. </p>
<p> </p>
<p><b>8.5.3.25 </b></p>
<p><b>ApplCanMemCheckFailed </b></p>
<p><b>ApplCanMemCheckFailed</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>vuint8 <b>ApplCanMemCheckFailed </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>ApplCanMemCheckFailed </b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>Handle of the CAN channel on which the check failed. The generated </p>
<p>macros should be used: </p>
<p><b>kCanIndexX</b></p>
<p>  (with X = 0 ... Number of generated channel index) </p>
<p><b>Return code </b></p>
<p>kCanEnableCommunication </p>
<p>Allow communication.  </p>
<p>kCanDisableCommunication </p>
<p>Disable communication, no reception and no transmission is performed. </p>
<p><b>Functional Description </b></p>
<p>This callback function is called if the CAN driver has found at least one corrupt memory bit within the </p>
<p>CAN mailboxes. The application can decide if the CAN driver allows further communication by means </p>
<p>of the return value. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>Call context</b></p>
<p>: This function is called on task level or within the busoff interrupt. </p>
<p> </p>
<p><b>8.5.3.26 </b></p>
<p><b>ApplCanCorruptMailbox </b></p>
<p><b>ApplCanCorruptMailbox</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanCorruptMailbox </b>( CanObjectHandle hwObjHandle ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanCorruptMailbox </b>( CanChannelHandle channel,    </p>
<p>                            CanObjectHandle hwObjHandle ) </p>
<p><b>Parameter </b></p>
<p>hwObjHandle </p>
<p>The index of the corrupt mailbox. </p>
<p>channel </p>
<p>Handle of the CAN channel on which the corrupt mailbox is located. The </p>
<p>generated macros should be used: </p>
<p><b>kCanIndexX</b></p>
<p>  (with X = 0 ... Number of generated channel index) </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>120 / 149</p>
<p><b>Return code </b></p>
<p>- </p>
<p>-  </p>
<p><b>Functional Description </b></p>
<p>This callback function is called if the CAN driver has found a corrupt mailbox. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>Call context</b></p>
<p>: This function is called on task level or within the busoff interrupt. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>121 / 149</p>
<p><b>9 </b></p>
<p><b>Description of the API (High End extension) </b></p>
<p><b>9.1 </b></p>
<p><b>Functions </b></p>
<p><b>9.1.1 </b></p>
<p><b>Service Functions </b></p>
<p><b>9.1.1.1 </b></p>
<p><b>CanTxObjTask </b></p>
<p><b>CanTxObjTask</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanTxObjTask </b>( CanObjectHandle txObjHandle ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanTxObjTask </b>( CanChannelHandle canHwChannel, </p>
<p>CanObjectHandle txObjHandle ) </p>
<p><b>Parameter </b></p>
<p>canHwChannel </p>
<p>Handle of a CAN Hardware channel. The generated macros should be </p>
<p>used: </p>
<p>Normal Tx Object: </p>
<p>C_TX_NORMAL_&lt;channel&gt;_HW_CHANNEL</p>
<p> </p>
<p>(with &lt;channel&gt; = 0 ... Number </p>
<p>of logical channel) </p>
<p>Full CAN Tx Object: </p>
<p>&lt;message name&gt;_HW_CHANNEL </p>
<p>(with &lt;message name&gt; = Name of the </p>
<p>Message with pre and postfixes generated in “can_par.h”t) </p>
<p>Low Level Tx Object: </p>
<p>C_TX_LL_&lt;channel&gt;_HW_CHANNEL </p>
<p>(with &lt;channel&gt; = 0 ... Number of logical </p>
<p>channel)</p>
<p> </p>
<p>txObjHandle </p>
<p>Handle of a Tx mailbox. The generated macros should be used: </p>
<p>Normal Tx Object: </p>
<p>C_TX_NORMAL_&lt;channel&gt;_HW_OBJ</p>
<p> </p>
<p>(with &lt;channel&gt; = 0 ... Number of </p>
<p>logical channel) </p>
<p>Full CAN Tx Object: </p>
<p>&lt;message name&gt;_HW_OBJ </p>
<p>(with &lt;message name&gt; = Name of the Message with </p>
<p>pre and postfixes generated in “can_par.h”) </p>
<p>Low Level Tx Object: </p>
<p>C_TX_LL_&lt;channel&gt;_HW_OBJ </p>
<p>(with &lt;channel&gt; = 0 ... Number of logical </p>
<p>channel) </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanTxObjTask()</p>
<p> does polling of specified transmit hardware objects in the </p>
<p>CAN controller. Confirmation functions will be called and confirmation flags will be set. If the transmit </p>
<p>queue is configured, this service function additionally transmits the queued messages. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>CanTxObjTask()</p>
<p> is available, if the individual polling mode and at least one mailbox is configured </p>
<p>for polling. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>122 / 149</p>
<p><b>9.1.1.2 </b></p>
<p><b>CanRxFullCANObjTask </b></p>
<p><b>CanRxFullCANObjTask</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanRxFullCANObjTask </b>(CanObjectHandle rxObjHandle ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanRxFullCANObjTask </b>( CanChannelHandle canHwChannel, </p>
<p>CanObjectHandle rxObjHandle ) </p>
<p><b>Parameter </b></p>
<p>canHwChannel </p>
<p>Handle of a CAN Hardware channel. The generated macros should be </p>
<p>used: </p>
<p>&lt;message name&gt;_HW_ CHANNEL </p>
<p>(with &lt;message name&gt; = Name of the </p>
<p>Message with pre and postfixes generated in “can_par.h”)</p>
<p> </p>
<p>rxObjHandle </p>
<p>Handle of an Rx mailbox. The generated macros should be used: </p>
<p>&lt;message name&gt;_HW_OBJ </p>
<p>(with &lt;message name&gt; = Name of the Message </p>
<p>with pre and postfixes generated in “can_par.h”t) </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanRxFullCANObjTask()</p>
<p> does polling of specified Full CAN receive objects </p>
<p>according to the configured objects in polling mode. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>CanRxFullCANObjTask()</p>
<p> must not run on higher priority than other CAN functions. </p>
<p></p>
<p> </p>
<p>CanRxFullCANObjTask()</p>
<p> is available, if the individual polling mode and at least one mailbox is </p>
<p>configured for polling. </p>
<p> </p>
<p><b>9.1.1.3 </b></p>
<p><b>CanRxBasicCANObjTask </b></p>
<p><b>CanRxBasicCANObjTask</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanRxBasicCANObjTask </b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanRxBasicCANObjTask </b>(CanChannelHandle canHwChannel, </p>
<p>CanObjectHandle rxObjHandle ) </p>
<p><b>Parameter </b></p>
<p>canHwChannel </p>
<p>Handle of a CAN Hardware channel. The generated macros should be </p>
<p>used: </p>
<p>C_BASIC&lt;number_of_the_BasicCAN&gt;_&lt;channel&gt;HW_CHANNEL</p>
<p> </p>
<p>(with &lt;number_of_the_BasicCAN&gt;= the logical number of the Basic CAN on this </p>
<p>channel </p>
<p>&lt;channel&gt; = 0 ... Number of logical channel)</p>
<p> </p>
<p>txObjHandle </p>
<p>Handle of a Rx mailbox. The generated macros should be used: </p>
<p>C_BASIC&lt;number_of_the_BasicCAN&gt;_&lt;channel&gt;_HW_OBJ </p>
<p>(with </p>
<p> &lt;number_of_the_BasicCAN&gt;= the logical number of the Basic CAN on this channel </p>
<p>&lt;channel&gt; = 0 ... Number of logical channel) </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>123 / 149</p>
<p>The service function </p>
<p>CanRxBasicCANObjTask()</p>
<p> does polling of specified Basic CAN receive </p>
<p>objects according to the configured objects in polling mode. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>CanRxBasicCANObjTask()</p>
<p> must not run on higher priority than other CAN functions. </p>
<p></p>
<p> </p>
<p>CanRxBasicCANObjTask()</p>
<p> is available, if the individual polling mode and at least one mailbox is </p>
<p>configured for polling. </p>
<p> </p>
<p><b>9.1.1.4 </b></p>
<p><b>CanMsgTransmit </b></p>
<p><b>CanMsgTransmit</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>vuint8 <b>CanMsgTransmit </b>( tCanMsgTransmitStruct *txData ) </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>CanMsgTransmit </b>( CanChannelHandle channel,         </p>
<p>                          tCanMsgObject *txData ) </p>
<p><b>Parameter </b></p>
<p>*txData </p>
<p>Pointer to the structure with ID, DLC and data to send </p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p><b>kCanIndexX</b></p>
<p>  (with X = 0 ... Number of generated channel index) </p>
<p><b>Return code </b></p>
<p>kCanTxOk </p>
<p>if the message-buffer is free and the data could be copied to the CAN-</p>
<p>data-buffer or if  passive mode (</p>
<p>CanSetPassive()</p>
<p>) is active. </p>
<p>kCanTxFailed </p>
<p>if offline mode is active, the CAN buffer is not free. </p>
<p><b>Functional Description </b></p>
<p>This function is called by the application. The function sends the message which is defined in the </p>
<p>txData (Id, DLC, Data) to the CAN-Bus which is defined in the channel. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>the contents of txData may not be changed while </p>
<p>CanMsgTransmit()</p>
<p> is running </p>
<p> </p>
<p><b>9.1.1.5 </b></p>
<p><b>CanCancelMsgTransmit </b></p>
<p><b>CanCancelMsgTransmit</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanCancelMsgTransmit</b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanCancelMsgTransmit</b>( CanChannelHandle channel ) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX </p>
<p> (with X = 0 ... Number of generated channel index) </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The call of </p>
<p>ApplCanMsgTransmitConf()</p>
<p> is suppressed, if a message is already in the transmit </p>
<p>buffer of the CAN controller associated with </p>
<p>CanMsgTransmit()</p>
<p>. Dependent on the configuration </p>
<p>this function cancels a message in the CAN hardware. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>124 / 149</p>
<p><b>Particularities and Limitations </b></p>
<p>The function call of </p>
<p>CanCancelTransmit()</p>
<p> must not interrupt the transmit ISR, </p>
<p>CanMsgTransmit()</p>
<p> or the </p>
<p>CanTxTask()</p>
<p>. </p>
<p>Though a transmission is canceled it will be sent if the request has been already in the hardware </p>
<p>object. Only if activated and highly dependent on hardware and vehicle manufacturer the transmit </p>
<p>request which is initiated with </p>
<p>CanMsgTransmit()</p>
<p> can be deleted in the hardware transmit object, </p>
<p>too. The function </p>
<p>CanCancelMsgTranmit()</p>
<p> is only available if the confirmation </p>
<p>ApplCanMsgTransmitConf() </p>
<p>is configured. </p>
<p> </p>
<p><b>9.1.1.6 </b></p>
<p><b>CanHandleRxMsg </b></p>
<p><b>CanHandleRxMsg</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanHandleRxMsg </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanHandleRxMsg()</p>
<p> handles the received messages which are stored in the Rx </p>
<p>Queue. The standard mechanism (GenericPrecopy, UserPrecopy, copy of data, Indication Flag and </p>
<p>UserIndication) is started for each stored message. </p>
<p><b>Particularities and Limitations </b></p>
<p>This function is only allowed to be called on task level. </p>
<p> </p>
<p><b>9.1.1.7 </b></p>
<p><b>CanDeleteRxQueue </b></p>
<p><b>CanDeleteRxQueue</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanDeleteRxQueue </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The service function </p>
<p>CanDeleteRxQueue()</p>
<p> clears all pending messages in the Rx Queue. </p>
<p><b>Particularities and Limitations </b></p>
<p>This function is only allowed to be called on task level. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>125 / 149</p>
<p><b>9.1.2 </b></p>
<p><b>Callback Functions </b></p>
<p><b>9.1.2.1 </b></p>
<p><b>ApplCanMsgTransmitConf </b></p>
<p><b>ApplCanMsgTransmitConf</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanMsgTransmitConf</b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanMsgTransmitConf</b>(CanChannelHandle channel) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p>  (with X = 0 ... Number of generated channel index) </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function will be called from the CAN Driver after sending the message. It is called directly in the </p>
<p>transmit Interrupt (Confirmation) from the CAN-Controller. On task level it is called in the </p>
<p>CanTask()</p>
<p> </p>
<p>or in the </p>
<p>CanTxTask()</p>
<p>. With this callback function it is possible to implement a queue-functionality.  </p>
<p><b>Particularities and Limitations </b></p>
<p>ApplCanMsgTransmitConf()</p>
<p> is only called if configured. </p>
<p> </p>
<p><b>9.1.2.2 </b></p>
<p><b>ApplCanMsgTransmitInit </b></p>
<p><b>ApplCanMsgTransmitInit</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanMsgTransmitInit</b>( void ) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanMsgTransmitInit</b>(CanChannelHandle channel) </p>
<p><b>Parameter </b></p>
<p>channel </p>
<p>Handle of a CAN channel. The generated macros should be used: </p>
<p>kCanIndexX</p>
<p>  (with X = 0 ... Number of generated channel index) </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function will be called from the CAN Driver after a possible cancel of a transmit request in </p>
<p>CanInit()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p>ApplCanMsgTransmitInit()</p>
<p> is only called if </p>
<p>ApplCanMsgTransmitConf()</p>
<p> is configured. </p>
<p> </p>
<p><b>9.1.2.3 </b></p>
<p><b>ApplCanMsgCancelNotification </b></p>
<p><b>ApplCanMsgCancelNotification</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanMsgCancelNotification</b>( void ) </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>126 / 149</p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanMsgCancelNotification</b>( CanChannelHandle channel </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>Channel </p>
<p>CAN Channel on which the Tx Object was cancelled. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function will be called if a transmit message is deleted (CanCancelMsgTransmit). It applies only </p>
<p>to Tx messages that have been transmitted via CanMsgTransmit. </p>
<p>This function could be called in </p>
<p>Interrupt or Task context. </p>
<p><b>Particularities and Limitations </b></p>
<p> </p>
<p>ApplCanMsgCancelNotification()</p>
<p> is only called if configured. </p>
<p> </p>
<p><b>9.1.2.4 </b></p>
<p><b>ApplCanPreRxQueue </b></p>
<p><b>ApplCanPreRxQueue</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>ApplCanPreRxQueue</b>( CanRxInfoStructPtr rxStruct ) </p>
<p><b>Parameter </b></p>
<p>rxStruct </p>
<p>Pointer to receive information structure </p>
<p><b>Return code </b></p>
<p>kCanCopyData </p>
<p>The data of the received message will be stored in the Rx Queue.  </p>
<p>kCanNoCopyData </p>
<p>The data of the received message are not stored in the Rx Queue. The </p>
<p>reception is handled within the receive interrupt. </p>
<p><b>Functional Description </b></p>
<p>This precopy function is called if a message is received which is a valid message in the receive </p>
<p>structures or has to be handled via a range (in case the use of the Rx Queue is configured for this </p>
<p>range ). The application can decide whether to handle the message via the Rx Queue or the standard </p>
<p>CAN Driver mechanism within the receive interrupt. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>Call context</b></p>
<p>: This function is called within the receive interrupt. </p>
<p> </p>
<p><b>9.1.2.5 </b></p>
<p><b>ApplCanRxQueueOverrun </b></p>
<p><b>ApplCanRxQueueOverrun</b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanRxQueueOverrun</b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>-  </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>127 / 149</p>
<p><b>Functional Description </b></p>
<p>This callback function indicates an overrun of the Rx Queue. This function is called by the CAN Driver, </p>
<p>in case a new message has to be stored in the Rx Queue, but the Queue if full. This new message will </p>
<p>be lost. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>Call context</b></p>
<p>: This function is called within the receive interrupt. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>128 / 149</p>
<p><b>10 Configuration (Standard and High End) </b></p>
<p>This chapter describes the common options for configuring (customizing) the CAN Driver. </p>
<p>CAN  Controller  dependent  configuration  is  described  in  the  CAN  Controller  specific </p>
<p>documentation  TechnicalReference_CAN_&lt;hardware&gt;.pdf  [#hw_conf].  The  configuration </p>
<p>can be done by the Generation Tool automatically.  </p>
<p><b>10.1  Network Database – Attribute Definition </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>Attribute names in CANgen are case sensitive and not evaluated, if the name case is </p>
<p>incorrect.<b> </b></p>
<p> </p>
<p><b>Name </b></p>
<p><b>GenMsgMinAcceptLength </b></p>
<p><b>Description </b></p>
<p>The DLC check can be configured to verify the received DLC against the value </p>
<p>given by this attribute (Against minimum acceptance length). The value can be </p>
<p>smaller than the Application receive buffer of this message. </p>
<p>Value “-1” means the DLC of the received message will be compared to the </p>
<p>length of the Application receive buffer of this message. </p>
<p><b>Type Of Object </b></p>
<p>Message </p>
<p><b>Value Type </b></p>
<p>Integer </p>
<p><b>Default </b></p>
<p>-1 </p>
<p><b>Minimum </b></p>
<p>-1 </p>
<p><b>Maximum </b></p>
<p>8 </p>
<p> </p>
<p><b>10.2 </b></p>
<p><b>Automatic Configuration by GENy </b></p>
<p>Using </p>
<p>the </p>
<p>Generation </p>
<p>Tool </p>
<p>GENy </p>
<p>the </p>
<p>configuration </p>
<p>can </p>
<p>be </p>
<p>done </p>
<p>by </p>
<p>the </p>
<p>tool. </p>
<p>The </p>
<p>configuration options common to all CAN Drivers is described here. The CAN Controller </p>
<p>dependent options are described in the CAN Controller specific user manual. The following </p>
<p>dialog describes the CAN Driver common options. The configuration data is stored by the </p>
<p>tool in the file can_cfg.h for GENy.  </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>129 / 149</p>
<p> </p>
<p>Figure 10-1 Configuration of the common CAN Driver options with GENy </p>
<p> </p>
<p><b>Feature </b></p>
<p><b>Explanation </b></p>
<p>Common Driver Parameters </p>
<p>Online/Offline Callback </p>
<p>Functions </p>
<p>If </p>
<p>CanOnline()</p>
<p> or </p>
<p>CanOffline()</p>
<p> is called the Application is notified that </p>
<p>a certain CAN driver state was entered. </p>
<p>DLC check </p>
<p>The DLC check can be configured to “disabled”, comparison of received </p>
<p>DLC “against data length” or “against minimum acceptance length”. </p>
<p> “against data length” means the number of bytes necessary for the ECU </p>
<p>and is equal to the length of the application data buffer.  </p>
<p>The minimum acceptance length can be configured message specific via </p>
<p>database or on the Rx message view. </p>
<p>If DLC check is used, received Data messages with smaller DLC than </p>
<p>expected for this ID are ignored.  </p>
<p>Data Copy Mechanism </p>
<p>The Data Copy Mechanism can be configured to “copy number of </p>
<p>needed bytes” or “copy all received bytes”.  </p>
<p>“copy number of needed bytes” means the CAN driver copies always the </p>
<p>number of bytes which is equal to the length of the application data </p>
<p>buffer. </p>
<p> “copy all received bytes” means if the number of received bytes is less </p>
<p>than the size of the application data buffer only the received bytes are </p>
<p>copied. Otherwise the number of bytes which is equal to the length of the </p>
<p>application data buffer will be copied. </p>
<p>RAM check </p>
<p>The CAN driver supports a RAM check of the CAN controller mailboxes. </p>
<p>Sleep / Wakeup </p>
<p>If this field is checked, the CAN controller can be switched to sleep </p>
<p>mode. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>130 / 149</p>
<p><b>Feature </b></p>
<p><b>Explanation </b></p>
<p>Cancel in Hardware </p>
<p>CanCancelTransmit()</p>
<p> and </p>
<p>CanCancelMsgTransmit()</p>
<p> will delete a </p>
<p>pending request in the CAN controller hardware. </p>
<p>FullCAN Overrun </p>
<p>Notification </p>
<p>If checked an overrun in the receive FullCAN objects will be signaled to </p>
<p>the Application. </p>
<p>Receive Function </p>
<p>The receive function </p>
<p>ApplCanMsgReceived()</p>
<p> is called by the CAN </p>
<p>Driver on every reception of a CAN message after the hardware </p>
<p>acceptance filter is passed. Within this callback function the Application </p>
<p>may preprocess the received message in any way (ECU specific </p>
<p>dynamic filtering mechanisms, preprocessing of the messages, gateway </p>
<p>functionality...).  </p>
<p>If the callback function </p>
<p>ApplCanMsgReceived()</p>
<p> returns </p>
<p>kCanCopyData</p>
<p>, </p>
<p>the CAN Driver continues to work on the message received. </p>
<p>If the callback function returns </p>
<p>kCanNoCopyData</p>
<p>, the CAN finishes </p>
<p>working on the message received. </p>
<p>The callback function has to be defined by the application. </p>
<p>Active / Passive State </p>
<p>If this field is checked, the CAN Driver's transmit path can be switched to </p>
<p>the &quot;Passive&quot; state. In this state no CAN messages are sent to the CAN </p>
<p>bus. The transmit request always returns with ”OK”. </p>
<p>This ”passive” state functionality may be used to localize errors in a CAN </p>
<p>bus: If there are errors in a CAN bus, and the errors disappear when a </p>
<p>particular node is switched to passive state, the scapegoat is found. The </p>
<p>Application must be switched to the passive state and back to active </p>
<p>state by an external tester. </p>
<p>If active/passive state is enabled, the CAN Driver is in active state after </p>
<p>initialization. </p>
<p>If this field is not selected, the corresponding service functions are </p>
<p>available but without any effect on the CAN Driver status. </p>
<p>Extended Status </p>
<p>This is the global checkbox for using hardware status information in the </p>
<p>CAN Driver service </p>
<p>CanGetStatus()</p>
<p> or not. </p>
<p>Transmit Queue </p>
<p>If this field is checked the CAN Driver is configured to use a transmit </p>
<p>queue.  </p>
<p>If no transmit queue is used, the Application is responsible to restart a </p>
<p>transmit request if it wasn’t accepted by the CAN Driver. In the case of </p>
<p>using a transmit queue, a transmit request is almost accepted. But the </p>
<p>queue does only store the transmit request of a message. It doesn’t </p>
<p>store the data to be sent in any case. The CAN Driver inserts a transmit </p>
<p>request to the queue, if no hardware object is available when </p>
<p>CanTransmit()</p>
<p> is called. On a transmit interrupt, this means a former </p>
<p>requested message is transmitted, the CAN Driver checks whether </p>
<p>transmit requests are stored in the queue. If so, these requests are </p>
<p>removed from the queue and the transmit request is executed. The </p>
<p>search algorithm in the queue is priority based, there is no FIFO </p>
<p>strategy. This means the identifier with the lowest number is removed </p>
<p>first from the queue. </p>
<p>Tx observation </p>
<p>This is the global switch for using the Tx observe functionality of the </p>
<p>CAN Driver or not. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>131 / 149</p>
<p><b>Feature </b></p>
<p><b>Explanation </b></p>
<p>Message-Not-Matched </p>
<p>Function </p>
<p>This is the global switch for using the </p>
<p>MsgNotMatched</p>
<p> function of the </p>
<p>CAN Driver or not. </p>
<p>Overrun Notification </p>
<p>If this field is checked the CAN Driver is configured to notify the </p>
<p>Application in case of an overrun. </p>
<p>The Application has to provide an Overrun callback function: </p>
<p>void </p>
<p>ApplCanOverrun(void)</p>
<p>  /* Overrun in the CAN Controller */  </p>
<p>The overrun handling itself is done by the CAN Driver. </p>
<p>Hardware Loop Check </p>
<p>This is the global switch for using the hardware loop check of the CAN </p>
<p>Driver or not. </p>
<p>Partial Offline Mode </p>
<p>If the checkbox “Use PartOffline Functionality” is checked, the partial </p>
<p>offline mode is available.  </p>
<p>Generic Pre-copy  </p>
<p>This checkbox enables the use of the generic precopy function – </p>
<p>ApplCanGenericPrecopy()</p>
<p>. This precopy function is common to all </p>
<p>receive messages. it will be called as soon as the receive handle is </p>
<p>determined. </p>
<p>CAN Copy from &amp; to CAN </p>
<p>This checkbox enables the use of copy functions </p>
<p>CopyFromCan()</p>
<p> and </p>
<p>CopyToCan()</p>
<p>. </p>
<p>CAN cancel Notification </p>
<p>The application will be notified via </p>
<p>ApplCanCancelNotification()</p>
<p> if a </p>
<p>message is canceled and therefore confirmation will occur. This is valid </p>
<p>for messages which have been requested via </p>
<p>CanTransmit()</p>
<p>. </p>
<p>CAN Interrupt Control </p>
<p>Callbacks </p>
<p>There are two call back functions for the application. Within </p>
<p>CanCanInterruptDisable()</p>
<p> the function </p>
<p>ApplCanAddCanInterruptDisable()</p>
<p> is called and within </p>
<p>CanCanInterruptRestore()</p>
<p> the function </p>
<p>ApplCanAddCanInterruptRestore()</p>
<p> is called. </p>
<p>These two functions have to be used to handle the wake-up interrupt if </p>
<p>the hardware treats this interrupt separately or if the Driver runs in </p>
<p>Polling Mode the polling tasks have to be disabled. </p>
<p>Common Confirmation </p>
<p>Function </p>
<p>If this field is checked the common confirmation function of the CAN </p>
<p>Driver is enabled. </p>
<p>Offline Modes </p>
<p>Name of Mode X </p>
<p>with X = 0..7.  </p>
<p>If the partial Offline Mode is enabled the name of each send group can </p>
<p>be configured here. more... </p>
<p>Default Mapping </p>
<p>Message Class 0 </p>
<p>All messages with don’t belong to an other class are assigned to this </p>
<p>class. </p>
<p>OfflineModeX </p>
<p>with X = 0..7.  </p>
<p>The message class 0 can be assigned to certain Offline Modes (send </p>
<p>goups) by selecting the check box. </p>
<p>Message Class 1 (Appl) </p>
<p>All application messages are assigned to this message class. </p>
<p>OfflineModeX </p>
<p>with X = 0..7.  </p>
<p>The message class 1 can be assigned to certain Offline Modes (send </p>
<p>goups) by selecting the check box. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>132 / 149</p>
<p><b>Feature </b></p>
<p><b>Explanation </b></p>
<p>Message Class 2 (NM) </p>
<p>All network mangement messages are assigned to this message class. </p>
<p>OfflineModeX </p>
<p>with X = 0..7.  </p>
<p>The message class 2 can be assigned to certain Offline Modes (send </p>
<p>goups) by selecting the check box. </p>
<p>Message Class 3 (TP) </p>
<p>All transport layer messages are assigned to this message class. </p>
<p>OfflineModeX </p>
<p>with X = 0..7.  </p>
<p>The message class 3 can be assigned to certain Offline Modes (send </p>
<p>goups) by selecting the check box. </p>
<p>Message Class 4 (Diag) </p>
<p>All diagnostic messages are assigned to this message class. </p>
<p>OfflineModeX </p>
<p>with X = 0..7.  </p>
<p>The message class 4 can be assigned to certain Offline Modes (send </p>
<p>goups) by selecting the check box. </p>
<p>Message Class 5 (IL) </p>
<p>All interaction layer messages are assigned to this message class. </p>
<p>OfflineModeX </p>
<p>with X = 0..7.  </p>
<p>The message class 5 can be assigned to certain Offline Modes (send </p>
<p>goups) by selecting the check box. </p>
<p>OSEK OS </p>
<p>Use OsekOS Interrupt Cat </p>
<p>2 </p>
<p>In case of using OSEK-OS the interrupt category of the CAN Driver </p>
<p>interrupts have to be defined. Normally category 1 is used. Instead of </p>
<p>this category 2 can be selected. </p>
<p>OSEK OS </p>
<p>If this field is checked the CAN Driver is configured to support OSEK-</p>
<p>OS. The kind of OSEK-OS depends on the specific microprocessor. </p>
<p>Polling </p>
<p>Polling type </p>
<p>The polling type can be switched between “None”, “Type specific” and </p>
<p>“individual”. </p>
<p>Individual: </p>
<p> If enabled, each BasicCAN, Normal Tx, Low level Tx and </p>
<p>FullCAN can be selected to be polled individual </p>
<p>Rx Basic CAN Polling </p>
<p>Normally the CAN driver works interrupt driven. To use the reception via </p>
<p>Basic CAN objects in polling mode, check this field. This field is available </p>
<p>in “Type specific polling mode”. </p>
<p>Rx Full CAN Polling </p>
<p>Normally the CAN driver works interrupt driven. To use the reception via </p>
<p>Full CAN objects in polling mode, check this field. This field is available </p>
<p>in “Type specific polling mode”. </p>
<p>Tx Polling </p>
<p>Normally the CAN driver works interrupt driven. To use the transmission </p>
<p>in polling mode, check this field. This field is available in “Type specific </p>
<p>polling mode”. </p>
<p>Wakeup Polling </p>
<p>Normally the CAN driver works interrupt driven. To use the wake up </p>
<p>detection in polling mode, check this field.  </p>
<p>CAN Status Polling </p>
<p>Normally the CAN driver works interrupt driven. To use the Status and </p>
<p>Error detection in polling mode, check this field. </p>
<p>Low Level Transmission </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>133 / 149</p>
<p><b>Feature </b></p>
<p><b>Explanation </b></p>
<p>Cancel Notification </p>
<p>Function </p>
<p>The application will be notified if a message is canceled and therefore </p>
<p>confirmation will occur. This is valid if the transmission has been </p>
<p>requested via </p>
<p>CanMsgTransmit()</p>
<p>. </p>
<p>Enable Low Level </p>
<p>Transmission </p>
<p>If the checkbox “Use Low Level Message Transmit” is checked, the </p>
<p>function </p>
<p>CanMsgTransmit()</p>
<p> can be used. </p>
<p>Confirmation Function </p>
<p>This checkbox is only available, if “use Low Level Message Transmit” is </p>
<p>active. The confirmation and init callback functions of low level transmit </p>
<p>functionality can be activated by this checkbox. </p>
<p>API </p>
<p>Symbolic Names for </p>
<p>Signal Values </p>
<p>If the database allows the assignment of value tables to individual </p>
<p>signals, this feature is selectable. If this functionality is enabled, symbolic </p>
<p>names for values are generated for all signals that have an associated </p>
<p>value table </p>
<p>Indexed Component </p>
<p>This switch determines whether the component should configure the </p>
<p>indexed or non-indexed version of the driver component</p>
<p>.</p>
<p><b> </b></p>
<p>General Settings </p>
<p>Security level </p>
<p>This is the define value to configure the security level. Valid values are 0, </p>
<p>10, 20 or 30. more... </p>
<p>User Config File </p>
<p>The CAN Driver configuration file (can_cfg.h) is generated. If the user </p>
<p>wants to overwrite this automatically generated configuration file, the </p>
<p>user is able to define the name of a user defined configuration file which </p>
<p>is included at the end of the generated file can_cfg.h. This means entries </p>
<p>in the user defined configuration file overwrite the entries in can_cfg.h. </p>
<p>Debug Suport </p>
<p>Assertions </p>
<p>There are different groups of assertions supported by the CAN Driver. </p>
<p>They can be selected depending of the development phase: </p>
<p><b>None</b>: No debug functionality active.  </p>
<p><b>User</b>: User API is debugged. The CAN Driver service function </p>
<p>parameters are checked. </p>
<p> </p>
<p><b>Hardware</b>: The CAN Controller interface is checked. Depends on CAN </p>
<p>Controller. </p>
<p><b>Gen</b>: The configuration data are checked. </p>
<p><b>Internal</b>: CAN Driver internal checking. </p>
<p>Dynamic Tx Objects </p>
<p>ID </p>
<p>If the checkbox “ID” is checked, the IDs of the dynamic transmit objects </p>
<p>can be changed by the service function </p>
<p>CanDynTxObjSetId()</p>
<p> and/or by </p>
<p>the service function </p>
<p>CanDynTxObjSetExtId()</p>
<p>. The last mentioned </p>
<p>service function is only available if extended ID addressing is checked in </p>
<p>the Generation Tool. </p>
<p>DLC </p>
<p>If the checkbox “DLC” is checked, the DLC of the dynamic transmit </p>
<p>objects can be changed by the service function </p>
<p>CanDynTxObjSetDlc</p>
<p>. </p>
<p>Data Pointer </p>
<p>If the checkbox “Data Pointer” is checked, the data pointers of the </p>
<p>dynamic transmit objects can be changed by the service function </p>
<p>CanDynTxObjSetDataPtr()</p>
<p>. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>134 / 149</p>
<p><b>Feature </b></p>
<p><b>Explanation </b></p>
<p>Confirmation </p>
<p>If the checkbox “Confirmation” is checked, the confirmation function of </p>
<p>the dynamic transmit objects can be changed by the service function </p>
<p>CanDynTxObjSetConfirmationFct()</p>
<p>. The occurrence of this switch is </p>
<p>CAN Controller dependent. </p>
<p>Pre-transmit </p>
<p>If the checkbox “Pre-transmit” is checked, the pretransmit function of the </p>
<p>dynamic transmit objects can be changed by the service function </p>
<p>CanDynTxObjSetPreTransmitFct()</p>
<p>.The occurrence of this switch is </p>
<p>CAN Controller dependent. </p>
<p>ID Search Algorithm </p>
<p>Search Algorithm </p>
<p>For a Basic CAN Controller or the Basic CAN object of a Full CAN </p>
<p>Controller the hardware acceptance filtering provided by the CAN </p>
<p>Controller is not sufficient. Therefore a software acceptance filtering has </p>
<p>to be supported by comparing the incoming message identifier with the </p>
<p>complete list of all relevant message identifier. Here could the way how </p>
<p>to search in the table of the receive messages be defined. The optimum </p>
<p>algorithm depends on the number of the received messages to search in </p>
<p>and their identifier structure. The supported search algorithms are </p>
<p>dependent of the CAN Driver and the hardware. Refer to the CAN </p>
<p>controller specific documenation </p>
<p>TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_feature] for more </p>
<p>information. </p>
<p></p>
<p> </p>
<p>linear </p>
<p></p>
<p> </p>
<p>hash search </p>
<p></p>
<p> </p>
<p>index search </p>
<p></p>
<p> </p>
<p>table search  </p>
<p>Additional Memory [Byes] </p>
<p>This shows the byte consumption when <b>hash search </b>is selected. It is </p>
<p>just for information. </p>
<p>Maximum Search Steps </p>
<p>This is only activated when <b>hash search </b>is selected. Enter here the </p>
<p>amount of maximum search steps that are necessary to find the received </p>
<p>message ID in the list of to be received messages. The little this value </p>
<p>the greater the additional memory bytes and the faster the receive ISR.  </p>
<p>Rx Queue </p>
<p>Overrun Notification </p>
<p>The Application is informed, if the Rx Queue is full and a new message </p>
<p>should be copied into the Queue. The new message will be lost. </p>
<p>Enable Rx Queue </p>
<p>If the checkbox “Enable Rx Queue” is checked, the RX Queue is </p>
<p>enabled. Else the Rx Queue is disabled. </p>
<p>Pre Rx Queue Function </p>
<p>If the checkbox “Pre Rx Queue Function” is checked, a Callback function </p>
<p>is enabled where the application could decide what should happen with </p>
<p>the CAN Message which was received. The two possibilities are to store </p>
<p>the message in the queue, or to process the message in the interrupt. </p>
<p>Number of queued Rx </p>
<p>Messages </p>
<p>Specifies the depth of the queue (&quot;Number of queued Rx messages&quot;). </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>135 / 149</p>
<p> </p>
<p>Figure 10-2 Channel Specific Configuration for GENy </p>
<p> </p>
<p><b>Features </b></p>
<p><b>Explanation </b></p>
<p>Configuration Options </p>
<p>General Settings </p>
<p>Bus System Type </p>
<p>Each channel is configured for a specific type of bus </p>
<p>system. The bus system is always CAN for CAN Driver. </p>
<p>Manufacturer </p>
<p>Manufacturer with is specified in the database file for this </p>
<p>channel. </p>
<p>Common Driver Parameters </p>
<p>Multiple Basic CAN </p>
<p>Enable Multiple Basic </p>
<p>CAN </p>
<p>If checked, the number of Basic CAN objects can be </p>
<p>selected. The deselecting of this checkbox resets the </p>
<p>number of Basic CAN objects to the default. </p>
<p>Number Of BasicCAN </p>
<p>Objects </p>
<p>Enter number of needed Basic CAN objects. Each Basic </p>
<p>CAN object may consist of 2 hardware mailboxes. This </p>
<p>depends on the CAN controller. </p>
<p>Ranges / Range Precopy Functions </p>
<p>Range </p>
<p>Ranges are normally used for Network Management, </p>
<p>Transport Protocol and so on. There are in maximum 4 </p>
<p>ranges configurable. </p>
<p>Mask </p>
<p>Acceptance mask of this identifier range. </p>
<p>Code </p>
<p>Acceptance code of this identifier range. </p>
<p>Precopy function </p>
<p>Specific precopy function for this range. </p>
<p>Extended IDs </p>
<p>The range can be specified to receive extended IDs. If not </p>
<p>selected, this range will receive standard IDs. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>136 / 149</p>
<p>Use Own Filter </p>
<p>If there are enough Basic CAN filters available, one Basic </p>
<p>CAN filter can be used exclusive for this range. </p>
<p>Use Rx Queue </p>
<p>All messages which are received by this range can be </p>
<p>configured to be handled via the Rx Queue. This is only </p>
<p>possible, if the feature Rx Queue is activated. </p>
<p>Dynamic Tx objects </p>
<p>Number of dynamic Tx </p>
<p>objects </p>
<p>Maximum number of dynamic send objects which are </p>
<p>available at run time. </p>
<p> </p>
<p> </p>
<p> </p>
<p>Figure 10-3 Configuration of individual polling with GENy </p>
<p> </p>
<p><b>Features </b></p>
<p><b>Explanation </b></p>
<p>Configuration Options </p>
<p>Enable Polling </p>
<p>If checked, the associated mailbox will be handled in </p>
<p>polling mode. This is only selectable, if the polling mode is </p>
<p>configured to individual polling. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>137 / 149</p>
<p> </p>
<p>Figure 10-4 Configuration of a Tx message with GENy </p>
<p><b>Features </b></p>
<p><b>Explanation </b></p>
<p>Configuration Options </p>
<p>Message / Frame Properties </p>
<p>Generate </p>
<p>If unchecked, the generation of this message will be </p>
<p>suppressed. </p>
<p>Common Driver Parameters </p>
<p>Signal Access Macros </p>
<p>Signal access macros can be used by the application for </p>
<p>an easy access to signals specified within a message. </p>
<p>Offline Modes </p>
<p>&lt;Part offline group&gt;/&lt;Mode X name&gt; </p>
<p>Usage </p>
<p>Standard: configuration via default mapping </p>
<p>User Defined: the user can set or reset the “Real Value” </p>
<p>Real Value </p>
<p>It set, the message belongs to this group and the </p>
<p>transmission of this message will be disabled if this group </p>
<p>is switched offline. </p>
<p>Flags </p>
<p>Confirmation Flag </p>
<p>After successful transmission of a message the driver sets </p>
<p>the confirmation flag of the message. </p>
<p>Functions </p>
<p>Confirmation Function </p>
<p>After successful transmission of a message the driver call </p>
<p>the user defined confirmation function of the message. The </p>
<p>name of this function has to be specified in this field. </p>
<p>Pretransmit Function </p>
<p>The used defined pretransmit function can be called before </p>
<p>the transmission of a message is started. The name of this </p>
<p>function has to be specified in this field. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>138 / 149</p>
<p>Full CAN Tx </p>
<p>Tx FullCAN </p>
<p>A Tx message can be assigned to a Full CAN objects. </p>
<p> </p>
<p> </p>
<p>Figure 10-5 Configuration of an Rx message with GENy </p>
<p><b>Features </b></p>
<p><b>Explanation </b></p>
<p>Configuration Options </p>
<p>Message / Frame Properties </p>
<p>Generate </p>
<p>If unchecked, the generation of this message will be </p>
<p>suppressed. </p>
<p>Common Driver Parameters </p>
<p>Minimum Data Length </p>
<p> </p>
<p>Signal Access Macros </p>
<p>Signal access macros can be used by the application for </p>
<p>an easy access to signals specified within a message. </p>
<p>Flags </p>
<p>Indication Flag </p>
<p>After successful reception of a message the driver sets the </p>
<p>indication flag of the message </p>
<p>Functions </p>
<p>Indication Function </p>
<p>The name of the used defined indication function can be </p>
<p>specified in this field. </p>
<p>Precopy Function </p>
<p>The name of the used defined precopy function can be </p>
<p>specified in this field. </p>
<p>Full CAN </p>
<p>Full CAN </p>
<p>An Rx message can be assigned to a Full CAN objects. </p>
<p>Lock Full CAN </p>
<p>If set, the assignment of a Rx message to a Full CAN </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>139 / 149</p>
<p>object cannot be changes by the filter optimization. </p>
<p>Hardware Channel </p>
<p>In case a receive message is configured to be ‘FullCAN’ </p>
<p>and Common CAN is activated then the user can configure </p>
<p>this message to be received on the first (Channel A) or the </p>
<p>second (Channel B) CAN controller on this channel. </p>
<p> </p>
<p> </p>
<p><b>10.3  Automatic Configuration by CANgen </b></p>
<p>Using  the  Generation  Tool  CANgen  the  configuration  can  be  done  by  the  tool.  The </p>
<p>configuration options common to all CAN Drivers is described here. The CAN Controller </p>
<p>dependent options are described in the CAN Controller specific user manual. The following </p>
<p>dialog describes the CAN Driver common options. The configuration data is stored by the </p>
<p>tool in the file can_cfg.h for CANgen.  </p>
<p> </p>
<p> </p>
<p>Figure 10-6 CAN Driver configuration tab </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>140 / 149</p>
<p><b>Feature </b></p>
<p><b>Explanation </b></p>
<p> </p>
<p>Path of the CAN config file </p>
<p>The CAN Driver configuration file (can_cfg.h) is generated. If the user </p>
<p>wants to overwrite this automatically generated configuration file, the </p>
<p>user is able to define the name of a user defined configuration file which </p>
<p>is included at the end of the generated file can_cfg.h. This means entries </p>
<p>in the user defined configuration file overwrite the entries in can_cfg.h. </p>
<p>Use Receive Function </p>
<p>(</p>
<p>ApplCanMsgReceived</p>
<p>) </p>
<p>The receive function </p>
<p>ApplCanMsgReceived()</p>
<p> is called by the CAN </p>
<p>Driver on every reception of a CAN message after the hardware </p>
<p>acceptance filter is passed. Within this callback function the Application </p>
<p>may preprocess the received message in any way (ECU specific </p>
<p>dynamic filtering mechanisms, preprocessing of the messages, gateway </p>
<p>functionality...).  </p>
<p>If the callback function </p>
<p>ApplCanMsgReceived()</p>
<p> returns </p>
<p>kCanCopyData</p>
<p>, </p>
<p>the CAN Driver continues to work on the message received. </p>
<p>If the callback function returns </p>
<p>kCanNoCopyData</p>
<p>, the CAN finishes </p>
<p>working on the message received. </p>
<p>Support Active/Passive </p>
<p>State </p>
<p>If this field is checked, the CAN Driver's transmit path can be switched to </p>
<p>the &quot;Passive&quot; state. In this state no CAN messages are sent to the CAN </p>
<p>bus. The transmit request always returns with ”OK”. </p>
<p>This ”passive” state functionality may be used to localize errors in a CAN </p>
<p>bus: If there are errors in a CAN bus, and the errors disappear when a </p>
<p>particular node is switched to passive state, the scapegoat is found. The </p>
<p>Application must be switched to the passive state and back to active </p>
<p>state by an external tester. </p>
<p>If active/passive state is enabled, the CAN Driver is in active state after </p>
<p>initialization. </p>
<p>Use Transmit Queue </p>
<p>If this field is checked the CAN Driver is configured to use a transmit </p>
<p>queue.  </p>
<p>If no transmit queue is used, the Application is responsible to restart a </p>
<p>transmit request if it wasn’t accepted by the CAN Driver. In the case of </p>
<p>using a transmit queue, a transmit request is almost accepted. But the </p>
<p>queue does only store the transmit request of a message. It doesn’t </p>
<p>store the data to be sent in any case. The CAN Driver inserts a transmit </p>
<p>request to the queue, if no hardware object is available when </p>
<p>CanTransmit()</p>
<p> is called. On a transmit interrupt, this means a former </p>
<p>requested message is transmitted, the CAN Driver checks whether </p>
<p>transmit requests are stored in the queue. If so, these requests are </p>
<p>removed from the queue and the transmit request is executed. The </p>
<p>search algorithm in the queue is priority based, there is no FIFO </p>
<p>strategy. This means the identifier with the lowest number is removed </p>
<p>first from the queue. </p>
<p>Support for OSEK OS </p>
<p>If this field is checked the CAN Driver is configured to support OSEK-</p>
<p>OS. The kind of OSEK-OS depends on the specific microprocessor. </p>
<p>Use OsekOS Interrupt Cat </p>
<p>2 </p>
<p>In case of using OSEK-OS the interrupt category of the CAN Driver </p>
<p>interrupts have to be defined. Normally category 1 is used. Instead of </p>
<p>this category 2 can be selected. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>141 / 149</p>
<p><b>Feature </b></p>
<p><b>Explanation </b></p>
<p>Support Overrun </p>
<p>Notification </p>
<p>If this field is checked the CAN Driver is configured to notify the </p>
<p>Application in case of an overrun. </p>
<p>The Application has to provide an Overrun callback function: </p>
<p>void </p>
<p>ApplCanOverrun(void)</p>
<p>  /* Overrun in the CAN Controller */  </p>
<p>The overrun handling itself is done by the CAN Driver: </p>
<p>Security Level </p>
<p>This is the define value to configure the security level. Valid values are </p>
<p>0,10, 20 or 30. </p>
<p>Extended Status </p>
<p>This is the global checkbox for using hardware status information in the </p>
<p>CAN Driver service </p>
<p>CanGetStatus()</p>
<p> or not. </p>
<p>Debug level </p>
<p>There are different Debug Levels supported by the CAN Driver: </p>
<p>None: No debug functionality active.  </p>
<p>User: User API is debugged. The CAN Driver service function </p>
<p>parameters are checked. </p>
<p> </p>
<p>Hardware: The CAN Controller interface is checked. Depends on CAN </p>
<p>Controller. </p>
<p>Gen: The configuration data are checked. </p>
<p>Internal: CAN Driver internal checking (consistency of transmit queue). </p>
<p>Extended IDs </p>
<p>This checkbox is available only if extended CAN identifiers are selected </p>
<p>in the channel configuration dialog. It has to be enabled if extended CAN </p>
<p>identifiers have to be received by the range specific acceptance filtering </p>
<p>and the appropriate precopy function has to be called. In such case no </p>
<p>standard identifiers can be received by any acceptance range. </p>
<p>Use Range X </p>
<p>This is the global switch to select identifier range specific precopy </p>
<p>functions. These ranges are normally used for Network Management, </p>
<p>Transport Protocol and so on. There are in maximum 4 ranges </p>
<p>configurable, where ‘X’ is the number of the specified range. If a range is </p>
<p>enabled, the following additional settings has to be done: </p>
<p>Range X mask </p>
<p>Acceptance code of the identifier range X. </p>
<p>Range X ID </p>
<p>Acceptance mask of the identifier range X. </p>
<p>Range X precopy function </p>
<p>Specific precopy function for range X. </p>
<p>Tx observe </p>
<p>This is the global switch for using the tx observe functionality of the CAN </p>
<p>Driver or not. </p>
<p>Use MsgNotMatched </p>
<p>function </p>
<p>This is the global switch for using the </p>
<p>MsgNotMatched</p>
<p> function of the </p>
<p>CAN Driver or not. </p>
<p>Hardware Loop Check </p>
<p>This is the global switch for using the hardware loop check of the CAN </p>
<p>Driver or not. </p>
<p>Number of dynamic tx </p>
<p>objects  </p>
<p>Maximum number of dynamic send objects which are available at run </p>
<p>time. </p>
<p>Dynamic TxId </p>
<p>If the checkbox “DynamicTxId” is checked, the IDs of the dynamic </p>
<p>transmit objects can be changed by the service function </p>
<p>CanDynTxObjSetId()</p>
<p> and/or by the service function </p>
<p>CanDynTxObjSetExtId()</p>
<p>. The last mentioned service function is only </p>
<p>available if extended ID addressing is checked in the Generation Tool. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>142 / 149</p>
<p><b>Feature </b></p>
<p><b>Explanation </b></p>
<p>Dynamic TxDLC </p>
<p>If the checkbox “DynamicTxDLC” is checked, the DLCs of the dynamic </p>
<p>transmit objects can be changed by the service function </p>
<p>CanDynTxObjSetDlc()</p>
<p>. </p>
<p>Dynamic TxDataPtr </p>
<p>If the checkbox “DynamicTxDataPtr” is checked, the data pointers of the </p>
<p>dynamic transmit objects can be changed by the service function </p>
<p>CanDynTxObjSetDataPtr()</p>
<p>. The occurrence of this switch is CAN </p>
<p>Controller dependent. </p>
<p>Dynamic TxConfirmation </p>
<p>If the checkbox “DynamicTxConfirmation” is checked, the confirmation </p>
<p>function of the dynamic transmit objects can be changed by the service </p>
<p>function </p>
<p>CanDynTxObjSetConfirmationFct()</p>
<p>. The occurrence of this </p>
<p>switch is CAN Controller dependent. </p>
<p>Dynamic TxPreTransmit </p>
<p>If the checkbox “DynamicTxPretransmit” is checked, the pretransmit </p>
<p>function of the dynamic transmit objects can be changed by the service </p>
<p>function </p>
<p>CanDynTxObjSetPreTransmitFct()</p>
<p>.The occurrence of this </p>
<p>switch is CAN Controller dependent. </p>
<p>Use Low Level Message </p>
<p>Transmit </p>
<p>If the checkbox “Use Low Level Message Transmit” is checked, the </p>
<p>function </p>
<p>CanMsgTransmit()</p>
<p> can be used. </p>
<p>Use Low Level Message </p>
<p>Transmit Confirmation </p>
<p>This checkbox is only available, if “use Low Level Message Transmit” is </p>
<p>active. The confirmation and init callback functions of low level transmit </p>
<p>functionality can be activated by this checkbox. </p>
<p>Use PartOffline </p>
<p>Functionality </p>
<p>If the checkbox “Use PartOffline Functionality” is checked, the partial </p>
<p>offline mode is available.  </p>
<p>Use Generic Precopy </p>
<p>This checkbox enables the use of the generic precopy function – </p>
<p>ApplCanGenericPrecopy()</p>
<p>. This precopy function is common to all </p>
<p>receive messages. It will be called as soon as the receive handle is </p>
<p>determined. </p>
<p> </p>
<p>The  next  figure  shows  the  Configuration  of  the  partial  offline  mode.  Every  transmit </p>
<p>message can be assigned to up to eight partial offline groups. </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>143 / 149</p>
<p> </p>
<p> Figure 10-7 Configuration of Partial Offline Mode </p>
<p> </p>
<p><b>Feature </b></p>
<p><b>Explanation </b></p>
<p>Edit part offline mode </p>
<p>names </p>
<p>this button can be used to change the names of the eight partial offline </p>
<p>groups </p>
<p> </p>
<p>The following features cannot be configured by the Application. They are set automatically </p>
<p>depending on the used OEM: </p>
<p></p>
<p> </p>
<p>DLC check </p>
<p></p>
<p> </p>
<p>Data Copy Mechanism </p>
<p></p>
<p> </p>
<p>Cancel in Hardware </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>144 / 149</p>
<p> </p>
<p><b>10.4  Manual configuration via user configuration file </b></p>
<p>This chapter describes additional configuration options for special features which can only </p>
<p>be configured via user configuration file. </p>
<p>In  the  following  table  you  will  find  a  list  of  configuration  switches,  used  to  control  the </p>
<p>functional units of the CAN Driver: </p>
<p> </p>
<p><b>Switch </b></p>
<p><b>Value / Range </b></p>
<p><b>Use of ... </b></p>
<p>C_xxx_APPLCANPREWAKEUP_FCT</p>
<p> </p>
<p>ENABLE, DISABLE </p>
<p>Activate call of ApplCanPreWakeUp() if </p>
<p>an WakeUp Interrupt occurs. </p>
<p>C_xxx_NOTIFY_CORRUPT_MAILBOX </p>
<p>ENABLE, DISABLE </p>
<p>Activate call of  ApplCanCorruptMailbox() </p>
<p>in case the CAN RAM Check fails for a </p>
<p>certain mailbox. </p>
<p> </p>
<p>If the Generation Tool CANgen is used, some additional configurations can only be due via </p>
<p>user configuration file: </p>
<p> </p>
<p><b>Switch </b></p>
<p><b>Value / Range </b></p>
<p><b>Use of ... </b></p>
<p>C_xxx_ONLINE_OFFLINE_CALLBACK</p>
<p>_FCT</p>
<p> </p>
<p>ENABLE, DISABLE </p>
<p>Activate call of ApplCanOnline() and </p>
<p>ApplCanOffline() if the associated CAN </p>
<p>driver state was entered. </p>
<p>C_xxx_INTCTRL_ADD_CAN_FCT </p>
<p>ENABLE, DISABLE </p>
<p>Activate call of</p>
<p> </p>
<p>ApplCanAddCanInterruptDisable()</p>
<p> </p>
<p>and</p>
<p> </p>
<p>ApplCanAddCanInterruptRestore()</p>
<p>.</p>
<p> </p>
<p>These two functions have to be used to </p>
<p>handle the wake-up interrupt if the </p>
<p>hardware treats this interrupt separately </p>
<p>or if the Driver runs in Polling Mode the </p>
<p>polling tasks have to be disabled. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>145 / 149</p>
<p><b>11 Glossary </b></p>
<p><b>Abbreviations and </b></p>
<p><b>Expressions </b></p>
<p><b>Explanation </b></p>
<p>Acceptance filtering </p>
<p>Mechanism which decides whether each received protocol frame is </p>
<p>to be taken into account by the local Node or ignored. </p>
<p>API </p>
<p>Application Program Interface. </p>
<p>Application Interface </p>
<p>An application interface is the prescribed method of a SW </p>
<p>component for using the available functionality. </p>
<p>Arbitration </p>
<p>Mechanism which guarantees that a simultaneous access made by </p>
<p>multiple stations results in a contention where one frame will </p>
<p>survive uncorrupted. </p>
<p>ASAP </p>
<p>Arbeitskreis zur Standardisierung von Applikationssystemen. </p>
<p>Standardization of Application and Calibration system task force </p>
<p>BCD </p>
<p>Binary Coded Decimal </p>
<p>Buffer </p>
<p>A buffer in a memory area normally in the RAM. It is an area, the </p>
<p>application reserved for data storage </p>
<p>Bus </p>
<p>Defines what we call internal as channel or connection. </p>
<p>BusOff </p>
<p>A node is in the state bus off when it is switched off from the bus </p>
<p>due to a request of fault confinement entity. In the bus off state, a </p>
<p>node can neither send nor receive any frames. A node can start the </p>
<p>recovery from bus off state only upon a user request.A node is in </p>
<p>the state BusOff when it is switched off from the bus. In the state </p>
<p>BusOff a node can neither send nor receive any protocol frames. </p>
<p>Callback function </p>
<p>This is a function provided by an application. E.g. the CAN Driver </p>
<p>calls a callback function to allow the application to control some </p>
<p>action, to make decisions at runtime and to influence the work of </p>
<p>the Driver. </p>
<p>CAN </p>
<p>Controller Area Network protocol originally defined for use as a </p>
<p>communication network for control applications in vehicles. </p>
<p>CAN Controller </p>
<p>A hardware unit integrated into a micro controller (or as a separate </p>
<p>unit) handling the CAN protocol. </p>
<p>CAN Driver </p>
<p>The CAN driver encapsulates a specific CAN controller handling. It </p>
<p>consists of algorithms for HW initialization, CAN message </p>
<p>transmission and reception. The application interface supports both </p>
<p>event and polling notification and WR/RD access to the message </p>
<p>buffers. </p>
<p>Channel </p>
<p>A channel defines the assignment (1:1) between a physical </p>
<p>communication interface and a physical layer on which different </p>
<p>modules are connected to (either CAN or LIN). 1 channel consists </p>
<p>of 1..X network(s). </p>
<p>Configuration </p>
<p>The communication configuration adapts the communication stack </p>
<p>to the specific component requirements by means of the </p>
<p>Generation Tool. </p>
<p>Confirmation </p>
<p>A service primitive defined in the ISO/OSI Reference model (ISO </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>146 / 149</p>
<p>7498). With the service primitive 'confirmation' a service provider </p>
<p>informs a service user about the result of a preceding service </p>
<p>request of the service user. Notification by the CAN Driver on </p>
<p>asynchronous successful transmission of a CAN message. </p>
<p>Data consistency </p>
<p>Data consistency means that the content of a given application </p>
<p>message correlates unambiguously to the operation performed </p>
<p>onto the message by the application. This means that no </p>
<p>unforeseen sequence of operations may alter the content of a </p>
<p>message hence rendering a message inconsistent with respect to </p>
<p>its allowed and expected value. </p>
<p>DBC </p>
<p>CAN database format of the Vector company which is used by </p>
<p>Vector tools </p>
<p>DLC </p>
<p>Data Length CodeNumber of data bytes of a CAN message </p>
<p>ECU </p>
<p>Electronic Control Unit </p>
<p>Error </p>
<p>Error is a local problem which could be solved locally. If not, the </p>
<p>error will be given as an exception to the application. An error is not </p>
<p>the specification conform misbehavior of a system (e.g. a not </p>
<p>responded diagnostic request after three requests without </p>
<p>response is no error). Discrepancy between a computed, observed </p>
<p>or measured value or condition and the true, specified or </p>
<p>theoretically correct value or condition (IEC 61508-4). </p>
<p>FIFO </p>
<p>First In First Out </p>
<p>FILO </p>
<p>First In Last Out </p>
<p>Gateway </p>
<p>A gateway is designed to enable communication between different </p>
<p>bus systems, e.g. from CAN to LIN. </p>
<p>Generation Tool </p>
<p>See CANgen, DBKOMGen and GENy. The generation tool </p>
<p>configures the communication stack based on database attributes </p>
<p>(vehicle manufacturer), project settings (module supplier) and </p>
<p>license information (Vector). </p>
<p>HIS </p>
<p>Hersteller-Initiative Software </p>
<p>HW </p>
<p>Hardware </p>
<p>ID </p>
<p>Identifier (e.g. Identifier of a CAN message) </p>
<p>Indication </p>
<p>A service primitive defined in the ISO/OSI Reference Model (ISO </p>
<p>7498). With the service primitive 'indication' a service provider </p>
<p>informs a service user about the occurrence of either an internal </p>
<p>event or a service request issued by another service user. </p>
<p>Notification of application in case of events in the Vector software </p>
<p>components, e.g. an asynchronous reception of a CAN message. </p>
<p>Interrupt </p>
<p>Processor-specific event which can interrupt the execution of a </p>
<p>current program section. </p>
<p>Interrupt level </p>
<p>Processing level provided for time-critical activities. To keep the </p>
<p>interrupt latency brief, only absolutely indispensable actions should </p>
<p>be effected in the Interrupt Service Routine, which ensures </p>
<p>reception of the interrupt and trigger its (post) processing within a </p>
<p>task. Other processing levels are: Operating System Level and </p>
<p>Task Level. </p>
<p>ISO </p>
<p>International Standardization Organization </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>147 / 149</p>
<p>ISR </p>
<p>Interrupt Service Routine </p>
<p>LIN </p>
<p>Local Interconnect Network </p>
<p>Manufacturer </p>
<p>Vehicle manufacturer </p>
<p>Message </p>
<p>A message is responsible for the logical transmission and reception </p>
<p>of information depending on the restrictions of the physical layer. </p>
<p>The definition of the message contents is part of the database </p>
<p>given by the vehicle manufacturer. </p>
<p>MISRA </p>
<p>Motor Industry Software Reliability Association </p>
<p>MRC </p>
<p>Multiple Receive Channel </p>
<p>Network </p>
<p>A network defines the assignment (1:N) between a logical </p>
<p>communication grouping and a physical layer on which different </p>
<p>modules are connected to (either CAN or LIN). 1 network consists </p>
<p>of 1 channel, Y networks consists of 1..Z channel(s). We say </p>
<p>network if we talk about more than 1 bus. </p>
<p>NM </p>
<p>Network Management </p>
<p>Node </p>
<p>A network topological entity. Nodes are connected by data links </p>
<p>forming the network. Each node is separately addressable on the </p>
<p>network. </p>
<p>OEM </p>
<p>Original Equipment Manufacturer </p>
<p>Offline </p>
<p>State of the data link layer. In the Offline state, no application </p>
<p>communication is possible. Only the network management is </p>
<p>allowed to communicate. </p>
<p>Online </p>
<p>(Normal) state of the data link layer. Application and Network </p>
<p>Management communication are possible. </p>
<p>OS </p>
<p>Operating System </p>
<p>OSEK </p>
<p>Name of the overall project: Abbreviation of the German term </p>
<p>&quot;Offene Systeme und deren Schnittstellen fÃ¼r die Elektronik im </p>
<p>Kraftfahrzeug&quot; - Open Systems and the Corresponding Interfaces </p>
<p>for Automotive Electronics. </p>
<p>Overrun </p>
<p>Overwriting data in a memory with limited capacity, e.g. Queued </p>
<p>message object </p>
<p>Platform </p>
<p>The sum of micro controller derivative, communication controller </p>
<p>implementation and compiler is called platform. </p>
<p>RAM </p>
<p>Random Access Memory </p>
<p>Register </p>
<p>A register is a memory area in the controller, e.g. in the CAN </p>
<p>Controller. Distinguish Register from Buffer </p>
<p>RI </p>
<p>Reference Implementation </p>
<p>ROM </p>
<p>Read-Only Memory </p>
<p>Signal </p>
<p>A signal is responsible for the logical transmission and reception of </p>
<p>information depending on the restrictions of the physical layer. The </p>
<p>definition of the signal contents is part of the database given by the </p>
<p>vehicle manufacturer. Signals describe the significance of the </p>
<p>individual data segments within a message.  Typically bits, bytes or </p>
<p>words are used for data segments but individual bit combinations </p>
<p>are also possible. In the CAN data base, each data segment is </p>
<p>assigned a symbolic name, a value range, a conversion formula </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>148 / 149</p>
<p>and a physical unit, as well as a list of receiving nodes. </p>
<p>SRC </p>
<p>Single Receive Channel </p>
<p>Status </p>
<p>A status describes the properties (parameters) of an entity. A state </p>
<p>is interpreted as an information, e.g. an error, by the entity which </p>
<p>uses a status, and is frequently determined by the history. </p>
<p>Task Level </p>
<p>Processing level where the actual application software, is </p>
<p>executed. Tasks are executed according to the priority assigned to </p>
<p>them, and to the selected scheduling policy. Other processing </p>
<p>levels are: Interrupt level and Operating System Level. </p>
<p>Transceiver </p>
<p>A transceiver adapts the physical layer to the communication </p>
<p>interface. </p>
<p>Vehicle Manufacturer </p>
<p>We use this instead of OEM </p>
<p>Watchdog </p>
<p>A monitoring entity. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>TechnicalReference Vector CAN Driver </p>
<p> </p>
<p>©</p>
<p>2010, Vector Informatik GmbH </p>
<p>Version: 3.01.01 </p>
<p>based on template version 2.1 </p>
<p>149 / 149</p>
<p><b>12 Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p>&gt;   News </p>
<p>&gt;   Products </p>
<p>&gt;   Demo software </p>
<p>&gt;   Support </p>
<p>&gt;   Training data </p>
<p>&gt;   Addresses </p>
<p> </p>
<p><b>www.vector-informatik.com </b></p>
</body>
</html>
{% endraw %}