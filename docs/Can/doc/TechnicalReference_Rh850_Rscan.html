---
layout: default
title: TechnicalReference_Rh850_Rscan
nav_order: 2
parent: CAN Driver
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Vector CAN Driver </b></p>
<p>Technical Reference </p>
<p> </p>
<p>Renesas </p>
<p>RH850 </p>
<p>RSCAN </p>
<p> </p>
<p>Version 1.05.00 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Authors </p>
<p>Torsten Kercher </p>
<p>Status </p>
<p>Released </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>2 /46 </p>
<p> </p>
<p><b>Document Information </b></p>
<p><b>History </b></p>
<p> </p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>Torsten Kercher </p>
<p>2013-05-27 </p>
<p>1.00.00 </p>
<p>Initial release (support F1L with Green Hills compiler) </p>
<p>Torsten Kercher </p>
<p>2013-07-18 </p>
<p>1.01.00 </p>
<p>Support R1L </p>
<p>Correct description of nested interrupt behavior </p>
<p>Torsten Kercher </p>
<p>2013-08-26 </p>
<p>1.02.00 </p>
<p>Support HighEnd features </p>
<p>Support Diab compiler </p>
<p>Torsten Kercher </p>
<p>2013-10-16 </p>
<p>1.03.00 </p>
<p>Support R1M </p>
<p>Update referenced version of the R1x hardware manual </p>
<p>Support external wakeup functionality </p>
<p>Update chapters 5, 6, 7.2.2 </p>
<p>Torsten Kercher </p>
<p>2014-04-04 </p>
<p>1.04.00 </p>
<p>Support extended CAN RAM check </p>
<p>Support RSCAN RAM test </p>
<p>Support D1L, D1M, P1M </p>
<p>Update referenced version of the F1L hardware manual </p>
<p>Torsten Kercher </p>
<p>2014-04-29 </p>
<p>1.04.01 </p>
<p>Update description of nested interrupt behavior </p>
<p>Torsten Kercher </p>
<p>2014-05-15 </p>
<p>1.05.00 </p>
<p>Support IAR compiler </p>
<p>Support F1H </p>
<p>Update expected loop durations in chapter 5 </p>
<p>Table 1-1  </p>
<p>History of the document </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Please note </b></p>
<p>We have configured the programs in accordance with your specifications in the </p>
<p>questionnaire. Whereas the programs do support other configurations than the one </p>
<p>specified in your questionnaire, Vector´s release of the programs delivered to your </p>
<p>company is expressly restricted to the configuration you have specified in the </p>
<p>questionnaire. </p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>3 /46 </p>
<p> </p>
<p><b>Contents </b></p>
<p><b> </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>Introduction .................................................................................................................... 5</b></p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>Important References .................................................................................................... 6</b></p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Usage of Controller Features ........................................................................................ 7</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>[#hw_comObj] - Communication Objects ......................................................... 7</p>
<p> </p>
<p>3.2</p>
<p> </p>
<p>Acceptance Filters ......................................................................................... 10</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>[#hw_sleep] - SleepMode and WakeUp ....................................................................... 11</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Sleep ............................................................................................................. 11</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Internal Wakeup ............................................................................................ 11</p>
<p> </p>
<p>4.3</p>
<p> </p>
<p>External Wakeup ........................................................................................... 11</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>[#hw_loop] - Hardware Loop Check ............................................................................ 13</b></p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b>[#hw_busoff] - Bus off ................................................................................................. 15</b></p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>CAN Driver Features .................................................................................................... 16</b></p>
<p> </p>
<p>7.1</p>
<p> </p>
<p>[#hw_feature] - Feature List ........................................................................... 16</p>
<p> </p>
<p>7.2</p>
<p> </p>
<p>Description of Hardware-related Features ..................................................... 18</p>
<p> </p>
<p>7.2.1</p>
<p> </p>
<p>[#hw_status] - Status ..................................................................................... 18</p>
<p> </p>
<p>7.2.2</p>
<p> </p>
<p>[#hw_stop] - Stop Mode ................................................................................ 18</p>
<p> </p>
<p>7.2.3</p>
<p> </p>
<p>[#hw_int] - Control of CAN Interrupts ............................................................. 18</p>
<p> </p>
<p>7.2.4</p>
<p> </p>
<p>[#hw_cancel] - Cancel in Hardware ............................................................... 19</p>
<p> </p>
<p>7.2.5</p>
<p> </p>
<p>Remote Frames ............................................................................................ 19</p>
<p> </p>
<p>7.2.6</p>
<p> </p>
<p>CAN RAM Check .......................................................................................... 19</p>
<p> </p>
<p>7.2.7</p>
<p> </p>
<p>Extended CAN RAM Check ........................................................................... 20</p>
<p> </p>
<p>7.2.8</p>
<p> </p>
<p>RSCAN ECC Configuration ........................................................................... 21</p>
<p> </p>
<p>7.2.9</p>
<p> </p>
<p>RSCAN RAM Test ......................................................................................... 22</p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>[#hw_assert] – Assertions ........................................................................................... 23</b></p>
<p> </p>
<p><b>9</b></p>
<p> </p>
<p><b>API ................................................................................................................................. 24</b></p>
<p> </p>
<p>9.1</p>
<p> </p>
<p>Category ....................................................................................................... 24</p>
<p> </p>
<p>9.2</p>
<p> </p>
<p>RSCAN ECC Configuration ........................................................................... 24</p>
<p> </p>
<p>9.3</p>
<p> </p>
<p>(Extended) CAN RAM Check ........................................................................ 25</p>
<p> </p>
<p>9.4</p>
<p> </p>
<p>CAN Interrupt Handling by Application .......................................................... 30</p>
<p> </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>4 /46 </p>
<p> </p>
<p><b>10</b></p>
<p> </p>
<p><b>Implementations Hints ................................................................................................. 32</b></p>
<p> </p>
<p>10.1</p>
<p> </p>
<p>Important Notes ............................................................................................. 32</p>
<p> </p>
<p>10.2</p>
<p> </p>
<p>Interrupt Configuration ................................................................................... 33</p>
<p> </p>
<p>10.2.1</p>
<p> </p>
<p>Configuration of Interrupt Vectors with IAR compiler...................................... 34</p>
<p> </p>
<p>10.3</p>
<p> </p>
<p>CAN Interrupt Handling by Application .......................................................... 35</p>
<p> </p>
<p><b>11</b></p>
<p> </p>
<p><b>Configuration................................................................................................................ 37</b></p>
<p> </p>
<p>11.1</p>
<p> </p>
<p>Configuration by GENy .................................................................................. 37</p>
<p> </p>
<p>11.1.1</p>
<p> </p>
<p>Platform Settings ........................................................................................... 37</p>
<p> </p>
<p>11.1.2</p>
<p> </p>
<p>Component Settings ...................................................................................... 38</p>
<p> </p>
<p>11.1.3</p>
<p> </p>
<p>Channel-specific Settings .............................................................................. 39</p>
<p> </p>
<p>11.2</p>
<p> </p>
<p>Manual Configuration .................................................................................... 44</p>
<p> </p>
<p><b>12</b></p>
<p> </p>
<p><b>Known Issues / Limitations ......................................................................................... 45</b></p>
<p> </p>
<p><b>13</b></p>
<p> </p>
<p><b>Contact.......................................................................................................................... 46</b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Illustrations </b></p>
<p> </p>
<p> </p>
<p>Figure 3-1</p>
<p> </p>
<p>Hardware Object Layout ............................................................................. 7</p>
<p> </p>
<p>Figure 11-1</p>
<p> </p>
<p>GENy Platform Settings ............................................................................ 37</p>
<p> </p>
<p>Figure 11-2</p>
<p> </p>
<p>GENy Component Settings ....................................................................... 38</p>
<p> </p>
<p>Figure 11-3</p>
<p> </p>
<p>GENy Channel Specific Settings ............................................................... 39</p>
<p> </p>
<p>Figure 11-4</p>
<p> </p>
<p>GENy Acceptance Filter Configuration ...................................................... 41</p>
<p> </p>
<p>Figure 11-5</p>
<p> </p>
<p>GENy Acceptance Filter Assignment ........................................................ 42</p>
<p> </p>
<p>Figure 11-6</p>
<p> </p>
<p>GENy Bustiming Configuration ................................................................. 43</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Tables </b></p>
<p> </p>
<p>Table 1-1 </p>
<p> </p>
<p>History of the document .............................................................................. 2</p>
<p> </p>
<p>Table 2-1 </p>
<p> </p>
<p>Supported Hardware Overview ................................................................... 6</p>
<p> </p>
<p>Table 3-1 </p>
<p> </p>
<p>Hardware Object Layout ............................................................................. 9</p>
<p> </p>
<p>Table 7-1 </p>
<p> </p>
<p>CAN Driver Functionality .......................................................................... 17</p>
<p> </p>
<p>Table 7-2 </p>
<p> </p>
<p>CAN Status ............................................................................................... 18</p>
<p> </p>
<p>Table 9-1 </p>
<p> </p>
<p>API Category ............................................................................................ 24</p>
<p> </p>
<p>Table 10-1 </p>
<p> </p>
<p>Interrupt Service Routines ........................................................................ 33</p>
<p> </p>
<p>Table 11-1 </p>
<p> </p>
<p>GENy Platform Settings ............................................................................ 37</p>
<p> </p>
<p>Table 11-2 </p>
<p> </p>
<p>GENy Component Settings ....................................................................... 38</p>
<p> </p>
<p>Table 11-3 </p>
<p> </p>
<p>GENy Channel Specific Settings ............................................................... 40</p>
<p> </p>
<p>Table 11-4 </p>
<p> </p>
<p>GENy Acceptance Filter Configuration ...................................................... 41</p>
<p> </p>
<p>Table 11-5 </p>
<p> </p>
<p>GENy Bustiming Configuration ................................................................. 43</p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>5 /46 </p>
<p> </p>
<p><b>1 </b></p>
<p><b>Introduction </b></p>
<p>The concept of the CAN driver and the standardized interface between the CAN driver and </p>
<p>the  application  is  described  in  the  document <b> TechnicalReference_CANDriver.pdf</b>.  The </p>
<p>CAN driver interface to the hardware is designed in a way that capabilities of the special </p>
<p>CAN chips can be utilized optimally. The interface to the application was made identical for </p>
<p>the  different  CAN  chips,  so  that  the  &quot;higher&quot;  layers  such </p>
<p>as  network  management, </p>
<p>transport protocols and especially the application would essentially be independent of the </p>
<p>particular CAN chip used. </p>
<p> </p>
<p>This  document  describes  the  hardware  dependent  special  features  and  implementation </p>
<p>specifics of the Renesas RSCAN on the RH850 platform. </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>6 /46 </p>
<p> </p>
<p><b>2 </b></p>
<p><b>Important References </b></p>
<p>The  following  table  summarizes  information  about  the  CAN  Driver.  It  gives  you  detailed </p>
<p>information about  the versions,  derivatives  and  compilers. As  very important  information </p>
<p>the documentations of the hardware manufacturers are listed. The CAN Driver is based </p>
<p>upon these documents in the given version.  </p>
<p> </p>
<p><b>Driver </b></p>
<p><b>Version </b></p>
<p><b>Supported </b></p>
<p><b>Compilers </b></p>
<p><b>Supported </b></p>
<p><b>Derivatives </b></p>
<p><b>Hardware Manufacturer Document </b></p>
<p><b>Version </b></p>
<p>3.11.xx, </p>
<p>RI 1.5 </p>
<p>Green Hills, </p>
<p>Wind River Diab, </p>
<p>IAR </p>
<p>D1L </p>
<p>D1M </p>
<p>R01UH0451EJ0041, RH850/D1L/D1M </p>
<p>Group, User’s Manual: Hardware </p>
<p>Rev.0.41 </p>
<p>Jan 2014 </p>
<p>F1L </p>
<p>R01UH0390EJ0100, RH850/F1L Group,  </p>
<p>User’s Manual: Hardware </p>
<p>Rev.1.00 </p>
<p>Jan 2014 </p>
<p>F1H </p>
<p>1</p>
<p> </p>
<p>R01UH0445EJ0010, RH850/F1H Group, </p>
<p>User’s Manual: Hardware </p>
<p>Rev.0.10 </p>
<p>Jan 2014 </p>
<p>P1M </p>
<p>R01UH0436EJ0041, RH850/P1x Group,  </p>
<p>User’s Manual: Hardware </p>
<p>Rev.0.41 </p>
<p>Nov 2013 </p>
<p>R1L </p>
<p>R1M </p>
<p>R01UH0411EJ0061, RH850/R1x Group,  </p>
<p>User’s Manual: Hardware </p>
<p>Rev.0.61 </p>
<p>Aug 2013 </p>
<p> </p>
<p>R01US0058EJ0020, RH850 Family, </p>
<p>User’s Manual: Software </p>
<p>Rev.0.20 </p>
<p>Feb 2013 </p>
<p>Table 2-1  </p>
<p>Supported Hardware Overview </p>
<p> </p>
<p><b>Driver Version: </b>This is the current version of the CAN Driver. RI shows the version of the Reference </p>
<p>Implementation and therefore the functional scope of the CAN Driver. </p>
<p><b>Supported Compilers: </b>List of compilers the CAN Driver is working with. </p>
<p><b>Supported Derivatives: </b>List of derivatives the CAN Driver can be used on. </p>
<p><b>Hardware Manufacturer Document: </b>List of hardware documentation the CAN Driver is based on.  </p>
<p><b>Version: </b>To be able to reference to this hardware documentation its version is very important. </p>
<p> </p>
<p>                                            </p>
<p>1</p>
<p> Only RSCAN0 is supported (physical channels CAN0-CAN5). </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>7 /46 </p>
<p> </p>
<p><b>3 </b></p>
<p><b>Usage of Controller Features </b></p>
<p><b>3.1 </b></p>
<p><b>[#hw_comObj] - Communication Objects </b></p>
<p>The generation tool supports a flexible allocation of message buffers: </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p>Figure 3-1 </p>
<p>Hardware Object Layout </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Figure 3-1 depicts the maximum RSCAN capacities - the actual layout depends on the </p>
<p>used derivative. Refer to the hardware manual to get the number of supported physical </p>
<p>channels to determine which Tx buffers are available. The amount of supported Rx </p>
<p>buffers (nRXMBmax) equals the number of supported physical channels * 16. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>8 /46 </p>
<p> </p>
<p><b>Obj </b></p>
<p><b>number </b></p>
<p><b>Hw object </b></p>
<p><b>type </b></p>
<p><b>Log object </b></p>
<p><b>type </b></p>
<p><b>No. of </b></p>
<p><b>objects </b></p>
<p><b>Comment </b></p>
<p>0 </p>
<p>- </p>
<p>(nRxFC -1) </p>
<p>Receive </p>
<p>buffer </p>
<p>Receive </p>
<p>FullCAN </p>
<p> </p>
<p>0 </p>
<p>- </p>
<p>nRxMBmax </p>
<p> </p>
<p>= nRXFC </p>
<p>These objects are used to receive </p>
<p>specific CAN messages. The user </p>
<p>defines statically (Generation Tool) that </p>
<p>a CAN message should be received in a </p>
<p>FullCAN message object. The </p>
<p>Generation Tool distributes the </p>
<p>messages to the FullCAN objects. Up to </p>
<p>nRxMBmax receive FullCAN objects can </p>
<p>be configured per channel, but the sum </p>
<p>over all receive FullCAN objects on all </p>
<p>channels must not exceed nRxMBmax. </p>
<p>The receive buffers for the FullCAN </p>
<p>objects of all channels (sorted </p>
<p>ascending by the physical channel </p>
<p>index) are allocated continuously </p>
<p>starting from index 0. </p>
<p>nRxFC </p>
<p>- </p>
<p>127 </p>
<p>Receive </p>
<p>buffer </p>
<p>Unused </p>
<p>0 </p>
<p>- </p>
<p>128 </p>
<p>These objects are not used. It depends </p>
<p>on the configuration of receive FullCAN </p>
<p>objects and nRxMBmax how many </p>
<p>receive buffers are not used. These </p>
<p>objects will not be configured, so they </p>
<p>don’t consume shared hardware buffers. </p>
<p>128 </p>
<p>-  </p>
<p>(128 +  </p>
<p>nRxBC -1) </p>
<p>Receive </p>
<p>FIFO buffer </p>
<p>Receive </p>
<p>BasicCAN </p>
<p>0 </p>
<p>- </p>
<p>8 </p>
<p> </p>
<p>= nRXBC </p>
<p>All other CAN messages (Application, </p>
<p>Diagnostics, Network Management) are </p>
<p>received via the BasicCAN objects. </p>
<p>Each object consists of one receive </p>
<p>FIFO buffer with a configurable amount </p>
<p>of acceptance filters and an individually </p>
<p>configurable FIFO depth (number of </p>
<p>allocated shared buffers). In general </p>
<p>there is one BasicCAN object per </p>
<p>channel, but by using the Multiple </p>
<p>BasicCAN feature the amount of used </p>
<p>BasicCAN objects can be configured. </p>
<p>Up to 8 receive BasicCAN objects can </p>
<p>be configured per channel, but the sum </p>
<p>over all receive BasicCAN objects on all </p>
<p>channels must not exceed 8. The </p>
<p>receive FIFO buffers for the BasicCAN </p>
<p>objects of all channels (sorted </p>
<p>ascending by the physical channel </p>
<p>index) are allocated continuously </p>
<p>starting from index 128. </p>
<p>128 + nRxBC </p>
<p>- </p>
<p>135 </p>
<p>Receive </p>
<p>FIFO buffer </p>
<p>Unused </p>
<p>0 </p>
<p>- </p>
<p>8 </p>
<p>These objects are not used. It depends </p>
<p>on the configuration of receive </p>
<p>BasicCAN objects how many receive </p>
<p>FIFO buffers are not used. These </p>
<p>objects will not be configured, so they </p>
<p>don’t consume shared hardware buffers. </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>9 /46 </p>
<p> </p>
<p><b>Obj </b></p>
<p><b>number </b></p>
<p><b>Hw object </b></p>
<p><b>type </b></p>
<p><b>Log object </b></p>
<p><b>type </b></p>
<p><b>No. of </b></p>
<p><b>objects </b></p>
<p><b>Comment </b></p>
<p>136 </p>
<p>- </p>
<p>159 </p>
<p>Transmit / </p>
<p>Receive </p>
<p>FIFO buffer </p>
<p>Unused </p>
<p>24 </p>
<p>The usage of Transmit / Receive FIFO </p>
<p>buffers is not supported by this driver. </p>
<p>These objects are always unused and </p>
<p>will not be configured, so they don’t </p>
<p>consume shared hardware buffers. </p>
<p>160 + (n*16) </p>
<p>Transmit </p>
<p>buffer </p>
<p>Transmit </p>
<p>Normal </p>
<p>1  </p>
<p>per channel </p>
<p>This object is used by </p>
<p>CanTransmit()</p>
<p> </p>
<p>to send several messages on the logical </p>
<p>channel that is mapped to physical </p>
<p>channel n. If the transmit message </p>
<p>object is busy, the transmit request is </p>
<p>stored in a software queue. </p>
<p>161 + (n*16) </p>
<p>Transmit </p>
<p>buffer </p>
<p>Low Level </p>
<p>Transmit </p>
<p>0 or 1 </p>
<p>per channel </p>
<p> </p>
<p>= nTXLL </p>
<p>This object is used by </p>
<p>CanMsgTransmit()</p>
<p> to send its </p>
<p>messages on the logical channel that is </p>
<p>mapped to physical channel n if the Low </p>
<p>Level transmit functionality is used. </p>
<p>161 + (n*16) </p>
<p> + nTXLL  </p>
<p>- </p>
<p>161 + (n*16) + </p>
<p>nTXLL + </p>
<p>nTXFC(n) -1 </p>
<p>Transmit </p>
<p>buffer </p>
<p>Transmit </p>
<p>FullCAN </p>
<p> </p>
<p>0 </p>
<p>- </p>
<p>15 </p>
<p>per channel </p>
<p> </p>
<p>= nTXFC(n)  </p>
<p>These objects are used by </p>
<p>CanTransmit()</p>
<p> to send a certain </p>
<p>message on the logical channel that is </p>
<p>mapped to physical channel n. The user </p>
<p>defines statically (Generation Tool) </p>
<p>which CAN messages are located in </p>
<p>such Tx FullCAN objects. The </p>
<p>Generation Tool distributes the </p>
<p>messages to the objects. Up to 15 </p>
<p>transmit FullCAN objects can be </p>
<p>assigned per channel (up to 14 if the </p>
<p>Low Level transmit functionality is used). </p>
<p>161 + (n*16) + </p>
<p>nTXLL + </p>
<p>nTXFC(n) </p>
<p>- </p>
<p>161 + (n*16) </p>
<p>+14 </p>
<p>Transmit </p>
<p>buffer </p>
<p>Unused </p>
<p>0 </p>
<p>- </p>
<p>15  </p>
<p>per channel </p>
<p>These objects are not used. It depends </p>
<p>on the configuration of transmit objects </p>
<p>how many transmit buffer objects are </p>
<p>not used. Additionally all transmit buffers </p>
<p>of not supported or unused physical </p>
<p>channels n are unused. </p>
<p>Table 3-1  </p>
<p>Hardware Object Layout </p>
<p> </p>
<p>nRxMBmax </p>
<p>Amount of RX buffers that is supported by the used derivative (see note above) </p>
<p>nRxFC </p>
<p>Number of used Rx FullCAN objects over all channels </p>
<p>nRxBC </p>
<p>Number of used Rx BasicCAN objects over all channels </p>
<p>n </p>
<p>Index of the physical channel </p>
<p>nTXLL </p>
<p>Number of Low Level transmit objects per channel (0 or 1) </p>
<p>nTXFC(n) </p>
<p>Number of used Tx FullCAN objects on the channel that is mapped to the physical channel n </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>10 /46 </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The number of available transmit buffer objects per physical channel is constant. The </p>
<p>receive buffers and FIFOs are shared over all channels and the availability per channel </p>
<p>is restricted as explained in table 3-1. Furthermore the internal buffers for all receive </p>
<p>objects are allocated out of a common buffer pool with size of (number of supported </p>
<p>physical channels * 64). This has to be considered when configuring the number of the </p>
<p>Rx FullCAN objects and the number and individual FIFO depths of the Rx BasicCAN </p>
<p>objects (refer to section 11.1.3 for further information and details on how to configure </p>
<p>the hardware objects). </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.2 </b></p>
<p><b>Acceptance Filters </b></p>
<p>The hardware acceptance filters of the receive BasicCAN objects must allow reception of </p>
<p>all  messages  that  are  not  received  in  FullCAN  message  objects  and  additionally  all </p>
<p>messages </p>
<p>that </p>
<p>fit </p>
<p>in </p>
<p>a </p>
<p>configured </p>
<p>range </p>
<p>(e.g. </p>
<p>for </p>
<p>Network </p>
<p>Management, </p>
<p>Transport </p>
<p>Protocol).  The  generation  tool  offers  assistance  for  configuration.  The  number  of  used </p>
<p>filters  is  also  configurable  to  allow  efficient  hardware  filtering  to  minimize  unnecessary </p>
<p>CPU load. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The hardware supports a pool of acceptance filters with size of (number of supported </p>
<p>physical channels * 64) that are used for Rx BasicCAN as well as Rx FullCAN objects. </p>
<p>This has to be considered when configuring the number of Rx FullCAN objects and the </p>
<p>number of filters per Rx BasicCAN object. See section 11.1.3 for further information </p>
<p>and details on the configuration. </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>11 /46 </p>
<p> </p>
<p><b>4 </b></p>
<p><b> [#hw_sleep] - SleepMode and WakeUp </b></p>
<p>The  driver  supports  sleep  and  wakeup  functionality.  With  the  function </p>
<p>CanSleep()</p>
<p>  the </p>
<p>CAN controller enters sleep mode and leaves it with the function </p>
<p>CanWakeUp()</p>
<p> (internal </p>
<p>wakeup)  or  upon  a  falling  edge  respectively  dominant  level  on  the  Rx  pin  (external </p>
<p>wakeup). </p>
<p>If  you  want  to  use  sleep/wakeup  functionality  specify  the  Sleep/Wakeup  option  in  the </p>
<p>generation tool. If this functionality is not configured, the service functions </p>
<p>CanSleep()</p>
<p> </p>
<p>and </p>
<p>CanWakeUp()</p>
<p> are empty and return </p>
<p>kCanNotSupported</p>
<p>. </p>
<p><b>4.1 </b></p>
<p><b>Sleep </b></p>
<p>The  function </p>
<p>CanSleep()</p>
<p>  changes  the  channel  from  communication  mode  via  reset </p>
<p>mode to stop mode. If the function is called during CAN communication, the reception or </p>
<p>transmission </p>
<p>is </p>
<p>terminated </p>
<p>before </p>
<p>it </p>
<p>is </p>
<p>completed </p>
<p>(the </p>
<p>same </p>
<p>applies </p>
<p>to </p>
<p>a </p>
<p>call </p>
<p>of </p>
<p>CanResetBusSleep()</p>
<p>). </p>
<p>These transitions do not depend on external influences (e.g. the CAN bus level), so the </p>
<p>return  value </p>
<p>kCanOk</p>
<p>  is  always  expected.  However,  if  the  function  returns </p>
<p>kCanFailed</p>
<p> </p>
<p>call </p>
<p>CanSleep()</p>
<p> again or re-initialize the channel. </p>
<p><b>4.2 </b></p>
<p><b>Internal Wakeup </b></p>
<p>The  function </p>
<p>CanWakeUp()</p>
<p>  changes  the  channel  from  stop  mode  via  reset  mode  to </p>
<p>communication mode. </p>
<p>The  return  value </p>
<p>kCanOk</p>
<p>  is  always  expected  for  this  mode  change.  However,  as  the </p>
<p>transition to operation mode takes two CAN bit times on the corresponding channel, the </p>
<p>hardware loop </p>
<p>kCanLoopEnterOperationMode</p>
<p> is implemented (see chapter 5). If the </p>
<p>function  returns </p>
<p>kCanFailed</p>
<p>  (e.g.  caused  by  a  loop  cancellation)  call </p>
<p>CanWakeup()</p>
<p> </p>
<p>again or re-initialize the channel. </p>
<p><b>4.3 </b></p>
<p><b>External Wakeup </b></p>
<p>The external wakeup functionality is realized by external interrupts but fully handled by the </p>
<p>CAN driver. The RSCAN itself does not provide any possibility of detecting bus activity if it </p>
<p>is in stop mode. Instead the port configuration of the RH850 allows combining the CANn </p>
<p>Rx pin with an external interrupt INTPn to be able to detect a CAN event even if the driver </p>
<p>is in sleep mode. Refer to chapter 10 for implementation hints. </p>
<p>When the driver is in sleep mode and a CAN event is detected on the Rx pin a wakeup </p>
<p>interrupt is generated. This event can also be detected by polling. The ISR or the polling </p>
<p>task  calls  the  application  function </p>
<p>ApplCanPreWakeUp()</p>
<p>  (if  configured),  changes  the </p>
<p>channel mode via reset mode to communication mode and calls </p>
<p>ApplCanWakeUp()</p>
<p>.  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>12 /46 </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If the Sleep/Wakeup functionality is enabled via the configuration tool both the internal </p>
<p>and external wakeup are available and the CAN driver expects that the Rx pin of each </p>
<p>used  CAN  channel  is  linked  with  an  external  interrupt  in  context  of  the  RH850  port </p>
<p>configuration. Also the driver expects that each external interrupt source is assigned to </p>
<p>the  lowest  possible  interrupt  channel  (check  the  “INTC1  interrupt  select  register”  if </p>
<p>applicable). </p>
<p>If  this  configuration  is  not  possible  for  the  actual  derivative  (refer  to  the  hardware </p>
<p>documentation) or any respective external interrupt cannot be used exclusively by the </p>
<p>driver  (write  accesses  to  the  corresponding  interrupt  control  register),  the  external </p>
<p>wakeup functionality can’t be used. </p>
<p>In this case Sleep/Wakeup functionality itself has to be disabled or the external wakeup </p>
<p>has to be deactivated by adding following to the user configuration file. Then only the </p>
<p>internal wakeup is possible and the driver does not wake up on bus activity. </p>
<p>#define C_ENABLE_EXTERNAL_WAKEUP_SUPPRESSION</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The driver performs write accesses within the interrupt controller address space of the </p>
<p>MCU.  If  wakeup  processing  is  configured  to  interrupt  the  corresponding  interrupt  is </p>
<p>enabled at successful sleep transitions and disabled at successful wakeup transitions. </p>
<p>Additionally the corresponding interrupt request flag is cleared right before the interrupt </p>
<p>is enabled; hence a wakeup event can only be detected after the sleep transition has </p>
<p>been  completed.  Refer  to  section  10.3  if  an  exclusive  write  access  to  the  interrupt </p>
<p>control registers is not possible. Please note that the interrupt request flag also has to </p>
<p>be cleared for polling configurations.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>13 /46 </p>
<p> </p>
<p><b>5 </b></p>
<p><b> [#hw_loop] - Hardware Loop Check </b></p>
<p>In  context  of  the  feature  Hardware  Loop  Check  (see  TechnicalReference_CANDriver, </p>
<p>chapter Hardware Loop Check) this CAN Driver provides the following timer identifications.  </p>
<p>If the common term clock is used below always consider the one with the lower frequency </p>
<p>out of clkc and pclk. The RSCAN requires clkc to be less or equal pclk/2, thus clkc can be </p>
<p>taken as a basis in general. Refer to the hardware manual for a description of the different </p>
<p>clocks and hardware specifics.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Always significantly increase the given durations for the loop callout implementation to </p>
<p>compensate additional software delays. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>kCanLoopRamInit </b></p>
<p>This loop may be called within the function </p>
<p>CanInitPowerOn()</p>
<p> and is processed until </p>
<p>the  CAN  RAM  initialization  after  a  MCU  reset  has  finished.  This  is  necessary  as  this </p>
<p>initialization has to be completed before the RSCAN can be configured. As this loop is </p>
<p>not called in channel context the channel parameter has to be ignored. </p>
<p>The maximum expected duration to wait for the CAN RAM initialization starts from the </p>
<p>time  of  the  MCU  reset  and  is  device  specific.  Refer  to  the  corresponding  hardware </p>
<p>manual (e.g. section RSCAN Setting Procedure – Initial Settings) to get the number of </p>
<p>required  clock  cycles.  If  the  loop  is  canceled  try  to  call </p>
<p>CanInitPowerOn()</p>
<p>  again  or </p>
<p>reset the MCU.</p>
<p> </p>
<p> </p>
<p><b>kCanLoopInit </b></p>
<p>This loop may be called within the function </p>
<p>CanInitPowerOn()</p>
<p>. As it is not called in </p>
<p>channel  context  the  channel  parameter  has  to  be  ignored.  The  loop  may  be  called </p>
<p>multiple times within this function and the possible occurrences are as follows: </p>
<p></p>
<p> </p>
<p>To protect the transition via global reset mode to global stop mode (only active if the </p>
<p>RSCAN ECC callout is enabled). </p>
<p></p>
<p> </p>
<p>To protect the transition to global reset mode. </p>
<p></p>
<p> </p>
<p>To protect transitions and settings in context of the global test mode (only active if the </p>
<p>RSCAN RAM test is enabled) </p>
<p></p>
<p> </p>
<p>To protect the transition to channel reset mode for each active channel. </p>
<p></p>
<p> </p>
<p>To protect the transition to global operation mode. </p>
<p> </p>
<p>The duration for each mode transition in this context is expected to be 10 clock cycles at </p>
<p>highest.  If  any  loop  occurrence  is  canceled  try  to  call </p>
<p>CanInitPowerOn()</p>
<p>  again  or </p>
<p>reset the MCU.</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>14 /46 </p>
<p> </p>
<p><b>kCanLoopBusOffRecovery </b></p>
<p>This channel dependent loop may be called in </p>
<p>CanInit()</p>
<p> if the RSCAN is currently in </p>
<p>BusOff  state and  is processed  until 11  consecutive  recessive  bits  have  been  detected </p>
<p>128  times  on  the  bus  to  ensure  compliance  to  the  BusOff  recovery  specification  (see </p>
<p>chapter 6). </p>
<p>The  maximum  expected  duration  is  1408  CAN  bit  times  on  a  recessive  bus,  128 </p>
<p>message  times  (including  inter-frame  space)  on  a  communicative  bus  or  any  time  if </p>
<p>disturbances are present. There is no issue and nothing to do if the loop is canceled, but </p>
<p>the specified BusOff recovery time may not be met.</p>
<p> </p>
<p> </p>
<p><b>kCanLoopEnterResetMode </b></p>
<p>This channel dependent loop may be called in </p>
<p>CanInit()</p>
<p> and is processed as long as </p>
<p>the CAN cell does not enter channel reset mode.  </p>
<p>The maximum expected duration of the loop is three clock cycles. If the loop is canceled </p>
<p>try to reinitialize the channel again or call </p>
<p>CanInitPowerOn()</p>
<p>.</p>
<p> </p>
<p> </p>
<p><b>kCanLoopEnterOperationMode </b></p>
<p>This </p>
<p>channel </p>
<p>dependent </p>
<p>loop </p>
<p>is </p>
<p>always </p>
<p>called </p>
<p>in </p>
<p>CanInit()</p>
<p>, </p>
<p>CanStart()</p>
<p> </p>
<p>and </p>
<p>CanWakeUp()</p>
<p>  and  is  processed  as  long  as  the  CAN  cell  does  not  enter  channel </p>
<p>operation mode.  </p>
<p>The maximum expected duration of the loop is two CAN bit times on the current channel. </p>
<p>If  the  loop  is  canceled  try  to  call </p>
<p>CanStart()</p>
<p>  respectively </p>
<p>CanWakeUp()</p>
<p>  again  or </p>
<p>reinitialize the channel.</p>
<p> </p>
<p> </p>
<p><b>kCanLoopRxFcProcess </b></p>
<p>This  channel  depended  loop  is  always  called  in </p>
<p>CanFullCanMsgReceived()</p>
<p>  and  is </p>
<p>processed as long as new messages are received by the current hardware object while </p>
<p>copying a previously received message to a temporary software buffer. This ensures that </p>
<p>always consistent and most recent data is indicated. </p>
<p>It is expected that the loop iterates one or two times. Please note that if the loop iterates </p>
<p>more  than  one  time  previously  received  messages  of  the  current  receive  buffer  are </p>
<p>discarded without further notification as data consistency cannot be ensured. There is no </p>
<p>issue and nothing to do if the loop is canceled, but the latest message is also discarded </p>
<p>and </p>
<p>CanFullCanMsgReceived()</p>
<p> returns without indicating any message at all.</p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>15 /46 </p>
<p> </p>
<p><b>6 </b></p>
<p><b>[#hw_busoff] - Bus off </b></p>
<p>In  case  of  a  BusOff  event  the  controller  automatically  changes  to  stop  mode  on  the </p>
<p>respective  channel.  There  is  no  automatic  recovery  as  specified  by  ISO11898-1;  the </p>
<p>application </p>
<p>has </p>
<p>to </p>
<p>restart </p>
<p>communication </p>
<p>following </p>
<p>the </p>
<p>description </p>
<p>in </p>
<p>the </p>
<p>Technical </p>
<p>Reference CAN driver, i.e. by calling </p>
<p>CanResetBusOffStart/-End()</p>
<p> which leads to a </p>
<p>call  of </p>
<p>CanInit()</p>
<p>.  Please  note  that  if </p>
<p>CanResetBusOffEnd()</p>
<p>  is  called  before  11 </p>
<p>consecutive recessive bits have been detected 128 times, </p>
<p>kCanLoopBusOffRecovery</p>
<p> is </p>
<p>called within </p>
<p>CanInit()</p>
<p> (see chapter 5). </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>16 /46 </p>
<p> </p>
<p><b>7 </b></p>
<p><b>CAN Driver Features </b></p>
<p><b>7.1 </b></p>
<p><b>[#hw_feature] - Feature List </b></p>
<p> </p>
<p><b>Standard </b></p>
<p><b>HighEnd </b></p>
<p><b>Initialization </b></p>
<p>Power-On Initialization </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Re-Initialization </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p><b>Transmission </b></p>
<p>Transmit Request </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Transmit Request Queue </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Internal data copy mechanism </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Pretransmit functions </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Common confirmation function </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Confirmation flag </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Confirmation function </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Offline Mode </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Partial Offline Mode </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Passive-Mode </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Tx Observe mode </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Dynamic TxObjects </p>
<p>ID </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>DLC </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>Data-Ptr </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Full CAN Tx Objects </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Cancellation in Hardware </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Low Level Message Transmit </p>
<p>- </p>
<p></p>
<p> </p>
<p><b>Reception </b></p>
<p>Receive function </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Search algorithms </p>
<p>Linear </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>Table </p>
<p>- </p>
<p>- </p>
<p> </p>
<p>Index </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>Hash </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Range specific precopy functions </p>
<p>(min. 2, typ.4) </p>
<p>4 </p>
<p>4 </p>
<p>DLC check </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Internal data copy mechanism </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Generic precopy function </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Precopy function </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Indication flag </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Indication function </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Message not matched function </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>17 /46 </p>
<p> </p>
<p>Overrun Notification </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Full CAN overrun notification </p>
<p>- </p>
<p>- </p>
<p>Multiple Basic CAN </p>
<p>- </p>
<p></p>
<p> </p>
<p>Rx Queue </p>
<p>2</p>
<p> </p>
<p>- </p>
<p></p>
<p> </p>
<p><b>Bus off </b></p>
<p>Notification function </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Nested Recovery functions </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p><b>Sleep Mode </b></p>
<p>Mode Change </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Preparation </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Notification function </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p><b>Special Features </b></p>
<p>Status </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Security Level </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Assertions </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Hardware loop check </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Stop Mode </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Support of OSEK operating </p>
<p>system </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Polling Mode </p>
<p>Tx  </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>Rx (FullCAN) </p>
<p>3</p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>Rx (BasicCAN) </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>Error </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>Wakeup </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Individual Polling </p>
<p>4</p>
<p> </p>
<p>- </p>
<p></p>
<p> </p>
<p>Multi channel </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Support extended ID addressing </p>
<p>mode </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Support mixed ID addressing </p>
<p>mode </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Support access to error counters </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Copy functions </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>CAN RAM check </p>
<p>5</p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Extended CAN RAM check </p>
<p>6</p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Table 7-1  </p>
<p>CAN Driver Functionality </p>
<p> </p>
<p>                                            </p>
<p>2</p>
<p> Consider that the Rx BasicCAN hardware FIFOs in combination with Rx BasicCAN polling might be a more </p>
<p>efficient alternative to the Rx Queue in many configurations. </p>
<p>3</p>
<p> Due to hardware limitations (no interrupt request can be generated for receive buffers) Rx FullCAN polling </p>
<p>is mandatory if Rx FullCAN objects are configured. </p>
<p>4</p>
<p> Due to hardware limitations (see note 3) all Rx FullCAN objects have to be polled. </p>
<p>5</p>
<p> Due to hardware limitations (no write access to Rx objects) only supported for Tx objects. </p>
<p>6</p>
<p> This feature is project specific and only available if explicitly ordered. </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>18 /46 </p>
<p> </p>
<p><b>7.2 </b></p>
<p><b>Description of Hardware-related Features </b></p>
<p><b>7.2.1 </b></p>
<p><b>[#hw_status] - Status </b></p>
<p>If a status is not supported, the related macro always returns false. </p>
<p><b>Status </b></p>
<p><b>Support </b></p>
<p>CanHwIsOk(state) </p>
<p></p>
<p> </p>
<p>CanHwIsWarning(state) </p>
<p></p>
<p> </p>
<p>CanHwIsPassive(state) </p>
<p></p>
<p> </p>
<p>CanHwIsBusOff(state) </p>
<p></p>
<p> </p>
<p>CanHwIsWakeup(state) </p>
<p></p>
<p> </p>
<p>CanHwIsSleep(state) </p>
<p></p>
<p> </p>
<p>CanHwIsStart(state) </p>
<p></p>
<p> </p>
<p>CanHwIsStop(state) </p>
<p></p>
<p> </p>
<p>CanIsOnline(state) </p>
<p></p>
<p> </p>
<p>CanIsOffline(state) </p>
<p></p>
<p> </p>
<p>Table 7-2  </p>
<p>CAN Status </p>
<p><b>7.2.2 </b></p>
<p><b>[#hw_stop] - Stop Mode </b></p>
<p>The service function </p>
<p>CanStop()</p>
<p> calls </p>
<p>CanInit()</p>
<p> and then puts the CAN Controller into </p>
<p>channel reset mode, where it is disconnected from the bus. If the function is called during </p>
<p>CAN  communication, the  reception  or transmission  is terminated before  it  is  completed. </p>
<p>This mode can be left by calling </p>
<p>CanStart()</p>
<p>. Both transitions do not depend on external </p>
<p>influences  (e.g.  the  CAN  bus  level),  so  the  return  value </p>
<p>kCanOk</p>
<p>  is  always  expected. </p>
<p>However, </p>
<p>if </p>
<p>the </p>
<p>functions </p>
<p>return </p>
<p>kCanFailed</p>
<p> </p>
<p>(e.g. </p>
<p>caused </p>
<p>by </p>
<p>a </p>
<p>hardware </p>
<p>loop </p>
<p>cancellation) call </p>
<p>CanStop()</p>
<p>, respectively </p>
<p>CanStart()</p>
<p> again or re-initialize the channel. </p>
<p> </p>
<p><b>7.2.3 </b></p>
<p><b>[#hw_int] - Control of CAN Interrupts </b></p>
<p>CAN interrupt locking is performed by modifying the interrupt request mask bits (MK) in the </p>
<p>control registers of the appropriate sources directly within the interrupt controller address </p>
<p>space of the MCU. Therefore the driver needs exclusive write access to all CAN related EI </p>
<p>level interrupt control registers (ICn). If the sleep/wakeup functionality is enabled this may </p>
<p>include the ICn of external interrupt sources (see chapter 4). </p>
<p>Since  Rx  FIFO  interrupt  and  overrun  (global  error)  cannot  be  enabled  and  disabled  for </p>
<p>every  object  individually  they  are  disabled  globally  when  the  interrupts  of  at  least  one </p>
<p>controller are disabled and enabled globally if the interrupts of no controller are disabled </p>
<p>anymore. </p>
<p>All CAN related ICn are initialized and then modified by the driver during runtime (interrupt </p>
<p>disable  and  restore).  The  priority  level  for  the  initialization  can  be  selected  via  the </p>
<p>configuration  tool  (all  CAN  interrupts  must  have  the  same  priority),  see  section  11.1.3. </p>
<p>Refer to chapter 10 for further information on CAN interrupts. </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>19 /46 </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>In standard configuration the driver needs <b>exclusive</b> write access to all CAN related EI </p>
<p>level interrupt control registers. Refer to chapter 10 for further information and </p>
<p>especially section 10.3 if an exclusive write access is not possible. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>7.2.4 </b></p>
<p><b>[#hw_cancel] - Cancel in Hardware </b></p>
<p> </p>
<p><b> </b></p>
<p><b>Yes </b></p>
<p><b>No </b></p>
<p>Has the </p>
<p>CanTxTask()</p>
<p> to be called by the application to handle the canceled </p>
<p>transmit request in the hardware? </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>Cancelling transmission of messages via </p>
<p>CanCancelTransmit()</p>
<p> or</p>
<p> </p>
<p>CanCancelMessageTransmit()</p>
<p>:</p>
<p> </p>
<p><b> </b></p>
<p><b>Yes </b></p>
<p><b>No </b></p>
<p>ApplCanTxConfirmation()</p>
<p> is only called for transmitted messages, successfully </p>
<p>canceled messages are not notified. That means the CAN driver is able to detect </p>
<p>whether a message is transmitted even if the application has tried to cancel. </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p><b>7.2.5 </b></p>
<p><b>Remote Frames </b></p>
<p>Remote Frames will not have any influence on the communication because they are not </p>
<p>received due to hardware filtering. </p>
<p> </p>
<p><b>7.2.6 </b></p>
<p><b>CAN RAM Check </b></p>
<p>The  CAN  driver  supports  a  check  of  the  CAN  mailboxes  which  is  performed  internally </p>
<p>every  time  the  function </p>
<p>CanInit()</p>
<p>  is  called.  The  CAN  driver  verifies  that  no  used </p>
<p>mailboxes are corrupt. A mailbox is considered corrupt if predefined patterns are written to </p>
<p>the appropriate mailbox registers and read operations do not return the expected patterns. </p>
<p>If  a  corrupt  mailbox  is  found  the  function </p>
<p>ApplCanCorruptMailbox()</p>
<p>  is  optionally </p>
<p>called to inform the application which mailbox is affected. </p>
<p>After  the  check  of  all  mailboxes  on  the  given  channel  the  CAN  driver  calls  the  function </p>
<p>ApplCanMemCheckFailed()</p>
<p> if at least one corrupt mailbox was found. The application </p>
<p>can control whether the CAN driver disables communication on the current channel or not </p>
<p>by  means  of  the  return  value  of  the  call-back function.  If the  application  has  decided  to </p>
<p>disable the communication there is no possibility to enable the communication again until </p>
<p>the next call of </p>
<p>CanInitPowerOn()</p>
<p>. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Due to hardware limitations (no write access for receive objects) the CAN RAM check </p>
<p>is only supported for transmit mailboxes. Consider the behavioural differences of CAN </p>
<p>RAM check when it is used in combination with the extended CAN RAM check feature. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>20 /46 </p>
<p> </p>
<p>The additional call-back function </p>
<p>ApplCanCorruptMailbox()</p>
<p> can only be activated via </p>
<p>the user configuration file - the settings are listed below. In case no user config file is used </p>
<p>(i.e. the mentioned switch is not defined) the feature is disabled. </p>
<p><b>Switch </b></p>
<p><b>Value </b></p>
<p><b>Description </b></p>
<p>C_ENABLE_NOTIFY_CORRUPT_MAILBOX </p>
<p> </p>
<p>Activate call of </p>
<p>ApplCanCorruptMailbox()</p>
<p> </p>
<p>in case the CAN RAM check fails for a certain </p>
<p>mailbox. </p>
<p> </p>
<p> </p>
<p><b>7.2.7 </b></p>
<p><b>Extended CAN RAM Check </b></p>
<p>The extended RAM check provides an additional check of the CAN cell control registers </p>
<p>RAM with extended API and modified standard CAN RAM check and driver behaviour. </p>
<p>The RSCAN control registers are differentiated between registers that have to be written in </p>
<p>global reset mode (afterwards referred to as “global registers”) or can also be written in </p>
<p>channel reset mode (afterwards referred to as “channel registers”). Since the transition to </p>
<p>global reset mode affects all channels, the global register RAM is checked only once within </p>
<p>CanInitPowerOn()</p>
<p>. If the global register RAM is considered corrupt a call-back function </p>
<p>(see below) is issued to allow the application to control whether the driver initialization is </p>
<p>proceeded or not. </p>
<p>The </p>
<p>channel </p>
<p>register </p>
<p>and </p>
<p>mailbox </p>
<p>RAM </p>
<p>check </p>
<p>is </p>
<p>performed </p>
<p>within </p>
<p>the </p>
<p>function </p>
<p>CanInit()</p>
<p>. The registers RAM check disables the complete channel communication if at </p>
<p>least  one of  the  checked  registers is considered  corrupt. The mailbox  RAM  check  (only </p>
<p>available for Tx objects) disables corrupt mailboxes so that no transmission is possible on </p>
<p>them.  In  both  cases  the  appropriate  call-backs  (see  below)  are  called  to  inform  the </p>
<p>application </p>
<p>about </p>
<p>the </p>
<p>failures. </p>
<p>Channels </p>
<p>and </p>
<p>mailboxes </p>
<p>can </p>
<p>be </p>
<p>re-enabled </p>
<p>by </p>
<p>the </p>
<p>application  using  the  extended API.  If  any  of  the  control  registers  check  or  the  mailbox </p>
<p>registers  check  fails  the  overall  RAM  check  call-back </p>
<p>ApplCanMemCheckFailed()</p>
<p><i> </i> is </p>
<p>invoked.  </p>
<p>More detailed information is given below; section 9.3 describes the API functions: </p>
<p></p>
<p> </p>
<p>If any of the global registers (e.g. global configuration registers, registers relating to the </p>
<p>configuration of receive objects and receive rules) are considered corrupt the function </p>
<p>ApplCanGlobalMemCheckFailed()</p>
<p>  is  invoked  within </p>
<p>CanInitPowerOn()</p>
<p>.  If  this </p>
<p>function  returns </p>
<p>kCanEnableCommunication</p>
<p>  the  initialization  is  continued  ignoring </p>
<p>the results of the check. If it returns </p>
<p>kCanDisableCommunication</p>
<p> the RSCAN is put </p>
<p>back  into  global  stop  mode  and</p>
<p> CanInitPowerOn()</p>
<p>  returns  without  initializing  the </p>
<p>RSCAN. </p>
<p>The </p>
<p>check </p>
<p>of </p>
<p>the </p>
<p>channel </p>
<p>registers </p>
<p>RAM </p>
<p>is </p>
<p>also </p>
<p>not </p>
<p>performed </p>
<p>and </p>
<p>CanInitPowerOn()</p>
<p> has to be called again to be able to use the CAN functionality in </p>
<p>this case (other CAN API functions must not be called until </p>
<p>CanInitPowerOn()</p>
<p> was </p>
<p>executed completely). The check is performed with every call of this function. </p>
<p></p>
<p> </p>
<p>If </p>
<p>any </p>
<p>of </p>
<p>the </p>
<p>channel </p>
<p>control </p>
<p>registers </p>
<p>are </p>
<p>considered </p>
<p>corrupt </p>
<p>the </p>
<p>function </p>
<p>ApplCanCorruptRegisters()</p>
<p> </p>
<p>is </p>
<p>called </p>
<p>and </p>
<p>the </p>
<p>communication </p>
<p>on </p>
<p>the </p>
<p>given </p>
<p>channel is disabled. The CAN cell stays in stop mode whatever the general call-back </p>
<p>function </p>
<p>ApplCanMemCheckFailed()</p>
<p> returns and the channel is disconnected from </p>
<p>the Tx port pin. </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>21 /46 </p>
<p> </p>
<p></p>
<p> </p>
<p>If  a  corrupt  mailbox  is  found  it  is  disabled  by  the  driver  and  the  call-back  function </p>
<p>ApplCanCorruptMailbox()</p>
<p><i> </i></p>
<p>is </p>
<p>invoked </p>
<p>(if </p>
<p>this </p>
<p>is </p>
<p>enabled </p>
<p>by </p>
<p>the </p>
<p>definition </p>
<p>of </p>
<p>C_ENABLE_NOTIFY_CORRUPT_MAILBOX). In this case (but only if no corrupt CAN </p>
<p>control registers were found on the given channel) the application can decide whether </p>
<p>the  communication  on  the  channel  should  be  disabled  using  the  return  value  of  the </p>
<p>function </p>
<p>ApplCanMemCheckFailed()</p>
<p><i>, </i>but the mailbox stays disabled anyway. </p>
<p></p>
<p> </p>
<p>If the communication on a channel was disabled previously it can be re-enabled using </p>
<p>the function </p>
<p>CanEnableChannelCommunication()</p>
<p>. </p>
<p></p>
<p> </p>
<p>Mailboxes that were disabled by mailbox RAM check can be re-enabled by the function </p>
<p>CanEnableMailboxCommunication()</p>
<p> (but only if the communication on the given </p>
<p>channel is enabled). </p>
<p></p>
<p> </p>
<p>No  mailbox  or  register  RAM  check  is  performed  and  no  RAM  check  call-backs  are </p>
<p>invoked if </p>
<p>CanInit()</p>
<p> is called by </p>
<p>CanResetBusOffEnd()</p>
<p>. However, all previously </p>
<p>disabled channels or mailboxes stay disabled. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The only way to re-enable channel or mailbox communication is to use the functions </p>
<p>CanEnableChannelCommunication()</p>
<p>, </p>
<p>CanEnableMailboxCommunication()</p>
<p> </p>
<p>or </p>
<p>CanInitPowerOn()</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>The extended CAN RAM check feature needs the standard CAN RAM check functionality </p>
<p>to  be  activated. The following  settings  have  to  be  done  in  the  user configuration file.  In </p>
<p>case  no  user config file  is  used  (i.e.  the mentioned  switch  is not defined) the feature  is </p>
<p>disabled. Please note that this is a project specific feature that might not be available and </p>
<p>C_ENABLE_CAN_RAM_CHECK_EXTENDED has no effect in this case. </p>
<p><b>Switch </b></p>
<p><b>Value </b></p>
<p><b>Description </b></p>
<p>C_ENABLE_CAN_RAM_CHECK_EXTENDED </p>
<p> </p>
<p>Activate the extended CAN RAM check feature. </p>
<p> </p>
<p> </p>
<p><b>7.2.8 </b></p>
<p><b>RSCAN ECC Configuration </b></p>
<p>In context of the RSCAN RAM error detection and correction (ECC) the driver provides the </p>
<p>additional  call-back  function </p>
<p>ApplCanEccConfiguration()</p>
<p>  (see  section  9.2)  that  is </p>
<p>invoked by </p>
<p>CanInitPowerOn()</p>
<p> after the CAN RAM initialization is complete and before </p>
<p>the RSCAN is configured while the cell is in global stop mode. This gives the application </p>
<p>the possibility to configure the ECC behavior for the RSCAN. The driver offers no further </p>
<p>support for this feature - any ECC configuration and handling has to be performed by the </p>
<p>application. </p>
<p>The following settings have to be done in the user configuration file. In case no user config </p>
<p>file is used (i.e. the mentioned switch is not defined) the feature is disabled. </p>
<p><b>Switch </b></p>
<p><b>Value </b></p>
<p><b>Description </b></p>
<p>C_ENABLE_ECC_CALLOUT </p>
<p> </p>
<p>Activate call of </p>
<p>ApplCanEccConfiguration()</p>
<p>. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>22 /46 </p>
<p> </p>
<p><b>7.2.9 </b></p>
<p><b>RSCAN RAM Test </b></p>
<p>The RSCAN provides a global test mode that enables the driver to perform a check of the </p>
<p>entire internal RSCAN RAM that is not accessible during normal operation. This check is </p>
<p>performed once within </p>
<p>CanInitPowerOn()</p>
<p>. Similar to the (extended) CAN RAM check </p>
<p>the internal RAM is considered corrupt if predefined patterns are written to the appropriate </p>
<p>RAM addresses and read operations do not return the expected patterns. If any corrupt </p>
<p>bits  are  found  the  call-back  function </p>
<p>ApplCanGlobalMemCheckFailed() </p>
<p>is  invoked </p>
<p>(see section 9.3). If this function returns </p>
<p>kCanEnableCommunication</p>
<p> the initialization is </p>
<p>continued  ignoring  the  results  of  the  check.  If  it  returns </p>
<p>kCanDisableCommunication</p>
<p> </p>
<p>the RSCAN is put back into global stop mode and</p>
<p> CanInitPowerOn()</p>
<p> returns without </p>
<p>initializing the RSCAN. </p>
<p>CanInitPowerOn()</p>
<p> has to be called again to be able to use the </p>
<p>CAN </p>
<p>functionality </p>
<p>in </p>
<p>this </p>
<p>case </p>
<p>(other </p>
<p>CAN  API </p>
<p>functions </p>
<p>must </p>
<p>not </p>
<p>be </p>
<p>called </p>
<p>until </p>
<p>CanInitPowerOn()</p>
<p>  was  executed  completely). The  RAM  test  is  performed  with  every </p>
<p>call of this function. </p>
<p>The size of RAM to be checked is given by 2432 bytes multiplied with the number of CAN </p>
<p>channels that are supported by the used derivative (as configured in the configuration tool; </p>
<p>see section 11.1.2). The test always starts at the first address but the size to be checked </p>
<p>can be changed via user configuration (see below). </p>
<p>If this test is used in combination with  the (extended) CAN RAM check  the latter one is </p>
<p>reduced in order to save runtime. </p>
<p></p>
<p> </p>
<p>The receive rule registers are omitted by the global register check within the function </p>
<p>CanInitPowerOn().</p>
<p> </p>
<p></p>
<p> </p>
<p>The mailbox check is omitted if </p>
<p>CanInit()</p>
<p> is called out of </p>
<p>CanInitPowerOn()</p>
<p>. </p>
<p> </p>
<p>The following settings have to be done in the user configuration file. In case no user config </p>
<p>file is used (i.e. the first switch is not defined) the feature is disabled. The optional second </p>
<p>switch is only evaluated if C_ENABLE_CAN_HW_RAM_CHECK is defined. </p>
<p><b>Switch </b></p>
<p><b>Value </b></p>
<p><b>Description </b></p>
<p>C_ENABLE_CAN_HW_RAM_CHECK </p>
<p> </p>
<p>Activate the RSCAN RAM test feature. </p>
<p>C_ENABLE_CAN_HW_RAM_CHECK_SIZE </p>
<p>32 .. 65504 </p>
<p>(bytes) </p>
<p>Instead of the default size as stated above the </p>
<p>given number of bytes is checked by the RAM </p>
<p>test. The value must be a multiple of 32 bytes </p>
<p>and has to be valid for the used derivative </p>
<p>(refer to the corresponding hardware manual). </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Depending on the size of RAM to be checked, used compiler options, clock settings </p>
<p>and others this check might take up to several milliseconds. Suggestion is to verify the </p>
<p>runtime of </p>
<p>CanInitPowerOn()</p>
<p>in the actual project if this feature is enabled. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>23 /46 </p>
<p> </p>
<p><b>8 </b></p>
<p><b> [#hw_assert] – Assertions </b></p>
<p>The driver implements no specific assertions with additional error codes. </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>24 /46 </p>
<p> </p>
<p><b>9 </b></p>
<p><b>API </b></p>
<p><b>9.1 </b></p>
<p><b>Category </b></p>
<p><b>Single Receive Channels (SRC) </b></p>
<p></p>
<p> </p>
<p>A “Single Receive Channel” CAN Driver supports one CAN </p>
<p>channel.) </p>
<p><b>Multiple Receive Channel (MRC) </b></p>
<p></p>
<p> </p>
<p>A &quot;Single Receive Channel&quot; CAN Driver is typically </p>
<p>extended for multiple channels by adding an index to the </p>
<p>function parameter list (e.g. </p>
<p>CanOnline()</p>
<p> becomes to </p>
<p>CanOnline(channel)</p>
<p>) or by using the handle as a </p>
<p>channel indicator (e.g. </p>
<p>CanTransmit(txHandle)</p>
<p>). </p>
<p>Table 9-1  </p>
<p>API Category </p>
<p> </p>
<p><b>9.2 </b></p>
<p><b>RSCAN ECC Configuration </b></p>
<p>In  context  of  the  RSCAN  ECC  feature  the  application  has  to  provide  following  callback </p>
<p>function (see section 7.2.8 further information). </p>
<p> </p>
<p><b>ApplCanEccConfiguration </b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanEccConfiguration </b>(void) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanEccConfiguration </b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function is called by </p>
<p>CanInitPowerOn()</p>
<p> to allow the configuration of the RSCAN ECC functionality. </p>
<p><b>Particularities and Limitations </b></p>
<p>Only available if </p>
<p>C_ENABLE_ECC_CALLOUT</p>
<p> is defined. </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>25 /46 </p>
<p> </p>
<p><b>9.3 </b></p>
<p><b>(Extended) CAN RAM Check </b></p>
<p> </p>
<p>In context of the CAN RAM check feature the application has to provide following callback </p>
<p>functions (see sections 7.2.6 and 7.2.7 for further information). </p>
<p> </p>
<p><b>ApplCanMemCheckFailed </b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>vuint8 <b>ApplCanMemCheckFailed </b>(void) </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>ApplCanMemCheckFailed </b>(CanChannelHandle channel) </p>
<p><b>Parameter </b></p>
<p>CanChannelHandle channel </p>
<p>This parameter specifies the CAN channel on which the memory check is </p>
<p>performed. </p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p><b>kCanEnableCommunication – </b></p>
<p>Allow communication (see note in </p>
<p>“Particularities and Limitations”). </p>
<p><b>kCanDisableCommunication – </b></p>
<p>Disable communication, no reception and </p>
<p>no transmission is performed. </p>
<p><b>Functional Description </b></p>
<p>This call-back function is invoked within </p>
<p>CanInit()</p>
<p> if the CAN driver has found at least one corrupt bit </p>
<p>within the CAN mailboxes RAM or (if extended CAN RAM check is enabled) at least one corrupt bit within </p>
<p>the channel control registers RAM. The application can decide whether the CAN driver allows further </p>
<p>communication by means of the return value. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>Call context</b>: If the feature Extended CAN RAM check is deactivated this function is called on task level or </p>
<p>within the BusOff interrupt; else only on task level. </p>
<p><b>Configuration</b>: The following setting must be active: </p>
<p>C_ENABLE_CAN_RAM_CHECK </p>
<p><b>Important note: </b>If the optional feature “Extended CAN RAM check” is activated </p>
<p>(C_ENABLE_CAN_RAM_CHECK_EXTENDED is defined) and the registers RAM check failed (call-back </p>
<p>function </p>
<p>ApplCanCorruptRegisters()</p>
<p><i> </i>was called for the given channel), the communication on the </p>
<p>channel will be disabled, the CAN cell stays in stop mode and the return value of this function is ignored – </p>
<p>the communication will NOT be allowed even if the return value is </p>
<p>kCanEnableCommunication</p>
<p>. </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>26 /46 </p>
<p> </p>
<p><b>ApplCanCorruptMailbox </b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanCorruptMailbox </b>(CanObjectHandle hwObjHandle) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanCorruptMailbox </b>(CanChannelHandle channel, </p>
<p>CanObjectHandle hwObjHandle) </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>       CanObjectHandle hwObjHandle ) </p>
<p><b>Parameter </b></p>
<p>CanChannelHandle channel </p>
<p>This parameter specifies the CAN channel on which the memory check is </p>
<p>performed. </p>
<p>CanObjectHandle </p>
<p>hwObjHandle </p>
<p>This parameter specifies the index of the corrupt mailbox. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function is called within </p>
<p>CanInit()</p>
<p> if the CAN driver has found a corrupt mailbox. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>Call context</b>: If the feature “Extended CAN RAM check” is deactivated this function is called on task level or </p>
<p>within the BusOff interrupt; else only on task level. </p>
<p><b>Configuration</b>: The following settings must be active: </p>
<p>C_ENABLE_CAN_RAM_CHECK </p>
<p>C_ENABLE_NOTIFY_CORRUPT_MAILBOX </p>
<p> </p>
<p> </p>
<p>In case the feature extended CAN RAM check is enabled the following additional callback </p>
<p>functions have to be provided by the application. </p>
<p> </p>
<p><b>ApplCanCorruptRegisters </b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanCorruptRegisters </b>(void) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanCorruptRegisters </b>(CanChannelHandle channel) </p>
<p><b>Parameter </b></p>
<p>CanChannelHandle channel </p>
<p>This parameter specifies the CAN channel on which the memory check is </p>
<p>performed. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function is called if the CAN driver has found corrupt channel control registers. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>Call context</b>: This function is called out of task level within </p>
<p>CanInit()</p>
<p> on the given channel if the RAM </p>
<p>check is not suppressed. The RAM check is suppressed if </p>
<p>CanInit()</p>
<p><i> </i>is called in scope of the functions </p>
<p>CanResetBusOffEnd()</p>
<p>or (dependent on parameter) </p>
<p>CanEnableChannelCommunication()</p>
<p>. </p>
<p><b>Configuration</b>: The following settings must be active: </p>
<p>C_ENABLE_CAN_RAM_CHECK </p>
<p>C_ENABLE_CAN_RAM_CHECK_EXTENDED </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>27 /46 </p>
<p> </p>
<p><b>ApplCanGlobalMemCheckFailed </b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>vuint8 <b>ApplCanGlobalMemCheckFailed </b>(void) </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>ApplCanGlobalMemCheckFailed </b>(void) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p><b>kCanEnableCommunication – </b></p>
<p>Continue initialization of the RSCAN. </p>
<p><b>kCanDisableCommunication – </b></p>
<p>Stop initialization of the RSCAN. </p>
<p><b>Functional Description </b></p>
<p>This call-back function is invoked if the CAN driver has found at least one corrupt bit within the global control </p>
<p>registers RAM in context of the extended CAN RAM check or if any corrupt bit was found in context of the </p>
<p>RSCAN RAM test (see section 7.2.9). The application can decide whether the CAN driver proceeds with the </p>
<p>RSCAN initialization by means of the return value. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>Call context</b>: This function is called out of task level within </p>
<p>CanInitPowerOn()</p>
<p>. </p>
<p><b>Configuration</b>: The following settings must be active: </p>
<p>C_ENABLE_CAN_RAM_CHECK </p>
<p>C_ENABLE_CAN_RAM_CHECK_EXTENDED </p>
<p>or </p>
<p>C_ENABLE_CAN_HW_RAM_CHECK </p>
<p><b>Important note: </b>Be aware of undefined runtime behavior if </p>
<p>kCanEnableCommunication</p>
<p> is returned as </p>
<p>the driver tries to initialize and communicate despite corrupt RAM was found. The application has to verify </p>
<p>the system in this case. </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>28 /46 </p>
<p> </p>
<p>The following service functions are provided by the driver in context of the extended CAN </p>
<p>RAM check feature. </p>
<p> </p>
<p><b>CanEnableChannelCommunication </b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>CanEnableChannelCommunication </b>(vuint8 suppressRamCheck) </p>
<p>Multiple Receive Channel </p>
<p>void <b>CanEnableChannelCommunication </b>(CanChannelHandle channel, </p>
<p>vuint8 suppressRamCheck) </p>
<p><b>Parameter </b></p>
<p>CanChannelHandle channel </p>
<p>This parameter specifies the CAN channel that shall be re-enabled. </p>
<p>vuint8 suppressRamCheck </p>
<p><b>kCanTrue – </b></p>
<p>RAM check will be suppressed while re-enabling the </p>
<p>communication on the channel. </p>
<p><b>kCanFalse – </b></p>
<p>RAM check will be performed while re-enabling the </p>
<p>communication on the channel </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The function re-enables the channel communication if it was disabled previously. It calls </p>
<p>CanInit()</p>
<p> </p>
<p>internally but all eventually disabled mailboxes stay disabled. If the RAM check is not suppressed it can fail </p>
<p>again and the appropriate call-back function is invoked in this case. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>Restriction</b>: Same restrictions as for a call of </p>
<p>CanInit()</p>
<p> apply. </p>
<p><b>Call context</b>: This function is called by the application. </p>
<p><b>Configuration</b>: The following settings must be active: </p>
<p>C_ENABLE_CAN_RAM_CHECK </p>
<p>C_ENABLE_CAN_RAM_CHECK_EXTENDED </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>29 /46 </p>
<p> </p>
<p><b>CanEnableMailboxCommunication </b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>vuint8 <b>CanEnableMailboxCommunication </b>(CanObjectHandle </p>
<p>hwObjHandle) </p>
<p>Multiple Receive Channel </p>
<p>vuint8 <b>CanEnableMailboxCommunication </b>(CanChannelHandle channel, </p>
<p>CanObjectHandle hwObjHandle) </p>
<p><b>Parameter </b></p>
<p>CanChannelHandle channel </p>
<p>This parameter specifies the CAN channel for which the mailbox shall be </p>
<p>re-enabled. </p>
<p>CanObjectHandle </p>
<p>hwObjHandle </p>
<p>The index of the mailbox to be re-enabled. </p>
<p><b>Return code </b></p>
<p>vuint8 </p>
<p><b>kCanOk</b></p>
<p> </p>
<p><b>-</b></p>
<p> Mailbox communication was re-enabled. </p>
<p><b>kCanFailed</b></p>
<p> </p>
<p><b>-</b></p>
<p> Enabling of mailbox communication failed: </p>
<p>hwObjHandle</p>
<p> is </p>
<p>not a valid Tx mailbox, the mailbox was not disabled previously or the </p>
<p>communication on the channel is still disabled. </p>
<p><b>Functional Description </b></p>
<p>The function re-enables the mailbox communication that was disabled previously by the extended CAN </p>
<p>RAM check. Note that the mailbox RAM check is not performed in scope of this function call - the </p>
<p>application must guarantee that the mailbox is not corrupt. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>Call context</b>: This function is called by the application. </p>
<p><b>Configuration</b>: The following settings must be active: </p>
<p>C_ENABLE_CAN_RAM_CHECK </p>
<p>C_ENABLE_CAN_RAM_CHECK_EXTENDED </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>30 /46 </p>
<p> </p>
<p><b>9.4 </b></p>
<p><b>CAN Interrupt Handling by Application </b></p>
<p>These additional call-back functions are used if the driver does not perform CAN interrupt </p>
<p>handling. See section 10.3 for details and the functional description. </p>
<p> </p>
<p><b>OsCanCanInterruptDisable </b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>OsCanCanInterruptDisable </b>(void) </p>
<p>Multiple Receive Channel </p>
<p>void <b>OsCanCanInterruptDisable </b>(CanChannelHandle channel) </p>
<p><b>Parameter </b></p>
<p>CanChannelHandle channel </p>
<p>This parameter specifies the CAN channel for which the interrupts shall be </p>
<p>disabled. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function is called by </p>
<p>CanCanInterruptDisable()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p>Only available if </p>
<p>C_ENABLE_OSEK_CAN_INTCTRL</p>
<p> is defined. </p>
<p> </p>
<p> </p>
<p><b>OsCanCanInterruptRestore </b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>OsCanCanInterruptRestore </b>(void) </p>
<p>Multiple Receive Channel </p>
<p>void <b>OsCanCanInterruptRestore </b>(CanChannelHandle channel) </p>
<p><b>Parameter </b></p>
<p>CanChannelHandle channel </p>
<p>This parameter specifies the CAN channel for which the interrupts shall be </p>
<p>restored. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function is called by </p>
<p>CanCanInterruptRestore()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p>Only available if </p>
<p>C_ENABLE_OSEK_CAN_INTCTRL</p>
<p> is defined. </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>31 /46 </p>
<p> </p>
<p> </p>
<p><b>ApplCanWakeupInterruptDisable </b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanWakeupInterruptDisable </b>(vuint8 channel) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanWakeupInterruptDisable </b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>vuint8 channel </p>
<p>This parameter specifies the CAN channel for which the wakeup interrupt </p>
<p>shall be disabled. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function is called by </p>
<p>CanWakeup()</p>
<p> and </p>
<p>CanInit()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p>Only available if </p>
<p>C_ENABLE_OSEK_CAN_INTCTRL</p>
<p> and </p>
<p>C_ENABLE_SLEEP_WAKEUP</p>
<p> are defined and </p>
<p>external wakeup is used. </p>
<p> </p>
<p> </p>
<p><b>ApplCanWakeupInterruptEnable </b></p>
<p><b>Prototype </b></p>
<p>Single Receive Channel </p>
<p>void <b>ApplCanWakeupInterruptEnable </b>(vuint8 channel) </p>
<p>Multiple Receive Channel </p>
<p>void <b>ApplCanWakeupInterruptEnable </b>(vuint8 channel) </p>
<p><b>Parameter </b></p>
<p>vuint8 channel </p>
<p>This parameter specifies the CAN channel for which the wakeup interrupt </p>
<p>shall be enabled. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function is called by </p>
<p>CanSleep()</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p>Only available if </p>
<p>C_ENABLE_OSEK_CAN_INTCTRL</p>
<p> and </p>
<p>C_ENABLE_SLEEP_WAKEUP</p>
<p> are defined and </p>
<p>external wakeup is used. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>32 /46 </p>
<p> </p>
<p><b>10 Implementations Hints </b></p>
<p><b>10.1 </b></p>
<p><b>Important Notes </b></p>
<p>1. </p>
<p>The </p>
<p>following </p>
<p>condition </p>
<p>will </p>
<p>lead </p>
<p>to </p>
<p>an </p>
<p>endless </p>
<p>recursion </p>
<p>in </p>
<p>the </p>
<p>CAN </p>
<p>Driver:  </p>
<p>Recursive  call  of  'CanTransmit'  within  a  confirmation  routine,  if  the  CAN  Driver  has </p>
<p>been set into the passive state by </p>
<p>CanSetPassive</p>
<p>. Recommendations are: </p>
<p><b>&gt; </b> NO CALL OF </p>
<p>CanTransmit</p>
<p> WITHIN CONFIRMATION-ROUTINES </p>
<p><b>&gt; </b> PLEASE USE </p>
<p>CanSetPassive</p>
<p> ONLY ACCORDING TO THE DESCRIPTION </p>
<p>2. </p>
<p>Only the transmit line of the CAN Driver is blocked by the functions </p>
<p>CanOffline()</p>
<p>. </p>
<p>However, messages in the transmit buffer of the CAN-Chip, are still sent. For a reliable </p>
<p>prevention  of  this  fact,  call  function </p>
<p>CanInit()</p>
<p>  after  calling </p>
<p>CanOffline()</p>
<p>.  The </p>
<p>order of the two function calls is urgently required, due to the fact, that </p>
<p>CanInit()</p>
<p> is </p>
<p>only allowed in offline mode. </p>
<p>3. </p>
<p>If the VStdLib interrupt-lock-level is used, the chosen priority level must be higher than </p>
<p>the  highest  level  of any  functionality  of  the  CAN  Driver (signal  access,  etc).  Keep  in </p>
<p>mind that smaller values represent higher priorities. </p>
<p>4. </p>
<p>Resetting  indication  flags  and  confirmation  flags  is  done  by  Read-Modify-Write.  The </p>
<p>application  is  responsible  for  consistency. </p>
<p>CanGlobalInterruptDisable()</p>
<p>  and </p>
<p>CanGlobalInterruptRestore()</p>
<p> must be called to avoid interruption by the CAN. </p>
<p>Otherwise confirmations or indications can be lost. </p>
<p>5. </p>
<p>Port and general clock settings are not handled by the driver. This has to be performed </p>
<p>by </p>
<p>the </p>
<p>upper </p>
<p>layers </p>
<p>before </p>
<p>the </p>
<p>call </p>
<p>of </p>
<p>CanInitPowerOn()</p>
<p>. </p>
<p>Please </p>
<p>check </p>
<p>the </p>
<p>appropriate hardware manual of the used derivative for details regarding the hardware </p>
<p>specific  configuration  aspects.  The  CAN  clock  (f</p>
<p>CAN</p>
<p>)  for  baudrate  generation  can  be </p>
<p>selected via the configuration tool; refer to section 11.1.2. </p>
<p>6. </p>
<p>If  external  wakeup  support  is  used  the  port  configuration  (performed  by  the  upper </p>
<p>layers) has to be extended. Besides setting the correct port functions for CAN it has to </p>
<p>be  ensured  that  this  function  is  combined  with  the  respective  external  interrupt. </p>
<p>Additionally the edge/level detection has to be configured correctly to generate interrupt </p>
<p>requests  upon  detection  of  CAN  events  (e.g.  on  low  level  or  falling  edges)  on  the </p>
<p>corresponding  pins  (see  the  hardware  manual  for  details;  refer  to  the  filter  control </p>
<p>register for instance). If the external wakeup is used the control registers of the external </p>
<p>interrupts are also fully handled by the CAN driver in default configuration. </p>
<p>7. </p>
<p>When using Green Hills or IAR compiler the ID bit of the PSW is cleared by software </p>
<p>when  any  category  1  interrupt  service  routine  of  the  CAN  driver  is  entered  to  allow </p>
<p>nesting of interrupts. For other compilers the default platform behavior is not modified </p>
<p>(the ID bit stays set) and the acknowledgement of further interrupt requests is blocked </p>
<p>when any driver ISR is processed. This default driver behavior for category 1 interrupts </p>
<p>can </p>
<p>be </p>
<p>changed </p>
<p>by </p>
<p>definition </p>
<p>of </p>
<p>C_DISABLE_NESTED_INTERRUPTS</p>
<p> </p>
<p>respectively </p>
<p>C_ENABLE_NESTED_INTERRUPTS</p>
<p> via the user configuration file. Keep in mind that the </p>
<p>feature is redundant if the compiler inserts code to allow nesting of interrupts in general </p>
<p>and always verify that the compiler generates correct code if the feature is enabled. </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>33 /46 </p>
<p> </p>
<p><b>10.2 </b></p>
<p><b>Interrupt Configuration </b></p>
<p>With  exception  of  the  CAN  related  EI  level  interrupt  control  registers  (ICn,  see  section </p>
<p>7.2.3) all further interrupt configuration within the interrupt controller address space of the </p>
<p>MCU has to be performed by the application before the call of </p>
<p>CanInitPoweron()</p>
<p>. </p>
<p>The  default  implementation  configures  table  reference  as  the  way  to  determine  the </p>
<p>interrupt  vector  (TB  bit  in  ICn  registers  is  set).  The  application  has  to  take  care  about </p>
<p>referencing the CAN interrupt service routines in the interrupt vector table - the prototypes </p>
<p>are exported in the driver header file. Please check the appropriate hardware manual of </p>
<p>the used derivative for details regarding the hardware specific configuration aspects. Table </p>
<p>10-1 shows the provided ISRs and the accordant interrupt sources (n is the index of the </p>
<p>physical  channel).  Please  note  that  it  is  configuration  dependent  whether  a  particular </p>
<p>interrupt service routine is available (see remarks in table).  </p>
<p> </p>
<p><b>CAN interrupt </b></p>
<p><b>request name </b></p>
<p><b>CAN interrupt  </b></p>
<p><b>request cause </b></p>
<p><b>Provided service </b></p>
<p><b>routine </b></p>
<p><b>Remarks </b></p>
<p>INTRCANGRECC </p>
<p>CAN RX FIFO </p>
<p>interrupt </p>
<p>CanIsrRxFifo</p>
<p> </p>
<p>Used for BasicCAN reception if ‘Rx </p>
<p>BasicCan Polling’ is not enabled or </p>
<p>‘Individual Polling’ is configured. </p>
<p>INTRCANGERR </p>
<p>CAN global error </p>
<p>interrupt </p>
<p>CanIsrGlobalStatus </p>
<p>Used for Rx BasicCAN overrun if ‘Error </p>
<p>Polling’ is not enabled. </p>
<p>INTRCANnTRX </p>
<p>CANn TX interrupt  </p>
<p>CanIsrTx_n </p>
<p>Used for transmission on physical </p>
<p>channel n if ‘Tx Polling’ is not enabled </p>
<p>or ‘Individual Polling’ is configured. </p>
<p>INTRCANnREC </p>
<p>CANn TX/RX  FIFO </p>
<p>RX complete interrupt </p>
<p>- </p>
<p>This interrupt is not used. </p>
<p>INTRCANnERR </p>
<p>CANn error interrupt </p>
<p>CanIsrStatus_n </p>
<p>Used for BusOff detection on physical </p>
<p>channel n if ‘Error Polling’ is not </p>
<p>enabled. </p>
<p>INTPn </p>
<p>External interrupt </p>
<p>(see chapter 4) </p>
<p>CanIsrWakeup_n </p>
<p>Used for wakeup detection on physical </p>
<p>channel n if the sleep/wakeup </p>
<p>functionality is enabled, the external </p>
<p>wakeup is used and ‘Wakeup Polling’ is </p>
<p>not enabled. </p>
<p>Table 10-1  </p>
<p>Interrupt Service Routines </p>
<p>If the INTC shall implement direct jumps to an address determined by the interrupt priority </p>
<p>level  (instead  of  table  reference)  the  switch </p>
<p>C_ENABLE_DIRECT_INTERRUPT_BRANCH</p>
<p> </p>
<p>has to be defined via the user configuration file. (This setting affects the TB bit in the ICn </p>
<p>registers.) In this case the application has to implement a common service routine for all </p>
<p>CAN interrupts and jump to it from the corresponding address (refer to hardware manual </p>
<p>for configuration aspects).  </p>
<p>See below an implementation example for Green Hills compiler and a full interrupt system </p>
<p>with disabled sleep/wakeup functionality that uses physical channels 1 and 4; also refer to </p>
<p>the information in table 10-1 about the presence of the individual CAN interrupt functions. </p>
<p>Each driver routine must not be called if the CAN interrupts for the corresponding channel </p>
<p>(respectively  any  CAN  channel  for  the  global  handlers)  are  currently  disabled.  This  is </p>
<p>especially relevant if more than one channel is used or other interrupt sources also call the </p>
<p>common service routine. In general it is recommended to check the status of the MK bit in </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>34 /46 </p>
<p> </p>
<p>the  ICn  register  of  each  CAN  interrupt  source  before  invoking  the  corresponding  driver </p>
<p>routine as these bits directly indicate the status of the CAN interrupt lock mechanism. Any </p>
<p>driver routine may only be called if the corresponding interrupt source is enabled (MK bit </p>
<p>== 0). These actions may differ if the application handles the CAN interrupt disable/restore </p>
<p>mechanism (see section 10.3 below), but the requirements above must always be met. If </p>
<p>the feature “Multiple Configurations” is used only functions corresponding to channels that </p>
<p>are used in the active identity should be called. </p>
<p> </p>
<p>#pragma ghs interrupt </p>
<p>void CommonIsr_Prio_x ( void ) </p>
<p>{ </p>
<p>  /* handling for other interrupts that are assigned to  </p>
<p>     this priority and not handled by table reference   */ </p>
<p> </p>
<p>  /* CAN interrupts */ </p>
<p>  if (MK bit of INTRCANGRECC == 0) CanIsrRxFifo(); </p>
<p>  if (MK bit of INTRCANGERR == 0) CanIsrGlobalStatus(); </p>
<p>  if (MK bit of INTRCAN1ERR == 0) CanIsrStatus_1(); </p>
<p>  if (MK bit of INTRCAN1TRX == 0) CanIsrTx_1(); </p>
<p>  if (MK bit of INTRCAN4ERR == 0) CanIsrStatus_4(); </p>
<p>  if (MK bit of INTRCAN4TRX == 0) CanIsrTx_4(); </p>
<p> </p>
<p>  /* handling for other interrupts that are assigned to  </p>
<p>     this priority and not handled by table reference   */ </p>
<p>} </p>
<p> </p>
<p>Since  the  common  service  routine  is  already  qualified  as  an  ISR  to  the  compiler,  the </p>
<p>individual CAN interrupt routines have to be configured as void-void functions if this variant </p>
<p>is used. Therefore the switch </p>
<p>C_ENABLE_ISRVOID</p>
<p> additionally has to be defined via the </p>
<p>user configuration file (if category 1 CAN interrupts are used). </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The driver performs no measures to ensure the correct functionality of the CAN </p>
<p>interrupt disable/restore mechanism if it is bypassed by the common interrupt handler </p>
<p>when </p>
<p>C_ENABLE_DIRECT_INTERRUPT_BRANCH</p>
<p> is defined. Therefore the usage of </p>
<p>this switch in not recommended in general and should only be defined if table reference </p>
<p>is not possible at all.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>10.2.1 </b></p>
<p><b>Configuration of Interrupt Vectors with IAR compiler </b></p>
<p>Instead of a manual initialization of the interrupt vector table it is possible to let the IAR </p>
<p>compiler set up the  table  by  using  the  #pragma  vector=xx  directive  (only  for category  1 </p>
<p>interrupts). This feature can be enabled via the user configuration file by defining the EI </p>
<p>level  interrupt  number  for  each  used  CAN  interrupt.  The  names  of  these  defines  are </p>
<p>derived from the corresponding ISR names. </p>
<p>See below an example for a full interrupt system with external wakeup support that uses </p>
<p>physical channels 2 and 5. Refer to the information in table 10-1 about the presence of the </p>
<p>individual CAN interrupt functions. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>35 /46 </p>
<p> </p>
<p>#define C_CANISRRXFIFO_VECTOR         15 </p>
<p>#define C_CANISRGLOBALSTATUS_VECTOR 14 </p>
<p>#define C_CANISRTX_VECTOR_2           211 </p>
<p>#define C_CANISRSTATUS_VECTOR_2       209 </p>
<p>#define C_CANISRWAKEUP_VECTOR_2       31 </p>
<p>#define C_CANISRTX_VECTOR_5           281 </p>
<p>#define C_CANISRSTATUS_VECTOR_5       279 </p>
<p>#define C_CANISRWAKEUP_VECTOR_5       36 </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>This is an example and the necessary defines depend on the actual configuration. The </p>
<p>interrupt numbers depend on the selected derivative; refer to the hardware manual to </p>
<p>get the respective values.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>10.3 </b></p>
<p><b>CAN Interrupt Handling by Application </b></p>
<p>If an exclusive write access to the CAN related EI level interrupt control registers (ICn) is </p>
<p>not possible or if the driver must not access registers outside the CAN address space the </p>
<p>switch </p>
<p>C_ENABLE_OSEK_CAN_INTCTRL</p>
<p> has to be defined via the user configuration file. </p>
<p>In this case the driver does not access the registers of the interrupt controller at all and the </p>
<p>application has to ensure proper initialization, disabling and restoring of the CAN interrupt </p>
<p>sources. </p>
<p>The initialization of all necessary ICn has to be performed additionally by the application </p>
<p>before  the  call  of </p>
<p>CanInitPowerOn()</p>
<p>if  this  switch  is  defined.  All  used  sources  (see </p>
<p>remarks in table 10-1) have to be enabled after initialization whereas unused sources have </p>
<p>to be disabled.  </p>
<p>In  context  of  the  interrupt  disable/restore  mechanism  the  driver  implements  application </p>
<p>call-backs </p>
<p>that  are </p>
<p>used </p>
<p>whenever </p>
<p>the  functions </p>
<p>CanCanInterruptDisable() </p>
<p>or</p>
<p> </p>
<p>CanCanInterruptRestore()</p>
<p>  are  invoked  (see  section  9.4  for  API  definitions).  The </p>
<p>function </p>
<p>OsCanCanInterruptDisable()</p>
<p> should save the current mask status (MK bits) </p>
<p>of all used CAN interrupt sources that are linked to the given logical channel and then set </p>
<p>these bits to 1 in order to disable the sources. </p>
<p>OsCanCanInterruptRestore()</p>
<p> has to </p>
<p>restore the previously saved mask bits for the given logical channel. These actions may </p>
<p>differ </p>
<p>based </p>
<p>on </p>
<p>the </p>
<p>actual </p>
<p>software </p>
<p>configuration, </p>
<p>but </p>
<p>all </p>
<p>CAN </p>
<p>interrupts </p>
<p>on </p>
<p>the </p>
<p>corresponding  channel  have  to  be  locked  after  the  first  call  (nested  calls  can  occur)  of </p>
<p>OsCanCanInterruptDisable()</p>
<p>  and  be  available </p>
<p>not  until  the  last  nested  call  of </p>
<p>OsCanCanInterruptRestore()</p>
<p>. Keep in mind that the right physical channel has to be </p>
<p>chosen  based  on  the  given  logical  controller  (to  get  the  right  ICn)  and  that  the  receive </p>
<p>FIFO and global status interrupt are used by all controllers. </p>
<p>If sleep/wakeup functionality is enabled and the switch </p>
<p>C_ENABLE_OSEK_CAN_INTCTRL</p>
<p> </p>
<p>is defined please note that the external wakeup interrupts always have to be disabled after </p>
<p>initialization as these sources are only enabled on demand. Also there are two additional </p>
<p>application  call-back  functions.  See  section  9.4  for  API  definitions.  This  is  relevant  for </p>
<p>interrupt  and  polling  systems  as  the  external  interrupt  request  flag  has  to  be  cleared </p>
<p>independently of the interrupt configuration. </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>36 /46 </p>
<p> </p>
<p> </p>
<p>ApplCanWakeupInterruptEnable()</p>
<p>  is  always  invoked  in  context  of </p>
<p>CanSleep()</p>
<p>. </p>
<p>This function first has to clear the corresponding external interrupt request flag in the ICn </p>
<p>and  then  –  only  if  wakeup  processing  is  performed  by  interrupts  –  enable  the  external </p>
<p>interrupt.  Keep  in  mind  that </p>
<p>depending  on  the  current </p>
<p>status  of  the  CAN  interrupt </p>
<p>disable/restore mechanism this has to be performed either by clearing the corresponding </p>
<p>mask  bit  in  the  respective  hardware  register  or  in  the  mask  status  that  was  saved  by </p>
<p>OsCanCanInterruptDisable()</p>
<p>. </p>
<p> </p>
<p>ApplCanWakeupInterruptDisable()</p>
<p> </p>
<p>is </p>
<p>only </p>
<p>invoked </p>
<p>if </p>
<p>wakeup </p>
<p>processing </p>
<p>is </p>
<p>performed  by  interrupts  in  context  of </p>
<p>CanWakeup()</p>
<p>,  respectively  the  external  wakeup </p>
<p>handling and in </p>
<p>CanInit()</p>
<p>. This function has to disable the interrupt - depending on the </p>
<p>current  status  of  the  CAN  interrupt  disable/restore  mechanism  either  by  setting  the </p>
<p>corresponding mask bit in the hardware register or in the saved mask status. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If </p>
<p>C_ENABLE_OSEK_CAN_INTCTRL</p>
<p> is defined the driver performs no measures to </p>
<p>ensure consistency of the interrupt lock mechanism. Additionally the application has to </p>
<p>ensure correct concurrent accesses to the ICn by all modules and has to handle nested </p>
<p>calls of </p>
<p>OsCanCanInterruptDisable()</p>
<p> and</p>
<p> </p>
<p>OsCanCanInterruptRestore()</p>
<p>.Therefore the usage of this switch is not </p>
<p>recommended in general and should only be defined if the internal driver mechanisms </p>
<p>are not possible at all (e.g. write access to interrupt control registers is not allowed).</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>37 /46 </p>
<p> </p>
<p><b>11 Configuration </b></p>
<p><b>11.1 </b></p>
<p><b>Configuration by GENy </b></p>
<p>The  driver  is  configured  with  the  help  of  the  configuration  tool  GENy.  This  section </p>
<p>describes  the  configuration  of  the  driver  specific  aspects. </p>
<p>The  configuration  options </p>
<p>common to all CAN drivers are described in TechnicalReference_CANDriver.pdf. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>To get further information please refer to the online help of the generation tool. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>11.1.1 </b></p>
<p><b>Platform Settings </b></p>
<p> </p>
<p> </p>
<p>Figure 11-1 </p>
<p>GENy Platform Settings </p>
<p><b>Attribute </b></p>
<p><b>Supported </b></p>
<p><b>Values </b></p>
<p><b>Description </b></p>
<p>Preconfiguration </p>
<p> </p>
<p>Select the pre-configuration file to use. </p>
<p>Micro </p>
<p>Hw_Rh850Cpu </p>
<p>Select the target platform. </p>
<p>Derivative </p>
<p>See Table 2-1 </p>
<p>Select the specific derivative group. </p>
<p>Compiler </p>
<p>See Table 2-1 </p>
<p>Select the used compiler. </p>
<p>Table 11-1  </p>
<p>GENy Platform Settings </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>38 /46 </p>
<p> </p>
<p><b>11.1.2 </b></p>
<p><b>Component Settings </b></p>
<p> </p>
<p> </p>
<p>Figure 11-2 </p>
<p>GENy Component Settings  </p>
<p><b>Attribute </b></p>
<p><b>Supported </b></p>
<p><b>Values </b></p>
<p><b>Description </b></p>
<p>Maximum number of </p>
<p>CAN channels </p>
<p>1 - 8 </p>
<p>Enter the maximum number of physical CAN channels that </p>
<p>are supported by the actually used derivative. This value is </p>
<p>independent from the number of channels in the configuration </p>
<p>but used to determine the available hardware resources. Only </p>
<p>if this value is correct the tool can ensure valid configurations </p>
<p>for the actual derivative. Depending on the selected derivative </p>
<p>not all values may be available. </p>
<p>CAN external clock </p>
<p>source </p>
<p>true, false </p>
<p>Enable this attribute to use the external clock input </p>
<p>(clk_xincan) as CAN clock (f</p>
<p>CAN</p>
<p>). If the attribute is disabled </p>
<p>clkc is used - this is the default selection. (This setting directly </p>
<p>affects the DCS bit in the global configuration register.) </p>
<p>Table 11-2  </p>
<p>GENy Component Settings </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>39 /46 </p>
<p> </p>
<p><b>11.1.3 </b></p>
<p><b>Channel-specific Settings </b></p>
<p> </p>
<p> </p>
<p>Figure 11-3 </p>
<p>GENy Channel Specific Settings </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The sum of the shared buffers used to allocate the receive objects over all </p>
<p>channels must not exceed (“Maximum number of CAN channels”</p>
<p>  </p>
<p>* 64)</p>
<p>7</p>
<p>. This </p>
<p>includes the Rx FullCAN objects (1 buffer per actually assigned object; not the </p>
<p>value of “Rx FullCAN object allocation) and the depth of all Rx BasicCAN </p>
<p>objects (individually configurable amount of buffers, selected by the attribute </p>
<p>“Rx Fifo depth”) on all channels.  </p>
<p>The sum of used acceptance filters over all channels must not exceed </p>
<p>(“Maximum number of CAN channels” * 64)</p>
<p>7</p>
<p>. Each actually assigned Rx </p>
<p>FullCAN object uses one filter and each Rx BasicCAN object uses the number </p>
<p>of filters that is selected by the attribute “Filters per BasicCAN” on the </p>
<p>corresponding channel. </p>
<p>The generation tool checks these and other restrictions (e.g. allowed selection </p>
<p>for the attribute “Physical controller”) to ensure valid configurations. Therefore it </p>
<p>is mandatory to enter a valid value for the attribute “Maximum number of CAN </p>
<p>channels”</p>
<p>6</p>
<p>. Refer to chapter 3 for further information. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>                                            </p>
<p>7</p>
<p> Refer to section 11.1.2 for the description of the attribute “Maximum number of CAN channels“. </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>40 /46 </p>
<p> </p>
<p><b>Attribute </b></p>
<p><b>Supported </b></p>
<p><b>Values </b></p>
<p><b>Description </b></p>
<p>BCFG </p>
<p>register value </p>
<p>The value for the Channel Configuration Register. </p>
<p>Acceptance Filter </p>
<p>Configuration </p>
<p>- </p>
<p>Opens the acceptance filter dialog, see section 11.1.3.1. If </p>
<p>several init structures are created this is only possible for the </p>
<p>first structure. </p>
<p>Bustiming </p>
<p>Configuration </p>
<p>- </p>
<p>Opens the bustiming dialog to determine the value for BCFG, </p>
<p>see section 11.1.3.2. </p>
<p>Physical controller </p>
<p>CAN 0 – CAN 7 </p>
<p>Select the physical channel you want to assign to this logical </p>
<p>channel. The value is enumerated the same way as referenced </p>
<p>in the hardware manual. Depending on the selected derivative </p>
<p>and configuration of the attribute “Maximum number of CAN </p>
<p>channels” (see section 11.1.2) not all values may be available. </p>
<p>CAN interrupt priority </p>
<p>0 – 15 </p>
<p>Select the interrupt priority level of this CAN channel’s interrupts </p>
<p>that are configured if the driver has interrupt control. Depending </p>
<p>on the selected derivative not all levels may be available. See </p>
<p>section 7.2.3 and chapter 10 for further information. </p>
<p>Rx FullCAN object </p>
<p>allocation </p>
<p>0 – nRXMBmax </p>
<p>You can configure as many receive FullCAN messages on this </p>
<p>channel as specified here. This value is used to limit the </p>
<p>selection for manual or automatic configuration - only the </p>
<p>actually arranged FullCAN objects will be configured in </p>
<p>hardware. The value of nRXMBmax equals “Maximum number </p>
<p>of CAN channels” * 16. </p>
<p>Filters per BasicCAN </p>
<p>1 – 128 </p>
<p>Select how many acceptance filters will be assigned to each Rx </p>
<p>BasicCAN object on this channel; see section 11.1.3.1 for </p>
<p>details. Depending on the selected derivative not all values may </p>
<p>be available. </p>
<p>Rx Fifo process count </p>
<p>2 – 255 </p>
<p>Select the maximum number of pending receive messages that </p>
<p>are processed for each Rx BasicCAN object within one polling </p>
<p>cycle respectively one interrupt occurrence. By adjusting this </p>
<p>value it can be ensured that high FIFO loads will be evenly </p>
<p>processed by the driver. Remaining messages are processed </p>
<p>within the next polling cycle respectively the interrupt of the next </p>
<p>received message on this channel. Select greater values if </p>
<p>overruns occur. </p>
<p>Rx Fifo depth </p>
<p>4; 8; 16; 32;  </p>
<p>48; 64; 128 </p>
<p>Individually configure the depth (amount of assigned shared </p>
<p>buffers) of every Rx FIFO, that is used as Rx BasicCAN object </p>
<p>on this channel. </p>
<p>Table 11-3  </p>
<p>GENy Channel Specific Settings </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>As the RSCAN has restrictions regarding the receive buffers (e.g. no interrupt </p>
<p>processing, no overrun detection) also consider configurations without Rx FullCAN </p>
<p>objects. The large FIFO sizes and amount of filters that are possible for the BasicCAN </p>
<p>objects give similar advantages as the usage of FullCAN objects. For many </p>
<p>configurations this can be an alternative that above all is more effective regarding </p>
<p>runtime and memory usage. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>41 /46 </p>
<p> </p>
<p><b>11.1.3.1 </b></p>
<p><b>Acceptance Filter Configuration </b></p>
<p> </p>
<p> </p>
<p>Figure 11-4 </p>
<p>GENy Acceptance Filter Configuration </p>
<p><b>Attribute  </b></p>
<p><b>Supported </b></p>
<p><b>Values </b></p>
<p><b>Description </b></p>
<p>Acceptance Filter </p>
<p>representation of </p>
<p>type, mask and </p>
<p>code </p>
<p>The configured BasicCAN filters are shown. Each ID-bit is </p>
<p>represented by “0/1/X”, meaning must match “0”, “1” or don’t </p>
<p>care “X”. The number of filters can be adjusted by the attribute </p>
<p>“Filters per BasicCAN” on the channel view. </p>
<p>Type </p>
<p>standard, </p>
<p>extended </p>
<p>Select if the filter shall apply to standard or extended ID types. </p>
<p>(Based on the database and configuration only one type may </p>
<p>be available.) </p>
<p>Mask / Code </p>
<p>register values </p>
<p>The register values for this filter that will be configured in </p>
<p>hardware. </p>
<p>Open filters </p>
<p>- </p>
<p>Open the filters completely to receive all messages. </p>
<p>Optimize </p>
<p>- </p>
<p>Configure the filters automatically to just receive IDs in the </p>
<p>database if possible. A large number of filters allow better </p>
<p>optimizations, but don’t configure more filters than the </p>
<p>optimization algorithm uses for message distribution. </p>
<p>“Use FullCAN” tries to put as many messages as possible in </p>
<p>FullCAN objects. Select the maximum number of available </p>
<p>objects by adjusting the attribute “Rx FullCAN object </p>
<p>allocation” on the channel view. This is useful when only a few </p>
<p>number of BasicCAN filters are configured for example. </p>
<p>Table 11-4  </p>
<p>GENy Acceptance Filter Configuration </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>42 /46 </p>
<p> </p>
<p><b>11.1.3.1.1  Additional information if the feature “Multiple BasicCAN objects” is used </b></p>
<p>The dialog shows all BasicCAN acceptance filters for the respective channel. The amount </p>
<p>of filters equals the product of configured BasicCAN objects and the number of filters per </p>
<p>BasicCAN.  An  example  configuration  with  3  BasicCAN  objects  and  2  filters  per  object </p>
<p>results in 6 filters as shown in figure 11-5. The first 2 filters (in accordance with the attribute </p>
<p>“Filters per BasicCAN”) are assigned to the first BasicCAN object, the next 2 to the second </p>
<p>BasicCAN object and so on.  </p>
<p> </p>
<p> </p>
<p>Figure 11-5 </p>
<p>GENy Acceptance Filter Assignment </p>
<p>Please note that a received message is stored in the first mailbox with a matching filter. </p>
<p>After  an  identifier  was  compared  against  the  FullCAN  filters,  it  is  compared  against  the </p>
<p>BasicCAN filters in the order that is depicted in the dialog. This has to be considered when </p>
<p>the  feature  “Multiple  BasicCAN  objects”  is  used.  If  filter  number  1  in  the  example  from </p>
<p>figure 11-5 was open (all bits “don’t care”), all non FullCAN standard identifiers would be </p>
<p>received by BasicCAN0 and BasicCAN2 would never receive any message.  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In </p>
<p>some </p>
<p>“Multiple </p>
<p>BasicCAN” </p>
<p>configurations </p>
<p>it </p>
<p>may </p>
<p>be </p>
<p>useful </p>
<p>to </p>
<p>assign </p>
<p>certain </p>
<p>BasicCAN  messages  to  specific  hardware  objects  as  the  FIFO  depths  or  “Individual </p>
<p>Polling” settings can be adapted to the actual communication aspects for example. As </p>
<p>the  optimization  algorithms  don’t  consider this  use  case  the filters  have  to  be  edited </p>
<p>manually in this case. </p>
<p>Alternatively it is possible to configure and lock only several significant filters and then </p>
<p>use the optimization functionality. But after doing so always check the result because </p>
<p>manually configured filters may not always receive the pre-assigned identifiers as the </p>
<p>message could match an automatically assigned filter that is compared first. Focus on </p>
<p>filters with smaller numbers or add some “dummy filters” for earlier objects to achieve </p>
<p>better results.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>43 /46 </p>
<p> </p>
<p><b>11.1.3.2 </b></p>
<p><b>Bustiming Configuration </b></p>
<p> </p>
<p> </p>
<p>Figure 11-6 </p>
<p>GENy Bustiming Configuration </p>
<p><b>Attribute  </b></p>
<p><b>Supported </b></p>
<p><b>Values </b></p>
<p><b>Description </b></p>
<p>Clock </p>
<p>CAN clock </p>
<p>Set the clock frequency that is provided to the CAN cell for </p>
<p>baudrate generation (f</p>
<p>CAN</p>
<p>). Consider the setting of the </p>
<p>attribute “CAN external clock source” (see section 11.1.2). </p>
<p>Baudrate </p>
<p>baudrate </p>
<p>Set the baudrate to be used for this channel. </p>
<p>CAN BTR register </p>
<p>register value </p>
<p>Enter the value for the Channel Configuration Register (see </p>
<p>attribute BCFG in section 11.1.3). </p>
<p>Calculate </p>
<p>- </p>
<p>Calculate possible Channel Configuration Register settings </p>
<p>out of the entered baudrate or vice versa. </p>
<p>CAN_BTR, Sample, </p>
<p>BTL cycles, SJW </p>
<p>- </p>
<p>Select specific channel configuration register values to adapt </p>
<p>the sample point and sync phase to comply with your bus </p>
<p>physics. </p>
<p>Table 11-5  </p>
<p>GENy Bustiming Configuration </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>44 /46 </p>
<p> </p>
<p><b>11.2 </b></p>
<p><b>Manual Configuration </b></p>
<p>This section describes additional configuration options for special features that can only be </p>
<p>configured via the user configuration file. </p>
<p></p>
<p> </p>
<p>Define </p>
<p>C_DISABLE_NESTED_INTERRUPTS</p>
<p>  or </p>
<p>C_ENABLE_NESTED_INTERRUPTS</p>
<p>  to </p>
<p>control the nesting of the CAN interrupts. See section 10.1 for further information. </p>
<p></p>
<p> </p>
<p>Define </p>
<p>C_ENABLE_DIRECT_INTERRUPT_BRANCH</p>
<p> </p>
<p>(and </p>
<p>if </p>
<p>needed </p>
<p>additionally </p>
<p>C_ENABLE_ISRVOID</p>
<p>)  to  deactivate  table  reference  as  the  method  to  handle  CAN </p>
<p>interrupts. See section 10.2 for further information.  </p>
<p></p>
<p> </p>
<p>Define </p>
<p>C_ENABLE_OSEK_CAN_INTCTRL</p>
<p> to prohibit write accesses by the driver within </p>
<p>the interrupt controller address space. See section 10.3 for further information. </p>
<p></p>
<p> </p>
<p>Define </p>
<p>C_ENABLE_EXTERNAL_WAKEUP_SUPPRESSION</p>
<p> to disable the external wakeup </p>
<p>functionality. See chapter 4 for further information. </p>
<p></p>
<p> </p>
<p>See sections 7.2.6 to 7.2.9 for options that control different RAM test features. </p>
<p></p>
<p> </p>
<p>See  section  10.2.1  for  information  on  how  to  set  up  the  interrupt  vector  table  when </p>
<p>using IAR compiler. </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>45 /46 </p>
<p> </p>
<p><b>12 Known Issues / Limitations </b></p>
<p>1. </p>
<p>Due to hardware limitations the feature CAN RAM check is not supported for receive </p>
<p>mailboxes (no write access is possible for these objects). </p>
<p>2. </p>
<p>Due to hardware limitations receive FullCANs cannot be processed in interrupt context </p>
<p>and no overruns can be detected for these objects. </p>
<p>3. </p>
<p>With  default  configuration  the  driver  needs  exclusive  write  access  to  all  EI  level </p>
<p>interrupt control registers (ICn) that are related to a CAN interrupt source (see section </p>
<p>7.2.3 and chapter 10 for further information.). </p>
<p>4. </p>
<p>Refer </p>
<p>to </p>
<p>chapter </p>
<p>4 </p>
<p>for </p>
<p>restrictions </p>
<p>when </p>
<p>using </p>
<p>the </p>
<p>sleep/wakeup </p>
<p>functionality. </p>
<p>Additionally the global stop mode of the RSCAN is not supported. </p>
<p>5. </p>
<p>When using multiple initialization structures no multiple acceptance filter configurations </p>
<p>are  supported  by  the  driver.  The  filter  settings  are  always  derived  from  the  first </p>
<p>structure. Use several structures only to arrange multiple baudrate configurations. </p>
<p>6. </p>
<p>When using the feature Multiple ECU Configurations it is not supported to use a logical </p>
<p>channel in more than one identity. The only exception is the first logical channel which </p>
<p>can be present in any identity if it is also mapped to the physical channel CAN0. This </p>
<p>limitation  does not  apply  to  the  usage  of  physical  channels:  Every  available  physical </p>
<p>channel can be used in any identity and the same physical channel can be used in as </p>
<p>many identities as needed (if it is referenced by different logical channels). </p>
<p>7. </p>
<p>For derivatives that incorporate multiple RSCAN units only the first one (RSCAN0) is </p>
<p>supported by the driver. </p>
<p> </p>
<p> </p>
<p>For  latest  information  about  issues  or  limitations  of  the  actually  used  derivative  please </p>
<p>contact the hardware manufacturer. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Vector CAN Driver Technical Reference RH850 RSCAN </p>
<p> </p>
<p></p>
<p>2014, Vector Informatik GmbH </p>
<p>Version: 1.05.00  </p>
<p>based on template version 3.2 </p>
<p> </p>
<p>46 /46 </p>
<p> </p>
<p><b>13 Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p><b>&gt; </b> News </p>
<p><b>&gt; </b> Products </p>
<p><b>&gt; </b> Demo software </p>
<p><b>&gt; </b> Support </p>
<p><b>&gt; </b> Training data </p>
<p><b>&gt; </b> Addresses </p>
<p> </p>
<p>www.vector.com<b> </b></p>
<p> </p>
</body>
</html>
{% endraw %}