---
layout: default
title: TechnicalReference_Rte
nav_order: 4
parent: RTE
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>MICROSAR RTE </b></p>
<p>Technical Reference </p>
<p> </p>
<p>  </p>
<p>Version 4.12.0 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Author </p>
<p>PES1.3 </p>
<p>Status </p>
<p>Released </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>2 </p>
<p>based on template version 3.5 </p>
<p><b>Document Information </b></p>
<p><b>History </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>Bernd Sigle </p>
<p>2005-11-14 </p>
<p>2.0.0 </p>
<p>Document completely reworked and adapted to </p>
<p>AUTOSAR RTE  </p>
<p>Bernd Sigle </p>
<p>2006-04-20 </p>
<p>2.0.1 </p>
<p>API description for Rte_IRead / Rte_IWrite added, </p>
<p>description of used OS/COM services added </p>
<p>Bernd Sigle </p>
<p>2006-07-11 </p>
<p>2.0.2 </p>
<p>API description for Rte_Receive / Rte_Send added; </p>
<p>Adaptation to RTE SWS 1.0.0 Final </p>
<p>Martin Schlodder </p>
<p>2006-11-02 </p>
<p>2.0.3 </p>
<p>Separation of RTE and target package </p>
<p>Martin Schlodder </p>
<p>2006-11-15 </p>
<p>2.0.4 </p>
<p>Client/Server communication </p>
<p>Martin Schlodder </p>
<p>2006-12-21 </p>
<p>2.0.5 </p>
<p>Serialized client/server communication </p>
<p>Martin Schlodder </p>
<p>2007-01-17 </p>
<p>2.0.6 </p>
<p>Array data types </p>
<p>Martin Schlodder </p>
<p>2007-02-14 </p>
<p>2.0.7 </p>
<p>Added exclusive areas, removed description of </p>
<p>TargetPackages </p>
<p>Bernd Sigle </p>
<p>2007-02-19 </p>
<p>2.0.8 </p>
<p>Added transmission acknowledgement  handling and </p>
<p>minor rework of the document  </p>
<p>Bernd Sigle </p>
<p>2007-04-25 </p>
<p>2.0.9 </p>
<p>Added Rte_IStatus </p>
<p>Martin Schlodder </p>
<p>2007-04-27 </p>
<p>2.0.10 </p>
<p>Added IRV and Const/Enum </p>
<p>Martin Schlodder </p>
<p>Bernd Sigle </p>
<p>2007-05-01 </p>
<p>2.1.0 </p>
<p>Completed documentation for Version 2.2 </p>
<p>Bernd Sigle </p>
<p>2007-07-27 </p>
<p>2.1.1 </p>
<p>Added Rte_InitMemory, Rte_IWriteRef Runnable. </p>
<p>Added description of runnable activation offset und </p>
<p>updated picture of MICROSAR architecture.  </p>
<p>Martin Schlodder </p>
<p>2007-08-03 </p>
<p>2.1.2 </p>
<p>Added description of template update. </p>
<p>Martin Schlodder </p>
<p>Bernd Sigle </p>
<p>2007-11-16 </p>
<p>2.1.3 </p>
<p>Added warning regarding IWrite / IrvIWrite.           </p>
<p>Added API descriptions of VFB trace hooks. </p>
<p>Updated data type info for nested types. </p>
<p>Martin Schlodder </p>
<p>Bernd Sigle </p>
<p>2008-02-06 </p>
<p>2.1.4 </p>
<p>Updated descriptions on template merging and task </p>
<p>mapping.                                                                </p>
<p>Added description of Rte_Pim, Rte_CData, </p>
<p>Rte_Calprm and Rte_Result.                                </p>
<p>Added support of string data type.                      </p>
<p>Updated command line argument description.     </p>
<p>Added NvRAM mapping description.                    </p>
<p>Added chapter about compiler abstraction and </p>
<p>memory mapping. </p>
<p>Hannes Futter </p>
<p>2008-03-11 </p>
<p>2.1.5 </p>
<p>Additional command line switches to support direct </p>
<p>generation on xml and dcf files. </p>
<p>Bernd Sigle </p>
<p>2008-03-26 </p>
<p>2.2.0 </p>
<p>Updated description of NV Memory Mapping and </p>
<p>Chapter about limitations added.                       </p>
<p>Chapter about compiler and memory abstraction </p>
<p>updated.                                                              </p>
<p>Support for AUTOSAR Release 3.0 added. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>3 </p>
<p>based on template version 3.5 </p>
<p>Bernd Sigle </p>
<p>2008-04-16 </p>
<p>2.3.0 </p>
<p>Added description about A2L file generation and </p>
<p>updated command line options and example calls to </p>
<p>cover also the AUTOSAR XML input files. </p>
<p>Bernd Sigle </p>
<p>2008-07-16 </p>
<p>2.4.0 </p>
<p>Removed limitations for multiple instantiation and </p>
<p>compatibility mode support. </p>
<p>Bernd Sigle </p>
<p>2008-08-13 </p>
<p>2.5.0 </p>
<p>Added description of indirect APIs Rte_Port, Rte_Ports </p>
<p>and Rte_NPorts. Added description of platform </p>
<p>dependent resource calculation. </p>
<p>Bernd Sigle </p>
<p>2008-10-23 </p>
<p>2.6.0 </p>
<p>Added description of memory protection support. </p>
<p>Bernd Sigle </p>
<p>2009-01-23 </p>
<p>2.7.0 </p>
<p>Added description of mode management APIs </p>
<p>Rte_Mode and Rte_Switch and updated description of </p>
<p>Rte_Feedback.                                                      </p>
<p>Added description of Rte_Invalidate and </p>
<p>Rte_IInvalidate and added new Com APIs.           </p>
<p>Added additional runnable trigger events and removed </p>
<p>section for runnables without trigger, which is no </p>
<p>longer supported.                                             </p>
<p>Deviation for [rte_sws_2648] added.                                </p>
<p>Usage of new document template </p>
<p>Bernd Sigle </p>
<p>2009-03-26 </p>
<p>2.8.0 </p>
<p>Removed limitations for unconnected ports and for </p>
<p>data type generation. </p>
<p>Sascha Sommer </p>
<p>Bernd Sigle </p>
<p>2009-08-11 </p>
<p>2.9.0 </p>
<p>Added description about usage of basic / extended </p>
<p>task </p>
<p>Added description of command line parameter -v </p>
<p>Sascha Sommer </p>
<p>Bernd Sigle  </p>
<p>2009-10-22 </p>
<p>2.10.0 </p>
<p>Added a warning for VFB trace hooks that prevent </p>
<p>macro optimizations </p>
<p>Explained that the Activation task attribute has to be </p>
<p>set for basic tasks </p>
<p>Init-Runnables no longer need to have a special suffix </p>
<p>Explained the new periodic trigger implementation </p>
<p>dialog. </p>
<p>Server runnables with CanBeInvokedConcurrently set </p>
<p>to false do not need to be mapped to tasks when the </p>
<p>calling clients cannot interrupt each other </p>
<p>Resource Usage is now listed in a HTML report </p>
<p>Updated version of referenced documents and of </p>
<p>supported AUTOSAR release. </p>
<p>Updated examples with new workspace file extension. </p>
<p>Added new defines for memory mapping. </p>
<p>Bernd Sigle </p>
<p>2010-04-09 </p>
<p>2.11.0 </p>
<p>Added description of user header file Rte_UserTypes.h </p>
<p>Updated component history and interface functions to </p>
<p>the OS. Added pictures of Rte Interfaces and Rte </p>
<p>Include Structure. Updated picture of MICROSAR </p>
<p>architecture. Rework of chapter structure. </p>
<p>Bernd Sigle </p>
<p>2010-05-25 </p>
<p>2.11.1 </p>
<p>Added description of RTE optimization mode </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>4 </p>
<p>based on template version 3.5 </p>
<p>Bernd Sigle </p>
<p>Sascha Sommer </p>
<p>2010-05-26 </p>
<p>2.12.0 </p>
<p>Added new measurement chapter, added description </p>
<p>of COM Rx Filter, macros for access of invalid value, </p>
<p>initial value, lower and upper limit, added support of   </p>
<p>minimum start interval and second array passing </p>
<p>variant. Support of AUTOSAR Release 3.1 (RTE SWS </p>
<p>2.2.0) </p>
<p>Bernd Sigle </p>
<p> </p>
<p>2010-07-22 </p>
<p>2.13.0 </p>
<p>Added online calibration support. Removed limitation </p>
<p>of missing transmission error detection </p>
<p>Bernd Sigle </p>
<p> </p>
<p>2010-09-28 </p>
<p>2.13.1 </p>
<p>Added more detailed description of extended record </p>
<p>data type compatibility rule </p>
<p>Bernd Sigle </p>
<p> </p>
<p>2010-11-23 </p>
<p>2.14.0 </p>
<p>Removed obsolete command line parameters –bo, –bc </p>
<p>and –bn. </p>
<p>Stephanie Schaaf</p>
<p>        </p>
<p>Bernd Sigle </p>
<p>Sascha Sommer  </p>
<p>2011-07-25 </p>
<p>2.15.0 </p>
<p>Added general support of AUTOSAR Release 3.2.1 </p>
<p>(RTE SWS 2.4.0).  </p>
<p>Added support of never received status. </p>
<p>Added support of S/R update handling. </p>
<p>Mentioned that –g c and –g i ignore service </p>
<p>components when –m specifies an ECU project. </p>
<p>Explained RTE usage with Non-Trusted BSW     </p>
<p>Added hint for FUNC_P2CONST() problems </p>
<p>Explained measurement of COM signals </p>
<p>Stephanie Schaaf  </p>
<p>Bernd Sigle </p>
<p>Sascha Sommer </p>
<p>2012-01-25 </p>
<p>2.16.0 </p>
<p>Enhanced command line interface (support for several </p>
<p>generation modes in one command line call, optional </p>
<p>command line parameter –m) </p>
<p>Split of RTE into OS Application specific files </p>
<p>Byte arrays no longer need to be mapped to signals </p>
<p>groups </p>
<p>Allow configuration of Schedule() calls in non-</p>
<p>preemptive tasks </p>
<p>Bernd Sigle </p>
<p>2012-05-18 </p>
<p>2.17.0 </p>
<p>Corrected description how the Rte_IsUpdated API can </p>
<p>be enabled </p>
<p>Bernd Sigle </p>
<p>2012-09-18 </p>
<p>2.18.0 </p>
<p>Added general support of AUTOSAR Release 3.2.2 </p>
<p>(RTE SWS 2.5.0). </p>
<p>Added support of non-queued N:1 S/R communication    </p>
<p>Bernd Sigle </p>
<p>2012-08-28 </p>
<p>3.90.0 </p>
<p>AUTOSAR 4.0.3 support, DaVinci Configurator 5 </p>
<p>support  </p>
<p>Bernd Sigle</p>
<p> </p>
<p>2012-12-11 </p>
<p>4.0.0 </p>
<p>Updated API descriptions concerning </p>
<p>RTE_E_UNCONNECTED  return code </p>
<p>Added description of Rte_UserTypes.h file which is </p>
<p>now also generated with the template mechanism </p>
<p>Stephanie Schaaf</p>
<p> </p>
<p>2013-03-26 </p>
<p>4.1.0 </p>
<p>Added support of Rte_MemSeg.a2l file </p>
<p>Added description of –o sub option for A2L file path </p>
<p>Bernd Sigle</p>
<p> </p>
<p>2013-06-14 </p>
<p>4.1.1 </p>
<p>Added Multi-Core support (S/R communication) </p>
<p>Added support of Inter-Runnable Variables with </p>
<p>composite data types </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>5 </p>
<p>based on template version 3.5 </p>
<p>Katharina Benkert </p>
<p>Stephanie Schaaf </p>
<p>Sascha Sommer </p>
<p>Bernd Sigle </p>
<p>2013-10-30 </p>
<p>4.2.0 </p>
<p>Added support for arrays of dynamic data length </p>
<p>(Rte_Send/Rte_Receive) </p>
<p>Added support for parallel generation for multiple </p>
<p>component types </p>
<p>Multicore support </p>
<p>Added support for SchM Contract Phase Generation </p>
<p>Added support for Nv Block SWCs </p>
<p>Katharina Benkert </p>
<p>Sascha Sommer </p>
<p>Stephanie Schaaf </p>
<p>2014-02-06 </p>
<p>4.3.0 </p>
<p>Added support of VFB Trace Client Prefixes </p>
<p>Optimized Multicore support without IOCs </p>
<p>Memory Protection support for Multicore systems </p>
<p>Inter-ECU sender/receiver communication, queued </p>
<p>sender/receiver communication and mapped </p>
<p>client/server calls are no longer limited to the BSW </p>
<p>partition </p>
<p>Added support of Development Error Reporting </p>
<p>Added support of registering XCP Events in the XCP </p>
<p>module configuration </p>
<p>Stephanie Schaaf </p>
<p>Bernd Sigle </p>
<p>2014-06-17 </p>
<p>4.4.0 </p>
<p>Support for unconnected client ports for synchronous </p>
<p>C/S communication </p>
<p>Inter-Ecu C/S communication using SOME/IP </p>
<p>Transformer </p>
<p>Support for PR-Ports </p>
<p>S/R Serialization using SOME/IP Transformer and E2E </p>
<p>Transformer </p>
<p>Support LdCom </p>
<p>Bernd Sigle </p>
<p>2014-08-13 </p>
<p>4.4.1 </p>
<p>Described decimal coding of the version defines and </p>
<p>the return code of SchM_GetVersionInfo </p>
<p>Added chapter about additional copyrights of FOSS </p>
<p>Bernd Sigle </p>
<p>2014-09-12 </p>
<p>4.4.2 </p>
<p>Minor format changes only </p>
<p>Bernd Sigle </p>
<p>2014-08-13 </p>
<p>4.5.0 </p>
<p>Support Postbuild-Selectable for variant data </p>
<p>mappings and variant COM signals </p>
<p>Support E2E Transformer for Inter-Ecu C/S </p>
<p>communication </p>
<p>Support tasks mappings where multiple runnable or </p>
<p>schedulable entities using different cycle times or </p>
<p>activation offsets are mapped to a single Basic Task. </p>
<p>The realization uses OS Schedule Tables </p>
<p>Support Rte_DRead API </p>
<p>Enhanced support for PR-Ports </p>
<p>Support ServerArgumentImplPolicy = use </p>
<p>ArrayBaseType </p>
<p>Explicit order of ModeDeclarationGroups </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>6 </p>
<p>based on template version 3.5 </p>
<p>Bernd Sigle </p>
<p>2014-12-08 </p>
<p>4.6.0 </p>
<p>Support of PR Mode Ports </p>
<p>Support of PR Nv Ports </p>
<p>Support of bit field data types (CompuMethods with </p>
<p>category BITFIELD_TEXTTABLE) </p>
<p>Runtime optimized copying of large data </p>
<p>Support for SW-ADDR-METHOD on RAM blocks of </p>
<p>NvRAM SWCs </p>
<p>Bernd Sigle </p>
<p>2015-02-20 </p>
<p>4.7.0 </p>
<p>Support of background triggers </p>
<p>Support of data prototype mappings </p>
<p>Support of bit field text table mappings </p>
<p>Support of union data types </p>
<p>Support of UTF16 data type serialization in the </p>
<p>SOME/IP transformer </p>
<p>Runtime optimization in the generated RTE code by </p>
<p>usage of optimized interrupt locking APIs of the </p>
<p>MICROSAR OS  </p>
<p>Support of further E2E profiles for data transformation </p>
<p>with the SOME/IP and E2E transformer </p>
<p>Support of OS counters with tick durations smaller </p>
<p>than 1µs </p>
<p>Bernd Sigle </p>
<p>2015-07-26 </p>
<p>4.8.0 </p>
<p>Support of COM based Transformer ComXf  </p>
<p>Support of different strategies for writing NV data in Nv </p>
<p>Block SWCs  </p>
<p>Support of C/S Interfaces for Nv Block SWCs  </p>
<p>SWC Template generation provides user sections for </p>
<p>documentation of runnable entities  </p>
<p>Wide character support in paths  </p>
<p>Improved counter selection for operating systems with </p>
<p>multiple OS applications  </p>
<p>Support of optimized macro implementation for </p>
<p>SchM_Enter and SchM_Exit  </p>
<p>Enhanced OS Spinlock support  </p>
<p>Enable optimizations in QM partitions </p>
<p>Bernd Sigle </p>
<p>2016-01-04 </p>
<p>4.9.0 </p>
<p>Support of BSW multiple partition distribution </p>
<p>Support of activation reason for runnable entities </p>
<p>(Rte_ActivatingEvent) </p>
<p>Support for initialization of send buffers for implicit S/R </p>
<p>communication</p>
<p> </p>
<p>Generation of VFB Trace Hook calls only if hooks are </p>
<p>configured </p>
<p>Support of 64 events per task if supported by the </p>
<p>MICROSAR OS </p>
<p>Support of subelement mapping for Rx-GroupSignals </p>
<p>Support for RteUseComShadowSignalApi </p>
<p>Updated CFG5 figures </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>7 </p>
<p>based on template version 3.5 </p>
<p>Bernd Sigle </p>
<p>2016-02-23 </p>
<p>4.10.0 </p>
<p>AUTOSAR 4.2.2 support </p>
<p>Enhanced SomeIpXf support </p>
<p>Support of literal prefix </p>
<p>Migration to new Vector CI </p>
<p>Bernd Sigle </p>
<p>Sascha Sommer </p>
<p>2016-05-13 </p>
<p>4.11.0 </p>
<p>Support of application data types of category map, </p>
<p>curve and axis </p>
<p>Selection of COM signal timeout source (Swc / Signal)  </p>
<p>Support of 1:n Inter-ECU S/R with transmission </p>
<p>acknowledgement </p>
<p>Support E2EXf for primitive byte arrays without </p>
<p>serializer </p>
<p>Autonomous error responses for Inter-ECU C/S with </p>
<p>SomeIpXf </p>
<p>Described mapping of SWCs to OS Applications. </p>
<p>Bernd Sigle </p>
<p> </p>
<p>2016-07-14 </p>
<p>4.12.0 </p>
<p>Support of connections between Nv ports and S/R </p>
<p>ports </p>
<p>Support of Diagnostic Data Transformation (DiagXf) </p>
<p>Support of Data Conversion between integer data </p>
<p>types on network signals and floating point data types </p>
<p>on SWC ports </p>
<p>Support of counters from different partitions that are </p>
<p>assigned to the same core </p>
<p>Updated RTE and SWC include structure </p>
<p>Table 1-1  </p>
<p>History of the document </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>8 </p>
<p>based on template version 3.5 </p>
<p><b>Reference Documents </b></p>
<p><b>No. </b></p>
<p><b>Title </b></p>
<p><b>Version </b></p>
<p>[1] </p>
<p> </p>
<p>AUTOSAR_SWS_RTE.pdf </p>
<p>4.2.2 </p>
<p>[2] </p>
<p> </p>
<p>AUTOSAR_EXP_VFB.pdf  </p>
<p>4.2.2 </p>
<p>[3] </p>
<p> </p>
<p>AUTOSAR_SWS_COM.pdf </p>
<p>4.2.2 </p>
<p>[4] </p>
<p> </p>
<p>AUTOSAR_SWS_OS.pdf </p>
<p>4.2.2 </p>
<p>[5] </p>
<p> </p>
<p>AUTOSAR_SWS_NVRAMManager.pdf </p>
<p>4.2.2 </p>
<p>[6] </p>
<p> </p>
<p>AUTOSAR_SWS_ECU_StateManager.pdf </p>
<p>4.2.2 </p>
<p>[7] </p>
<p> </p>
<p>AUTOSAR_SWS_StandardTypes.pdf </p>
<p>4.2.2 </p>
<p>[8] </p>
<p> </p>
<p>AUTOSAR_SWS_PlatformTypes.pdf </p>
<p>4.2.2 </p>
<p>[9] </p>
<p> </p>
<p>AUTOSAR_SWS_CompilerAbstraction.pdf </p>
<p>4.2.2 </p>
<p>[10]  </p>
<p>AUTOSAR_SWS_MemoryMapping.pdf </p>
<p>4.2.2 </p>
<p>[11]  </p>
<p>AUTOSAR_TPS_SoftwareComponentTemplate.pdf </p>
<p>4.2.2 </p>
<p>[12]  </p>
<p>AUTOSAR_TPS_SystemTemplate.pdf </p>
<p>4.2.2 </p>
<p>[13]  </p>
<p>AUTOSAR_TPS_ECUConfiguration.pdf </p>
<p>4.2.2 </p>
<p>[14]  </p>
<p>AUTOSAR_TR_Glossary.pdf </p>
<p>4.2.2 </p>
<p>[15]  </p>
<p>AUTOSAR_TPS_BSWModuleDescriptionTemplate.pdf </p>
<p>4.2.2 </p>
<p>[16]  </p>
<p>AUTOSAR_SWS_XCP.pdf </p>
<p>4.2.2 </p>
<p>[17]  </p>
<p>AUTOSAR_SWS_ DefaultErrorTracer.pdf </p>
<p>4.2.2 </p>
<p>[18]  </p>
<p>AUTOSAR_SWS_LargeDataCOM.pdf </p>
<p>4.2.2 </p>
<p>[19]  </p>
<p>AUTOSAR_SWS_SOMEIPTransformer.pdf </p>
<p>4.2.2 </p>
<p>[20]  </p>
<p>AUTOSAR_SWS_COMBasedTransformer.pdf </p>
<p>4.2.2 </p>
<p>[21]  </p>
<p>AUTOSAR_SWS_E2ETransformer.pdf </p>
<p>4.2.2 </p>
<p>[22]  </p>
<p>Vector DaVinci Configurator Online help </p>
<p> </p>
<p>[23]  </p>
<p>Vector DaVinci Developer Online help </p>
<p> </p>
<p>[24]  </p>
<p>AUTOSAR Calibration User Guide </p>
<p>1.0 </p>
<p>Table 1-2  </p>
<p>Reference documents </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Scope of the Document </b></p>
<p>This document describes the MICROSAR RTE. It assumes that the reader is familiar with </p>
<p>the </p>
<p>AUTOSAR </p>
<p>architecture, </p>
<p>especially </p>
<p>the </p>
<p>software </p>
<p>component </p>
<p>(SWC) </p>
<p>design </p>
<p>methodology and the AUTOSAR RTE specification. It also assumes basic knowledge of </p>
<p>some basic software (BSW) modules like AUTOSAR Os, Com, LdCom, Transformer,  NvM </p>
<p>and  EcuM. The  description  of  those  components  is  not  part  of  this  documentation.  The </p>
<p>related documents are listed in Table 1-2. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>9 </p>
<p>based on template version 3.5 </p>
<p> </p>
<p><b>Please note </b></p>
<p>We have configured the programs in accordance with your specifications in the </p>
<p>questionnaire. Whereas the programs do support other configurations than the one </p>
<p>specified in your questionnaire, Vector´s release of the programs delivered to your </p>
<p>company is expressly restricted to the configuration you have specified in the </p>
<p>questionnaire. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>10 </p>
<p>based on template version 3.5 </p>
<p><b>Contents </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>Component History .................................................................................................... 16</b></p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>Introduction................................................................................................................. 21</b></p>
<p> </p>
<p>2.1</p>
<p> </p>
<p>Architecture Overview ...................................................................................... 22</p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Functional Description ............................................................................................... 25</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>Features .......................................................................................................... 25</p>
<p> </p>
<p>3.1.1</p>
<p> </p>
<p>Deviations ........................................................................................ 27</p>
<p> </p>
<p>3.1.2</p>
<p> </p>
<p>Additions/ Extensions ....................................................................... 28</p>
<p> </p>
<p>3.1.3</p>
<p> </p>
<p>Limitations ........................................................................................ 28</p>
<p> </p>
<p>3.2</p>
<p> </p>
<p>Initialization ...................................................................................................... 29</p>
<p> </p>
<p>3.3</p>
<p> </p>
<p>AUTOSAR ECUs ............................................................................................. 29</p>
<p> </p>
<p>3.4</p>
<p> </p>
<p>AUTOSAR Software Components.................................................................... 29</p>
<p> </p>
<p>3.5</p>
<p> </p>
<p>Runnable Entities ............................................................................................. 29</p>
<p> </p>
<p>3.6</p>
<p> </p>
<p>Triggering of Runnable Entities ........................................................................ 30</p>
<p> </p>
<p>3.6.1</p>
<p> </p>
<p>Time Triggered Runnables ............................................................... 30</p>
<p> </p>
<p>3.6.2</p>
<p> </p>
<p>Data Received Triggered Runnables ................................................ 31</p>
<p> </p>
<p>3.6.3</p>
<p> </p>
<p>Data Reception Error Triggered Runnables ...................................... 31</p>
<p> </p>
<p>3.6.4</p>
<p> </p>
<p>Data Send Completed Triggered Runnables .................................... 31</p>
<p> </p>
<p>3.6.5</p>
<p> </p>
<p>Mode Switch Triggered Runnables ................................................... 31</p>
<p> </p>
<p>3.6.6</p>
<p> </p>
<p>Mode Switched Acknowledge Triggered Runnables ......................... 31</p>
<p> </p>
<p>3.6.7</p>
<p> </p>
<p>Operation Invocation Triggered Runnables ...................................... 32</p>
<p> </p>
<p>3.6.8</p>
<p> </p>
<p>Asynchronous Server Call Return Triggered Runnables .................. 32</p>
<p> </p>
<p>3.6.9</p>
<p> </p>
<p>Init Triggered Runnables .................................................................. 32</p>
<p> </p>
<p>3.6.10</p>
<p> </p>
<p>Background Triggered Runnables .................................................... 32</p>
<p> </p>
<p>3.7</p>
<p> </p>
<p>Exclusive Areas ............................................................................................... 33</p>
<p> </p>
<p>3.7.1</p>
<p> </p>
<p>OS Interrupt Blocking ....................................................................... 33</p>
<p> </p>
<p>3.7.2</p>
<p> </p>
<p>All Interrupt Blocking ........................................................................ 34</p>
<p> </p>
<p>3.7.3</p>
<p> </p>
<p>OS Resource ................................................................................... 34</p>
<p> </p>
<p>3.7.4</p>
<p> </p>
<p>Cooperative Runnable Placement .................................................... 34</p>
<p> </p>
<p>3.8</p>
<p> </p>
<p>Error Handling .................................................................................................. 35</p>
<p> </p>
<p>3.8.1</p>
<p> </p>
<p>Development Error Reporting ........................................................... 35</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>RTE Generation and Integration ................................................................................ 37</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Scope of Delivery ............................................................................................. 37</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>RTE Generation ............................................................................................... 38</p>
<p> </p>
<p>4.2.1</p>
<p> </p>
<p>Command Line Options ................................................................... 38</p>
<p> </p>
<p>4.2.2</p>
<p> </p>
<p>RTE Generator Command Line Options ........................................... 38</p>
<p> </p>
<p>4.2.3</p>
<p> </p>
<p>Generation Path ............................................................................... 40</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>11 </p>
<p>based on template version 3.5 </p>
<p>4.3</p>
<p> </p>
<p>MICROSAR RTE generation modes ................................................................ 40</p>
<p> </p>
<p>4.3.1</p>
<p> </p>
<p>RTE Generation Phase .................................................................... 40</p>
<p> </p>
<p>4.3.2</p>
<p> </p>
<p>RTE Contract Phase Generation ...................................................... 42</p>
<p> </p>
<p>4.3.3</p>
<p> </p>
<p>Template Code Generation for Application Software Components ... 44</p>
<p> </p>
<p>4.3.4</p>
<p> </p>
<p>VFB Trace Hook Template Code Generation .................................... 45</p>
<p> </p>
<p>4.4</p>
<p> </p>
<p>Include Structure .............................................................................................. 46</p>
<p> </p>
<p>4.4.1</p>
<p> </p>
<p>RTE Include Structure ...................................................................... 46</p>
<p> </p>
<p>4.4.2</p>
<p> </p>
<p>SWC Include Structure ..................................................................... 47</p>
<p> </p>
<p>4.4.3</p>
<p> </p>
<p>BSW Include Structure ..................................................................... 48</p>
<p> </p>
<p>4.5</p>
<p> </p>
<p>Compiler Abstraction and Memory Mapping ..................................................... 49</p>
<p> </p>
<p>4.5.1</p>
<p> </p>
<p>Memory Sections for Calibration Parameters and Per-Instance </p>
<p>Memory ............................................................................................ 51</p>
<p> </p>
<p>4.5.2</p>
<p> </p>
<p>Memory Sections for Software Components .................................... 52</p>
<p> </p>
<p>4.5.3</p>
<p> </p>
<p>Compiler Abstraction Symbols for Software Components and RTE .. 53</p>
<p> </p>
<p>4.6</p>
<p> </p>
<p>Memory Protection Support ............................................................................. 54</p>
<p> </p>
<p>4.6.1</p>
<p> </p>
<p>Partitioning of SWCs ........................................................................ 54</p>
<p> </p>
<p>4.6.2</p>
<p> </p>
<p>OS Applications ................................................................................ 54</p>
<p> </p>
<p>4.6.3</p>
<p> </p>
<p>Partitioning Architecture ................................................................... 55</p>
<p> </p>
<p>4.6.4</p>
<p> </p>
<p>Conceptual Aspects ......................................................................... 58</p>
<p> </p>
<p>4.6.5</p>
<p> </p>
<p>Memory Protection Integration Hints ................................................ 59</p>
<p> </p>
<p>4.7</p>
<p> </p>
<p>Multicore support ............................................................................................. 60</p>
<p> </p>
<p>4.7.1</p>
<p> </p>
<p>Partitioning of SWCs ........................................................................ 60</p>
<p> </p>
<p>4.7.2</p>
<p> </p>
<p>BSW in Multicore Systems ............................................................... 60</p>
<p> </p>
<p>4.7.3</p>
<p> </p>
<p>Service BSW in Multicore Systems .................................................. 61</p>
<p> </p>
<p>4.7.4</p>
<p> </p>
<p>IOC Usage ....................................................................................... 62</p>
<p> </p>
<p>4.8</p>
<p> </p>
<p>BSW Access in Partitioned systems ................................................................. 62</p>
<p> </p>
<p>4.8.1</p>
<p> </p>
<p>Inter-ECU Communication ............................................................... 62</p>
<p> </p>
<p>4.8.2</p>
<p> </p>
<p>Client Server communication ........................................................... 63</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>API Description ........................................................................................................... 64</b></p>
<p> </p>
<p>5.1</p>
<p> </p>
<p>Data Type Definition ......................................................................................... 64</p>
<p> </p>
<p>5.1.1</p>
<p> </p>
<p>Invalid Value ..................................................................................... 65</p>
<p> </p>
<p>5.1.2</p>
<p> </p>
<p>Upper and Lower Limit ..................................................................... 65</p>
<p> </p>
<p>5.1.3</p>
<p> </p>
<p>Initial Value....................................................................................... 65</p>
<p> </p>
<p>5.2</p>
<p> </p>
<p>API Error Status ............................................................................................... 66</p>
<p> </p>
<p>5.3</p>
<p> </p>
<p>Runnable Entities ............................................................................................. 67</p>
<p> </p>
<p>5.3.1</p>
<p> </p>
<p>&lt;RunnableEntity&gt; ............................................................................ 67</p>
<p> </p>
<p>5.3.2</p>
<p> </p>
<p>Runnable Activation Reason ............................................................ 68</p>
<p> </p>
<p>5.4</p>
<p> </p>
<p>SWC Exclusive Areas ...................................................................................... 69</p>
<p> </p>
<p>5.4.1</p>
<p> </p>
<p>Rte_Enter ......................................................................................... 69</p>
<p> </p>
<p>5.4.2</p>
<p> </p>
<p>Rte_Exit ........................................................................................... 70</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>12 </p>
<p>based on template version 3.5 </p>
<p>5.5</p>
<p> </p>
<p>BSW Exclusive Areas ...................................................................................... 71</p>
<p> </p>
<p>5.5.1</p>
<p> </p>
<p>SchM_Enter ..................................................................................... 71</p>
<p> </p>
<p>5.5.2</p>
<p> </p>
<p>SchM_Exit ........................................................................................ 72</p>
<p> </p>
<p>5.6</p>
<p> </p>
<p>Sender-Receiver Communication .................................................................... 73</p>
<p> </p>
<p>5.6.1</p>
<p> </p>
<p>Rte_Read ......................................................................................... 73</p>
<p> </p>
<p>5.6.2</p>
<p> </p>
<p>Rte_DRead ...................................................................................... 74</p>
<p> </p>
<p>5.6.3</p>
<p> </p>
<p>Rte_Write ......................................................................................... 75</p>
<p> </p>
<p>5.6.4</p>
<p> </p>
<p>Rte_Receive .................................................................................... 76</p>
<p> </p>
<p>5.6.5</p>
<p> </p>
<p>Rte_Send ......................................................................................... 77</p>
<p> </p>
<p>5.6.6</p>
<p> </p>
<p>Rte_IRead ........................................................................................ 78</p>
<p> </p>
<p>5.6.7</p>
<p> </p>
<p>Rte_IWrite ........................................................................................ 79</p>
<p> </p>
<p>5.6.8</p>
<p> </p>
<p>Rte_IWriteRef .................................................................................. 80</p>
<p> </p>
<p>5.6.9</p>
<p> </p>
<p>Rte_IStatus ...................................................................................... 81</p>
<p> </p>
<p>5.6.10</p>
<p> </p>
<p>Rte_Feedback .................................................................................. 82</p>
<p> </p>
<p>5.6.11</p>
<p> </p>
<p>Rte_IsUpdated ................................................................................. 83</p>
<p> </p>
<p>5.7</p>
<p> </p>
<p>Data Element Invalidation ................................................................................ 84</p>
<p> </p>
<p>5.7.1</p>
<p> </p>
<p>Rte_Invalidate .................................................................................. 84</p>
<p> </p>
<p>5.7.2</p>
<p> </p>
<p>Rte_IInvalidate ................................................................................. 85</p>
<p> </p>
<p>5.8</p>
<p> </p>
<p>Mode Management .......................................................................................... 86</p>
<p> </p>
<p>5.8.1</p>
<p> </p>
<p>Rte_Switch ....................................................................................... 86</p>
<p> </p>
<p>5.8.2</p>
<p> </p>
<p>Rte_Mode ........................................................................................ 87</p>
<p> </p>
<p>5.8.3</p>
<p> </p>
<p>Enhanced Rte_Mode ....................................................................... 88</p>
<p> </p>
<p>5.8.4</p>
<p> </p>
<p>Rte_SwitchAck ................................................................................. 89</p>
<p> </p>
<p>5.9</p>
<p> </p>
<p>Inter-Runnable Variables .................................................................................. 90</p>
<p> </p>
<p>5.9.1</p>
<p> </p>
<p>Rte_IrvRead ..................................................................................... 90</p>
<p> </p>
<p>5.9.2</p>
<p> </p>
<p>Rte_IrvWrite ..................................................................................... 91</p>
<p> </p>
<p>5.9.3</p>
<p> </p>
<p>Rte_IrvIRead .................................................................................... 92</p>
<p> </p>
<p>5.9.4</p>
<p> </p>
<p>Rte_IrvIWrite .................................................................................... 93</p>
<p> </p>
<p>5.10</p>
<p> </p>
<p>Per-Instance Memory ....................................................................................... 94</p>
<p> </p>
<p>5.10.1</p>
<p> </p>
<p>Rte_Pim ........................................................................................... 94</p>
<p> </p>
<p>5.11</p>
<p> </p>
<p>Calibration Parameters .................................................................................... 95</p>
<p> </p>
<p>5.11.1</p>
<p> </p>
<p>Rte_CData ....................................................................................... 95</p>
<p> </p>
<p>5.11.2</p>
<p> </p>
<p>Rte_Prm ........................................................................................... 96</p>
<p> </p>
<p>5.12</p>
<p> </p>
<p>Client-Server Communication .......................................................................... 97</p>
<p> </p>
<p>5.12.1</p>
<p> </p>
<p>Rte_Call ........................................................................................... 97</p>
<p> </p>
<p>5.12.2</p>
<p> </p>
<p>Rte_Result ....................................................................................... 98</p>
<p> </p>
<p>5.13</p>
<p> </p>
<p>Indirect API ...................................................................................................... 99</p>
<p> </p>
<p>5.13.1</p>
<p> </p>
<p>Rte_Ports ......................................................................................... 99</p>
<p> </p>
<p>5.13.2</p>
<p> </p>
<p>Rte_NPorts .................................................................................... 100</p>
<p> </p>
<p>5.13.3</p>
<p> </p>
<p>Rte_Port ......................................................................................... 101</p>
<p> </p>
<p>5.14</p>
<p> </p>
<p>RTE Lifecycle API .......................................................................................... 102</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>13 </p>
<p>based on template version 3.5 </p>
<p>5.14.1</p>
<p> </p>
<p>Rte_Start ........................................................................................ 102</p>
<p> </p>
<p>5.14.2</p>
<p> </p>
<p>Rte_Stop ........................................................................................ 102</p>
<p> </p>
<p>5.14.3</p>
<p> </p>
<p>Rte_InitMemory .............................................................................. 103</p>
<p> </p>
<p>5.15</p>
<p> </p>
<p>SchM Lifecycle API ........................................................................................ 104</p>
<p> </p>
<p>5.15.1</p>
<p> </p>
<p>SchM_Init ....................................................................................... 104</p>
<p> </p>
<p>5.15.2</p>
<p> </p>
<p>SchM_Deinit .................................................................................. 104</p>
<p> </p>
<p>5.15.3</p>
<p> </p>
<p>SchM_GetVersionInfo .................................................................... 105</p>
<p> </p>
<p>5.16</p>
<p> </p>
<p>VFB Trace Hooks ........................................................................................... 106</p>
<p> </p>
<p>5.16.1</p>
<p> </p>
<p>Rte_[&lt;client&gt;_]&lt;API&gt;Hook_&lt;cts&gt;_&lt;ap&gt;_Start ............................... 106</p>
<p> </p>
<p>5.16.2</p>
<p> </p>
<p>Rte_[&lt;client&gt;_]&lt;API&gt;Hook_&lt;cts&gt;_&lt;ap&gt;_Return ............................ 107</p>
<p> </p>
<p>5.16.3</p>
<p> </p>
<p>SchM_[&lt;client&gt;_]&lt;API&gt;Hook_&lt;Bsw&gt;_&lt;ap&gt;_Start ......................... 108</p>
<p> </p>
<p>5.16.4</p>
<p> </p>
<p>SchM_[&lt;client&gt;_]&lt;API&gt;Hook_&lt;Bsw&gt;_&lt;ap&gt;_Return ...................... 109</p>
<p> </p>
<p>5.16.5</p>
<p> </p>
<p>Rte_[&lt;client&gt;_]ComHook_&lt;SignalName&gt;_SigTx ........................... 110</p>
<p> </p>
<p>5.16.6</p>
<p> </p>
<p>Rte_[&lt;client&gt;_]ComHook_&lt;SignalName&gt;_SigIv ............................. 111</p>
<p> </p>
<p>5.16.7</p>
<p> </p>
<p>Rte_[&lt;client&gt;_]ComHook_&lt;SignalName&gt;_SigGroupIv .................. 112</p>
<p> </p>
<p>5.16.8</p>
<p> </p>
<p>Rte_[&lt;client&gt;_]ComHook_&lt;SignalName&gt;_SigRx .......................... 113</p>
<p> </p>
<p>5.16.9</p>
<p> </p>
<p>Rte_[&lt;client&gt;_]ComHook&lt;Event&gt;_&lt;SignalName&gt; ......................... 114</p>
<p> </p>
<p>5.16.10</p>
<p> </p>
<p>Rte_[&lt;client&gt;_]Task_Activate ......................................................... 115</p>
<p> </p>
<p>5.16.11</p>
<p> </p>
<p>Rte_[&lt;client&gt;_]Task_Dispatch ........................................................ 115</p>
<p> </p>
<p>5.16.12</p>
<p> </p>
<p>Rte_[&lt;client&gt;_]Task_SetEvent ....................................................... 116</p>
<p> </p>
<p>5.16.13</p>
<p> </p>
<p>Rte_[&lt;client&gt;_]Task_WaitEvent ...................................................... 116</p>
<p> </p>
<p>5.16.14</p>
<p> </p>
<p>Rte_[&lt;client&gt;_]Task_WaitEventRet ................................................ 117</p>
<p> </p>
<p>5.16.15</p>
<p> </p>
<p>Rte_[&lt;client&gt;_]Runnable_&lt;cts&gt;_&lt;re&gt;_Start .................................. 117</p>
<p> </p>
<p>5.16.16</p>
<p> </p>
<p>Rte_[&lt;client&gt;_]Runnable_&lt;cts&gt;_&lt;re&gt;_Return ............................... 118</p>
<p> </p>
<p>5.17</p>
<p> </p>
<p>RTE Interfaces to BSW .................................................................................. 119</p>
<p> </p>
<p>5.17.1</p>
<p> </p>
<p>Interface to COM / LDCOM ............................................................ 119</p>
<p> </p>
<p>5.17.2</p>
<p> </p>
<p>Interface to Transformer ................................................................. 120</p>
<p> </p>
<p>5.17.3</p>
<p> </p>
<p>Interface to OS ............................................................................... 121</p>
<p> </p>
<p>5.17.4</p>
<p> </p>
<p>Interface to NVM ............................................................................ 122</p>
<p> </p>
<p>5.17.5</p>
<p> </p>
<p>Interface to XCP ............................................................................. 122</p>
<p> </p>
<p>5.17.6</p>
<p> </p>
<p>Interface to SCHM ......................................................................... 123</p>
<p> </p>
<p>5.17.7</p>
<p> </p>
<p>Interface to DET ............................................................................. 123</p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b>RTE Configuration .................................................................................................... 124</b></p>
<p> </p>
<p>6.1</p>
<p> </p>
<p>Configuration Variants .................................................................................... 124</p>
<p> </p>
<p>6.2</p>
<p> </p>
<p>Task Configuration ......................................................................................... 124</p>
<p> </p>
<p>6.3</p>
<p> </p>
<p>Memory Protection and Multicore Configuration ............................................. 126</p>
<p> </p>
<p>6.4</p>
<p> </p>
<p>NV Memory Mapping ..................................................................................... 129</p>
<p> </p>
<p>6.5</p>
<p> </p>
<p>RTE Generator Settings ................................................................................. 130</p>
<p> </p>
<p>6.6</p>
<p> </p>
<p>Measurement and Calibration ........................................................................ 131</p>
<p> </p>
<p>6.7</p>
<p> </p>
<p>Optimization Mode Configuration ................................................................... 135</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>14 </p>
<p>based on template version 3.5 </p>
<p>6.8</p>
<p> </p>
<p>VFB Tracing Configuration ............................................................................. 136</p>
<p> </p>
<p>6.9</p>
<p> </p>
<p>Exclusive Area Implementation ...................................................................... 137</p>
<p> </p>
<p>6.10</p>
<p> </p>
<p>Periodic Trigger Implementation ..................................................................... 138</p>
<p> </p>
<p>6.11</p>
<p> </p>
<p>Resource Calculation ..................................................................................... 140</p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>Glossary and Abbreviations .................................................................................... 141</b></p>
<p> </p>
<p>7.1</p>
<p> </p>
<p>Glossary ........................................................................................................ 141</p>
<p> </p>
<p>7.2</p>
<p> </p>
<p>Abbreviations ................................................................................................. 141</p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>Additional Copyrights .............................................................................................. 143</b></p>
<p> </p>
<p><b>9</b></p>
<p> </p>
<p><b>Contact ...................................................................................................................... 144</b></p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>15 </p>
<p>based on template version 3.5 </p>
<p><b>Illustrations </b></p>
<p>Figure 2-1 </p>
<p> </p>
<p>AUTOSAR architecture ............................................................................. 22</p>
<p> </p>
<p>Figure 2-2 </p>
<p> </p>
<p>Interfaces to adjacent modules of the RTE ............................................... 24</p>
<p> </p>
<p>Figure 4-1 </p>
<p> </p>
<p>RTE Include Structure .............................................................................. 46</p>
<p> </p>
<p>Figure 4-2 </p>
<p> </p>
<p>SWC Include Structure ............................................................................. 47</p>
<p> </p>
<p>Figure 4-3 </p>
<p> </p>
<p>BSW Include Structure ............................................................................. 48</p>
<p> </p>
<p>Figure 4-4 </p>
<p> </p>
<p>Trusted RTE Partitioning example ............................................................ 55</p>
<p> </p>
<p>Figure 4-5 </p>
<p> </p>
<p>Non-trusted RTE Partitioning example ...................................................... 56</p>
<p> </p>
<p>Figure 6-1 </p>
<p> </p>
<p>Mapping of Runnables to Tasks .............................................................. 125</p>
<p> </p>
<p>Figure 6-2 </p>
<p> </p>
<p>Assignment of a Task to an OS Application ............................................. 127</p>
<p> </p>
<p>Figure 6-3 </p>
<p> </p>
<p>OS Application Configuration .................................................................. 128</p>
<p> </p>
<p>Figure 6-4 </p>
<p> </p>
<p>Mapping of Per-Instance Memory to NV Memory Blocks ........................ 129</p>
<p> </p>
<p>Figure 6-5 </p>
<p> </p>
<p>RTE Generator Settings.......................................................................... 130</p>
<p> </p>
<p>Figure 6-6 </p>
<p> </p>
<p>Measurement and Calibration Generation Parameters ........................... 131</p>
<p> </p>
<p>Figure 6-7 </p>
<p> </p>
<p>SWC Calibration Support Parameters .................................................... 133</p>
<p> </p>
<p>Figure 6-8 </p>
<p> </p>
<p>CalibrationBufferSize Parameter ............................................................. 134</p>
<p> </p>
<p>Figure 6-9 </p>
<p> </p>
<p>A2L Include Structure ............................................................................. 134</p>
<p> </p>
<p>Figure 6-10 </p>
<p> </p>
<p>Optimization Mode Configuration ............................................................ 135</p>
<p> </p>
<p>Figure 6-11 </p>
<p> </p>
<p>VFB Tracing Configuration ...................................................................... 136</p>
<p> </p>
<p>Figure 6-12 </p>
<p> </p>
<p>Exclusive Area Implementation Configuration ......................................... 137</p>
<p> </p>
<p>Figure 6-13 </p>
<p> </p>
<p>Periodic Trigger Implementation Configuration ....................................... 138</p>
<p> </p>
<p>Figure 6-14 </p>
<p> </p>
<p>HTML Report .......................................................................................... 139</p>
<p> </p>
<p>Figure 6-15 </p>
<p> </p>
<p>Configuration of platform settings ........................................................... 140</p>
<p> </p>
<p><b>Tables </b></p>
<p>Table 1-1 </p>
<p> </p>
<p>History of the document .............................................................................. 7</p>
<p> </p>
<p>Table 1-2 </p>
<p> </p>
<p>Reference documents ................................................................................. 8</p>
<p> </p>
<p>Table 1-1 </p>
<p> </p>
<p>Component history.................................................................................... 20</p>
<p> </p>
<p>Table 3-1 </p>
<p> </p>
<p>Supported AUTOSAR standard conform features ..................................... 27</p>
<p> </p>
<p>Table 3-2 </p>
<p> </p>
<p>Not supported AUTOSAR standard conform features ............................... 28</p>
<p> </p>
<p>Table 3-3 </p>
<p> </p>
<p>Features provided beyond the AUTOSAR standard .................................. 28</p>
<p> </p>
<p>Table 3-4 </p>
<p> </p>
<p>Service IDs ............................................................................................... 36</p>
<p> </p>
<p>Table 3-5 </p>
<p> </p>
<p>Errors reported to DET ............................................................................. 36</p>
<p> </p>
<p>Table 4-1 </p>
<p> </p>
<p>Content of Delivery ................................................................................... 37</p>
<p> </p>
<p>Table 4-2 </p>
<p> </p>
<p>DVCfgCmd Command Line Options ......................................................... 38</p>
<p> </p>
<p>Table 4-3 </p>
<p> </p>
<p>RTE Generator Command Line Options ................................................... 40</p>
<p> </p>
<p>Table 4-4 </p>
<p> </p>
<p>Generated Files of RTE Generation Phase ............................................... 41</p>
<p> </p>
<p>Table 4-5 </p>
<p> </p>
<p>Generated Files of RTE Contract Phase ................................................... 42</p>
<p> </p>
<p>Table 4-6 </p>
<p> </p>
<p>Generated Files of RTE Template Code Generation ................................. 44</p>
<p> </p>
<p>Table 4-7 </p>
<p> </p>
<p>Generated Files of VFB Trace Hook Code Generation ............................. 45</p>
<p> </p>
<p>Table 4-8 </p>
<p> </p>
<p>Compiler abstraction and memory mapping .............................................. 50</p>
<p> </p>
<p>Table 4-9 </p>
<p> </p>
<p>Compiler abstraction and memory mapping for non-cacheable variables . 50</p>
<p> </p>
<p>Table 7-1 </p>
<p> </p>
<p>Glossary ................................................................................................. 141</p>
<p> </p>
<p>Table 7-2 </p>
<p> </p>
<p>Abbreviations .......................................................................................... 142</p>
<p> </p>
<p>Table 8-1 </p>
<p> </p>
<p>Free and Open Source Software Licenses ............................................. 143</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>16 </p>
<p>based on template version 3.5 </p>
<p><b>1 </b></p>
<p><b>Component History </b></p>
<p>The </p>
<p>component </p>
<p>history </p>
<p>gives </p>
<p>an </p>
<p>overview </p>
<p>over </p>
<p>the </p>
<p>important </p>
<p>milestones </p>
<p>that </p>
<p>are </p>
<p>supported in the different versions of the component.  </p>
<p> </p>
<p><b>Component Version </b></p>
<p><b>New Features </b></p>
<p>2.3 </p>
<p></p>
<p> Complex hierarchical data types like arrays of records </p>
<p></p>
<p> Optimization: Depending on the configuration the Rte_Read API is </p>
<p>generated as macro if possible </p>
<p>2.4 </p>
<p></p>
<p> String data type (Encoding ISO-8859-1) </p>
<p></p>
<p> SWC local calibration parameters (Rte_CData) </p>
<p></p>
<p> Optimization: Depending on the configuration the Rte_Write API is </p>
<p>generated as macro if possible </p>
<p></p>
<p> Generation of unmapped client runnables enabled </p>
<p></p>
<p> Asynchronous C/S communication (Rte_Result) </p>
<p>2.5 </p>
<p></p>
<p> Support of AUTOSAR 3.0 Revision 0001 </p>
<p></p>
<p> Access to calibration element prototypes of calibration components </p>
<p>(Rte_Calprm) </p>
<p></p>
<p> Access to Per-Instance Memory (Rte_Pim) </p>
<p></p>
<p> SWC implementation template generation (command line option </p>
<p>-g i</p>
<p>) </p>
<p>and Contract Phase generation (command line option </p>
<p>-g c</p>
<p>)  for a </p>
<p>complete ECU </p>
<p>2.6 </p>
<p></p>
<p> Intra-ECU timeout handling for synchronous C/S communication </p>
<p></p>
<p> Parallel access of synchronous and asynchronous server calls to an </p>
<p>operation of one server port </p>
<p></p>
<p> Generation of an ASAM MCD 2MC / ASAP2 compatible A2L file </p>
<p>fragment for calibration parameters and Per-Instance Memory </p>
<p>2.7 </p>
<p></p>
<p> Multiple instantiation of software components </p>
<p></p>
<p> Compatibility mode </p>
<p></p>
<p> Object code software components </p>
<p>2.8 </p>
<p></p>
<p> Indirect APIs (Rte_Ports, Rte_NPorts and Rte_Port) </p>
<p></p>
<p> Port API Option 'EnableTakeAddress' </p>
<p></p>
<p> Platform dependent resource calculation. </p>
<p>2.9 </p>
<p></p>
<p> Memory protection (OS with scalability class SC3/SC4) </p>
<p>2.10 </p>
<p></p>
<p> Mode management including mode switch triggered runnable entities </p>
<p>and mode dependent execution of runnable entities. (Rte_Switch, </p>
<p>Rte_Mode and Rte_Feedback for mode switch acknowledge) </p>
<p></p>
<p> Data element invalidation (Rte_Invalidate and Rte_IInvalidate) </p>
<p></p>
<p> Data reception error triggered runnable entities for invalidated and </p>
<p>outdated data elements </p>
<p></p>
<p> Multiple cyclic triggers per runnable entity </p>
<p></p>
<p> Multiple OperationInvokedEvent triggers for the same runnable entity </p>
<p>with compatible operations </p>
<p></p>
<p> Extended A2L file generation for calibration parameters and Per-</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>17 </p>
<p>based on template version 3.5 </p>
<p><b>Component Version </b></p>
<p><b>New Features </b></p>
<p>Instance Memory for user defined attributes (A2L-ANNOTATION) </p>
<p>2.11 </p>
<p></p>
<p> Signal Fan-In </p>
<p></p>
<p> Unconnected provide ports </p>
<p></p>
<p> Generation of unreferenced data types </p>
<p></p>
<p> Evaluation of COM return codes </p>
<p>2.12 </p>
<p></p>
<p> Basic task support (automatically selection) </p>
<p></p>
<p> Several optimizations (e.g. unneeded interrupt locks and Schedule() </p>
<p>call removed)  </p>
<p></p>
<p> Enhanced error reporting with help messages (-v command line </p>
<p>option) </p>
<p></p>
<p> Support of acknowledgement only mode for transmission and mode </p>
<p>switch notification </p>
<p></p>
<p> Usage of compiler library functions (e.g. memcpy) removed </p>
<p></p>
<p> Template file update mechanism also introduced for Rte_MemMap.h </p>
<p>and Rte_Compiler_Cfg.h </p>
<p>2.13 </p>
<p></p>
<p> Unconnected require ports </p>
<p></p>
<p> Basic task support (manual selection) </p>
<p></p>
<p> Init-Runnables no longer have name restrictions  </p>
<p></p>
<p> Automatic periodic trigger generation can be disabled e.g. useful for </p>
<p>Schedule Table support </p>
<p></p>
<p> HTML Report including resource usage  </p>
<p></p>
<p> Explicit selection of task role (Application / BSW Scheduler / Non Rte) </p>
<p></p>
<p> Runnables with CanBeInvokedConcurrently set to false no longer </p>
<p>require a mapping, if they are not called concurrently. </p>
<p>2.14 </p>
<p></p>
<p> Support composite data types where not all primitive members require </p>
<p>an invalid value </p>
<p></p>
<p> Support inclusion of user header file 'Rte_UserTypes.h' </p>
<p>2.15 </p>
<p></p>
<p> Optimized runnable scheduling to reduce latency times </p>
<p></p>
<p> Allow implementation template generation for service components, </p>
<p>complex device drivers and EcuAbstraction components </p>
<p></p>
<p> Optimization mode (minimize RAM consumption /  minimize execution </p>
<p>time) </p>
<p>2.16 </p>
<p></p>
<p> MinimumStartInterval attribute (runnable de-bouncing) </p>
<p></p>
<p> Measurement support for S/R communication, Interrunnable variables </p>
<p>and mode communication. Extended A2L File generation and support </p>
<p>of new ASAM MCD 2MC / ASAP2 standard. Measurement with </p>
<p>XcpEvents </p>
<p></p>
<p> Com Filter (NewDiffersOld, Always) </p>
<p></p>
<p> Invalid value accessible from application </p>
<p></p>
<p> Support of second array passing variant </p>
<p>2.17 </p>
<p></p>
<p> Online calibration support </p>
<p></p>
<p> Support transmission error detection </p>
<p></p>
<p> Support of extended record data type compatibility for S/R </p>
<p>communication with different record layout on sender and receiver side  </p>
<p>2.18 </p>
<p></p>
<p> Enhanced implicit communication support </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>18 </p>
<p>based on template version 3.5 </p>
<p><b>Component Version </b></p>
<p><b>New Features </b></p>
<p>2.19 </p>
<p></p>
<p> Support of AUTOSAR 3.2 Revision 0001 </p>
<p></p>
<p> Support never received status </p>
<p></p>
<p> Support S/R update handling (Rte_IsUpdated based on AUTOSAR </p>
<p>4.0) </p>
<p></p>
<p> Enhanced measurement support (Inter-Ecu S/R communication) </p>
<p></p>
<p> Selective file generation (only if file content is modified) </p>
<p></p>
<p> Support for Non-Trusted BSW </p>
<p>2.20 </p>
<p></p>
<p> Enhanced command line interface (support for several generation </p>
<p>modes in one call, optional command line parameter </p>
<p>–m</p>
<p>) </p>
<p></p>
<p> Split of generated RTE into OS Application specific files </p>
<p></p>
<p> Byte arrays no longer need to be mapped to signal groups </p>
<p></p>
<p> Allow configuration of Schedule() calls in non-preemptive tasks </p>
<p></p>
<p> Generation of MISRA justification comments  </p>
<p>2.21 </p>
<p></p>
<p> Support of SystemSignals and SystemSignalGroups using the same </p>
<p>name </p>
<p></p>
<p> Support of hexadecimal coded enumeration values </p>
<p>2.22 </p>
<p></p>
<p> Support of AUTOSAR 3.2 Revision 0002 </p>
<p></p>
<p> Support S/R update handling according AUTOSAR 3.2.2 </p>
<p></p>
<p> Support N:1 S/R communication </p>
<p></p>
<p> Support unconnected calibration R-Ports </p>
<p></p>
<p> Enhanced initial value handling  </p>
<p>3.90</p>
<p> </p>
<p></p>
<p> Support of AUTOSAR 4.0 Revision 0003 </p>
<p>4.0</p>
<p> </p>
<p></p>
<p> Support of pointer implementation data types </p>
<p></p>
<p> Support of ‘On Transition’ triggered runnable entities </p>
<p></p>
<p> Support of data type symbol attribute </p>
<p></p>
<p> Support of component type symbol attribute </p>
<p></p>
<p> Template generation mechanism added for Rte_UserTypes.h </p>
<p>4.1</p>
<p> </p>
<p></p>
<p> Support of Rte_MemSeg.a2l </p>
<p></p>
<p> Enhanced command line interface (path for A2L files selectable) </p>
<p>4.1.1 </p>
<p></p>
<p> Multi-Core support (S/R communication) </p>
<p></p>
<p> Support of Inter-Runnable Variables with composite data types </p>
<p>4.2 </p>
<p></p>
<p> Support for arrays of dynamic data length (Rte_Send/Rte_Receive) </p>
<p></p>
<p> Support for parallel generation for multiple component types </p>
<p></p>
<p> Multi-Core support: </p>
<p></p>
<p> C/S communication </p>
<p></p>
<p> Mode communication without ModeDisablings and ModeTriggers </p>
<p></p>
<p> Inter-ECU S/R communication </p>
<p></p>
<p> Support mapping of individual OperationInvoked triggers </p>
<p></p>
<p> Support of SchM Contract Phase Generation </p>
<p></p>
<p> Support of Nv Block SWCs </p>
<p>4.3 </p>
<p></p>
<p> Support of VFB Trace Client Prefixes </p>
<p></p>
<p> Enhanced Memory Protection support </p>
<p></p>
<p> Memory Protection support for Multi-Core systems </p>
<p></p>
<p> Inter-ECU sender/receiver communication is no longer limited to the </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>19 </p>
<p>based on template version 3.5 </p>
<p><b>Component Version </b></p>
<p><b>New Features </b></p>
<p>BSW partition </p>
<p></p>
<p> Mapped client/server calls are no longer limited to the BSW partition </p>
<p></p>
<p> Queued sender/receiver communication is no longer limited to the </p>
<p>BSW partition </p>
<p></p>
<p> Optimized Multi-Core support without IOCs </p>
<p></p>
<p> Support of Development Error Reporting </p>
<p></p>
<p> Support of registering XCP Events in the XCP module configuration </p>
<p>4.4 </p>
<p></p>
<p> Support for unconnected client ports for synchronous C/S </p>
<p>communication </p>
<p></p>
<p> Inter-Ecu C/S communication using SOME/IP Transformer </p>
<p></p>
<p> Support for PR-Ports </p>
<p></p>
<p> S/R Serialization using SOME/IP Transformer and E2E Transformer </p>
<p></p>
<p> Support LdCom </p>
<p></p>
<p> Improved support for 3rd Party OS interoperability especially regarding </p>
<p>OS Counter handling </p>
<p>4.5 </p>
<p></p>
<p> Support Postbuild-Selectable for variant data mappings and variant </p>
<p>COM signals </p>
<p></p>
<p> Support E2E Transformer for Inter-Ecu C/S communication </p>
<p></p>
<p> Support tasks mappings where multiple runnable or schedulable </p>
<p>entities using different cycle times or activation offsets are mapped to a </p>
<p>single Basic Task. The realization uses OS Schedule Tables </p>
<p></p>
<p> Support Rte_DRead API </p>
<p></p>
<p> Enhanced support for PR-Ports </p>
<p></p>
<p> Support ServerArgumentImplPolicy = use ArrayBaseType </p>
<p></p>
<p> Support for Mode Declaration Groups with Explicit Order </p>
<p>4.6 </p>
<p></p>
<p> Support of PR Mode Ports </p>
<p></p>
<p> Support of PR Nv Ports </p>
<p></p>
<p> Support of bit field data types (CompuMethods with category </p>
<p>BITFIELD_TEXTTABLE) </p>
<p></p>
<p> Runtime optimized copying of large data </p>
<p></p>
<p> Support for SW-ADDR-METHOD on RAM blocks of NvRAM SWCs </p>
<p>4.7 </p>
<p></p>
<p> Support of background triggers </p>
<p></p>
<p> Support of data prototype mappings </p>
<p></p>
<p> Support of bit field text table mappings </p>
<p></p>
<p> Support of union data types </p>
<p></p>
<p> Support of UTF16 data type serialization in the SOME/IP transformer </p>
<p></p>
<p> Runtime optimization in the generated RTE code by usage of </p>
<p>optimized interrupt locking APIs of the MICROSAR OS  </p>
<p></p>
<p> Support of further E2E profiles for data transformation with the </p>
<p>SOME/IP and E2E transformer </p>
<p></p>
<p> Support of OS counters with tick durations smaller than 1µs </p>
<p>4.8 </p>
<p></p>
<p> Support of COM based Transformer ComXf  </p>
<p></p>
<p> Support of different strategies for writing NV data in Nv Block SWCs  </p>
<p></p>
<p> Support of C/S Interfaces for Nv Block SWCs  </p>
<p></p>
<p> SWC Template generation provides user sections for documentation of </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>20 </p>
<p>based on template version 3.5 </p>
<p><b>Component Version </b></p>
<p><b>New Features </b></p>
<p>runnable entities  </p>
<p></p>
<p> Wide character support in paths  </p>
<p></p>
<p> Improved counter selection for operating systems with multiple OS </p>
<p>applications  </p>
<p></p>
<p> Support of optimized macro implementation for SchM_Enter and </p>
<p>SchM_Exit  </p>
<p></p>
<p> Enhanced OS Spinlock support  </p>
<p></p>
<p> Enable optimizations in QM partitions </p>
<p>4.9 </p>
<p></p>
<p> Support of BSW multiple partition distribution </p>
<p></p>
<p> Support of activation reason for runnable entities </p>
<p>(Rte_ActivatingEvent) </p>
<p></p>
<p> Support for initialization of send buffers for implicit S/R communication </p>
<p></p>
<p> Generation of VFB Trace Hook calls only if hooks are configured </p>
<p></p>
<p> Support of 64 events per task if supported by the MICROSAR OS </p>
<p></p>
<p> Support of subelement mapping for Rx-GroupSignals </p>
<p></p>
<p> Support for RteUseComShadowSignalApi </p>
<p>4.10 </p>
<p></p>
<p> AUTOSAR 4.2.2 support </p>
<p></p>
<p> Enhanced SomeIpXf support </p>
<p></p>
<p> Support of literal prefix </p>
<p></p>
<p> Support of VFB Trace Hooks for APIs of unconnected Ports </p>
<p></p>
<p> Support for NvMAutomaticBlockLength parameter </p>
<p></p>
<p> Support of E2E profiles 1 and 2 for SomeIpXf and E2EXf </p>
<p></p>
<p> Support of E2E profiles 4, 5 and 6 for ComXf and E2EXf </p>
<p>4.11 </p>
<p></p>
<p> Support of application data types of category map, curve and axis </p>
<p></p>
<p> Selection of COM signal timeout source (Swc / Signal) </p>
<p></p>
<p> Support of 1:n Inter-ECU S/R with transmission acknowledgement </p>
<p></p>
<p> Support E2EXf for primitive byte arrays without serializer </p>
<p></p>
<p> Autonomous error responses for Inter-ECU C/S with SomeIpXf </p>
<p>4.12 </p>
<p></p>
<p> Support of connections between Nv ports and S/R ports </p>
<p></p>
<p> Support of Diagnostic Data Transformation (DiagXf) </p>
<p></p>
<p> Support of Data Conversion between integer data types on network </p>
<p>signals and floating point data types on SWC ports </p>
<p></p>
<p> Support of counters from different partitions that are assigned to the </p>
<p>same core </p>
<p>Table 1-1  </p>
<p>Component history </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>21 </p>
<p>based on template version 3.5 </p>
<p><b>2 </b></p>
<p><b>Introduction </b></p>
<p>The </p>
<p>MICROSAR </p>
<p>RTE </p>
<p>generator </p>
<p>supports </p>
<p>RTE </p>
<p>and </p>
<p>contract </p>
<p>phase </p>
<p>generation. </p>
<p>Additionally, application template code can be generated for software components and for </p>
<p>VFB trace hooks. </p>
<p>This document describes the MICROSAR RTE generation process, the RTE configuration </p>
<p>with DaVinci Configurator and the RTE API. </p>
<p>Chapter  3  gives  an  introduction  to  the  MICROSAR  RTE.  This  brief  introduction  to  the </p>
<p>AUTOSAR  RTE  can  and  will  not  replace  an  in-depth  study  of  the  overall  AUTOSAR </p>
<p>methodology and in particular the AUTOSAR RTE specification, which  provides detailed </p>
<p>information on the concepts of the RTE. </p>
<p>In addition chapter 3 describes deviations, extensions and limitations of the MICROSAR </p>
<p>RTE compared to the AUTOSAR standard. </p>
<p>The RTE generation process including the command line parameters of the MICROSAR </p>
<p>RTE generator is described in chapter 4. This chapter also gives hints for integration of the </p>
<p>generated  RTE  code  into an  ECU  project.  In  addition  it  describes  the memory  mapping </p>
<p>and compiler abstraction related to the RTE and finally, chapter 4.6 describes the memory </p>
<p>protection support of the RTE including hints for integration with the OS.   </p>
<p>The  RTE  API  description  in  chapter  5  covers  the  API  functionality  implemented  in  the </p>
<p>MICROSAR RTE. </p>
<p>The description of the RTE configuration in chapter 6 covers the task mapping, memory </p>
<p>mapping  and  the  code  generation  settings  in  DaVinci  Configurator.  A  more  detailed </p>
<p>description  of  the  configuration  tool  including  the  configuration  of  AUTOSAR  software </p>
<p>components and compositions and their integration in an ECU project can be found in the </p>
<p>online help of the DaVinci Configurator [22]. </p>
<p> </p>
<p><b>Supported AUTOSAR Release*:  </b></p>
<p>4 </p>
<p><b>Supported Configuration Variants: </b></p>
<p>pre-compile </p>
<p><b>Vendor ID: </b></p>
<p>RTE_VENDOR_ID </p>
<p>30 decimal </p>
<p>(= Vector-Informatik, </p>
<p>according to HIS) </p>
<p><b>Module ID: </b></p>
<p>RTE_MODULE_ID </p>
<p>2 decimal </p>
<p><b>AR Version: </b></p>
<p>RTE_AR_RELEASE_MAJOR_VERSION </p>
<p>RTE_AR_RELEASE_MINOR_VERSION </p>
<p>RTE_AR_RELEASE_REVISION_VERSION </p>
<p>AUTOSAR Release  </p>
<p>version               </p>
<p>decimal coded </p>
<p><b>SW Version: </b></p>
<p>RTE_SW_MAJOR_VERSION </p>
<p>RTE_SW_MINOR_VERSION </p>
<p>RTE_SW_PATCH_VERSION </p>
<p>MICROSAR RTE </p>
<p>version               </p>
<p>decimal coded </p>
<p>* For the precise AUTOSAR Release 4.x please see the release specific documentation.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>22 </p>
<p>based on template version 3.5 </p>
<p><b>2.1 </b></p>
<p><b>Architecture Overview </b></p>
<p>The RTE is the realization of the interfaces of the AUTOSAR Virtual Function Bus (VFB) </p>
<p>for a  particular ECU. The  RTE provides  both  standardized  communication  interfaces for </p>
<p>AUTOSAR software components realized by generated RTE APIs and it also provides a </p>
<p>runtime environment for the component code – the runnable entities. The RTE triggers the </p>
<p>execution </p>
<p>of </p>
<p>runnable </p>
<p>entities </p>
<p>and </p>
<p>provides </p>
<p>the </p>
<p>infrastructure </p>
<p>services </p>
<p>that </p>
<p>enable </p>
<p>communication  between AUTOSAR  SWCs.  It  is  acting  as  a  broker  for  accessing  basic </p>
<p>software modules including the OS and communication services. </p>
<p>The  following  figure  shows  where  the</p>
<p> </p>
<p>MICROSAR  RTE  is  located  in  the  AUTOSAR </p>
<p>architecture. </p>
<p> </p>
<p> </p>
<p>Figure 2-1  </p>
<p>AUTOSAR architecture </p>
<p> </p>
<p>RTE functionality overview: </p>
<p><b></b></p>
<p><b> </b></p>
<p>Execution of runnable entities of SWCs on different trigger conditions </p>
<p><b></b></p>
<p><b> </b></p>
<p>Communication mechanisms between SWCs (Sender/Receiver and Client/Server) </p>
<p><b></b></p>
<p><b> </b></p>
<p>Mode Management </p>
<p><b></b></p>
<p><b> </b></p>
<p>Inter-Runnable communication and exclusive area handling </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>23 </p>
<p>based on template version 3.5 </p>
<p><b></b></p>
<p><b> </b></p>
<p>Per-Instance Memory and calibration parameter handling </p>
<p><b></b></p>
<p><b> </b></p>
<p>Multiple instantiation of SWCs </p>
<p><b></b></p>
<p><b> </b></p>
<p>OS task body and COM / LDCOM callback generation </p>
<p><b></b></p>
<p><b> </b></p>
<p>Automatic configuration of parts of the OS, NvM and COM / LDCOM dependent of the </p>
<p>needs of the RTE </p>
<p><b></b></p>
<p><b> </b></p>
<p>Assignment of SWCs to different memory partitions/cores </p>
<p> </p>
<p>SchM functionality overview:  </p>
<p><b></b></p>
<p><b> </b></p>
<p>Execution of cyclic triggered schedulable entities (BSW main functions)  </p>
<p><b></b></p>
<p><b> </b></p>
<p>Exclusive area handling for BSW modules </p>
<p><b></b></p>
<p><b> </b></p>
<p>OS task body generation </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>24 </p>
<p>based on template version 3.5 </p>
<p> </p>
<p> </p>
<p>Figure 2-2  </p>
<p>Interfaces to adjacent modules of the RTE </p>
<p> </p>
<p><b> composite structure Component</b></p>
<p>Interfaces to SWCs and BSW Moduls</p>
<p>Interfaces to Os</p>
<p>Interfaces to EcuM</p>
<p>Interfaces to Com</p>
<p>Module</p>
<p>RTE</p>
<p>«EmbeddedInterface»</p>
<p><b>RTE::S/R (explicit)</b></p>
<p>+ </p>
<p>Rte_Write_&lt;p&gt;_&lt;o&gt;([IN  Rte_Instance  &lt;instance&gt;,] IN  &lt;data&gt;)()  :Std_ReturnType</p>
<p>+ </p>
<p>Rte_Read_&lt;p&gt;_&lt;o&gt;([IN Rte_Instance &lt;instance&gt;,] OUT &lt;data&gt;)()  :Std_ReturnType</p>
<p>+ </p>
<p>Rte_Send_&lt;p&gt;_&lt;o&gt;([IN Rte_Instance &lt;instance&gt;,] IN &lt;data&gt; [,IN  uint16 &lt;length&gt;])()  :Std_ReturnType</p>
<p>+ </p>
<p>Rte_Receive_&lt;p&gt;_&lt;o&gt;([IN Rte_Instance &lt;instance&gt;,] OUT &lt;data&gt; [,OUT uint16 &lt;length&gt;])()  :Std_ReturnType</p>
<p>+ </p>
<p>Rte_Feedback_&lt;p&gt;_&lt;o&gt;([IN Rte_Instance &lt;instance&gt;])()  :Std_ReturnType</p>
<p>+ </p>
<p>Rte_Invalidate_&lt;p&gt;_&lt;o&gt;([IN Rte_Instance &lt;instance&gt;])()  :Std_ReturnType</p>
<p>+ </p>
<p>Rte_IsUpdated_&lt;p&gt;_&lt;o&gt;([IN Rte_Instance &lt;instance&gt;])()  :boolean</p>
<p>«EmbeddedInterface»</p>
<p><b>RTE::Lifecycle</b></p>
<p>+ </p>
<p>Rte_Start()  :Std_ReturnType</p>
<p>+ </p>
<p>Rte_Stop()  :Std_ReturnType</p>
<p>«EmbeddedInterface»</p>
<p><b>RTE::COM Callback</b></p>
<p>+ </p>
<p>Rte_COMCbk_&lt;SignalName&gt;()  :void</p>
<p>+ </p>
<p>Rte_COMCbkRxTOut_&lt;SignalName&gt;()  :void</p>
<p>+ </p>
<p>Rte_COMCbkTAck_&lt;SignalName&gt;()  :void</p>
<p>+ </p>
<p>Rte_COMCbkTxTOut_&lt;SignalName&gt;()  :void</p>
<p>+ </p>
<p>Rte_COMCbkTErr_&lt;SignalName&gt;()  :void</p>
<p>+ </p>
<p>Rte_COMCbkInv_&lt;SignalName&gt;()  :void</p>
<p>«EmbeddedInterface»</p>
<p><b>Used Interfaces::Com</b></p>
<p>+ </p>
<p>Com_SendDynSignal(Com_SignalIdType, const void*, uint16)  :uint8</p>
<p>+ </p>
<p>Com_SendSignal(Com_SignalIdType, const void*)  :uint8</p>
<p>+ </p>
<p>Com_UpdateShadowSignal(Com_SignalIdType, const void*)  :void</p>
<p>+ </p>
<p>Com_SendSignalGroup(Com_SignalGroupIdType)  :uint8</p>
<p>+ </p>
<p>Com_ReceiveDynSignal(Com_SignalIdType, void*, uint16*)  :uint8</p>
<p>+ </p>
<p>Com_ReceiveSignal(Com_SignalIdType, void*)  :uint8</p>
<p>+ </p>
<p>Com_ReceiveShadowSignal(Com_SignalIdType, void*)  :uint8</p>
<p>+ </p>
<p>Com_ReceiveSignalGroup(Com_SignalGroupIdType)  :uint8</p>
<p>+ </p>
<p>Com_InvalidateSignal(Com_SignalIdType)  :uint8</p>
<p>+ </p>
<p>Com_InvalidateSignalGroup(Com_SignalGroupIdType)  :uint8</p>
<p>«EmbeddedInterface»</p>
<p><b>Used Interfaces::Os</b></p>
<p>+ </p>
<p>ActivateTask(TaskType)  :StatusType</p>
<p>+ </p>
<p>CancelAlarm(AlarmType)  :StatusType</p>
<p>+ </p>
<p>ChainTask(TaskType)  :StatusType</p>
<p>+ </p>
<p>ClearEvent(EventMaskType)  :StatusType</p>
<p>+ </p>
<p>DisableAllInterrupts()  :void</p>
<p>+ </p>
<p>EnableAllInterrupts()  :void</p>
<p>+ </p>
<p>GetEvent(TaskType, EventMaskType*)  :StatusType</p>
<p>+ </p>
<p>GetResource(ResourceType)  :StatusType</p>
<p>+ </p>
<p>GetTaskID(TaskType*)  :StatusType</p>
<p>+ </p>
<p>IocRead_&lt;iocid&gt;(OUT &lt;data&gt;)()  :Std_ReturnType</p>
<p>+ </p>
<p>IocReadGroup_&lt;iocid&gt;(OUT &lt;data0&gt;,..., OUT &lt;data_n&gt;)()  :Std_ReturnType</p>
<p>+ </p>
<p>IocReceive_&lt;iocid&gt;(OUT &lt;data&gt;)()  :Std_ReturnType</p>
<p>+ </p>
<p>IocSend_&lt;iocid&gt;[_&lt;sid&gt;](IN &lt;data&gt;)()  :Std_ReturnType</p>
<p>+ </p>
<p>IocWrite_&lt;iocid&gt;[_&lt;sid&gt;](IN &lt;data&gt;)()  :Std_ReturnType</p>
<p>+ </p>
<p>IocWriteGroup_&lt;iocid&gt;[_&lt;sid&gt;](IN &lt;data0&gt;,..., IN &lt;data_n&gt;)()  :Std_ReturnType</p>
<p>+ </p>
<p>ReleaseResource(ResourceType)  :StatusType</p>
<p>+ </p>
<p>ResumeOSInterrupts()  :void</p>
<p>+ </p>
<p>Schedule()  :StatusType</p>
<p>+ </p>
<p>SetEvent(TaskType, EventMaskType)  :StatusType</p>
<p>+ </p>
<p>SetRelAlarm(AlarmType, TickType, TickType)  :StatusType</p>
<p>+ </p>
<p>SuspendOSInterrupts()  :void</p>
<p>+ </p>
<p>TerminateTask()  :StatusType</p>
<p>+ </p>
<p>WaitEvent(EventMaskType)  :StatusType</p>
<p>«EmbeddedInterface»</p>
<p><b>RTE::Error Handling</b></p>
<p>+ </p>
<p>Rte_HasOverlayedError(Std_ReturnType)  :boolean</p>
<p>+ </p>
<p>Rte_ApplicationError(Std_ReturnType)  :Std_ReturnType</p>
<p>+ </p>
<p>Rte_IsInfrastructureError(Std_ReturnType)  :boolean</p>
<p>«EmbeddedInterface»</p>
<p><b>SchM::Lifecycle</b></p>
<p>+ </p>
<p>SchM_Init([IN SchM_ConfigType ConfigPtr])()  :void</p>
<p>+ </p>
<p>SchM_Deinit()  :void</p>
<p>+ </p>
<p>SchM_GetVersionInfo(Std_VersionInfoType*)  :void</p>
<p>«EmbeddedInterface»</p>
<p><b>RTE::S/R (implicit)</b></p>
<p>+ </p>
<p>Rte_IWrite_&lt;re&gt;_&lt;p&gt;_&lt;o&gt;([IN  Rte_Instance  &lt;instance&gt;,] IN  &lt;data&gt;)()  :void</p>
<p>+ </p>
<p>Rte_IWriteRef_&lt;re&gt;_&lt;p&gt;_&lt;o&gt;([IN Rte_Instance &lt;instance&gt;])()  :&lt;return ref&gt;</p>
<p>+ </p>
<p>Rte_IRead_&lt;re&gt;_&lt;p&gt;_&lt;o&gt;([IN Rte_Instance &lt;instance&gt;])()  :&lt;return&gt;</p>
<p>+ </p>
<p>Rte_IStatus_&lt;re&gt;_&lt;p&gt;_&lt;o&gt;([IN Rte_Instance &lt;instance&gt;])()  :Std_ReturnType</p>
<p>+ </p>
<p>Rte_IInvalidate_&lt;re&gt;_&lt;p&gt;_&lt;o&gt;([IN Rte_Instance &lt;instance&gt;])()</p>
<p>«EmbeddedInterface»</p>
<p><b>RTE::Inter-Runnable Variable</b></p>
<p>+ </p>
<p>Rte_IrvWrite_&lt;v([IN  Rte_Instance  &lt;instance&gt;,] IN  &lt;data&gt;)()  :void</p>
<p>+ </p>
<p>Rte_IrvRead_&lt;v&gt;([IN Rte_Instance &lt;instance&gt;])()  :&lt;return&gt;</p>
<p>+ </p>
<p>Rte_IrvIWrite_&lt;re&gt;_&lt;v([IN  Rte_Instance  &lt;instance&gt;,] IN  &lt;data&gt;)()  :void</p>
<p>+ </p>
<p>Rte_IrvIRead_&lt;re&gt;_&lt;v&gt;([IN Rte_Instance &lt;instance&gt;])()  :&lt;return&gt;</p>
<p>«EmbeddedInterface»</p>
<p><b>Used Interfaces::Xcp</b></p>
<p>+ </p>
<p>Xcp_Event(uint8)  :void</p>
<p>Interfaces to Xcp</p>
<p>«EmbeddedInterface»</p>
<p><b>SchM::Exclusiv e Area</b></p>
<p>+ </p>
<p>SchM_Enter_&lt;ea&gt;([IN  Rte_Instance  &lt;instance&gt;])()  :void</p>
<p>+ </p>
<p>SchM_Exit_&lt;ea&gt;([IN  Rte_Instance  &lt;instance&gt;])()  :void</p>
<p>«EmbeddedInterface»</p>
<p><b>RTE::Exclusiv e Area</b></p>
<p>+ </p>
<p>Rte_Enter_&lt;ea&gt;([IN  Rte_Instance  &lt;instance&gt;])()  :void</p>
<p>+ </p>
<p>Rte_Exit_&lt;ea&gt;([IN  Rte_Instance  &lt;instance&gt;])()  :void</p>
<p>«EmbeddedInterface»</p>
<p><b>RTE::Mode Handling</b></p>
<p>+ </p>
<p>Rte_Switch_&lt;p&gt;_&lt;o&gt;([IN  Rte_Instance  &lt;instance&gt;,] IN  &lt;mode&gt;)()  :Std_ReturnType</p>
<p>+ </p>
<p>Rte_Mode_&lt;p&gt;_&lt;o&gt;([IN  Rte_Instance  &lt;instance&gt;])()  :Std_ReturnType</p>
<p>+ </p>
<p>Rte_Mode_&lt;p&gt;_&lt;o&gt;([IN  Rte_Instance  &lt;instance&gt;,] OUT previous, OUT next)()  :&lt;currentmode&gt;</p>
<p>+ </p>
<p>Rte_SwitchAck_&lt;p&gt;_&lt;o&gt;([IN  Rte_Instance  &lt;instance&gt;])()  :&lt;currentmode&gt;</p>
<p>«EmbeddedInterface»</p>
<p><b>RTE::C/S</b></p>
<p>+ </p>
<p>Rte_Call_&lt;p&gt;_&lt;o&gt;([IN  Rte_Instance  &lt;instance&gt;,] &lt;data_1&gt; ... &lt;data_n&gt;)()  :Std_ReturnType</p>
<p>+ </p>
<p>Rte_Result_&lt;p&gt;_&lt;o&gt;([IN  Rte_Instance  &lt;instance&gt;,] &lt;data_1&gt; ... &lt;data_n&gt;)()  :Std_ReturnType</p>
<p>«EmbeddedInterface»</p>
<p><b>RTE::Indirect API</b></p>
<p>+ </p>
<p>Rte_Port_&lt;p&gt;([IN  Rte_Instance  &lt;instance&gt;])()  :Rte_PortHandle_&lt;i&gt;_&lt;R/P&gt;</p>
<p>+ </p>
<p>Rte_Ports_&lt;pi&gt;_&lt;R/P&gt;([IN  Rte_Instance  &lt;instance&gt;])()  :Rte_PortHandle_&lt;i&gt;_&lt;R/P&gt;</p>
<p>+ </p>
<p>Rte_NPorts_&lt;pi&gt;_&lt;R/P&gt;([IN  Rte_Instance  &lt;instance&gt;])()  :uint8</p>
<p>«EmbeddedInterface»</p>
<p><b>RTE::Calibration Parameter</b></p>
<p>+ </p>
<p>Rte_CData_&lt;c&gt;([IN  Rte_Instance  &lt;instance&gt;])()  :&lt;parameter&gt;</p>
<p>+ </p>
<p>Rte_Prm_&lt;p&gt;_&lt;c&gt;([IN  Rte_Instance  &lt;instance&gt;])()  :&lt;parameter&gt;</p>
<p>«EmbeddedInterface»</p>
<p><b>RTE::Per-Instance Memory</b></p>
<p>+ </p>
<p>Rte_Pim_&lt;p&gt;([IN  Rte_Instance  &lt;instance&gt;])()  :&lt;pim&gt;</p>
<p>«EmbeddedInterface»</p>
<p><b>Prov ided Interfaces::</b></p>
<p><b>Memory Initialization</b></p>
<p>+ </p>
<p>Rte_InitMemory()  :void</p>
<p>«EmbeddedInterface»</p>
<p><b>RTE::Nv M Callback</b></p>
<p>+ </p>
<p>Rte_GetMirror_&lt;b&gt;_&lt;d&gt;(void*)  :Std_ReturnType</p>
<p>+ </p>
<p>Rte_SetMirror_&lt;b&gt;_&lt;d&gt;(const void*)  :Std_ReturnType</p>
<p>                                     Interfaces to NvM</p>
<p>«provide optionally»</p>
<p>«provide optionally»</p>
<p>«use optionally»</p>
<p>«provide optionally»</p>
<p>«provide optionally»</p>
<p>«provide optionally»</p>
<p>«provide optionally»</p>
<p>«use optionally»</p>
<p>«use optionally»</p>
<p>«provide optionally»</p>
<p>«provide optionally»</p>
<p>«provide optionally»</p>
<p>«provide optionally»</p>
<p>«provide optionally»</p>
<p>«provide optionally»</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>25 </p>
<p>based on template version 3.5 </p>
<p><b>3 </b></p>
<p><b>Functional Description </b></p>
<p><b>3.1 </b></p>
<p><b>Features </b></p>
<p>The features listed in the following tables cover the complete functionality specified for the </p>
<p>RTE. </p>
<p>The AUTOSAR  standard  functionality  is  specified  in  [1],  the  corresponding  features  are </p>
<p>listed in the tables </p>
<p><b></b></p>
<p><b> </b></p>
<p>Table 3-1   Supported AUTOSAR standard conform features </p>
<p><b></b></p>
<p><b> </b></p>
<p>Table 3-2   Not supported AUTOSAR standard conform features </p>
<p>Vector Informatik provides further RTE functionality beyond the AUTOSAR standard. The </p>
<p>corresponding features are listed in the table </p>
<p><b></b></p>
<p><b> </b></p>
<p>Table 3-3   Features provided beyond the AUTOSAR standard </p>
<p> </p>
<p>The following features specified in [1] are supported: </p>
<p><b>Supported AUTOSAR Standard Conform Features </b></p>
<p>Explicit S/R communication (last-is-best)  [API: Rte_Read, Rte_Write] </p>
<p>Explicit S/R communication (queued polling)  [API: Rte_Receive, Rte_Send] </p>
<p>Variable length arrays </p>
<p>Explicit S/R communication (queued blocking)  [API: Rte_Receive] </p>
<p>Implicit S/R communication  [API:Rte_IRead, Rte_IWrite, Rte_IWriteRef] </p>
<p>Timeout handling (DataReceiveErrorEvent) [API: Rte_IStatus] </p>
<p>Data element invalidation [API: Rte_Invalidate, Rte_IInvalidate] </p>
<p>Intra-Ecu S/R communication </p>
<p>Inter-Ecu S/R communication </p>
<p>1:N S/R communication (including network signal Fan-Out) </p>
<p>N:1 S/R communication (non-queued, pure network signal Fan-In or pure Intra-Ecu) </p>
<p>C/S communication (synchronous, direct calls)  [API: Rte_Call] </p>
<p>C/S communication (synchronous, scheduled calls)  [API: Rte_Call] </p>
<p>C/S communication (asynchronous calls)  [API: Rte_Call] </p>
<p>C/S communication (asynchronous) [API: Rte_Result] </p>
<p>Intra-Ecu C/S communication </p>
<p>Inter-Ecu C/S communication using SOME/IP Transformer </p>
<p>N:1 C/S communication </p>
<p>Explicit exclusive areas [API: Rte_Enter, Rte_Exit] </p>
<p>Implicit exclusive areas  </p>
<p>Explicit Inter-Runnable Variables [API: Rte_IrvRead, Rte_IrvWrite]  </p>
<p>Implicit Inter-Runnable Variables [API: Rte_IIrvRead, Rte_IIrvWrite] </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>26 </p>
<p>based on template version 3.5 </p>
<p><b>Supported AUTOSAR Standard Conform Features </b></p>
<p>Transmission ack. status (polling and blocking) [API: Rte_Feedback] </p>
<p>Runnable category 1a, 1b und 2 </p>
<p>RTE Lifecycle-API [API: Rte_Start, Rte_Stop] </p>
<p>Nv Block Software Components </p>
<p>Runnable to task mapping </p>
<p>Data element to signal mapping </p>
<p>Task body generation </p>
<p>VFB-Tracing </p>
<p>Multiple trace clients </p>
<p>ECU-C import / export </p>
<p>Automatic OS configuration according the needs of the RTE (basic and extended task support)  </p>
<p>Automatic COM / LDCOM configuration according the needs of the RTE </p>
<p>Primitive data types </p>
<p>Composite data types </p>
<p>Data reception triggered runnables entities (DataReceivedEvent) </p>
<p>Cyclic triggered runnable entities (TimingEvent) </p>
<p>Data transmission triggered runnable entities (DataSendCompletionEvent) </p>
<p>Data reception error triggered runnables entities (DataReceiveErrorEvent) </p>
<p>Mode switch acknowledge triggered runnable entities (ModeSwitchedAckEvent) </p>
<p>Mode switch triggered runnable entities (ModeSwitchEvent) </p>
<p>Background triggered runnable and scheduleable entities (BackgroundEvent) </p>
<p>Contract phase header generation </p>
<p>Port access to services (Port defined argument values) </p>
<p>Port access to ECU-Abstraction </p>
<p>Compatibility mode </p>
<p>Per-Instance Memory [API: Rte_Pim] </p>
<p>Multiple instantiation on ECU-level </p>
<p>Indirect API [API: Rte_Port, Rte_NPorts, Rte_Ports] </p>
<p>SWC internal calibration parameters [API: Rte_CData] </p>
<p>Shared calibration parameters (CalprmComponentType) [API: Rte_Prm] </p>
<p>Mode machine handling [API: Rte_Mode/Rte_Switch] </p>
<p>Mode switch ack. status (polling and blocking) [API: Rte_SwitchAck] </p>
<p>Multi-Core support (S/R communication, C/S communication, Mode communication (partially)) </p>
<p>Memory protection </p>
<p>Unconnected ports </p>
<p>COM-Filter (NewDiffersOld, Always) </p>
<p>Measurement (S/R-Communication, Mode-Communication, Inter-Runnable Variables) </p>
<p>Runnable de-bouncing (Minimum Start Interval)  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>27 </p>
<p>based on template version 3.5 </p>
<p><b>Supported AUTOSAR Standard Conform Features </b></p>
<p>Online calibration support  </p>
<p>Never received status  </p>
<p>S/R update handling [API: Rte_IsUpdated] </p>
<p>Contract Phase Header generation for BSW-Scheduler </p>
<p>PR-Ports</p>
<p> </p>
<p>Optimized S/R communication [API: Rte_DRead]</p>
<p> </p>
<p>Variant Handling support (Postbuild selectable for variant data mappings and COM signals)</p>
<p> </p>
<p>Data prototype mapping</p>
<p> </p>
<p>Subelement mapping for Rx GroupSignals</p>
<p> </p>
<p>Bit field texttable mapping</p>
<p> </p>
<p>Activation reason for runnable entities</p>
<p> </p>
<p>RteUseComShadowSignalApi</p>
<p> </p>
<p>Service BSW multiple partition distribution </p>
<p> </p>
<p>S/R and C/S Serialization using SOME/IP Transformer </p>
<p>LdCom Support  </p>
<p>ComXf Support  </p>
<p>E2E Transformer Support  </p>
<p>Initialization of send buffers for implicit S/R communication  </p>
<p>Data conversion (integer data type on network signal to floating point data type on SWC ports) </p>
<p>Table 3-1  </p>
<p>Supported AUTOSAR standard conform features </p>
<p><b>3.1.1 </b></p>
<p><b>Deviations </b></p>
<p>The following features specified in [1] are not supported: </p>
<p><b>Not Supported AUTOSAR Standard Conform Features </b></p>
<p>COM-Filter (only partially supported) </p>
<p>Measurement (Client-Server arguments) </p>
<p>external Trigger (via port) [API: Rte_Trigger] </p>
<p>Inter-Runnable Trigger (SWC internal) [API: Rte_IrTrigger] </p>
<p>Tx-Ack for implicit communication [API: Rte_IFeedback] </p>
<p>BSW-Scheduler Mode Handling [API: SchM_Mode, SchM_Switch, SchM_SwitchAck] </p>
<p>external Trigger between BSW modules [API: SchM_Trigger] </p>
<p>BSW-Scheduler Trigger [API: SchM_ActMainFunction] </p>
<p>BSW-Scheduler Calibration Parameter Access [API: SchM_CData] </p>
<p>BSW-Scheduler queued S/R communication [API: SchM_Send, SchM_Receive] </p>
<p>BSW-Scheduler C/S communication [API: SchM_Call, SchM_Result] </p>
<p>BSW-Scheduler Per-Instance Memory Access [API: SchM_Pim] </p>
<p>Enhanced Rte Lifecycle API [API: Rte_StartTiming] </p>
<p>Post Build Variant Sets </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>28 </p>
<p>based on template version 3.5 </p>
<p><b>Not Supported AUTOSAR Standard Conform Features </b></p>
<p>Debugging and Logging Support </p>
<p>Variant Handling support (Pre-Compile variability, Postbuild variability for Connectors and </p>
<p>ComponentPrototypes)  </p>
<p>Multi-Core support (Mode communication with ModeSwitchTriggers or ModeDisablings, </p>
<p>Rte_ComSendSignalProxyImmediate, RteIocInteractionReturnValue=RTE_COM) </p>
<p>Restarting of partitions </p>
<p>Re-scaling of ports / Data conversion (only partially supported) </p>
<p>Pre-Build data set generation phase </p>
<p>Post-Build data set generation phase </p>
<p>Initialization of PerInstanceMemories </p>
<p>Asynchronous Mode Handling </p>
<p>MC data support </p>
<p>Generated BSWMD </p>
<p>Range checks </p>
<p>RTE memory section initialization strategies </p>
<p>Configuration of coherency groups for implicit communication </p>
<p>Immediate Buffer update for implicit communication </p>
<p>External conﬁguration switch strictConfigurationCheck </p>
<p>Table 3-2  </p>
<p>Not supported AUTOSAR standard conform features </p>
<p><b>3.1.2 </b></p>
<p><b>Additions/ Extensions </b></p>
<p>The following features are provided beyond the AUTOSAR standard: </p>
<p><b>Features Provided Beyond The AUTOSAR Standard </b></p>
<p>Rte_InitMemory API function. See Chapter 5.14.3 for details. </p>
<p>Init-Runnables. See Chapter 3.6.9 for details. </p>
<p>VFB Trace Hooks for SchM APIs. See Chapter 5.16.3 and 5.16.4 for details. </p>
<p>Measurement support for mode communication. See Chapter 6.6 for details. </p>
<p>Measurement with XCP Events. See Chapter 6.6 for details. </p>
<p>Table 3-3  </p>
<p>Features provided beyond the AUTOSAR standard </p>
<p><b>3.1.3 </b></p>
<p><b>Limitations </b></p>
<p>There are no known limitations. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>29 </p>
<p>based on template version 3.5 </p>
<p><b>3.2 </b></p>
<p><b>Initialization </b></p>
<p>The  RTE  is  initialized  by  calling </p>
<p>Rte_Start</p>
<p>.  Initialization  is  done  by  the  ECU  State </p>
<p>Manager (EcuM). </p>
<p>The Basis Software Scheduler (SchM) is initialized by calling </p>
<p>SchM_Init</p>
<p>. Initialization is </p>
<p>done by the ECU State Manager (EcuM). </p>
<p><b>3.3 </b></p>
<p><b>AUTOSAR ECUs </b></p>
<p>Besides  the  basic  software  modules  each AUTOSAR  ECU  has  a  single  instance  of  the </p>
<p>RTE </p>
<p>to </p>
<p>manage </p>
<p>the </p>
<p>application </p>
<p>software </p>
<p>of </p>
<p>the </p>
<p>ECU. </p>
<p>The </p>
<p>application </p>
<p>software </p>
<p>is </p>
<p>modularized and assigned to one or more AUTOSAR software components (SWC). </p>
<p><b>3.4 </b></p>
<p><b>AUTOSAR Software Components </b></p>
<p>AUTOSAR software  components  (SWC)  are  described  by  their  ports  for communication </p>
<p>with  other  SWCs  and  their  internal  behavior  in  form  of  runnable  entities  realizing  the </p>
<p>smallest schedulable code fragments in an ECU.  </p>
<p>The following communication paradigms are supported for port communication: </p>
<p><b></b></p>
<p><b> </b></p>
<p>Sender-Receiver (S/R): queued and last-is-best, implicit and explicit </p>
<p><b></b></p>
<p><b> </b></p>
<p>Client-Server (C/S): synchronous and asynchronous </p>
<p><b></b></p>
<p><b> </b></p>
<p>Mode communication </p>
<p><b></b></p>
<p><b> </b></p>
<p>Calibration parameter communication </p>
<p>S/R and C/S communication may occur Intra-ECU or between different ECUs (Inter-ECU). </p>
<p>Mode communication and calibration parameters can only be accessed ECU internally. </p>
<p>In addition to Inter-SWC communication over ports, the description of the internal behavior </p>
<p>of  SWCs  contains  also  means  for  Intra-SWC  communication  and  synchronization  of </p>
<p>runnable entities. </p>
<p><b></b></p>
<p><b> </b></p>
<p>Inter-Runnable Variables  </p>
<p><b></b></p>
<p><b> </b></p>
<p>Per-Instance Memory </p>
<p><b></b></p>
<p><b> </b></p>
<p>Exclusive Areas </p>
<p><b></b></p>
<p><b> </b></p>
<p>Calibration Parameters </p>
<p>The description of the internal behavior of SWCs finally contains all information needed for </p>
<p>the handling of runnable entities, especially the events upon which they are triggered. </p>
<p><b>3.5 </b></p>
<p><b>Runnable Entities </b></p>
<p>All  application  code  is  organized  into  runnable  entities,  which  are  triggered  by  the  RTE </p>
<p>depending  on  certain  conditions.  They  are  mapped  to  OS  tasks  and  may  access  the </p>
<p>communication and data consistency mechanisms provided by the SWC they belong to.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>30 </p>
<p>based on template version 3.5 </p>
<p>The </p>
<p>trigger </p>
<p>conditions </p>
<p>for </p>
<p>runnable </p>
<p>entities </p>
<p>are </p>
<p>described </p>
<p>below, </p>
<p>together </p>
<p>with </p>
<p>the </p>
<p>signature  of  the  runnable  entities  that  results  from  these  trigger  conditions.  A  detailed </p>
<p>description  of  the  signature  of  runnable  entities  may  be  found  in  section  5.3  Runnable </p>
<p>Entities. </p>
<p><b>3.6 </b></p>
<p><b>Triggering of Runnable Entities </b></p>
<p>AUTOSAR has introduced the concept of RTEEvents to trigger the execution of runnable </p>
<p>entities. The following RTEEvents are supported by the MICROSAR RTE: </p>
<p><b></b></p>
<p><b> </b></p>
<p>TimingEvent  </p>
<p><b></b></p>
<p><b> </b></p>
<p>DataReceivedEvent </p>
<p><b></b></p>
<p><b> </b></p>
<p>DataReceiveErrorEvent </p>
<p><b></b></p>
<p><b> </b></p>
<p>DataSendCompletedEvent </p>
<p><b></b></p>
<p><b> </b></p>
<p>OperationInvokedEvent </p>
<p><b></b></p>
<p><b> </b></p>
<p>AsynchronousServerCallReturnsEvent </p>
<p><b></b></p>
<p><b> </b></p>
<p>ModeSwitchEvent </p>
<p><b></b></p>
<p><b> </b></p>
<p>ModeSwitchedAckEvent </p>
<p><b></b></p>
<p><b> </b></p>
<p>InitEvent </p>
<p><b></b></p>
<p><b> </b></p>
<p>BackgroundEvent </p>
<p> </p>
<p>The RTEEvents can lead to two different kinds of triggering: </p>
<p><b></b></p>
<p><b> </b></p>
<p>Activation of runnable entity </p>
<p><b></b></p>
<p><b> </b></p>
<p>Wakeup of waitpoint </p>
<p>Activation of runnable entity</p>
<p>  starts  a  runnable  entity  at  its  entry  point  while </p>
<p>wakeup of waitpoint</p>
<p> resumes runnable processing at a waitpoint. The second is not </p>
<p>possible  for  all  RTEEvents  and  needs  an  RTE  API  to  setup  this  waitpoint  inside  the </p>
<p>runnable entity code. </p>
<p>Depending on the existence of a waitpoint, runnable entities are categorized into category </p>
<p>1  or  category  2  runnables.  A  runnable  becomes  a  category  2  runnable  if  at  least  one </p>
<p>waitpoint exists. </p>
<p> </p>
<p><b>3.6.1 </b></p>
<p><b>Time Triggered Runnables </b></p>
<p>AUTOSAR  defines  the </p>
<p>TimingEvent</p>
<p>  for  periodic  triggering  of  runnable  entities.  The </p>
<p>TimingEvent </p>
<p>can  only  trigger  a  runnable  entity  at  its  entry  point.  Consequently  there </p>
<p>exists no API to set up a waitpoint for a </p>
<p>TimingEvent</p>
<p>. The signature of a time triggered </p>
<p>runnable is: </p>
<p>void &lt;RunnableName&gt;([IN Rte_Instance instance] </p>
<p>  </p>
<p> </p>
<p>    [,IN Rte_ActivatingEvent_&lt;RunnableEntity&gt; activation])</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>31 </p>
<p>based on template version 3.5 </p>
<p><b>3.6.2 </b></p>
<p><b>Data Received Triggered Runnables </b></p>
<p>AUTOSAR </p>
<p>defines </p>
<p>the </p>
<p>DataReceivedEvent</p>
<p> </p>
<p>to </p>
<p>trigger </p>
<p>a </p>
<p>runnable </p>
<p>entity </p>
<p>on </p>
<p>data </p>
<p>reception  (queued  or  last-is-best)  or  to  continue  reception  of  queued  data  in  a  blocking </p>
<p>Rte_Receive</p>
<p>  call.  Both  intra  ECU  and  inter  ECU  communication  is  supported.  Data </p>
<p>reception triggered runnables have the following signature: </p>
<p>void &lt;RunnableName&gt;([IN Rte_Instance instance] </p>
<p>  </p>
<p> </p>
<p>    [,IN Rte_ActivatingEvent_&lt;RunnableEntity&gt; activation]) </p>
<p> </p>
<p><b>3.6.3 </b></p>
<p><b>Data Reception Error Triggered Runnables </b></p>
<p>AUTOSAR  defines  the </p>
<p>DataReceiveErrorEvent</p>
<p>  to  trigger  a  runnable  entity  on  data </p>
<p>reception error. A reception error could be a timeout (</p>
<p>aliveTimeout</p>
<p>) or an invalidated </p>
<p>data  element.  The </p>
<p>DataReceiveErrorEvent</p>
<p>  can  only  trigger  a  runnable  entity  at  its </p>
<p>entry </p>
<p>point. </p>
<p>Consequently </p>
<p>there </p>
<p>exists </p>
<p>no </p>
<p>API </p>
<p>to </p>
<p>set </p>
<p>up </p>
<p>a </p>
<p>waitpoint </p>
<p>for </p>
<p>a </p>
<p>DataReceiveErrorEvent</p>
<p>. The signature of a data reception error triggered runnable is: </p>
<p>void &lt;RunnableName&gt;([IN Rte_Instance instance] </p>
<p>  </p>
<p> </p>
<p>    [,IN Rte_ActivatingEvent_&lt;RunnableEntity&gt; activation]) </p>
<p> </p>
<p><b>3.6.4 </b></p>
<p><b>Data Send Completed Triggered Runnables </b></p>
<p>AUTOSAR </p>
<p>defines </p>
<p>the </p>
<p>DataSendCompletedEvent</p>
<p> </p>
<p>to </p>
<p>signal </p>
<p>a </p>
<p>successful </p>
<p>or </p>
<p>an </p>
<p>erroneous transmission of explicit S/R communication. The </p>
<p>DataSendCompletedEvent </p>
<p>can either trigger the execution of a runnable entity or continue a runnable, which waits at </p>
<p>a waitpoint for the transmission status or the mode switch in a blocking </p>
<p>Rte_Feedback</p>
<p> </p>
<p>call.  Both  intra  ECU  and  inter  ECU  communication  is  supported.  Data  send  completed </p>
<p>triggered runnables have the following signature: </p>
<p>void &lt;RunnableName&gt;([IN Rte_Instance instance] </p>
<p>  </p>
<p> </p>
<p>    [,IN Rte_ActivatingEvent_&lt;RunnableEntity&gt; activation]) </p>
<p> </p>
<p><b>3.6.5 </b></p>
<p><b>Mode Switch Triggered Runnables </b></p>
<p>AUTOSAR defines the </p>
<p>ModeSwitchEvent</p>
<p> to trigger a runnable entity on either entering </p>
<p>or exiting of a specific mode of a mode declaration group. The </p>
<p>ModeSwitchEvent</p>
<p> can </p>
<p>only trigger a runnable entity at its entry point. Consequently there exists no API to set up </p>
<p>a waitpoint for a </p>
<p>ModeSwitchEvent</p>
<p>. The signature of a mode switch triggered runnable </p>
<p>is: </p>
<p>void &lt;RunnableName&gt;([IN Rte_Instance instance] </p>
<p>  </p>
<p> </p>
<p>    [,IN Rte_ActivatingEvent_&lt;RunnableEntity&gt; activation]) </p>
<p> </p>
<p><b>3.6.6 </b></p>
<p><b>Mode Switched Acknowledge Triggered Runnables </b></p>
<p>AUTOSAR defines the </p>
<p>ModeSwitchedAckEvent</p>
<p> to signal a successful mode transition. </p>
<p>The </p>
<p>ModeSwitchedAckEvent</p>
<p>  can  either  trigger  the  execution  of  a  runnable  entity  or </p>
<p>continue a runnable, which waits at a waitpoint for the mode transition status. Only intra </p>
<p>ECU  communication  is  supported.  Runnables  triggered  by  a  mode  switch  acknowledge </p>
<p>have the following signature: </p>
<p>void &lt;RunnableName&gt;([IN Rte_Instance instance] </p>
<p>  </p>
<p> </p>
<p>    [,IN Rte_ActivatingEvent_&lt;RunnableEntity&gt; activation]) </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>32 </p>
<p>based on template version 3.5 </p>
<p><b>3.6.7 </b></p>
<p><b>Operation Invocation Triggered Runnables </b></p>
<p>The </p>
<p>OperationInvokedEvent</p>
<p> is defined by AUTOSAR to always trigger the execution </p>
<p>of a runnable entity. The signature of server runnables depends on the parameters defined </p>
<p>at the C/S port. Its general appearance is as follows: </p>
<p>{void|Std_ReturnType} &lt;Runnable&gt;([IN Rte_Instance inst] {,paramlist}*) </p>
<p> </p>
<p>The return value depends on application errors being assigned to the operation that the </p>
<p>runnable  represents. The  parameter  list  contains  input  in/output  and  output  parameters. </p>
<p>Input  parameters  for  primitive  data  type  are  passed  by  value.  Input  parameters  for </p>
<p>composite data types and all in/output and output parameters independent whether they </p>
<p>are primitive or composite types are passed by reference. The string data type is handled </p>
<p>like a composite type. </p>
<p> </p>
<p><b>3.6.8 </b></p>
<p><b>Asynchronous Server Call Return Triggered Runnables </b></p>
<p>The </p>
<p>AsynchronousServerCallReturnsEvent</p>
<p>  signals  the  end  of  an  asynchronous </p>
<p>server  execution  and  triggers  either  a  runnable  entity  to  collect  the  result  by  using </p>
<p>Rte_Result</p>
<p> or resumes the waitpoint of a blocking </p>
<p>Rte_Result</p>
<p> call. </p>
<p>The runnables have the following signature: </p>
<p>void &lt;RunnableName&gt;([IN Rte_Instance instance] </p>
<p>  </p>
<p> </p>
<p>    [,IN Rte_ActivatingEvent_&lt;RunnableEntity&gt; activation]) </p>
<p> </p>
<p><b>3.6.9 </b></p>
<p><b>Init Triggered Runnables </b></p>
<p>Initialization runnables are called once during startup and have the following signature: </p>
<p>void &lt;RunnableName&gt;([IN Rte_Instance instance]) </p>
<p> </p>
<p><b>3.6.10 </b></p>
<p><b>Background Triggered Runnables </b></p>
<p>Background  triggered  runnables  have  to  be  mapped  to  tasks  with  lowest  priority.  The </p>
<p>runnables are called by the RTE in an endless loop – in the background – when no other </p>
<p>runnable runs. The signature of a background triggered runnable is: </p>
<p>void &lt;RunnableName&gt;([IN Rte_Instance instance] </p>
<p>  </p>
<p> </p>
<p>    [,IN Rte_ActivatingEvent_&lt;RunnableEntity&gt; activation])</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>33 </p>
<p>based on template version 3.5 </p>
<p><b>3.7 </b></p>
<p><b>Exclusive Areas </b></p>
<p>An exclusive area (EA) can be used to protect either only a part of runnable code (explicit </p>
<p>EA access) or the complete runnable code (implicit EA access). AUTOSAR specifies four </p>
<p>implementation methods which are configured during ECU configuration of the RTE. See </p>
<p>also Chapter 6.9. </p>
<p><b></b></p>
<p><b> </b></p>
<p>OS Interrupt Blocking </p>
<p><b></b></p>
<p><b> </b></p>
<p>All Interrupt Blocking </p>
<p><b></b></p>
<p><b> </b></p>
<p>OS Resource </p>
<p><b></b></p>
<p><b> </b></p>
<p>Cooperative Runnable Placement </p>
<p>All of them have to ensure that the current runnable is not preempted while executing the </p>
<p>code inside the exclusive area.  </p>
<p>The  MICROSAR  RTE  analyzes  the  accesses  to  the  different  RTE  exclusive  areas  and </p>
<p>eliminates redundant ones if that is possible e.g. if runnable entities accessing the same </p>
<p>EA they cannot preempt each other and can therefore be dropped. </p>
<p> </p>
<p> </p>
<p><b>Info</b> </p>
<p>For SchM exclusive areas the automatic optimization is currently not supported. </p>
<p>Optimization must be done manually by setting the implementation method to </p>
<p>NONE</p>
<p>. </p>
<p>In addition the implementation of the Exclusive Area APIs for the SchM can be set to </p>
<p>CUSTOM</p>
<p>. In that case the RTE generator doesn’t generate the </p>
<p>SchM_Enter</p>
<p> and </p>
<p>SchM_Exit</p>
<p> APIs. Instead of the APIs have to be implemented manually by the </p>
<p>customer.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If the user selects implementation method </p>
<p>NONE</p>
<p> or </p>
<p>CUSTOMER</p>
<p> it is in the responsibility </p>
<p>of the user that the code between the </p>
<p>SchM_Enter</p>
<p> and </p>
<p>SchM_Exit</p>
<p> still provides </p>
<p>exclusive access to the protected area. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.7.1 </b></p>
<p><b>OS Interrupt Blocking </b></p>
<p>When an exclusive area uses the implementation method </p>
<p>OS_INTERRUPT_BLOCKING</p>
<p>, it </p>
<p>is </p>
<p>protected </p>
<p>by </p>
<p>calling </p>
<p>the </p>
<p>OS </p>
<p>APIs </p>
<p>SuspendOSInterrupts()</p>
<p> </p>
<p>and  </p>
<p>ResumeOSInterrupts()</p>
<p>. The OS does not allow the invocation of event and resource </p>
<p>handling  functions  while  interrupts  are  suspended. This  precludes  calls  to  any  RTE API </p>
<p>that </p>
<p>is </p>
<p>based </p>
<p>upon </p>
<p>an </p>
<p>explicitly </p>
<p>modeled </p>
<p>waitpoint </p>
<p>(blocking </p>
<p>Rte_Receive</p>
<p>, </p>
<p>Rte_Feedback</p>
<p>, </p>
<p>Rte_SwitchAck</p>
<p>  or </p>
<p>Rte_Result</p>
<p> API)  as  well  as  synchronous  server </p>
<p>calls (which sometimes use waitpoints that are not explicitly modeled or other rescheduling </p>
<p>points).  Additionally,  all  APIs  that  might  trigger  a  runnable  entity  on  the  same  ECU  or </p>
<p>cause a blocking queue access to be released are forbidden, as well as exclusive areas </p>
<p>implemented as OS Resource. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>34 </p>
<p>based on template version 3.5 </p>
<p><b>3.7.2 </b></p>
<p><b>All Interrupt Blocking </b></p>
<p>When an exclusive area uses the implementation method </p>
<p>ALL_INTERRUPT_BLOCKING</p>
<p>, it </p>
<p>is </p>
<p>protected </p>
<p>by </p>
<p>calling </p>
<p>the </p>
<p>OS </p>
<p>APIs </p>
<p>SuspendAllInterrupts()</p>
<p> </p>
<p>and  </p>
<p>ResumeAllInterrupts()</p>
<p>. The OS does not allow the invocation of event and resource </p>
<p>handling  functions  while  interrupts  are  suspended. This  precludes  calls  to  any  RTE API </p>
<p>that </p>
<p>is </p>
<p>based </p>
<p>upon </p>
<p>an </p>
<p>explicitly </p>
<p>modeled </p>
<p>waitpoint </p>
<p>(blocking </p>
<p>Rte_Receive</p>
<p>, </p>
<p>Rte_Feedback</p>
<p>, </p>
<p>Rte_SwitchAck</p>
<p>  or </p>
<p>Rte_Result</p>
<p> API)  as  well  as  synchronous  server </p>
<p>calls (which sometimes use waitpoints that are not explicitly modeled or other rescheduling </p>
<p>points).  Additionally,  all  APIs  that  might  trigger  a  runnable  entity  on  the  same  ECU  or </p>
<p>cause a blocking queue access to be released are forbidden, as well as exclusive areas </p>
<p>implemented as OS Resource. </p>
<p><b>3.7.3 </b></p>
<p><b>OS Resource </b></p>
<p>An  exclusive  area  using  implementation  method </p>
<p>OS_RESOURCE</p>
<p>  is  protected  by  OS </p>
<p>resources entered and released via </p>
<p>GetResource()</p>
<p> / </p>
<p>ReleaseResource()</p>
<p>calls, which </p>
<p>raise the task priority so that no other task using the same resource may run. The OS does </p>
<p>not allow the invocation of </p>
<p>WaitEvent()</p>
<p> while an OS resource is occupied. This again </p>
<p>precludes  calls  to  any  RTE API  that  is  based  upon  an  explicitly  modeled  waitpoint  and </p>
<p>synchronous server calls. </p>
<p><b>3.7.4 </b></p>
<p><b>Cooperative Runnable Placement </b></p>
<p>For exclusive areas with implementation method </p>
<p>COOPERATIVE_RUNNABLE_PLACEMENT</p>
<p>, </p>
<p>the RTE generator only applies a check whether any of the tasks accessing the exclusive </p>
<p>area are able to preempt any other task of that group. This again precludes calls to any </p>
<p>RTE API that is based upon an explicitly modeled waitpoint and synchronous server calls. </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>35 </p>
<p>based on template version 3.5 </p>
<p><b>3.8 </b></p>
<p><b>Error Handling </b></p>
<p><b>3.8.1 </b></p>
<p><b>Development Error Reporting </b></p>
<p>By </p>
<p>default, </p>
<p>development </p>
<p>errors </p>
<p>are </p>
<p>reported </p>
<p>to </p>
<p>the </p>
<p>DET </p>
<p>using </p>
<p>the </p>
<p>service </p>
<p>Det_ReportError()</p>
<p> as specified in [21], if development error reporting is enabled in the </p>
<p>RteGeneration</p>
<p> parameters (i.e. by setting the parameters </p>
<p>DevErrorDetect</p>
<p> and / or </p>
<p>DevErrorDetectUninit).</p>
<p> </p>
<p>If  another  module  is  used  for  development  error  reporting,  the  function  prototype  for </p>
<p>reporting the error can be configured by the integrator, but must have the same signature </p>
<p>as the service </p>
<p>Det_ReportError()</p>
<p>. The reported RTE ID is 2. </p>
<p>The  reported  service  IDs  identify  the  services  which  are  described  in  chapter  5.  The </p>
<p>following table presents the service IDs and the related services: </p>
<p><b>Service ID </b></p>
<p><b>Service </b></p>
<p>0x00 </p>
<p>SchM_Init </p>
<p>0x01 </p>
<p>SchM_Deinit </p>
<p>0x03 </p>
<p>SchM_Enter </p>
<p>0x04 </p>
<p>SchM_Exit </p>
<p>0x13 </p>
<p>Rte_Send </p>
<p>0x14 </p>
<p>Rte_Write </p>
<p>0x15 </p>
<p>Rte_Switch </p>
<p>0x16 </p>
<p>Rte_Invalidate </p>
<p>0x17 </p>
<p>Rte_Feedback </p>
<p>0x18 </p>
<p>Rte_SwitchAck </p>
<p>0x19 </p>
<p>Rte_Read </p>
<p>0x1A </p>
<p>Rte_DRead </p>
<p>0x1B </p>
<p>Rte_Receive </p>
<p>0x1C </p>
<p>Rte_Call </p>
<p>0x1D </p>
<p>Rte_Result </p>
<p>0x1F </p>
<p>Rte_CData </p>
<p>0x20 </p>
<p>Rte_Prm </p>
<p>0x28 </p>
<p>Rte_IrvRead </p>
<p>0x29 </p>
<p>Rte_IrvWrite </p>
<p>0x2A </p>
<p>Rte_Enter </p>
<p>0x2B </p>
<p>Rte_Exit </p>
<p>0x2C </p>
<p>Rte_Mode </p>
<p>0x30 </p>
<p>Rte_IsUpdated </p>
<p>0x70 </p>
<p>Rte_Start </p>
<p>0x71 </p>
<p>Rte_Stop </p>
<p>0x90 </p>
<p>Rte_COMCbkTAck_&lt;sn&gt; </p>
<p>0x91 </p>
<p>Rte_COMCbkTErr_&lt;sn&gt; </p>
<p>0x92 </p>
<p>Rte_COMCbkInv_&lt;sn&gt; </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>36 </p>
<p>based on template version 3.5 </p>
<p><b>Service ID </b></p>
<p><b>Service </b></p>
<p>0x93 </p>
<p>Rte_COMCbkRxTOut_&lt;sn&gt; </p>
<p>0x94 </p>
<p>Rte_COMCbkTxTOut_&lt;sn&gt; </p>
<p>0x95 </p>
<p>Rte_COMCbk_&lt;sg&gt; </p>
<p>0x96 </p>
<p>Rte_COMCbkTAck_&lt;sg&gt; </p>
<p>0x97 </p>
<p>Rte_COMCbkTErr_&lt;sg&gt; </p>
<p>0x98 </p>
<p>Rte_COMCbkInv_&lt;sg&gt; </p>
<p>0x99 </p>
<p>Rte_COMCbkRxTOut_&lt;sg&gt; </p>
<p>0x9A </p>
<p>Rte_COMCbkTxTOut_&lt;sg&gt; </p>
<p>0x9F </p>
<p>Rte_COMCbk_&lt;sn&gt; </p>
<p>0xF0 </p>
<p>Rte_Task </p>
<p>0xF1 </p>
<p>Rte_IncDisableFlags </p>
<p>0xF2 </p>
<p>Rte_DecDisableFlags </p>
<p>Table 3-4  </p>
<p>Service IDs </p>
<p>The errors reported to DET are described in the following table: </p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>RTE_E_DET_ILLEGAL_NESTED_EX</p>
<p>CLUSIVE_AREA </p>
<p>The same exclusive area was called nested or exclusive </p>
<p>areas were not exited in the reverse order they were </p>
<p>entered </p>
<p>RTE_E_DET_UNINIT </p>
<p>Rte/SchM is not initialized </p>
<p>RTE_E_DET_MODEARGUMENT </p>
<p>Rte_Switch was called with an invalid mode parameter </p>
<p>RTE_E_DET_TRIGGERDISABLECOU</p>
<p>NTER </p>
<p>Counter of mode disabling triggers is in an invalid state </p>
<p>RTE_E_DET_TRANSITIONSTATE </p>
<p>Mode machine is in an invalid state </p>
<p>RTE_E_DET_MULTICORE_STARTUP </p>
<p>Initialization of the master core before all slave cores </p>
<p>were initialized </p>
<p>RTE_E_DET_ILLEGAL_SIGNAL_ID </p>
<p>RTE callback was called for a signal that is not active in </p>
<p>the current variant. </p>
<p>Table 3-5  </p>
<p>Errors reported to DET </p>
<p> </p>
<p>The </p>
<p>error </p>
<p>RTE_E_DET_UNINIT </p>
<p>will </p>
<p>only </p>
<p>be </p>
<p>reported </p>
<p>if </p>
<p>the </p>
<p>parameter</p>
<p> </p>
<p>DevErrorDetectUninit </p>
<p>is enabled. The reporting of all other errors can be enabled by </p>
<p>setting the parameter </p>
<p>DevErrorDetect</p>
<p>. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>37 </p>
<p>based on template version 3.5 </p>
<p><b>4 </b></p>
<p><b>RTE Generation and Integration </b></p>
<p>This  chapter  gives  necessary  information  about  the  content  of  the  delivery,  the  RTE </p>
<p>generation process including a description about the different RTE generation modes and </p>
<p>finally information how to integrate the MICROSAR RTE into an application environment of </p>
<p>an ECU.  </p>
<p><b>4.1 </b></p>
<p><b>Scope of Delivery </b></p>
<p>The delivery of the RTE contains no static RTE code files. The RTE module is completely </p>
<p>generated by the MICROSAR RTE Generator. After the installation, the delivery has the </p>
<p>following content: </p>
<p><b>Files </b></p>
<p><b>Description </b></p>
<p>DVCfgRteGen.exe                         </p>
<p>(including several DLLs and XML files) </p>
<p>Command line MICROSAR RTE generator </p>
<p>MicrosarRteGen.exe </p>
<p>MICROSAR RTE File generator  </p>
<p>Rte.jar </p>
<p>Settings_Rte.xml </p>
<p>DaVinci Configurator 5 adaptation modules </p>
<p>Rte_Bswmd.arxml </p>
<p>BSWMD file for MICROSAR RTE </p>
<p>TechnicalReference_Asr_Rte.pdf </p>
<p>This documentation </p>
<p>ReleaseNotes_MICROSAR_RTE.htm </p>
<p>Release Notes </p>
<p>Table 4-1  </p>
<p>Content of Delivery </p>
<p> </p>
<p> </p>
<p><b>Info</b> </p>
<p>The RTE Configuration Tool DaVinci Developer is not part of MICROSAR RTE / BSW </p>
<p>installation package. It has to be installed separately.  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>38 </p>
<p>based on template version 3.5 </p>
<p><b>4.2 </b></p>
<p><b>RTE Generation </b></p>
<p>The MICROSAR RTE generator can be called either from the command line  application </p>
<p>DVCfgCmd.exe</p>
<p> or directly from within the DaVinci Configurator.  </p>
<p><b>4.2.1 </b></p>
<p><b>Command Line Options </b></p>
<p><b>Option </b></p>
<p><b>Description </b></p>
<p>--project &lt;file&gt; </p>
<p>–p &lt;file&gt; </p>
<p>Specifies the absolute path to the DPA project file. </p>
<p>--generate </p>
<p>-g </p>
<p>Generate the given project specified in </p>
<p>&lt;file&gt;</p>
<p>. </p>
<p>--moduleToGenerate </p>
<p>-m &lt;module&gt; </p>
<p>Specifies the module definition references, which </p>
<p>should be generated by the </p>
<p>-g</p>
<p> switch. Separate </p>
<p>multiple modules by a ','.  </p>
<p>E.g. /MICROSAR/Rte, /MICROSAR/Nm </p>
<p>--genArg=”&lt;module&gt;: &lt;params&gt;”  </p>
<p>Passes the specified parameters </p>
<p>&lt;params&gt;</p>
<p> to the </p>
<p>generator of the specified module </p>
<p>&lt;module&gt;</p>
<p>. For </p>
<p>details of the possible parameters of the RTE module </p>
<p>see Table 4-3.  </p>
<p>--help </p>
<p>-h </p>
<p>Displays the general help information of </p>
<p>DVCfgCmd.exe</p>
<p> </p>
<p>Table 4-2  </p>
<p>DVCfgCmd Command Line Options </p>
<p><b>4.2.2 </b></p>
<p><b>RTE Generator Command Line Options </b></p>
<p><b>Option </b></p>
<p><b>Description </b></p>
<p>–m &lt;obj&gt; </p>
<p>Selects the DaVinci model object, where </p>
<p>&lt;obj&gt;</p>
<p> is either </p>
<p>&lt;ECUProjectName&gt;</p>
<p> or </p>
<p>&lt;ComponentTypeName&gt;</p>
<p>.   </p>
<p>Note: If </p>
<p>–g i</p>
<p> or </p>
<p>–g c</p>
<p> are selected, which accepts both, </p>
<p>&lt;ComponentTypeName&gt;</p>
<p> or </p>
<p>&lt;ECUProjectName&gt;</p>
<p> and the </p>
<p>configuration contains such objects with the same name, the </p>
<p>component type object takes preference over the ECU project. </p>
<p>When the workspace contains only a single ECUProject or a single </p>
<p>ComponentType, the </p>
<p>-m</p>
<p> parameter can be omitted. </p>
<p>With the </p>
<p>–m</p>
<p> parameter also multiple component types can be selected, </p>
<p>delimited with semicolons. </p>
<p>–g [r|c|i|h] </p>
<p>Selects generation of the RTE with the following sub options: </p>
<p>r </p>
<p>Selects RTE generation for the ECU project specified via option </p>
<p>-</p>
<p>m</p>
<p> </p>
<p>&lt;ECUProjectName&gt;</p>
<p>. This is the default option. Therefore </p>
<p>–g</p>
<p> is </p>
<p>equal to </p>
<p>–g r</p>
<p>. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>39 </p>
<p>based on template version 3.5 </p>
<p>c </p>
<p>Selects RTE contract phase header generation for a single </p>
<p>component type or BSW module if </p>
<p>-m </p>
<p>&lt;ComponentTypeName/BswModuleName&gt;</p>
<p> or for multiple </p>
<p>component types and BSW modules if </p>
<p>–m </p>
<p>&lt;ComponentType1Name/BswModule1Name&gt;; </p>
<p>&lt;ComponentType2Name/BswModule2Name&gt;</p>
<p> or for all non- </p>
<p>service component types and BSW modules of an ECU project if </p>
<p>-m &lt;ECUProjectName</p>
<p><i>&gt;</i>. </p>
<p> </p>
<p>i </p>
<p>Selects implementation template generation for a single </p>
<p>component type if </p>
<p>-m &lt;ComponentTypeName&gt; </p>
<p>or for multiple </p>
<p>component types if</p>
<p> –m </p>
<p>&lt;ComponentType1Name&gt;;&lt;ComponentType2Name&gt;</p>
<p> or for all </p>
<p>non- service component types of an ECU project if </p>
<p>-m </p>
<p>&lt;ECUProjectName&gt;</p>
<p><i>. </i></p>
<p>The optional </p>
<p>–f &lt;file&gt;</p>
<p> parameter specifies the file name to use </p>
<p>for the implementation template file. If the </p>
<p>–f &lt;file&gt;</p>
<p> parameter </p>
<p>is not given, or </p>
<p>–m</p>
<p> contains an ECU project name, the filename </p>
<p>defaults to </p>
<p>&lt;ComponentTypeName&gt;.c</p>
<p>. </p>
<p>Already existing implementation files are updated and a backup is </p>
<p>created. </p>
<p> </p>
<p>h </p>
<p>Selects VFB trace hook template generation for the ECU project </p>
<p>specified via option </p>
<p>-m &lt;ECUProjectName&gt;</p>
<p><i>. </i></p>
<p>The optional </p>
<p>–f &lt;file&gt;</p>
<p> parameter specifies the file name to use </p>
<p>for the VFB trace hook template file. If the </p>
<p>–f &lt;file&gt;</p>
<p> parameter </p>
<p>is not given, the filename defaults to </p>
<p>VFBTraceHook_&lt;ECUProjectName&gt;.c</p>
<p>. </p>
<p>Already existing implementation files are updated and a backup is </p>
<p>created. </p>
<p> </p>
<p> </p>
<p>This parameter can be used more than one time to generate several </p>
<p>modes in one step. </p>
<p>–o &lt;path&gt; </p>
<p>-o r=&lt;path&gt; </p>
<p>-o c=&lt;path&gt; </p>
<p>-o i=&lt;path&gt; </p>
<p>-o h=&lt;path&gt; </p>
<p>-o s=&lt;path&gt; </p>
<p>-o a=&lt;path&gt; </p>
<p>Output path for the generated files.  </p>
<p>If more than one generation mode is active, a special path can be </p>
<p>specified for each generation mode by assigning the path to the </p>
<p>character that is used as sub option for the </p>
<p>–g</p>
<p> parameter. </p>
<p>Furthermore the path for the application header files in the RTE </p>
<p>generation mode can be selected via option –o s=&lt;path&gt;. By default </p>
<p>they are generated into the subdirectory “Components”. </p>
<p>The path for A2L files can be specified with the option –o a=&lt;path&gt;. </p>
<p>These files are generated into the RTE directory by default. </p>
<p>Note: The </p>
<p>&lt;path&gt;</p>
<p> configured with </p>
<p>-o</p>
<p> parameter overwrites the path </p>
<p>which is specified in the dpa project file. </p>
<p>–f &lt;file&gt; </p>
<p>Optional parameter to specify the output file name for options </p>
<p>–g i</p>
<p> </p>
<p>and </p>
<p>–g h</p>
<p>. </p>
<p>Note: For option </p>
<p>–g i</p>
<p> the output file name can only be specified if </p>
<p>–m</p>
<p> </p>
<p>specifies a component type. The output file name cannot be specified </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>40 </p>
<p>based on template version 3.5 </p>
<p>when –m specifies multiple component types. </p>
<p>-v </p>
<p>Enables verbose mode which includes help information for error, </p>
<p>warning and info messages. </p>
<p>–h </p>
<p>Displays the general help information. </p>
<p>Table 4-3  </p>
<p>RTE Generator Command Line Options </p>
<p><b>4.2.3 </b></p>
<p><b>Generation Path </b></p>
<p>The RTE output files are generated into the path which is either specified within the dpa </p>
<p>project  file  or  which  is  specified  in  the </p>
<p>–o</p>
<p>  command  line  option.  If  several  generation </p>
<p>modes are activated in parallel, for each phase a special path can be specified with the </p>
<p>–o</p>
<p> </p>
<p>command line option. </p>
<p>In RTE generation phase (command line option </p>
<p>–g</p>
<p> or </p>
<p>–g r</p>
<p>), the component type specific </p>
<p>application </p>
<p>header </p>
<p>files </p>
<p>are </p>
<p>generated </p>
<p>into </p>
<p>the </p>
<p>subdirectory </p>
<p>Components</p>
<p>. </p>
<p>This </p>
<p>subdirectory </p>
<p>can </p>
<p>be </p>
<p>changed </p>
<p>in </p>
<p>the </p>
<p>RTE </p>
<p>generation </p>
<p>phase </p>
<p>with </p>
<p>the </p>
<p>option </p>
<p>–o </p>
<p>“s=&lt;path&gt;”</p>
<p>. In addition the directory for the A2L files, which are generated into the RTE </p>
<p>directory by default, can be specified with the option </p>
<p>–o “a=&lt;path&gt;”</p>
<p>. </p>
<p><b>4.3 </b></p>
<p><b>MICROSAR RTE generation modes </b></p>
<p>The sections give an overview of the files generated by the MICROSAR RTE generator in </p>
<p>the different RTE generation modes and some examples how the command line call looks </p>
<p>like. </p>
<p><b>4.3.1 </b></p>
<p><b>RTE Generation Phase </b></p>
<p>The following files are generated by the RTE generation: (Option </p>
<p>–g</p>
<p> or </p>
<p>–g r</p>
<p>) </p>
<p><b>File </b></p>
<p><b>Description </b></p>
<p>Rte_&lt;</p>
<p>ComponentType</p>
<p>&gt;.h </p>
<p>Application header file, which has to be included into the SWC </p>
<p>code. This header file is the only file to be included in the </p>
<p>component code. It is generated to the </p>
<p>Components</p>
<p> subdirectory </p>
<p>by default. </p>
<p>Rte_&lt;</p>
<p>ComponentType</p>
<p>&gt;_Type.h </p>
<p>Application type header file. This header file contains SWC specific </p>
<p>type definitions. It is generated to the </p>
<p>Components</p>
<p> subdirectory </p>
<p>by default. </p>
<p>SchM_&lt;</p>
<p>BswModule</p>
<p>&gt;.h </p>
<p>Module interlink header file, which has to be included into the BSW </p>
<p>module code. </p>
<p>SchM_&lt;</p>
<p>BswModule</p>
<p>&gt;_Type.h </p>
<p>Module interlink types header file. This header file contains BSW </p>
<p>module specific type definitions.  </p>
<p>&lt;</p>
<p>ComponentType</p>
<p>&gt;_MemMap.h </p>
<p>Template contains SWC specific part of the memory mapping. It is </p>
<p>generated to the </p>
<p>Components</p>
<p> subdirectory by default. </p>
<p>Rte.c </p>
<p>Generated RTE </p>
<p>Rte_&lt;OsApplication&gt;.c </p>
<p> </p>
<p>OsApplication specific part of the generated RTE (only generated </p>
<p>when OsApplications are configured) </p>
<p>Rte_PBCfg.c </p>
<p>The RTE post build data set configuration file contains the data </p>
<p>structures for the postbuild RTE initialization. </p>
<p>Rte.h </p>
<p>RTE internal declarations </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>41 </p>
<p>based on template version 3.5 </p>
<p>Rte_Main.h </p>
<p>Header file for RTE lifecycle API </p>
<p>Rte_Cfg.h </p>
<p>Configuration file for the RTE  </p>
<p>Rte_Cbk.h </p>
<p>Contains prototypes for COM callbacks </p>
<p>Rte_Hook.h </p>
<p>Contains relevant information for VFB tracing </p>
<p>Rte_Type.h </p>
<p>Contains the application defined data type definitions and RTE </p>
<p>internal data types </p>
<p>Rte_DataHandleType.h </p>
<p> </p>
<p>The RTE data handle types header file contains the data handle </p>
<p>type declarations required for the component data structures. </p>
<p>Rte_PBCfg.h </p>
<p>The RTE post build data set configuration header contains the </p>
<p>declarations for the data structures that are used for the postbuild </p>
<p>RTE initialization. </p>
<p>Rte_UserTypes.h </p>
<p>Template which is generated if either user defined data types are </p>
<p>required for Per-Instance memory or if a data type is used by the </p>
<p>RTE but generation is skipped with the </p>
<p>typeEmitter</p>
<p> attribute. </p>
<p>Rte_MemMap.h </p>
<p>Template contains RTE specific part of the memory mapping </p>
<p>Rte_Compiler_Cfg.h </p>
<p>Template contains RTE specific part of the compiler abstraction </p>
<p>usrostyp.h </p>
<p>Template which is only generated if memory protection support is </p>
<p>enabled. In that case this file is included by the MICROSAR OS. </p>
<p>Rte.oil </p>
<p>OS configuration for the RTE </p>
<p>Rte_Needs.ecuc.arxml </p>
<p>Contains the RTE requirements on BSW module configuration for </p>
<p>Os, Com and NvM.    </p>
<p>Rte.a2l </p>
<p> </p>
<p>A2L file containing CHARACTERISTIC and MEASUREMENT </p>
<p>objects for the generated RTE </p>
<p>Rte_MemSeg.a2l </p>
<p>A2L file containing MEMORY_SEGMENT objects for the </p>
<p>generated RTE </p>
<p>Rte_rules.mak, </p>
<p>Rte_defs.mak, </p>
<p>Rte_check.mak, </p>
<p>Rte_cfg.mak </p>
<p>Make files according to the AUTOSAR make environment proposal </p>
<p>are generated into the </p>
<p>mak</p>
<p> subdirectory. </p>
<p>Rte.html </p>
<p>Contains information about RAM / CONST consumption of the </p>
<p>generated RTE as well as a listing of all triggers and their OS </p>
<p>events and alarms. </p>
<p>Table 4-4  </p>
<p>Generated Files of RTE Generation Phase </p>
<p> </p>
<p>Example: </p>
<p><b> </b></p>
<p>DVCfgCmd -p &quot;InteriorLight.dpa&quot; –m /MICROSAR/Rte –g </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>42 </p>
<p>based on template version 3.5 </p>
<p><b>4.3.2 </b></p>
<p><b>RTE Contract Phase Generation </b></p>
<p>The following files are generated by the RTE contract phase generation: (Option </p>
<p>–g c</p>
<p>) </p>
<p><b>File </b></p>
<p><b>Description </b></p>
<p>Rte_&lt;</p>
<p>ComponentType</p>
<p>&gt;.h </p>
<p>Application header file, which must be included into the SWC </p>
<p>code. This header file is the only file to be included in the </p>
<p>component code.  </p>
<p>Rte_&lt;</p>
<p>ComponentType</p>
<p>&gt;_Type.h </p>
<p>Application type header file. This header file contains SWC specific </p>
<p>type definitions. </p>
<p>&lt;</p>
<p>ComponentType</p>
<p>&gt;_MemMap.h </p>
<p>Template contains SWC specific part of the memory mapping. </p>
<p>Rte.h </p>
<p>RTE internal declarations </p>
<p>Rte_Type.h </p>
<p>Contains the application defined data type definitions and RTE </p>
<p>internal data types </p>
<p>Rte_DataHandleType.h </p>
<p>The RTE data handle types header file contains the data handle </p>
<p>type declarations required for the component data structures. </p>
<p>Rte_UserTypes.h </p>
<p>Template which is generated if either user defined data types are </p>
<p>required for Per-Instance memory or if a data type is used by the </p>
<p>RTE but generation is skipped with the </p>
<p>typeEmitter</p>
<p> attribute. </p>
<p>Rte_MemMap.h </p>
<p>Template contains RTE specific part of the memory mapping </p>
<p>Rte_Compiler_Cfg.h </p>
<p>Template contains RTE specific part of the compiler abstraction </p>
<p>SchM_&lt;</p>
<p>BswModule</p>
<p>&gt;.h </p>
<p>Module interlink header file, which has to be included into the BSW </p>
<p>module code. </p>
<p>SchM_&lt;</p>
<p>BswModule</p>
<p>&gt;_Type.h </p>
<p>Module interlink types header file. This header file contains BSW </p>
<p>module specific type definitions. </p>
<p>Table 4-5  </p>
<p>Generated Files of RTE Contract Phase </p>
<p> </p>
<p>Example: </p>
<p><b> </b></p>
<p>DVCfgCmd -p &quot;InteriorLight.dpa&quot;  </p>
<p>    -m /MICROSAR/Rte  </p>
<p>    –g  </p>
<p>    --genArg=”Rte: -g c –m SenderComponent” </p>
<p> </p>
<p>The  generated  header  files  are  located  in  a  component  type  specific  subdirectory.  The </p>
<p>application  header  file  must  be  included  in  each  source  file  of  a  SWC  implementation, </p>
<p>where the RTE API for that specific SWC type is used.  </p>
<p>The  application  header  file  created  in  the  RTE  contract  phase  can  be  used  to  compile </p>
<p>object code components, which can be linked to an RTE generated in the RTE generation </p>
<p>phase. The application header files are generated in RTE compatibility mode.   </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>43 </p>
<p>based on template version 3.5 </p>
<p> </p>
<p><b>Caution </b></p>
<p>During the RTE generation phase an optimized header file is generated. This optimized </p>
<p>header file should be used when compiling the source code SWCs during the ECU </p>
<p>build process. </p>
<p>The usage of object code SWCs, which are compiled with the application header files </p>
<p>of the contract phase, require an “Implementation Code Type” for SWCs set to “object </p>
<p>code” in order to tell the RTE generator in the RTE generation phase NOT to create </p>
<p>optimized RTE API accesses but compatible ones.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>44 </p>
<p>based on template version 3.5 </p>
<p><b>4.3.3 </b></p>
<p><b>Template Code Generation for Application Software Components </b></p>
<p>The following file is generated by the implementation template generation: (Option </p>
<p>–g i</p>
<p>) </p>
<p><b>File </b></p>
<p><b>Description </b></p>
<p>&lt;FileName&gt;.c </p>
<p>An implementation template is generated if the </p>
<p>–g i</p>
<p> option is </p>
<p>selected. The </p>
<p>–f</p>
<p> option specifies the name of the generated c file. </p>
<p>If no name is selected the default name </p>
<p>&lt;</p>
<p>ComponentTypeName</p>
<p>&gt;.c</p>
<p> </p>
<p>is used. </p>
<p>Table 4-6  </p>
<p>Generated Files of RTE Template Code Generation </p>
<p> </p>
<p>Example: </p>
<p> </p>
<p>DVCfgCmd -p &quot;InteriorLight.dpa&quot;  </p>
<p>    –m /MICROSAR/Rte  </p>
<p>    –g  </p>
<p>    --genArg=”Rte: -g i –m SenderComponent -f Component1.c” </p>
<p> </p>
<p>The  generated  template  files  contain  all  empty  bodies  of  the  runnable  entities  for  the </p>
<p>selected component type. It also contains the include directive for the application header </p>
<p>file. In addition, the available RTE API calls are included in comments. </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>When the destination file of the SWC template code generation is already available, </p>
<p>code that is placed within the user code sections marked by “DO NOT CHANGE”-</p>
<p>comments is transferred unchanged to the updated template file. </p>
<p>Additionally, a numbered backup of the original file is made before the new file is </p>
<p>written.  </p>
<p>The preservation of runnable code is done by checking for the runnable symbol. This </p>
<p>implies that after a change of the name of a runnable the runnable implementation is </p>
<p>preserved, while a change of the symbol results in a new empty function for the </p>
<p>runnable. </p>
<p>Code that was removed during an update is kept in the “removed code” section at the </p>
<p>bottom of the implementation file and in the numbered backups. </p>
<p>The template update is particularly useful when e.g. access to some interfaces has </p>
<p>been added or removed from a runnable, because then the information of available </p>
<p>APIs is updated by the generation process without destroying the implementation. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>45 </p>
<p>based on template version 3.5 </p>
<p><b>4.3.4 </b></p>
<p><b>VFB Trace Hook Template Code Generation </b></p>
<p>The following file is generated by the VFB trace hook template generation: (Option </p>
<p>–g h</p>
<p>) </p>
<p><b>File </b></p>
<p><b>Description </b></p>
<p>&lt;FileName&gt;.c </p>
<p>An implementation template of the VFB trace hooks is generated if </p>
<p>the </p>
<p>–g h</p>
<p> option is selected. The </p>
<p>–f</p>
<p> option specifies the name of </p>
<p>the generated c file. If no name is selected the default name</p>
<p> </p>
<p>VFBTraceHook_&lt; ECUProjectName &gt;.c</p>
<p> is used.  </p>
<p>Table 4-7  </p>
<p>Generated Files of VFB Trace Hook Code Generation </p>
<p>Example: </p>
<p> </p>
<p>DVCfgCmd -p &quot;InteriorLight.dpa&quot;  </p>
<p>    –m /MICROSAR/Rte  </p>
<p>    –g  </p>
<p>    --genArg=”Rte: -g h –f VFBTraceHook_myEcu.c” </p>
<p><b> </b></p>
<p> </p>
<p><b>Caution </b></p>
<p>When the destination file of the VFB trace hook template generation is already </p>
<p>available, code that is placed within the user code sections marked by “DO NOT </p>
<p>CHANGE” comments is transferred unchanged to the updated template file. </p>
<p>Additionally, a numbered backup of the original file is made before the new file is </p>
<p>written. </p>
<p>The preservation of trace hook code is done by checking for the trace hook name. </p>
<p>When the name of a hook changes, e.g. because the name of a data element </p>
<p>changed, then the code of the previous trace hook is removed. </p>
<p>Code that was removed during an update is kept in the “removed code” section at the </p>
<p>bottom of the implementation file and in the numbered backups. </p>
<p>The template update is particularly useful when some trace hooks have been added or </p>
<p>removed due to changed interfaces or OS usage. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>46 </p>
<p>based on template version 3.5 </p>
<p><b>4.4 </b></p>
<p><b>Include Structure </b></p>
<p><b>4.4.1 </b></p>
<p><b>RTE Include Structure </b></p>
<p> </p>
<p>Figure 4-1  </p>
<p>RTE Include Structure </p>
<p> </p>
<p><b> class RTE Include Structure</b></p>
<p>Com.h</p>
<p>Rte_Cbk.h</p>
<p>Rte.c</p>
<p>Rte_&lt;Swc&gt;.h</p>
<p>Rte_Type.h</p>
<p>Rte_&lt;Swc&gt;_Type.h</p>
<p>Os.h</p>
<p>Rte_Hook.h</p>
<p>Rte_Cfg.h</p>
<p>Rte.h</p>
<p>Std_Types.h</p>
<p>Platform_Types.h</p>
<p>Compiler.h</p>
<p>Compiler_Cfg.h</p>
<p>Rte_Main.h</p>
<p>Rte_UserTypes.h</p>
<p>Rte_Compiler_Cfg.h</p>
<p>MemMap.h</p>
<p>&lt;Swc&gt;_MemMap.h</p>
<p>Rte_MemMap.h</p>
<p>Generated RTE C File</p>
<p>Generated RTE Header Files</p>
<p>Header Files of other Modules</p>
<p><b>Legend</b></p>
<p>Rte_DataHandleType.h</p>
<p>SchM_&lt;Bsw&gt;.h</p>
<p>SchM_&lt;Bsw&gt;_Type.h</p>
<p>Xcp.h</p>
<p>Det.h</p>
<p>Ioc.h</p>
<p>Rte_PBCfg.h</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>47 </p>
<p>based on template version 3.5 </p>
<p><b>4.4.2 </b></p>
<p><b>SWC Include Structure </b></p>
<p>The  following  figure  shows  the  include  structure  of  a  SWC  with  respect  to  the  RTE </p>
<p>dependency. All other header files which might be included by the SWC are not shown. </p>
<p> </p>
<p>Figure 4-2  </p>
<p>SWC Include Structure </p>
<p> </p>
<p><b> class Swc Include Structure</b></p>
<p>&lt;Swc&gt;.c</p>
<p>Rte_&lt;Swc&gt;.h</p>
<p>Rte_&lt;Swc&gt;_Type.h</p>
<p>Com.h</p>
<p>Rte_Type.h</p>
<p>Rte.h</p>
<p>Rte_UserTypes.h</p>
<p>MemMap.h</p>
<p>&lt;Swc&gt;_MemMap.h</p>
<p>Rte_MemMap.h</p>
<p>User SWC Implementation File(s)</p>
<p>Generated RTE Header Files</p>
<p>Header Files of other Modules</p>
<p><b>Legend</b></p>
<p>Rte_DataHandleType.h</p>
<p>Os.h</p>
<p>1..*</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>48 </p>
<p>based on template version 3.5 </p>
<p><b>4.4.3 </b></p>
<p><b>BSW Include Structure </b></p>
<p>The  following  figure  shows  the  include  structure  of  a  BSW  module  with  respect  to  the </p>
<p>SchM dependency. All other header files which might be included by the BSW module are </p>
<p>not shown.   </p>
<p> </p>
<p>Figure 4-3  </p>
<p>BSW Include Structure </p>
<p> </p>
<p><b> class Bsw Include Structure</b></p>
<p>BSW Module File(s)</p>
<p>Generated RTE Header Files</p>
<p>Header Files of other Modules</p>
<p><b>Legend</b></p>
<p>&lt;Bsw&gt;.c</p>
<p>SchM_&lt;Bsw&gt;.h</p>
<p>SchM_&lt;Bsw&gt;_Type.h</p>
<p>Os.h</p>
<p>Rte.h</p>
<p>Rte_Type.h</p>
<p>Rte_PBCfg.h</p>
<p>1..*</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<p>«include»</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>49 </p>
<p>based on template version 3.5 </p>
<p><b>4.5 </b></p>
<p><b>Compiler Abstraction and Memory Mapping  </b></p>
<p>The  objects  (e.g.  variables,  functions,  constants)  are  declared  by  compiler  independent </p>
<p>definitions  –  the  compiler  abstraction  definitions.  Each  compiler  abstraction  definition  is </p>
<p>assigned to a memory section. </p>
<p>The following two tables contain the memory section names and the compiler abstraction </p>
<p>definitions defined for the RTE and illustrate their assignment among each other. </p>
<p><b>Compiler Abstraction   </b></p>
<p><b>Definitions </b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Memory Mapping </b></p>
<p><b>Sections </b></p>
<p>RTE_VAR_ZERO_INIT </p>
<p>&lt;Swc&gt;_VAR_ZERO_INIT </p>
<p>RTE_VAR_INIT </p>
<p>&lt;Swc&gt;_VAR_INIT </p>
<p>RTE_VAR_NOINIT </p>
<p>&lt;Swc&gt;_VAR_NOINIT </p>
<p>RTE_VAR_&lt;Pim&gt; </p>
<p>RTE_&lt;NvRamBlock&gt; </p>
<p>RTE_VAR_&lt;Cal&gt; </p>
<p>RTE_CONST </p>
<p>&lt;Swc&gt;_CONST </p>
<p>RTE_CONST_&lt;Cal&gt; </p>
<p>RTE_CODE </p>
<p>&lt;Swc&gt;_CODE </p>
<p>RTE_APPL_CODE </p>
<p>RTE_&lt;SWC&gt;_APPL_CODE </p>
<p>RTE_&lt;SWC&gt;_APPL_VAR </p>
<p>RTE_&lt;SWC&gt;_APPL_DATA </p>
<p>RTE_APPL_VAR </p>
<p>RTE_APPL_DATA </p>
<p>RTE_START_SEC_VAR_ZERO_INIT_8BIT  </p>
<p>RTE_STOP_SEC_VAR_ZERO_INIT_8BIT </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_VAR_ZERO_INIT_UNSPECIFIED </p>
<p>RTE_STOP_SEC_VAR_ZERO_INIT_UNSPECIFIED </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_VAR_&lt;OsAppl&gt;_ZERO_INIT_UNSPECIFIED</p>
<p>1</p>
<p> </p>
<p>RTE_STOP_SEC_VAR_&lt;OsAppl&gt;_ZERO_INIT_UNSPECIFIED</p>
<p>1</p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>&lt;Swc&gt;_START_SEC_VAR_ZERO_INIT_UNSPECIFIED </p>
<p>&lt;Swc&gt;_STOP_SEC_VAR_ZERO_INIT_UNSPECIFIED </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_VAR_INIT_UNSPECIFIED </p>
<p>RTE_STOP_SEC_VAR_INIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_VAR_&lt;OsAppl&gt;_INIT_UNSPECIFIED</p>
<p>1</p>
<p> </p>
<p>RTE_STOP_SEC_VAR_&lt;OsAppl&gt;_INIT_UNSPECIFIED</p>
<p>1</p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>&lt;Swc&gt;_START_SEC_VAR_INIT_UNSPECIFIED </p>
<p>&lt;Swc&gt;_STOP_SEC_VAR_INIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_VAR_NOINIT_UNSPECIFIED </p>
<p>RTE_STOP_SEC_VAR_NOINIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_VAR_&lt;OsAppl&gt;_NOINIT_UNSPECIFIED</p>
<p>1</p>
<p> </p>
<p>RTE_STOP_SEC_VAR_&lt;OsAppl&gt;_NOINIT_UNSPECIFIED</p>
<p>1</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>&lt;Swc&gt;_START_SEC_VAR_NOINIT_UNSPECIFIED </p>
<p>&lt;Swc&gt;_STOP_SEC_VAR_NOINIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_VAR_&lt;Pim&gt;_UNSPECIFIED </p>
<p>RTE_STOP_SEC_VAR_&lt;Pim&gt;_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_&lt;NvRamBlock&gt;                    </p>
<p>RTE_STOP_SEC_&lt;NvRamBlock&gt; </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_VAR_&lt;Cal&gt;_UNSPECIFIED </p>
<p>RTE_STOP_SEC_VAR_&lt;Cal&gt;_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_CONST_UNSPECIFIED </p>
<p>RTE_STOP_SEC_CONST_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>&lt;Swc&gt;_START_SEC_CONST_UNSPECIFIED </p>
<p>&lt;Swc&gt;_STOP_SEC_CONST_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>                                            </p>
<p>1</p>
<p> This memory mapping sections are only used if memory protection support is enabled </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>50 </p>
<p>based on template version 3.5 </p>
<p>RTE_START_SEC_CONST_&lt;Cal&gt;_UNSPECIFIED </p>
<p>RTE_STOP_SEC_CONST_&lt;Cal&gt;_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_CODE                                 </p>
<p>RTE_STOP_SEC_CODE  </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>&lt;Swc&gt;_START_SEC_CODE                            </p>
<p>&lt;Swc&gt;_STOP_SEC_CODE  </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_APPL_CODE           </p>
<p>RTE_STOP_SEC_APPL_CODE </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Table 4-8  </p>
<p>Compiler abstraction and memory mapping </p>
<p><b>Compiler Abstraction   </b></p>
<p><b>Definitions </b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Memory Mapping </b></p>
<p><b>Sections </b></p>
<p>RTE_VAR_ZERO_INIT_NOCACHE </p>
<p>RTE_VAR_INIT_NOCACHE </p>
<p>RTE_VAR_NOINIT_NOCACHE </p>
<p>RTE_START_SEC_VAR_NOCACHE_ZERO_INIT_8BIT                  </p>
<p>RTE_STOP_SEC_VAR_NOCACHE_ZERO_INIT_8BIT </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_VAR_NOCACHE_ZERO_INIT_UNSPECIFIED </p>
<p>RTE_STOP_SEC_VAR_NOCACHE_ZERO_INIT_UNSPECIFIED </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_VAR_&lt;OsAppl&gt;_NOCACHE_ZERO_INIT_UNSPECIFIED </p>
<p>RTE_STOP_SEC_VAR_&lt;OsAppl&gt;_NOCACHE_ZERO_INIT_UNSPECIFIED </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_VAR_NOCACHE_INIT_UNSPECIFIED       </p>
<p>RTE_STOP_SEC_VAR_NOCACHE_INIT_UNSPECIFIED </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_VAR_&lt;OsAppl&gt;_NOCACHE_INIT_UNSPECIFIED </p>
<p>RTE_STOP_SEC_VAR_&lt;OsAppl&gt;_NOCACHE_INIT_UNSPECIFIED </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>RTE_START_SEC_VAR_NOCACHE_NOINIT_UNSPECIFIED </p>
<p>RTE_STOP_SEC_VAR_NOCACHE_NOINIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>RTE_START_SEC_VAR_&lt;OsAppl&gt;_NOCACHE_NOINIT_UNSPECIFIED </p>
<p>RTE_STOP_SEC_VAR_&lt;OsAppl&gt;_NOCACHE_NOINIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>Table 4-9  </p>
<p>Compiler abstraction and memory mapping for non-cacheable variables </p>
<p>The memory mapping sections and compiler abstraction defines specified in Table 4-9 are </p>
<p>only  used for variables  which  are  shared between  different  cores  on multicore  systems. </p>
<p>These variables must be linked into non-cacheable memory. </p>
<p>The RTE specific parts of </p>
<p>Compiler_Cfg.h</p>
<p> and </p>
<p>MemMap.h</p>
<p> depend on the configuration </p>
<p>of the RTE. Therefore the MICROSAR RTE generates templates for the following files:  </p>
<p><b></b></p>
<p><b> </b></p>
<p>Rte_Compiler_Cfg.h </p>
<p><b></b></p>
<p><b> </b></p>
<p>Rte_MemMap.h </p>
<p>They can be included into the common files and should be adjusted by the integrator like </p>
<p>the common files too. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>51 </p>
<p>based on template version 3.5 </p>
<p><b>4.5.1 </b></p>
<p><b>Memory Sections for Calibration Parameters and Per-Instance Memory </b></p>
<p>The variable part of the memory abstraction defines for calibration parameters </p>
<p>&lt;Cal&gt;</p>
<p> and </p>
<p>Per-Instance Memory </p>
<p>&lt;Pim&gt;</p>
<p> depends on the configuration. The following table shows the </p>
<p>attributes, which have to be defined in DaVinci Developer in order to assign a calibration </p>
<p>parameter  or  a  Per-Instance  Memory  to  one  of  the  configured  groups.  The  groups </p>
<p>represented by the enumeration values of the attributes can be configured in the attribute </p>
<p>definition dialog in DaVinci Developer without any naming restrictions. Only the name of </p>
<p>the attribute itself is predefined as described in the table below.   </p>
<p><b>Object Type </b></p>
<p><b>Attribute Name </b></p>
<p><b>Attribute Type </b></p>
<p>Calibration Parameter </p>
<p>PAR_GROUP_CAL </p>
<p>Enumeration </p>
<p>Calibration Element Prototype </p>
<p>PAR_GROUP_EL </p>
<p>Enumeration </p>
<p>Per-Instance Memory </p>
<p>PAR_GROUP_PIM </p>
<p>Enumeration </p>
<p>NvBlockDataPrototype </p>
<p>PAR_GROUP_NVRAM </p>
<p>Enumeration </p>
<p> </p>
<p>Details of configuration and usage of User-defined attributes can be found in the DaVinci </p>
<p>Online Help [23].    </p>
<p><b>Example for Calibration Parameters: </b></p>
<p>If  the  attribute </p>
<p>PAR_GROUP_CAL</p>
<p>  contains  e.g.  the  enumeration  values </p>
<p>CalGroupA</p>
<p>  and </p>
<p>CalGroupB</p>
<p> and calibration parameters are assigned to those groups, the RTE generator </p>
<p>will create the following memory mapping defines: </p>
<p>RTE_START_SEC_CONST_<b>CalGroupA</b>_UNSPECIFIED </p>
<p>RTE_STOP_SEC_CONST_<b>CalGroupA</b>_UNSPECIFIED </p>
<p>RTE_START_SEC_CONST_<b>CalGroupB</b>_UNSPECIFIED </p>
<p>RTE_STOP_SEC_CONST_<b>CalGroupB</b>_UNSPECIFIED </p>
<p> </p>
<p>In addition the following memory mapping defines are generated, if the calibration method </p>
<p>Initialized RAM is enabled (see also Chapter 6.6): </p>
<p>RTE_START_SEC_VAR_CalGroupA_UNSPECIFIED </p>
<p>RTE_STOP_SEC_VAR_CalGroupA_UNSPECIFIED </p>
<p>RTE_START_SEC_VAR_CalGroupB_UNSPECIFIED </p>
<p>RTE_STOP_SEC_VAR_CalGroupB_UNSPECIFIED </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>52 </p>
<p>based on template version 3.5 </p>
<p><b>Example for Per-Instance Memory: </b></p>
<p>If  the  attribute </p>
<p>PAR_GROUP_PIM</p>
<p>  contains  e.g.  the  enumeration  values </p>
<p>PimGroupA</p>
<p>  and </p>
<p>PimGroupB</p>
<p> and Per-Instance Memory is assigned to those group, the RTE generator will </p>
<p>create the following memory mapping defines:  </p>
<p>RTE_START_SEC_VAR_<b>PimGroupA</b>_UNSPECIFIED </p>
<p>RTE_STOP_SEC_VAR_<b>PimGroupA</b>_UNSPECIFIED </p>
<p>RTE_START_SEC_VAR_<b>PimGroupB</b>_UNSPECIFIED </p>
<p>RTE_STOP_SEC_VAR_<b>PimGroupB</b>_UNSPECIFIED </p>
<p><b>4.5.2 </b></p>
<p><b>Memory Sections for Software Components </b></p>
<p>The  MICROSAR  RTE  generator  generates  specific  memory  mapping  defines  for  each </p>
<p>SWC type which allows to locate SWC specific code, constants and variables in different </p>
<p>memory segments. </p>
<p>The  variable  part </p>
<p>&lt;Swc&gt; </p>
<p>is  the  camel  case  software  component  type  name.  The  RTE </p>
<p>implementation  template  code  generator  (command  line  option </p>
<p>–g i</p>
<p>)  uses  the  SWC </p>
<p>specific sections to locate the runnable entities in the appropriate memory section. </p>
<p>The SWC type specific parts of </p>
<p>MemMap.h</p>
<p> depend on the configuration. The MICROSAR </p>
<p>RTE generator creates a template for each SWC according the following naming rule:  </p>
<p><b></b></p>
<p><b> </b></p>
<p>&lt;Swc&gt;_MemMap.h </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>53 </p>
<p>based on template version 3.5 </p>
<p><b>4.5.3 </b></p>
<p><b>Compiler Abstraction Symbols for Software Components and RTE </b></p>
<p>The RTE generator uses SWC specific defines for the compiler abstraction. </p>
<p>The  following  define  is  used  in  RTE  generated  SW-C  implementation  templates  in  the </p>
<p>runnable entity function definitions.  </p>
<p>&lt;Swc&gt;_CODE </p>
<p> </p>
<p>In addition, the following compiler abstraction defines are available for the SWC developer. </p>
<p>They can be used to declare SWC specific function code, constants and variables. </p>
<p>&lt;Swc&gt;_CODE </p>
<p>&lt;Swc&gt;_CONST </p>
<p>&lt;Swc&gt;_VAR_NOINIT </p>
<p>&lt;Swc&gt;_VAR_INIT </p>
<p>&lt;Swc&gt;_VAR_ZERO_INIT </p>
<p> </p>
<p>If  the  user  code  contains  variable  definitions,  which  are  passed  to  the  RTE  API  by </p>
<p>reference in order to be modified by the RTE (e.g. buffers for reading data elements) the </p>
<p>RTE uses the following define to specify the distance to the buffer.     </p>
<p>RTE_APPL_VAR         </p>
<p>(RTE specific) </p>
<p> </p>
<p>If the user code contains variable or constant definitions, which are passed to the RTE API </p>
<p>as  pure  input  parameter  (e.g.  buffers  for  sending  data  elements)  the  RTE  uses  the </p>
<p>following define to specify the distance to the variable or constant.   </p>
<p>RTE_&lt;SWC&gt;_APPL_DATA    </p>
<p>(SWC specific) </p>
<p>RTE_APPL_DATA        </p>
<p>(RTE specific) </p>
<p> </p>
<p>All these SWC and RTE specific defines for the compiler abstraction might be adapted by </p>
<p>the integrator. The configured distances have to fit with the distances of the buffers and the </p>
<p>code of the application.   </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>The template files </p>
<p>&lt;Swc&gt;_MemMap.h, Rte_MemMap.h</p>
<p> and </p>
<p>Rte_Compiler_Cfg.h</p>
<p> </p>
<p>have to be adapted by the integrator depending on the used compiler and hardware </p>
<p>platform especially if memory protection is enabled.  </p>
<p>When the files are already available during RTE generation, the code that is placed </p>
<p>within the user code sections marked by “DO NOT CHANGE”-comments is transferred </p>
<p>unchanged to the updated template files. The behavior is the same as for template </p>
<p>generation of other files like SWC template generation. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>54 </p>
<p>based on template version 3.5 </p>
<p><b>4.6 </b></p>
<p><b>Memory Protection Support </b></p>
<p>The MICROSAR RTE supports memory protection as an extension to the AUTOSAR RTE </p>
<p>specification. Therefore the memory protection support of the Operating System provides </p>
<p>the  base  functionality.  The  support  is  currently  limited  to  the  Vector  MICROSAR  OS </p>
<p>because the RTE requires read access to the data from all partitions what is not required </p>
<p>by AUTOSAR. Moreover when trusted functions are used, the RTE uses wrapper functions </p>
<p>that are only generated by MICROSAR OS.  </p>
<p><b>4.6.1 </b></p>
<p><b>Partitioning of SWCs </b></p>
<p>The partitioning of SWCs to memory areas can be done DaVinci CFG. The partitioning is </p>
<p>based  on assignment of  tasks  to  OS applications,  which  is part of  the  OS  configuration </p>
<p>process.  </p>
<p>There exists the restriction that all Runnable Entities of a single SWC have to be assigned </p>
<p>to </p>
<p>the </p>
<p>same </p>
<p>OS </p>
<p>application. </p>
<p>This </p>
<p>restriction </p>
<p>and </p>
<p>the </p>
<p>assignment </p>
<p>of </p>
<p>tasks </p>
<p>to </p>
<p>OS </p>
<p>applications  indirectly  assign  SWCs  to  OS  applications.  This  is  the  basis  for  grouping </p>
<p>SWCs  to  different  memory  partitions.  Additional  information  about  memory  protection </p>
<p>configuration can be found in Chapter 6.3. </p>
<p><b>4.6.2 </b></p>
<p><b>OS Applications </b></p>
<p>The operating system supports different scalability classes (SC). Only in SC3 and SC4 the </p>
<p>memory  protection  mechanism  is  available.  Therefore  the  configuration  of  the  required </p>
<p>scalability  class  is  the  first  step  to  enable  memory  partitioning.  The  second  step  is  the </p>
<p>assignment of SWCs to partitions (OS applications) which is done by assigning tasks to </p>
<p>OS applications as described above. </p>
<p>The OS supports two types of OS applications: </p>
<p><b></b></p>
<p><b> </b></p>
<p>Non-Trusted </p>
<p><b></b></p>
<p><b> </b></p>
<p>Trusted </p>
<p>Non-Trusted OS applications run with enabled memory protection, trusted OS applications </p>
<p>with disabled memory protection. </p>
<p>Both  types  are  supported  by  the  MICROSAR  RTE  and  can  be  selected  in  the  OS </p>
<p>application configuration dialog or directly in the OS configuration tool.  </p>
<p> </p>
<p><b>Caution </b></p>
<p>If no assignment of tasks to OS applications exist memory protection is disabled.  </p>
<p>   </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>55 </p>
<p>based on template version 3.5 </p>
<p><b>4.6.3 </b></p>
<p><b>Partitioning Architecture </b></p>
<p>When  memory  protection  is  used,  one  or  more  SWCs  can  be  assigned  to  an  OS </p>
<p>application but it is not allowed to split up a SWC between two or more OS applications. </p>
<p>That means that all runnables of a SWC have to be assigned to tasks, which belong to the </p>
<p>same OS application.  It is the responsibility of the RTE to transfer the data of S/R and the </p>
<p>arguments of C/S port interfaces over the protection boundaries.  </p>
<p> </p>
<p><b>Caution </b></p>
<p>Client-Server invocations implemented as direct function calls should be used inside </p>
<p>one OS application only.  </p>
<p> </p>
<p>The MICROSAR RTE itself and the BSW can either run in a trusted OS application or in a </p>
<p>non-trusted OS application. Both architectures are described below. </p>
<p><b>4.6.3.1 </b></p>
<p><b>Trusted RTE and BSW </b></p>
<p> </p>
<p>Figure 4-4  </p>
<p>Trusted RTE Partitioning example </p>
<p> </p>
<p>This architecture overview assumes that the RTE and the BSW modules that are used by </p>
<p>the  RTE  run  in  one  or  more  trusted  OS  applications. Application  software  components </p>
<p>(SWC) above the RTE can either be trusted or non-trusted. When this architecture is used, </p>
<p>trusted/non-trusted</p>
<p>application</p>
<p>Non-trusted</p>
<p>application</p>
<p>trusted application</p>
<p>trusted application</p>
<p>ECU-Hardware</p>
<p>Operating</p>
<p>System</p>
<p>Software</p>
<p>Component</p>
<p>Software</p>
<p>Component</p>
<p>Software</p>
<p>Component</p>
<p>Software</p>
<p>Component</p>
<p><b>..............</b></p>
<p>AUTOSAR</p>
<p>Software</p>
<p>Communication</p>
<p>Complex</p>
<p>Device Driver</p>
<p>Basic Software</p>
<p>MICROSAR RTE</p>
<p>Service </p>
<p>Component</p>
<p>Ecu Abstraction</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>56 </p>
<p>based on template version 3.5 </p>
<p>the RTE uses trusted functions so that non-trusted SWCs can access the BSW and SWCs </p>
<p>in  other  OS  applications.  In  this  architecture, </p>
<p>Rte_Start()</p>
<p>  has  to  be  called  from  a </p>
<p>trusted task and the Com module needs to run in trusted context, too. The RTE will use the </p>
<p>same OS application as the BSW Scheduler tasks.  </p>
<p>An architecture where the BSW modules and the RTE are assigned to a non-trusted OS </p>
<p>application is described in the next chapter. </p>
<p><b>4.6.3.2 </b></p>
<p><b>Non-Trusted RTE and BSW </b></p>
<p> </p>
<p>Figure 4-5  </p>
<p>Non-trusted RTE Partitioning example </p>
<p> </p>
<p>This architecture overview assumes that the BSW modules below the RTE, as well as the </p>
<p>RTE itself run in a single non-trusted OS application. The SWCs above the RTE can either </p>
<p>be assigned to the same non-trusted OS application as the BSW or they can be assigned </p>
<p>to one or more other non-trusted or trusted OS applications. Every OS application has its </p>
<p>own buffers which are only written by runnables that run in the same OS application. The </p>
<p>RTE does not use trusted functions in this architecture. Therefore it is possible to create a </p>
<p>system where all SWCs and the BSW are assigned to non-trusted OS applications and all </p>
<p>runnables/tasks always run with enabled memory protection.  </p>
<p>trusted/non-trusted</p>
<p>application</p>
<p>Non-trusted</p>
<p>application</p>
<p>trusted application</p>
<p>non-trusted</p>
<p>application</p>
<p>ECU-Hardware</p>
<p>Operating</p>
<p>System</p>
<p>Software</p>
<p>Component</p>
<p>Software</p>
<p>Component</p>
<p>Software</p>
<p>Component</p>
<p>Software</p>
<p>Component</p>
<p><b>..............</b></p>
<p>AUTOSAR</p>
<p>Software</p>
<p>Communication</p>
<p>Complex</p>
<p>Device Driver</p>
<p>Basic Software</p>
<p>MICROSAR RTE</p>
<p>Service </p>
<p>Component</p>
<p>Ecu Abstraction</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>57 </p>
<p>based on template version 3.5 </p>
<p>The  non-trusted  RTE  architecture  is  automatically  chosen  when  the  RTE  configuration </p>
<p>fulfills the following criterions: </p>
<p><b></b></p>
<p><b> </b></p>
<p>The tasks that contain the BSW modules are known by the RTE. This can be achieved </p>
<p>by configuring them as BSW Scheduler tasks (See chapter 6.2). </p>
<p><b></b></p>
<p><b> </b></p>
<p>All BSW Scheduler tasks are assigned to the same non-trusted OS application (further </p>
<p>referred to as BSW OS Application). It is assumed that this is also the OS application </p>
<p>that initializes the RTE by calling Rte_Start. The application tasks can either be </p>
<p>assigned to the BSW OS Application or to other non-trusted or trusted OS </p>
<p>applications. </p>
<p><b></b></p>
<p><b> </b></p>
<p>There are no mode connections with mode disabling dependencies or mode triggers </p>
<p>between different OS Applications. </p>
<p><b></b></p>
<p><b> </b></p>
<p>There are no direct client/server calls across OS applications </p>
<p> </p>
<p>No special limitations apply to SWCs that are assigned to the same OS application as the </p>
<p>BSW.  Moreover,  the  following  RTE  features  can  also  be  used  by  SWCs  in  other  OS </p>
<p>applications:  </p>
<p><b></b></p>
<p><b> </b></p>
<p>direct or buffered inter-runnable variables </p>
<p><b></b></p>
<p><b> </b></p>
<p>per-instance memories </p>
<p><b></b></p>
<p><b> </b></p>
<p>SWC local calibration parameters </p>
<p><b></b></p>
<p><b> </b></p>
<p>access to calibration software components </p>
<p><b></b></p>
<p><b> </b></p>
<p>queued and nonqueued intra-ECU sender/receiver communication (when there is only </p>
<p>a single sender partition) </p>
<p><b></b></p>
<p><b> </b></p>
<p>inter-ECU sender/receiver communication (see also chapter 4.8.1) </p>
<p><b></b></p>
<p><b> </b></p>
<p>direct client/server calls to runnables within the same OS application </p>
<p><b></b></p>
<p><b> </b></p>
<p>mapped client/server calls to runnables in the same and different OS applications (see </p>
<p>also chapter 4.8.2) </p>
<p><b></b></p>
<p><b> </b></p>
<p>reading modes with the Rte_Mode API </p>
<p><b></b></p>
<p><b> </b></p>
<p>explicit and implicit exclusive areas </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>58 </p>
<p>based on template version 3.5 </p>
<p><b>4.6.4 </b></p>
<p><b>Conceptual Aspects </b></p>
<p>For intra OS application communication no additional RTE interaction is required. Special </p>
<p>memory  protection  handling  is  required  only  if  communication  between  different  OS </p>
<p>applications exists. In that case, the RTE has to provide means to transfer data over the </p>
<p>protection boundaries. The only possibility is the usage of trusted function calls inside the </p>
<p>generated RTE code. Those trusted function calls are expensive concerning code usage </p>
<p>and runtime. Therefore the usage of trusted function calls should be minimized if possible.  </p>
<p>The  MICROSAR  RTE  generator  uses  trusted  function  calls  only  if  necessary.  In  some </p>
<p>cases the usage of trusted function calls can be avoided by assigning the RTE buffers to </p>
<p>the appropriate  OS  application.   The  Vector MICROSAR OS only  provides  write  access </p>
<p>protection but doesn’t support read access protection. This behavior is the basis to avoid </p>
<p>trusted function calls, because the writing OS application can be seen as the owner of the </p>
<p>memory buffer. Only a simple assignment of the buffer to the appropriate OS application is </p>
<p>necessary. This also makes it possible to completely avoid trusted function calls when the </p>
<p>“Non-trusted RTE“ architecture (chapter 4.6.3.2) is chosen. </p>
<p>Only if the memory assignment cannot be used, the RTE needs trusted functions to cross </p>
<p>the protection boundaries.  </p>
<p>For that purpose, the RTE generator uses the OS application of the BSW Scheduler tasks </p>
<p>as its own OS application, which always needs to be trusted. The trusted functions called </p>
<p>by the RTE are assigned to that trusted OS application. In addition to the communication </p>
<p>between SWCs of different OS applications, there also exists communication between the </p>
<p>COM BSW module and the RTE. Especially the notifications of the COM are done in an </p>
<p>undefined call context. The MICROSAR RTE assumes that the calls of the COM callbacks </p>
<p>are done from the OS application that contains the BSW Scheduler tasks. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>59 </p>
<p>based on template version 3.5 </p>
<p><b>4.6.5 </b></p>
<p><b>Memory Protection Integration Hints </b></p>
<p><b>4.6.5.1 </b></p>
<p><b>Enabling of Memory Protection support </b></p>
<p>Please </p>
<p>make </p>
<p>sure </p>
<p>that </p>
<p>memory </p>
<p>protection </p>
<p>is </p>
<p>enabled </p>
<p>by </p>
<p>assigning </p>
<p>tasks </p>
<p>to </p>
<p>OS </p>
<p>applications and by selecting scalability class SC3 or SC4 in the OS configuration. </p>
<p><b>4.6.5.2 </b></p>
<p><b>Memory mapping in Linker Command File </b></p>
<p>If  memory  protection  is  enabled,  the  RTE  generator  creates  additional  OS  application </p>
<p>specific  memory  sections  for  variables:  In  addition,  the  user  has  to  split  up  his  Per-</p>
<p>Instance Memory (PIM) sections to the different OS applications. These additional memory </p>
<p>sections  have  to  be  mapped  in  the  linker  command  file  to  the  appropriate  memory </p>
<p>segments. See OS and compiler / linker manual for details. </p>
<p>The individual memory sections are listed in chapter 4.5. </p>
<p>The standard RTE memory section defines need to be mapped to the same segments as </p>
<p>the BSW. </p>
<p>OS  Application  specific  parts  of  the  RTE  implementation  are  generated  to  separate </p>
<p>Rte_&lt;OsApplicationName&gt;.c</p>
<p> files. </p>
<p><b>4.6.5.3 </b></p>
<p><b>OS Configuration extension </b></p>
<p>In addition to the RTE extensions in the OS configuration which are done automatically by </p>
<p>the RTE generator, the following steps have to be done by the Integrator. </p>
<p>All OS objects, used by BSW modules e.g. ISRs, BSW-Tasks, OS resources, alarms etc. </p>
<p>have  to  be  assigned  to  an  OS  application. COM  callbacks have  to  run  in  the  same  OS </p>
<p>application  as  the  RTE/BSW  Scheduler  tasks.  Dependent  on  the  implementation  of  the </p>
<p>COM Stack, the tasks or ISRs, which call the COM callbacks must therefore be assigned </p>
<p>to the right OS application.  </p>
<p>In the OS configuration of an SC3 or SC4 OS, the tasks must explicitly allow access by </p>
<p>other OS applications. Due to possible calls of </p>
<p>ActivateTask</p>
<p> or </p>
<p>SetEvent</p>
<p> inside RTE </p>
<p>implemented COM callbacks, the accessing BSW OS applications for all application tasks, </p>
<p>which are affected by these calls need to be configured. This is automatically done when </p>
<p>the  RTE  configuration  contains  all  BSW  Scheduler  tasks.  Otherwise,  the  configuration </p>
<p>needs to be extended by the integrator. </p>
<p>If  the  RTE  configuration  contains  not  all  BSW  Scheduler  tasks,  also  the  OS  application </p>
<p>that sets up the tasks and alarms by calling </p>
<p>Rte_Start</p>
<p> needs to be configured for the </p>
<p>task and alarm objects in the OS configuration. </p>
<p>This configuration extension has to be done in the OS configuration tool. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>60 </p>
<p>based on template version 3.5 </p>
<p><b>4.7 </b></p>
<p><b>Multicore support </b></p>
<p>Similar  to  the  mapping  of  SWCs  to  partitions  with  different  memory  access  rights,  the </p>
<p>MICROSAR RTE also supports the mapping of SWCs to partitions on different cores for </p>
<p>parallel execution. </p>
<p><b>4.7.1 </b></p>
<p><b>Partitioning of SWCs </b></p>
<p>The  mapping  of  SWCs  to  cores  happens  with  the  help  of  OS  Applications  like  in  the </p>
<p>memory protection use case. The user has to assign runnables to tasks and tasks to OS </p>
<p>Applications  in  order  to  map  SWCs  to  partitions.  The  OS  Applications  can  then  be </p>
<p>assigned  to  one  of  the  cores  of  the  ECU.  SWCs  can  only  be  assigned  to  a  single  OS </p>
<p>Application. This means that all runnables of a SWC need to be mapped to tasks within </p>
<p>the same OS Application. If a SWC contains only server runnables that are not mapped to </p>
<p>a task, the SWC can be mapped with the help of an ECUC partition. See chapter 6.3. </p>
<p>When </p>
<p>two </p>
<p>SWCs </p>
<p>on </p>
<p>different </p>
<p>cores </p>
<p>communicate </p>
<p>with </p>
<p>each </p>
<p>other, </p>
<p>the </p>
<p>RTE </p>
<p>will </p>
<p>automatically apply data consistency mechanisms. </p>
<p><b>4.7.2 </b></p>
<p><b>BSW in Multicore Systems </b></p>
<p>The  MICROSAR  RTE  assumes  that  all  BSW  modules  with  direct  RTE  interaction  (e.g. </p>
<p>COM and NVM) are located in a single BSW OS Application on a single BSW core. The </p>
<p>only  exceptions  are  BSW  modules  like  OS  and  ECUM  that  need  to  be  available  on  all </p>
<p>cores and service BSW like the WdgM with special multicore support. See chapter 4.7.3 </p>
<p>for details. The BSW OS Application is the OS Application that contains the tasks with the </p>
<p>schedulable entities. The RTE assumes that all COM and NVM callbacks are called from </p>
<p>this BSW OS Application. </p>
<p>All </p>
<p>RTE </p>
<p>Lifecycle </p>
<p>APIs </p>
<p>(</p>
<p>Rte_Start(),  Rte_Stop(),  Rte_InitMemory(), </p>
<p>SchM_Init(), SchM_Deinit()</p>
<p>) have to be called on all cores. </p>
<p>Cyclic triggered runnables will start to run as soon as </p>
<p>Rte_Start()</p>
<p> is called on the BSW </p>
<p>core. </p>
<p>It is recommended to use only a single BSW OS Application per core. The RTE will then </p>
<p>configure  the  access  rights  so  that </p>
<p>Rte_Start()</p>
<p>  can  be  called  from  the  core  specific </p>
<p>BSW OS application. </p>
<p>  </p>
<p> </p>
<p><b>Caution </b></p>
<p>The RTE will start the scheduling of cyclic triggered runnable entities as soon as </p>
<p>Rte_Start()</p>
<p> is called on the BSW Core. Therefore, </p>
<p>Rte_Start()</p>
<p> on the BSW core </p>
<p>should only be invoked when the </p>
<p>Rte_Start()</p>
<p> calls on all other cores finished </p>
<p>execution. This is checked with a DET check. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>61 </p>
<p>based on template version 3.5 </p>
<p><b>4.7.3 </b></p>
<p><b>Service BSW in Multicore Systems </b></p>
<p>The  MICROSAR  RTE  supports  BSW multiple  partition  distribution. This  requires  service </p>
<p>BSW modules which provide partition specific service SWC descriptions. The BSW main </p>
<p>function in such a distributed system can have  multiple triggers and each trigger can be </p>
<p>mapped to a different task on a different core.  </p>
<p>The following example shows a possible configuration for the BSW module WdgM:</p>
<p> </p>
<p><b>Service SWC:  WdgMCore0 </b></p>
<p></p>
<p> Runnable Entity: <b>WdgM_Mainfunction </b></p>
<p></p>
<p> Periodical Trigger: TriggerCore0 e.g. 5ms  </p>
<p></p>
<p> mapped to TaskCore0 in PartitionBSWCore0 on Core 0 </p>
<p></p>
<p> Service SWC implicitly mapped to Core 0 </p>
<p></p>
<p> Runnable Entity: <b>WdgM_CheckPointReached </b></p>
<p></p>
<p> </p>
<p>OperationInvocation Trigger</p>
<p> </p>
<p></p>
<p> unmapped </p>
<p><b>Service SWC: WdgMCore1 </b></p>
<p></p>
<p> Runnable Entity: <b>WdgM_Mainfunction </b></p>
<p></p>
<p> Periodical Trigger: TriggerCore1 e.g. 1ms  </p>
<p></p>
<p> mapped to TaskCore1 in PartitionBSWCore1 on Core 1 </p>
<p></p>
<p> Service SWC implicitly mapped to Core 1 </p>
<p></p>
<p> Runnable Entity: <b>WdgM_CheckPointReached </b></p>
<p></p>
<p> </p>
<p>OperationInvocation Trigger</p>
<p> </p>
<p></p>
<p> unmapped </p>
<p><b>Service SWC: WdgMCore1ASIL </b></p>
<p></p>
<p> </p>
<p>Service SWC </p>
<p>explicitly mapped to </p>
<p>PartitionCore1</p>
<p>ASIL</p>
<p>                                                  </p>
<p>because of the missing task mapping for WdgM_Mainfunction</p>
<p> </p>
<p></p>
<p> Runnable Entity: <b>WdgM_CheckPointReached </b></p>
<p></p>
<p> </p>
<p>OperationInvocation Trigger</p>
<p> </p>
<p></p>
<p> unmapped </p>
<p> </p>
<p>Application  SWCs  can  call  the  partition  local  C/S  operation  CheckPointReached.  If  the </p>
<p>server runnables are not mapped like in the example above, the RTE can implement the </p>
<p>Rte_Call</p>
<p> API by a direct function call. The BSW function </p>
<p>WdgM_CheckPointReached</p>
<p> </p>
<p>needs  to  be  implemented  multicore  reentrant  and  therefore  requires  specific  multicore </p>
<p>support. </p>
<p>Also the </p>
<p>WdgM_Mainfunction</p>
<p> needs to be implemented multicore reentrant because it is </p>
<p>called periodically by the RTE from different cores.  </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>Service BSW modules distributed on different cores requires specific multicore support </p>
<p>of the BSW module. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>62 </p>
<p>based on template version 3.5 </p>
<p><b>4.7.4 </b></p>
<p><b>IOC Usage </b></p>
<p>In multicore systems, the OS provides Inter OS-Application Communicator (IOC) Objects </p>
<p>for  the  communication  between  the  individual  cores.  However,  on  many  systems  the </p>
<p>memory of the different cores can also be accessed without IOCs. This is the case when </p>
<p>the RTE variables that are used for communication are mapped to non-cacheable RAM </p>
<p>and when they can either be accessed atomically or when the accesses are protected with </p>
<p>a spinlock. Moreover in case of memory protection, this is only possible when a variable is </p>
<p>only written by a single partition and when the variable can be read by the other partitions. </p>
<p>The MICROSAR RTE Generator tries to avoid IOCs so that it can use the same variables </p>
<p>for intra and inter partition communication. Moreover spinlocks are only used for variables </p>
<p>that cannot be accessed atomically. </p>
<p>If the RTE variables cannot be mapped to globally readable, shared, non-cacheable RAM </p>
<p>the </p>
<p>usage </p>
<p>of </p>
<p>IOCs </p>
<p>can </p>
<p>be </p>
<p>enforced </p>
<p>with </p>
<p>the </p>
<p>EnforceIoc</p>
<p> </p>
<p>parameter </p>
<p>in </p>
<p>the </p>
<p>RteGeneration</p>
<p> parameters. </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>RTE variables that are mapped to </p>
<p>NOCACHE</p>
<p> memory sections need to be mapped to </p>
<p>non-cacheable RAM. See also chapter 4.5. </p>
<p> </p>
<p><b>4.8 </b></p>
<p><b>BSW Access in Partitioned systems </b></p>
<p>When  the  SWCs  are  assigned  to  different  OS  Applications,  only  the  SWCs  that  are </p>
<p>assigned  to  the  BSW  OS  Application  can  access  the  BSW  directly.  SWCs  that  are </p>
<p>assigned to other cores or partitions do not always have the required access rights. The </p>
<p>same is true for runnable entities that are directly called by the BSW through client/server </p>
<p>interfaces. The RTE can transparently provide proxy code for such BSW accesses but the </p>
<p>user needs to map the SendSignal proxy and the server runnables to tasks in which they </p>
<p>can be executed. </p>
<p><b>4.8.1 </b></p>
<p><b>Inter-ECU Communication </b></p>
<p>IOCs or additional global RTE variables are automatically inserted by the RTE generator </p>
<p>when data needs to be sent from a partition without BSW to another ECU. This is required </p>
<p>because the COM APIs cannot be called directly in this case. </p>
<p>Instead, the RTE provides a schedulable entitiy </p>
<p>Rte_ComSendSignalProxyPeriodic</p>
<p>, </p>
<p>which periodically calls the COM APIs when a partition without BSW transmitted data. </p>
<p>The schedulable entity</p>
<p> Rte_ComSendSignalProxyPeriodic</p>
<p> should be mapped to the </p>
<p>same task as </p>
<p>Com_MainFunctionTx</p>
<p> with a lower position in task so that it can update </p>
<p>the signals before they are transmitted by COM. </p>
<p>Rte_ComSendSignalProxyPeriodic</p>
<p> </p>
<p>will be scheduled with the same cycle time as </p>
<p>Com_MainFunctionTx</p>
<p>. For this, the RTE </p>
<p>generator reads the period from the COM configuration.  </p>
<p>For  the  reception  of  signals  no  special  handling  is  required. The  RTE  will  automatically </p>
<p>forward the received data to the appropriate partition in the COM notifications. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>63 </p>
<p>based on template version 3.5 </p>
<p><b>4.8.2 </b></p>
<p><b>Client Server communication </b></p>
<p>Also client server calls between SWCs in different partitions are possible. </p>
<p>In order to execute the server runnable in another partition, the server runnable needs to </p>
<p>be  mapped  to  a  task.  The  RTE  will  then  make  the  server  arguments  available  in  the </p>
<p>partition of the server runnable, execute the server runnable in the context of its task and </p>
<p>return the results to the calling partition. </p>
<p>Direct  client  server  calls  to  servers  on  other  cores  are  not  possible  because  this  would </p>
<p>enforce that the server is executed in the context of the client core. This would lead to data </p>
<p>consistency problems for RTE APIs that only provide buffer pointers like </p>
<p>Rte_Pim()</p>
<p>. The </p>
<p>RTE  cannot  use  IOCs  for  these APIs  because  the  actual  buffer  update  is  done  by  the </p>
<p>application code. </p>
<p>You can instruct the RTE to generate a context switch. You can decide this over the task </p>
<p>mapping of a function trigger. </p>
<p>If you consider RTE calls which originate from the same partition as the server runnable, a </p>
<p>context switch into the task of the server runnable may not be required. Here, doing a task </p>
<p>switch would mean an additional overhead which can be avoided.  </p>
<p>Therefore  it  is  also  possible  to  configure  an  additional  server  port  prototype  for  clients </p>
<p>which are local to the server partition. The triggers from both server ports can then trigger </p>
<p>the same server runnable. However, only  the  trigger  from  the  port  that  is  connected  </p>
<p>to  foreign partitions needs to be mapped onto a task. As a consequence, the RTE can </p>
<p>implement calls from partition local clients as efficient direct function calls. </p>
<p>Please take into account, that this is only allowed when the server runnable is not invoked </p>
<p>concurrently  or  marked  as  “can  be  invoked  concurrently”.  In  addition,  you  can  use </p>
<p>Exclusive Areas to protect the runnable against concurrent access problems. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>64 </p>
<p>based on template version 3.5 </p>
<p><b>5 </b></p>
<p><b>API Description </b></p>
<p>The RTE API functions used inside the runnable entities are accessible by including the </p>
<p>SWC application header file </p>
<p>Rte_&lt;ComponentType&gt;.h</p>
<p>. </p>
<p> </p>
<p> </p>
<p><b>Info</b> </p>
<p>The following API descriptions contain the direction qualifier IN, OUT and INOUT. They </p>
<p>are intended as direction information only and shall not be used inside the application </p>
<p>code. </p>
<p> </p>
<p>Depending  on  the  configuration,  some APIs  are  efficiently  implemented  as  function-like </p>
<p>macros. This implementation introduces restrictions on how the APIs can be used in the </p>
<p>software-component. E.g. it is not possible to take the address of a macro in C. </p>
<p>The  macro  implementation  may  also  lead  to  unwanted  compiler optimizations  regarding </p>
<p>concurrent accesses of variables. If a variable is accessed multiple times (e.g. by calling </p>
<p>the Rte_Read API in a loop), the compiler may not be aware that the value of the variable </p>
<p>may change at any time and optimize away the subsequent accesses. </p>
<p> </p>
<p> </p>
<p><b>Info</b> </p>
<p>If it is not possible for the implementation of a software-component to use a function-</p>
<p>like macro of a port API, the Port API Option </p>
<p>enableTakeAddress</p>
<p> can be used to </p>
<p>force the generation of a “C” function. </p>
<p> </p>
<p>For an interfaces overview please see Figure 2-2. </p>
<p><b>5.1 </b></p>
<p><b>Data Type Definition </b></p>
<p>The MICROSAR RTE has special handling for the implementation data types, which are </p>
<p>defined in </p>
<p>Std_Types.h</p>
<p> and </p>
<p>Platform_Types.h</p>
<p> (see [7] and [8] for details). The RTE </p>
<p>generator assumes that these data types are available and therefore skips the generation </p>
<p>of type definitions.  </p>
<p>In addition implementation data types where the </p>
<p>typeEmitter</p>
<p> attribute is set to a value </p>
<p>different to </p>
<p>RTE</p>
<p> or where the value is not empty the RTE generator also skips generation </p>
<p>of  the  type  definition.  In  this  case  the  user  has  to  adopt  the  generated  template  file </p>
<p>Rte_UserTypes.h</p>
<p> which should contain the type definitions for the skipt implementation </p>
<p>data types because the RTE itself needs the type definition. </p>
<p>All other primitive or composite application and implementation data types are generated </p>
<p>by  the  RTE  generator. This  includes  the data  types  which  are  assigned  to  a  SWC by  a </p>
<p>definition of an </p>
<p>IncludedDataTypeSet</p>
<p>. </p>
<p>Floating  point data  types  with  double precision  may  not be used for data elements  with </p>
<p>external  connectivity,  because  the  MICROSAR  COM  layer  lacks  support  for  64  bit  data </p>
<p>types. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>65 </p>
<p>based on template version 3.5 </p>
<p><b>5.1.1 </b></p>
<p><b>Invalid Value </b></p>
<p>The MICROSAR RTE provides access to the invalid value of a primitive data type. It can </p>
<p>be accessed with the following macro:  </p>
<p>InvalidValue_&lt;literalPrefix&gt;&lt;DataType&gt; </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>Because the macro does not contain the </p>
<p>Rte_</p>
<p> prefix, care must be taken not to define </p>
<p>data types conflicting with any other symbols defined by the RTE or the application </p>
<p>code. The optional literalPrefix can be used to resolve conflicts. </p>
<p> </p>
<p><b>5.1.2 </b></p>
<p><b>Upper and Lower Limit </b></p>
<p>The range of the primitive application data types is specified by an upper and a lower limit. </p>
<p>These limits are accessible from the application by using the following macro if the limits </p>
<p>are specified: </p>
<p>&lt;literalPrefix&gt;&lt;DataType&gt;_LowerLimit </p>
<p>&lt;literalPrefix&gt;&lt;DataType&gt;_UpperLimit </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>Because the macro does not contain the </p>
<p>Rte_</p>
<p> prefix, care must be taken not to define </p>
<p>data types conflicting with any other symbols defined by the RTE or the application </p>
<p>code. The optional literalPrefix can be used to resolve conflicts. </p>
<p> </p>
<p><b>5.1.3 </b></p>
<p><b>Initial Value </b></p>
<p>Like the limits also the initial value of an un-queued data element of an S/R port prototype </p>
<p>is accessible from the application: </p>
<p>Rte_InitValue_&lt;PortPrototype&gt;_&lt;DataElementPrototype&gt; </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>The initial value of an Inter-Ecu S/R communication might be changed by the post-build </p>
<p>capabilities of the communication stack. Please note that the macro of the RTE still </p>
<p>provides the original initial value defined at pre-compile time. Please don’t use the </p>
<p>macro if the initial value will be changed in the communication stack at post-build time. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>66 </p>
<p>based on template version 3.5 </p>
<p><b>5.2 </b></p>
<p><b>API Error Status </b></p>
<p>Most of the RTE APIs provide an error status in the API return code. For easier evaluation </p>
<p>the MICROSAR RTE provides the following status access macros: </p>
<p>Rte_IsInfrastructureError(status) </p>
<p>Rte_HasOverlayedError(status) </p>
<p>Rte_ApplicationError(status) </p>
<p> </p>
<p>The macros can be used inside the runnable entities for evaluation of the RTE API return </p>
<p>code. </p>
<p>The </p>
<p>boolean</p>
<p> </p>
<p>return </p>
<p>code </p>
<p>of </p>
<p>the </p>
<p>Rte_IsInfrastructure</p>
<p> </p>
<p>and </p>
<p>Rte_HasOverlayedError</p>
<p>  macros  indicate  if  either  the  immediate  infrastructure  error </p>
<p>flag (bit 7) or the overlay error flag (bit 6) is set. </p>
<p>The </p>
<p>Rte_ApplicationError</p>
<p>  macro  returns  the  application  errors  without  overlayed </p>
<p>errors. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>67 </p>
<p>based on template version 3.5 </p>
<p><b>5.3 </b></p>
<p><b>Runnable Entities </b></p>
<p>Runnable entities are configured in DaVinci and must be implemented by the user. DaVinci </p>
<p>features  the  generation  of  a  template  file  containing  the  empty  bodies  of  all  runnable </p>
<p>entities that are configured for a specific component type. </p>
<p><b>5.3.1 </b></p>
<p><b>&lt;RunnableEntity&gt; </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void &lt;<b>RunnableEntity</b>&gt; ( [IN Rte_Instance instance][,                 </p>
<p>IN Rte_ActivatingEvent_&lt;RunnableEntity&gt; activation]) </p>
<p>{Std_ReturnType|void} &lt;<b>ServerRunnable</b>&gt; ( [IN Rte_Instance instance] {, </p>
<p>IN type [*]inputparam}* {, OUT type *outputparam}* ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p>activation </p>
<p>The activation parameter can be used to get the actual activation </p>
<p>reason of the runnable entity if the runnable has multiple possible </p>
<p>trigger conditions (e.g. different cyclic triggers or a cyclic trigger and a </p>
<p>data reception trigger). </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>an activation reason at the runnable entity. It is only reasonable if </p>
<p>more than one runnable trigger (RTE Event) is configured. </p>
<p>[*]inputparam, *outputparam </p>
<p>Parameters are only present for server runnables, i.e. runnable </p>
<p>entities triggered by an OperationInvokedEvent. Input (IN) parameters </p>
<p>are passed by value (primitive types) or reference (composite and </p>
<p>string types), output (OUT) parameters are always passed by </p>
<p>reference. </p>
<p><b>Return code </b></p>
<p>RTE_E_OK </p>
<p>Server runnables return RTE_E_OK for successful operation </p>
<p>execution if an application error is referenced by the operation </p>
<p>prototype. Application errors are defined at the client/server port </p>
<p>interface. </p>
<p>RTE_E_&lt;interf&gt;_&lt;error&gt; </p>
<p>Server runnables may return an application error (in the range of 1 to </p>
<p>63) if the operation execution was not successful. Application errors </p>
<p>are defined at the client/server port interface and are referenced by </p>
<p>the operation prototype. </p>
<p><b>Existence </b></p>
<p>If configured in DaVinci. </p>
<p><b>Functional Description </b></p>
<p>The user function </p>
<p>&lt;RunnableEntity&gt;()</p>
<p> is the specific implementation of a runnable entity of a </p>
<p>software component and has to be provided by the user. It is called from the MICROSAR RTE.  </p>
<p>The first prototype form with no return value and the optional instance parameter is valid for the following </p>
<p>trigger conditions: </p>
<p></p>
<p>  TimingEvent: Triggered on expiration of a configured timer.   </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>68 </p>
<p>based on template version 3.5 </p>
<p></p>
<p>  DataReceivedEvent: Triggered on reception of a data element.  </p>
<p></p>
<p>  DataReceiveErrorEvent: Triggered on reception error of a data element.  </p>
<p></p>
<p>  DataSendCompletionEvent: Triggered on successful transmission of a data element. </p>
<p></p>
<p>  ModeSwitchEvent: Triggered on entering or exiting of a mode of a mode declaration group. </p>
<p></p>
<p>  ModeSwitchedAckEvent: Triggered on completion of a mode switch of a mode declaration group. </p>
<p></p>
<p>  AsynchronousServerCallReturnsEvent: Triggered on finishing of an asynchronous server call. The </p>
<p>Rte_Result()</p>
<p> API shall be used to get the out parameters of the server call. </p>
<p></p>
<p>  InitEvent: Triggered on startup of the RTE. </p>
<p></p>
<p>  BackgroundEvent: Triggered by the RTE in an endless loop – in the background – when no other </p>
<p>runnable runs. </p>
<p>The optional activation parameter is valid for all above described trigger conditions with the exception of </p>
<p>the InitEvent.</p>
<p> </p>
<p>The second prototype form is valid for server runnables:    </p>
<p></p>
<p> </p>
<p>OperationInvokedEvent: Triggered on invocation of the operation in a C/S port interface (server </p>
<p>runnable). A return value is only present if application errors are referenced by the implemented </p>
<p>operation. The parameter list is directly derived from the configured operation prototype with the </p>
<p>addition of the optional instance parameter</p>
<p>. </p>
<p>The configuration of the trigger conditions can be done in the runnable entities tab of the component type </p>
<p>configuration. </p>
<p><b>Call Context </b></p>
<p>The call context of server runnables depends on the task mapping. Server runnables mapped to a task </p>
<p>are executed in the context of this task, unmapped server runnables are executed in the context of the </p>
<p>task that invoked the operation. All other runnables are invoked by the RTE in the context of the task the </p>
<p>runnables are mapped to. </p>
<p> </p>
<p><b>Caution </b></p>
<p>The relative priority of the assigned OS tasks is responsible for the call sequence </p>
<p>of Init-Runnables. The RTE ensures that the Init-Runnable is called before any </p>
<p>other runnable mapped to the same task, but does not enforce that all Init-</p>
<p>Runnables have been executed before any other runnable is called. To make sure </p>
<p>that all Init-Runnables are executed before any other runnable is called, all Init-</p>
<p>Runnables should be mapped to the task with the highest priority. </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>5.3.2 </b></p>
<p><b>Runnable Activation Reason </b></p>
<p>If the activation reason is configured the actual reason can be evaluated with the following </p>
<p>generated define </p>
<p>Rte_ActivatingEvent_&lt;RunnabaleEntity&gt;_&lt;Reason&gt; </p>
<p>where </p>
<p>_&lt;RunnabaleEntity&gt;</p>
<p> is the symbol attribute of the Runnable and </p>
<p>&lt;Reason&gt;</p>
<p> is the </p>
<p>symbolic name of activation reason. The return type of the macro depends on the highest </p>
<p>configured bit position for all trigger conditions of a runnable entity. It is </p>
<p>uint8</p>
<p>, </p>
<p>uint16</p>
<p> or </p>
<p>unit32</p>
<p>. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>69 </p>
<p>based on template version 3.5 </p>
<p><b>5.4 </b></p>
<p><b>SWC Exclusive Areas </b></p>
<p><b>5.4.1 </b></p>
<p><b>Rte_Enter </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_Enter_&lt;ExclusiveArea&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This API exists when at least one runnable has configured explicit access </p>
<p>(</p>
<p>canEnterExclusiveArea</p>
<p>) to an exclusive area of a component. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Enter_&lt;ea&gt;()</p>
<p> implements explicit access to the exclusive area. The exclusive </p>
<p>area is defined in the context of a component type and may be accessed by all runnables of that </p>
<p>component, either implicitly or explicitly via this API. </p>
<p>This function is the counterpart of </p>
<p>Rte_Exit_&lt;ea&gt;()</p>
<p>. Each call to </p>
<p>Rte_Enter_&lt;ea&gt;()</p>
<p> must be </p>
<p>matched by a call to </p>
<p>Rte_Exit_&lt;ea&gt;()</p>
<p> in the same runnable entity. One exclusive area must not </p>
<p>be entered more than once at a time, but different exclusive areas may be nested, as long as they </p>
<p>are left in reverse order of entering them. </p>
<p>For restrictions on using exclusive areas with different implementations, see section 3.6.10. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside runnable entities. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>70 </p>
<p>based on template version 3.5 </p>
<p><b>5.4.2 </b></p>
<p><b>Rte_Exit </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_Exit_&lt;ExclusiveArea&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This API exists when at least one runnable has configured explicit access </p>
<p>(</p>
<p>canEnterExclusiveArea</p>
<p>) to an exclusive area of a component. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Exit_&lt;ea&gt;()</p>
<p> implements releasing of an explicit entered exclusive area. The </p>
<p>exclusive area is defined in the context of a component type and may be accessed by all runnables </p>
<p>of that component, either implicitly or explicitly via this API. </p>
<p>This function is the counterpart of </p>
<p>Rte_Enter_&lt;ea&gt;()</p>
<p>. Each call to </p>
<p>Rte_Enter_&lt;ea&gt;()</p>
<p> must </p>
<p>be matched by a call to </p>
<p>Rte_Exit_&lt;ea&gt;()</p>
<p> in the same runnable entity. One exclusive area must </p>
<p>not be entered more than once at a time, but different exclusive areas may be nested, as long as </p>
<p>they are left in reverse order of entering them. </p>
<p>For restrictions on using exclusive areas with different implementations, see section 3.6.10. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside runnable entities. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>71 </p>
<p>based on template version 3.5 </p>
<p><b>5.5 </b></p>
<p><b>BSW Exclusive Areas </b></p>
<p><b>5.5.1 </b></p>
<p><b>SchM_Enter </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>SchM_Enter_&lt;Bsw&gt;_&lt;ExclusiveArea&gt; </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This API exists when at least one schedulable entity has configured access </p>
<p>(</p>
<p>canEnterExclusiveArea</p>
<p>) to an exclusive area in the internal behavior of the BSW module </p>
<p>description. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>SchM_Enter_&lt;bsw&gt;_&lt;ea&gt;()</p>
<p> implements access to the exclusive area. The </p>
<p>exclusive area is defined in the context of a BSW module and may be accessed by all schedulable </p>
<p>entities of that module via this API. </p>
<p>This function is the counterpart of </p>
<p>SchM_Exit_&lt;bsw&gt;_&lt;ea&gt;()</p>
<p>. Each call to </p>
<p>SchM_Enter_&lt;bsw&gt;_&lt;ea&gt;()</p>
<p> must be matched by a call to </p>
<p>SchM_Exit_&lt;bsw&gt;_&lt;ea&gt;()</p>
<p> in the </p>
<p>same schedulable entity. One exclusive area must not be entered more than once at a time, but </p>
<p>different exclusive areas may be nested, as long as they are left in reverse order of entering them. </p>
<p>For restrictions on using exclusive areas with different implementation methods, see section 3.6.10. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a schedulable entity in Task or Interrupt context. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>72 </p>
<p>based on template version 3.5 </p>
<p><b>5.5.2 </b></p>
<p><b>SchM_Exit </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>SchM_Exit_&lt;Bsw&gt;_&lt;ExclusiveArea&gt; </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This API exists when at least one schedulable entity has configured access </p>
<p>(</p>
<p>canEnterExclusiveArea</p>
<p>) to an exclusive area in the internal behavior of the BSW module </p>
<p>description. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>SchM_Exit_&lt;bsw&gt;_&lt;ea&gt;()</p>
<p> implements releasing of the exclusive area. The </p>
<p>exclusive area is defined in the context of a BSW module and may be accessed by all schedulable </p>
<p>entities of that module via this API. </p>
<p>This function is the counterpart of </p>
<p>SchM_Enter_&lt;bsw&gt;_&lt;ea&gt;()</p>
<p>. Each call to </p>
<p>SchM_Enter_&lt;bsw&gt;_&lt;ea&gt;()</p>
<p> must be matched by a call to </p>
<p>SchM_Exit_&lt;bsw&gt;_&lt;ea&gt;()</p>
<p> in the </p>
<p>same schedulable entity. One exclusive area must not be entered more than once at a time, but </p>
<p>different exclusive areas may be nested, as long as they are left in reverse order of entering them. </p>
<p>For restrictions on using exclusive areas with different implementation methods, see section 3.6.10. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a schedulable entity in Task or Interrupt context. </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>73 </p>
<p>based on template version 3.5 </p>
<p><b>5.6 </b></p>
<p><b>Sender-Receiver Communication </b></p>
<p><b>5.6.1 </b></p>
<p><b>Rte_Read </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Rte_Read_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance,] OUT &lt;DataType&gt; *data ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different </p>
<p>instances in case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the </p>
<p>configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> </p>
<p>attribute. </p>
<p>*data </p>
<p>The output &lt;data&gt; is passed by reference. The &lt;DataType&gt; is </p>
<p>the type, specified at the data element prototype in the SWC </p>
<p>description.  </p>
<p><b>Return code </b></p>
<p>RTE_E_OK </p>
<p>Data read successfully.  </p>
<p>RTE_E_UNCONNECTED </p>
<p>Indicates that the receiver port is not connected. </p>
<p>RTE_E_INVALID </p>
<p>An invalidated signal has been received by the RTE.  </p>
<p>RTE_E_MAX_AGE_EXCEEDED </p>
<p>Indicates a timeout, detected by the COM module in case of </p>
<p>inter ECU communication, if an </p>
<p>aliveTimeout</p>
<p> is specified.  </p>
<p>RTE_E_NEVER_RECEIVED </p>
<p>No data received since system start. </p>
<p>RTE_E_SOFT_TRANSFORMER_ERROR </p>
<p>An error during transformation occurred which shall be notified </p>
<p>to the SWC but still produces valid data as output. </p>
<p>RTE_E_HARD_TRANSFORMER_ERROR </p>
<p>An error during transformation occurred which produces invalid </p>
<p>data as output. </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured direct (explicit) access in the role  </p>
<p>dataReceivePointByArgument</p>
<p> for the data element in the DaVinci configuration and the referenced data </p>
<p>element prototype is configured without queued communication (</p>
<p>isQueued=false</p>
<p>).  </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Read_&lt;p&gt;_&lt;d&gt;()</p>
<p> supplies the current value of the data element. This API can be used </p>
<p>for explicit read of S/R data with </p>
<p>isQueued=false</p>
<p>. After startup </p>
<p>Rte_Read</p>
<p> provides the initial value. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>74 </p>
<p>based on template version 3.5 </p>
<p><b>5.6.2 </b></p>
<p><b>Rte_DRead </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>&lt;DataType&gt; <b>Rte_DRead_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different </p>
<p>instances in case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the </p>
<p>configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> </p>
<p>attribute. </p>
<p><b>Return code </b></p>
<p>&lt;DataType&gt; </p>
<p>The return value contains the current value of the data element. </p>
<p>The &lt;DataType&gt; is the (primitive) type, specified at the data </p>
<p>element prototype in the SWC description. </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured direct (explicit) access in the role </p>
<p>dataReceivePointByValue</p>
<p> for the data element in the DaVinci configuration and the referenced data </p>
<p>element prototype is configured without queued communication (</p>
<p>isQueued=false</p>
<p>).  </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_DRead_&lt;p&gt;_&lt;d&gt;()</p>
<p> supplies the current value of the data element. This API can be used </p>
<p>for explicit read of S/R data with </p>
<p>isQueued=false</p>
<p>. After startup or if the receiver port is unconnected, </p>
<p>Rte_DRead</p>
<p> provides the initial value. The API is only available for primitive data types. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>75 </p>
<p>based on template version 3.5 </p>
<p><b>5.6.3 </b></p>
<p><b>Rte_Write </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Rte_Write_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance,] IN &lt;DataType&gt; data ) </p>
<p>Std_ReturnType <b>Rte_Write_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance,] IN &lt;DataType&gt; *data ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different </p>
<p>instances in case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the </p>
<p>configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> </p>
<p>attribute. </p>
<p>data </p>
<p>The input data &lt;data&gt; for primitive data types without string </p>
<p>types is passed by value. The &lt;DataType&gt; is the type, specified </p>
<p>at the data element prototype in the SWC description.  </p>
<p>*data </p>
<p>The input data &lt;data&gt; for string types and composite data types </p>
<p>is passed by reference. The &lt;DataType&gt; is the type, specified </p>
<p>at the data element prototype in the SWC description.  </p>
<p><b>Return code </b></p>
<p>RTE_E_OK </p>
<p>Data passed to communication services successfully.  </p>
<p>RTE_E_COM_STOPPED </p>
<p>An infrastructure communication error was detected by the RTE. </p>
<p>RTE_E_SOFT_TRANSFORMER_ERROR </p>
<p>An error during transformation occurred which shall be notified </p>
<p>to the SWC but still produces valid data as output. </p>
<p>RTE_E_HARD_TRANSFORMER_ERROR </p>
<p>An error during transformation occurred which produces invalid </p>
<p>data as output. </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured direct (explicit) access to the data element in </p>
<p>the DaVinci configuration and the referenced data element prototype is configured without queued </p>
<p>communication (</p>
<p>isQueued=false</p>
<p>).  </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Write_&lt;p&gt;_&lt;d&gt;()</p>
<p> can be used for explicit transmission of S/R data with </p>
<p>isQueued=false</p>
<p>.  </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>76 </p>
<p>based on template version 3.5 </p>
<p><b>5.6.4 </b></p>
<p><b>Rte_Receive </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Rte_Receive_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance,] OUT &lt;DataType&gt; *data [, OUT uint16 </p>
<p>*length] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different </p>
<p>instances in case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the </p>
<p>configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> </p>
<p>attribute. </p>
<p>*data </p>
<p>The output &lt;data&gt; is passed by reference. The &lt;DataType&gt; is </p>
<p>the type, specified at the data element prototype in the SWC </p>
<p>description.  </p>
<p>*length </p>
<p>In case of an array with variable number of elements, the </p>
<p>dynamic length &lt;length&gt; is returned. </p>
<p><b>Return code </b></p>
<p>RTE_E_OK </p>
<p>Data read successfully.  </p>
<p>RTE_E_UNCONNECTED </p>
<p>Indicates that the receiver port is not connected. </p>
<p>RTE_E_NO_DATA </p>
<p>A non-blocking call returned no data due to an empty receive </p>
<p>queue. No other error occurred. </p>
<p>RTE_E_TIMEOUT </p>
<p>Returned by a blocking call after the timeout has expired. No </p>
<p>data returned and no other error occurred. The argument buffer </p>
<p>is not changed. </p>
<p>RTE_E_LOST_DATA </p>
<p>Indicates that some incoming data has been lost due to an </p>
<p>overflow of the receive queue. This is not an error of the data </p>
<p>returned in the out parameter. </p>
<p>RTE_E_SOFT_TRANSFORMER_ERROR </p>
<p>An error during transformation occurred which shall be notified </p>
<p>to the SWC but still produces valid data as output. </p>
<p>RTE_E_HARD_TRANSFORMER_ERROR </p>
<p>An error during transformation occurred which produces invalid </p>
<p>data as output. </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured polling or waiting access to the data element </p>
<p>in the DaVinci configuration and the referenced data element prototype is configured with queued </p>
<p>communication (</p>
<p>isQueued=true</p>
<p>).  </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Receive_&lt;p&gt;_&lt;d&gt;()</p>
<p> supplies the oldest value stored in the reception queue of the data </p>
<p>element. This API can be used for explicit read of S/R data with </p>
<p>isQueued=true</p>
<p>.  </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>77 </p>
<p>based on template version 3.5 </p>
<p><b>5.6.5 </b></p>
<p><b>Rte_Send </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Rte_Send_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance,] IN &lt;DataType&gt; data ) </p>
<p>Std_ReturnType <b>Rte_Send_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance,] IN &lt;DataType&gt; *data [, IN uint16 </p>
<p>length] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different </p>
<p>instances in case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the </p>
<p>configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> </p>
<p>attribute. </p>
<p>data </p>
<p>The input data &lt;data&gt; for primitive data types without string </p>
<p>types is passed by value. The &lt;DataType&gt; is the type, specified </p>
<p>at the data element prototype in the SWC description.  </p>
<p>*data </p>
<p>The input data &lt;data&gt; for string types and composite data types </p>
<p>is passed by reference. The &lt;DataType&gt; is the type, specified </p>
<p>at the data element prototype in the SWC description.  </p>
<p>length </p>
<p>In case of an array with variable number of elements, the input </p>
<p>data &lt;length&gt; specifies the dynamic array length. </p>
<p><b>Return code </b></p>
<p>RTE_E_OK </p>
<p>Data passed to communication services successfully.  </p>
<p>RTE_E_COM_STOPPED </p>
<p>An infrastructure communication error was detected by the RTE.  </p>
<p>RTE_E_LIMIT </p>
<p>The submitted data has been discarded because the receiver </p>
<p>queue is full. Relevant only to intra ECU communication. </p>
<p>RTE_E_SOFT_TRANSFORMER_ERROR </p>
<p>An error during transformation occurred which shall be notified </p>
<p>to the SWC but still produces valid data as output. </p>
<p>RTE_E_HARD_TRANSFORMER_ERROR </p>
<p>An error during transformation occurred which produces invalid </p>
<p>data as output. </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured access to the data element in the DaVinci </p>
<p>configuration and the referenced data element prototype is configured with queued communication </p>
<p>(</p>
<p>isQueued=true</p>
<p>).  </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Send_&lt;p&gt;_&lt;d&gt;()</p>
<p> can be used for explicit transmission of S/R data with </p>
<p>isQueued=true</p>
<p>.  </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>78 </p>
<p>based on template version 3.5 </p>
<p><b>5.6.6 </b></p>
<p><b>Rte_IRead </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>&lt;DataType&gt; <b>Rte_IRead_&lt;r&gt;_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance] ) </p>
<p>&lt;DataType&gt; <b>*Rte_IRead_&lt;r&gt;_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>Instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>&lt;DataType&gt; </p>
<p>The return value contains the buffered data for primitive data types. </p>
<p>&lt;DataType&gt; is the type, specified at the data element prototype in the </p>
<p>SWC description </p>
<p>&lt;DataType&gt; * </p>
<p>The return value contains a reference to the buffered data for string </p>
<p>types and composite data types. &lt;DataType&gt; is the type, specified at </p>
<p>the data element prototype in the SWC description </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured buffered (implicit) access to the data </p>
<p>element in the DaVinci configuration.  </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_IRead_&lt;r&gt;_&lt;p&gt;_&lt;d&gt;()</p>
<p> supplies the value of the data element, stored in a </p>
<p>buffer before starting of the runnable entity. This API can be used for buffered (implicit) read of S/R </p>
<p>data with </p>
<p>isQueued=false</p>
<p><i>. </i>After startup </p>
<p>Rte_IRead</p>
<p> provides the initial value. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside the runnable &lt;r&gt; of an AUTOSAR software component (SWC). </p>
<p>Usage in other runnables of the same SWC is forbidden! </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>79 </p>
<p>based on template version 3.5 </p>
<p><b>5.6.7 </b></p>
<p><b>Rte_IWrite </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_IWrite_&lt;r&gt;_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance,] IN &lt;DataType&gt; data ) </p>
<p>void <b>Rte_IWrite_&lt;r&gt;_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance,] IN &lt;DataType&gt; *data ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p>data </p>
<p>The input data &lt;data&gt; for primitive data types without string types is </p>
<p>passed by value. The &lt;DataType&gt; is the type, specified at the data </p>
<p>element prototype in the SWC description.  </p>
<p>*data </p>
<p>The input data &lt;data&gt; for string types and composite data types is </p>
<p>passed by reference. The &lt;DataType&gt; is the type, specified at the </p>
<p>data element prototype in the SWC description.  </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured buffered (implicit) access to the data </p>
<p>element in the DaVinci configuration.  </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_IWrite_&lt;r&gt;_&lt;p&gt;_&lt;d&gt;()</p>
<p> can be used for buffered transmission of S/R data </p>
<p>with </p>
<p>isQueued=false</p>
<p>. Note, that the actual transmission is performed and therefore visible for </p>
<p>other runnable entities after the runnable entity has been terminated.  </p>
<p><b>Call Context </b></p>
<p>This function can be used inside the runnable &lt;r&gt; of an AUTOSAR software component (SWC). </p>
<p>Usage in other runnables of the same SWC is forbidden! </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>When implicit write access to a data element has been configured for a runnable, the </p>
<p>runnable has to update the data element at least once during its execution time using </p>
<p>the </p>
<p>Rte_IWrite</p>
<p> API or writing to the location returned by the </p>
<p>Rte_IWriteRef</p>
<p> API. </p>
<p>Otherwise, the content of the data element is undefined upon return from the runnable. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>80 </p>
<p>based on template version 3.5 </p>
<p><b>5.6.8 </b></p>
<p><b>Rte_IWriteRef </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>&lt;DataType&gt; <b>*Rte_IWriteRef_&lt;r&gt;_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>Instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>&lt;DataType&gt; * </p>
<p>The return value contains a reference to the buffered data. </p>
<p>&lt;DataType&gt; is the type, specified at the data element prototype in the </p>
<p>SWC description </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured buffered (implicit) access to the data </p>
<p>element in the DaVinci configuration.  </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_IWriteRef_&lt;r&gt;_&lt;p&gt;_&lt;d&gt;()</p>
<p> can be used for buffered transmission of S/R </p>
<p>data with </p>
<p>isQueued=false</p>
<p>. Note, that the actual transmission is performed and therefore visible </p>
<p>for other runnable entities after the runnable entity has been terminated.  </p>
<p>The returned reference can be used by the runnable entity to directly update the corresponding </p>
<p>data elements. This is especially useful for data elements of composite types. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside the runnable &lt;r&gt; of an AUTOSAR software component (SWC). </p>
<p>Usage in other runnables of the same SWC is forbidden! </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>When implicit write access to a data element has been configured for a runnable, the </p>
<p>runnable has to update the data element at least once during its execution time using </p>
<p>the </p>
<p>Rte_IWrite</p>
<p> API or writing to the location returned by the </p>
<p>Rte_IWriteRef</p>
<p> API. </p>
<p>Otherwise, the content of the data element is undefined upon return from the runnable. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>81 </p>
<p>based on template version 3.5 </p>
<p><b>5.6.9 </b></p>
<p><b>Rte_IStatus </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Rte_IStatus_&lt;r&gt;_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>RTE_E_OK </p>
<p>Data read successfully.  </p>
<p>RTE_E_UNCONNECTED </p>
<p>Indicates that the receiver port is not connected. </p>
<p>RTE_E_INVALID </p>
<p>An invalidated signal has been received by the RTE.  </p>
<p>RTE_E_MAX_AGE_EXCEEDED </p>
<p>Indicates a timeout, detected by the COM module in case of inter ECU </p>
<p>communication, if an </p>
<p>aliveTimeout</p>
<p> is specified.  </p>
<p>RTE_E_NEVER_RECEIVED </p>
<p>No data received since system start.  </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured buffered (implicit) access to the data </p>
<p>element in the DaVinci configuration and if either  </p>
<p></p>
<p> data element outdated notification (</p>
<p>aliveTimeout</p>
<p> </p>
<p>&gt; 0</p>
<p>) or  </p>
<p></p>
<p> data element invalidation is activated for this data element or </p>
<p></p>
<p> the attribute </p>
<p>handleNeverReceived</p>
<p> is configured. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_IStatus_&lt;r&gt;_&lt;p&gt;_&lt;d&gt;()</p>
<p> returns the status of the data element which can be read </p>
<p>with </p>
<p>Rte_IRead</p>
<p>.  </p>
<p><b>Call Context </b></p>
<p>This function can be used inside the runnable &lt;r&gt; of an AUTOSAR software component (SWC). Usage in </p>
<p>other runnables of the same SWC is forbidden! </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>82 </p>
<p>based on template version 3.5 </p>
<p><b>5.6.10 </b></p>
<p><b>Rte_Feedback </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Rte_Feedback_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>RTE_E_NO_DATA </p>
<p>No data transmitted, when the feedback API was attempted (non-</p>
<p>blocking call only).  </p>
<p>RTE_E_UNCONNECTED </p>
<p>Indicates that the sender port is not connected. </p>
<p>RTE_E_TIMEOUT </p>
<p>A timeout notiﬁcation was received from COM before any error </p>
<p>notiﬁcation (Inter-ECU only).  </p>
<p>RTE_E_COM_STOPPED </p>
<p>The last transmission was rejected when either Rte_Send / Rte_Write </p>
<p>API was called and the COM was stopped or an error notiﬁcation from </p>
<p>COM was received before any timeout notiﬁcation (Inter-ECU only).   </p>
<p>RTE_E_TRANSMIT_ACK </p>
<p>A “transmission acknowledgement” has been received. </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured explicit access to the data element </p>
<p>in the DaVinci configuration of a runnable entity and in addition the transmission acknowledgement </p>
<p>is enabled at the communication specification. Furthermore, polling or waiting acknowledgment </p>
<p>mode has to be specified for the same data element. If a timeout is specified, timeout monitoring </p>
<p>for waiting acknowledgment access is enabled. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Feedback_&lt;p&gt;_&lt;d&gt;()</p>
<p> can be used to read the transmission status for explicit </p>
<p>S/R communication. It indicated the status of data, transmitted by </p>
<p>Rte_Write()</p>
<p> and </p>
<p>Rte_Send()</p>
<p> calls. Depending on the configuration, the API can be either blocking or non-blocking. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>83 </p>
<p>based on template version 3.5 </p>
<p><b>5.6.11 </b></p>
<p><b>Rte_IsUpdated </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>boolean <b>Rte_IsUpdated_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>TRUE </p>
<p>Data element has been updated since last read.  </p>
<p>FALSE </p>
<p>Data element has not been updated since last read.  </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured explicit access to the data element </p>
<p>in the DaVinci configuration of a runnable entity and in addition the </p>
<p>EnableUpdate</p>
<p> attribute is </p>
<p>enabled at the communication specification. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_IsUpdated_&lt;p&gt;_&lt;d&gt;()</p>
<p> returns if the data element has been updated since </p>
<p>the last read or not. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>84 </p>
<p>based on template version 3.5 </p>
<p><b>5.7 </b></p>
<p><b>Data Element Invalidation </b></p>
<p><b>5.7.1 </b></p>
<p><b>Rte_Invalidate </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Rte_Invalidate_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different </p>
<p>instances in case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the </p>
<p>configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> </p>
<p>attribute. </p>
<p><b>Return code </b></p>
<p>RTE_E_OK </p>
<p>No error occurred.  </p>
<p>RTE_E_COM_STOPPED </p>
<p>The RTE could not perform the operation because the COM </p>
<p>service is currently not available (inter ECU communication </p>
<p>only). </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured explicit and non-queued access to the data </p>
<p>element in the DaVinci configuration of a runnable entity and in addition the data element invalidation is </p>
<p>enabled at the communication specification (</p>
<p>CanInvalidate=true</p>
<p>).  </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Invalidate_&lt;p&gt;_&lt;d&gt;()</p>
<p> can be used to set the transmission data invalid for explicit </p>
<p>non-queued S/R communication. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>85 </p>
<p>based on template version 3.5 </p>
<p><b>5.7.2 </b></p>
<p><b>Rte_IInvalidate </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_IInvalidate_&lt;r&gt;_&lt;p&gt;_&lt;d&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured buffered (implicit) access to the data </p>
<p>element in the DaVinci configuration of a runnable entity and in addition the data element </p>
<p>invalidation is enabled at the communication specification (</p>
<p>CanInvalidate=true</p>
<p>).  </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_IInvalidate_&lt;r&gt;_&lt;p&gt;_&lt;d&gt;()</p>
<p> can be used to set the transmission data </p>
<p>invalid for implicit (buffered) S/R communication. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside the runnable &lt;r&gt; of an AUTOSAR software component (SWC). </p>
<p>Usage in other runnables of the same SWC is forbidden! </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>86 </p>
<p>based on template version 3.5 </p>
<p><b>5.8 </b></p>
<p><b>Mode Management </b></p>
<p><b>5.8.1 </b></p>
<p><b>Rte_Switch </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Rte_Switch_&lt;p&gt;_&lt;m&gt; </b>( [IN Rte_Instance instance,]                           </p>
<p>IN Rte_ModeType_&lt;ModeDeclarationGroup&gt; mode ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p>mode </p>
<p>The next mode. It is of type </p>
<p>Rte_ModeType_&lt;m&gt;</p>
<p>, where &lt;m&gt; is the </p>
<p>name of the mode declaration group.   </p>
<p><b>Return code </b></p>
<p>RTE_E_OK </p>
<p>Mode switch trigger passed to the RTE successfully.  </p>
<p> </p>
<p>RTE_E_LIMIT </p>
<p>The submitted mode switch has been discarded because the mode </p>
<p>queue is full. </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured access to the mode declaration </p>
<p>group prototype in the DaVinci configuration.  </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Switch_&lt;p&gt;_&lt;m&gt;()</p>
<p> can be used to trigger a mode switch of the specified </p>
<p>mode declaration group prototype.  </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>87 </p>
<p>based on template version 3.5 </p>
<p><b>5.8.2 </b></p>
<p><b>Rte_Mode </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Rte_ModeType_&lt;ModeDeclarationGroup&gt; <b>Rte_Mode_&lt;p&gt;_&lt;m&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>RTE_TRANSITION_&lt;mg&gt; </p>
<p>This return code is returned if the mode machine is in a mode </p>
<p>transition.  </p>
<p>RTE_MODE_&lt;mg&gt;_&lt;m&gt; </p>
<p>This value is returned if the mode machine is not in a transition.     </p>
<p>&lt;m&gt; indicates the currently active mode. </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured access to the mode declaration </p>
<p>group prototype in the DaVinci configuration and the enhanced Mode API is not active. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Mode_&lt;p&gt;_&lt;m&gt;()</p>
<p> provides the current mode of a mode declaration group </p>
<p>prototype.  </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>88 </p>
<p>based on template version 3.5 </p>
<p><b>5.8.3 </b></p>
<p><b>Enhanced Rte_Mode </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Rte_ModeType_&lt;ModeDeclarationGroup&gt; <b>Rte_Mode_&lt;p&gt;_&lt;m&gt; </b>( [IN Rte_Instance instance],    </p>
<p>OUT Rte_ModeType_&lt;ModeDeclarationGroup&gt; previousMode,                               </p>
<p>OUT Rte_ModeType_&lt;ModeDeclarationGroup&gt; nextMode ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p>previousMode</p>
<p> </p>
<p>The previous mode is returned if the mode machine is in a transition. </p>
<p>nextMode  </p>
<p> </p>
<p>The next mode is returned if the mode machine is in a transition. </p>
<p><b>Return code </b></p>
<p>RTE_TRANSITION_&lt;mg&gt; </p>
<p>This return code is returned if the mode machine is in a mode </p>
<p>transition.  </p>
<p>RTE_MODE_&lt;mg&gt;_&lt;m&gt; </p>
<p>This value is returned if the mode machine is not in a transition.     </p>
<p>&lt;m&gt; indicates the currently active mode. </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured access to the mode declaration </p>
<p>group prototype in the DaVinci configuration and the enhanced Mode API is active. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Mode_&lt;p&gt;_&lt;m&gt;()</p>
<p> provides the current mode of a mode declaration group </p>
<p>prototype. In addition it provodes the previous mode and the next mode if the mode machine is in </p>
<p>transition.  </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>89 </p>
<p>based on template version 3.5 </p>
<p><b>5.8.4 </b></p>
<p><b>Rte_SwitchAck </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Rte_SwitchAck_&lt;p&gt;_&lt;m&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>RTE_E_NO_DATA </p>
<p>No mode switch triggered, when the switch ack API was attempted </p>
<p>(non-blocking call only).  </p>
<p>RTE_E_TIMEOUT </p>
<p>No mode switch processed within the specified timeout time, when the </p>
<p>switch ack API was attempted (blocking call only).  </p>
<p>RTE_E_TRANSMIT_ACK </p>
<p>The mode switch acknowledgement has been received. </p>
<p>RTE_E_UNCONNECTED </p>
<p>Indicates that the mode provide port is not connected. </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured access to the mode declaration </p>
<p>group prototype in the DaVinci configuration of a runnable entity and in addition the mode switch </p>
<p>acknowledgement is enabled at the mode switch communication specification. Furthermore, polling </p>
<p>or waiting acknowledgment mode has to be specified for the same mode declaration group </p>
<p>prototype. If a timeout is specified, timeout monitoring for waiting acknowledgment access is </p>
<p>enabled. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_SwitchAck_&lt;p&gt;_&lt;m&gt;()</p>
<p> can be used to read the mode switch status of a </p>
<p>specific mode declaration group prototype. It indicated the status of a mode switch, triggered by an </p>
<p>Rte_Switch</p>
<p> call. Depending on the configuration, the API can be either blocking or non-blocking. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>90 </p>
<p>based on template version 3.5 </p>
<p><b>5.9 </b></p>
<p><b>Inter-Runnable Variables </b></p>
<p><b>5.9.1 </b></p>
<p><b>Rte_IrvRead </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>&lt;DataType&gt; <b>Rte_IrvRead_&lt;r&gt;_&lt;v&gt; </b>( [IN Rte_Instance instance] ) </p>
<p>void <b>Rte_IrvRead_&lt;r&gt;_&lt;v&gt; </b>([IN Rte_Instance instance,]  OUT &lt;DataType&gt; *data) </p>
<p><b>Parameter </b></p>
<p>Instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p>*data </p>
<p>The output &lt;data&gt; is passed by reference for composite data types. </p>
<p>The &lt;DataType&gt; is the type of the Inter-Runnable Variable specified in </p>
<p>the SWC description. </p>
<p><b>Return code </b></p>
<p>&lt;DataType&gt; </p>
<p>The return value contains the current content of the Inter-Runnable </p>
<p>Variable of primitive data types. The &lt;DataType&gt; is the type of the </p>
<p>Inter-Runnable Variable specified in the SWC description. </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured direct (explicit) read access to the </p>
<p>Inter-Runnable Variable in the SWC configuration.  </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_IrvRead_&lt;r&gt;_&lt;v&gt;()</p>
<p> supplies the current value of the Inter-Runnable Variable. </p>
<p>This API is used to read direct (explicit) Inter-Runnable Variables<i>. </i>After startup </p>
<p>Rte_IrvRead</p>
<p> </p>
<p>provides the configured initial value. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside the runnable &lt;r&gt; of an AUTOSAR software component (SWC). </p>
<p>Usage in other runnables of the same SWC is forbidden! </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>91 </p>
<p>based on template version 3.5 </p>
<p><b>5.9.2 </b></p>
<p><b>Rte_IrvWrite </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_IrvWrite_&lt;r&gt;_&lt;v&gt; </b>( [IN Rte_Instance instance,] IN &lt;DataType&gt; data ) </p>
<p>void <b>Rte_IrvWrite_&lt;r&gt;_&lt;v&gt; </b>( [IN Rte_Instance instance,] IN &lt;DataType&gt; *data ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p>data </p>
<p>The input data &lt;data&gt; is passed by value for primitive data types. The </p>
<p>&lt;DataType&gt; is the type of the Inter-Runnable Variable specified in the </p>
<p>SWC description.  </p>
<p>*data </p>
<p>The input data &lt;data&gt; for composite data types is passed by </p>
<p>reference. The &lt;DataType&gt; is the type of the Inter-Runnable Variable </p>
<p>specified in the SWC description.  </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured direct (explicit) write access to the </p>
<p>Inter-Runnable Variable in the SWC configuration.  </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_IrvIWrite_&lt;r&gt;_&lt;v&gt;()</p>
<p> can be used for updating direct (explicit) access Inter-</p>
<p>Runnable Variables. The update is performed immediately. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside the runnable &lt;r&gt; of an AUTOSAR software component (SWC). </p>
<p>Usage in other runnables of the same SWC is forbidden! </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>92 </p>
<p>based on template version 3.5 </p>
<p><b>5.9.3 </b></p>
<p><b>Rte_IrvIRead </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>&lt;DataType&gt; <b>Rte_IrvIRead_&lt;r&gt;_&lt;v&gt; </b>( [IN Rte_Instance instance] ) </p>
<p>&lt;DataType&gt; *<b>Rte_IrvIRead_&lt;r&gt;_&lt;v&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>&lt;DataType&gt; </p>
<p>The return value contains the buffered content of the Inter-Runnable </p>
<p>Variable for primitive data types. The &lt;DataType&gt; is the type of the </p>
<p>Inter-Runnable Variable specified in the SWC description. </p>
<p>&lt;DataType&gt; * </p>
<p>The return value contains a reference to the buffered content of the </p>
<p>Inter-Runnable Variable for composite data types. The &lt;DataType&gt; is </p>
<p>the type of the Inter-Runnable Variable specified in the SWC </p>
<p>description.  </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured buffered (implicit) read access to the </p>
<p>Inter-Runnable Variable in the SWC configuration.  </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_IrvIRead_&lt;r&gt;_&lt;v&gt;()</p>
<p> supplies the value of the Inter-Runnable Variable, </p>
<p>stored in a buffer before the runnable entity is started. This API is used to read the buffered </p>
<p>(implicit) Inter-Runnable Variable<i>. </i>After startup </p>
<p>Rte_IrvIRead</p>
<p> provides the configured initial </p>
<p>value. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside the runnable &lt;r&gt; of an AUTOSAR software component (SWC). </p>
<p>Usage in other runnables of the same SWC is forbidden! </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>93 </p>
<p>based on template version 3.5 </p>
<p><b>5.9.4 </b></p>
<p><b>Rte_IrvIWrite </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_IrvIWrite_&lt;r&gt;_&lt;v&gt; </b>( [IN Rte_Instance instance,] IN &lt;DataType&gt; data ) </p>
<p>void <b>Rte_IrvIWrite_&lt;r&gt;_&lt;v&gt; </b>( [IN Rte_Instance instance,] IN &lt;DataType&gt; *data) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p>data </p>
<p>The input data &lt;data&gt; is passed by value for primitive data types. The </p>
<p>&lt;DataType&gt; is the type of the Inter-Runnable Variable specified in the </p>
<p>SWC description.  </p>
<p>*data </p>
<p>The input data &lt;data&gt; is passed by reference for composite data </p>
<p>types. The &lt;DataType&gt; is the type of the Inter-Runnable Variable </p>
<p>specified in the SWC description.  </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured buffered (implicit) write access to </p>
<p>the Inter-Runnable Variable in the SWC configuration.  </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_IrvIWrite_&lt;r&gt;_&lt;v&gt;()</p>
<p> can be used for updating buffered (implicit) Inter-</p>
<p>Runnable Variables. Note, that the actual update is performed and therefore visible for other </p>
<p>runnable entities after the runnable entity has been terminated.  </p>
<p><b>Call Context </b></p>
<p>This function can be used inside the runnable &lt;r&gt; of an AUTOSAR software component (SWC). </p>
<p>Usage in other runnables of the same SWC is forbidden! </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>When buffered (implicit) write access to an Inter-Runnable Variable has been </p>
<p>configured for a runnable, the runnable has to update the Inter-Runnable variable at </p>
<p>least once during its execution time using the </p>
<p>Rte_IrvIWrite</p>
<p> API. Otherwise, the </p>
<p>content of the Inter-Runnable Variable may become undefined upon return from the </p>
<p>runnable. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>94 </p>
<p>based on template version 3.5 </p>
<p><b>5.10 </b></p>
<p><b>Per-Instance Memory </b></p>
<p><b>5.10.1 </b></p>
<p><b>Rte_Pim </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>&lt;C-type&gt; <b>*Rte_Pim_&lt;n&gt; </b>( [IN Rte_Instance instance] ) </p>
<p>&lt;DataType&gt; <b>*Rte_Pim_&lt;n&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>&lt;C-Type&gt; * </p>
<p>If the configured data type of the Per-Instance Memory is specified by </p>
<p>any C type string, a reference to the PIM of the C-type is returned. </p>
<p>&lt;DataType&gt; * </p>
<p>If the configured DataType of the Per-Instance Memory is an </p>
<p>AUTOSAR DataType, a reference to the PIM of this AUTOSAR type is </p>
<p>returned. If the data type is known and completely described, the RTE </p>
<p>generator knows the size of the PIM variable and is able to generate </p>
<p>the PIM variables in a specific optimized order.   </p>
<p><b>Existence </b></p>
<p>This API exists for each specified Per-Instance Memory specified for an AUTOSAR application </p>
<p>SWC. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Pim_&lt;n&gt;()</p>
<p> can be used to access Per-Instance Memory.  Note: If several </p>
<p>runnable entities have concurrent access to the same Per-Instance Memory, the user has to </p>
<p>protect the accesses by using implicit or explicit exclusive areas.  </p>
<p><b>Call Context </b></p>
<p>This function can be used inside all runnable entities of the AUTOSAR software component (SWC) </p>
<p>specifying the Per-Instance Memory. </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>When the Per–Instance Memory uses no AUTOSAR data type and is also not based </p>
<p>on a standard data type like e.g. </p>
<p>uint8</p>
<p> the RTE generator cannot create the type </p>
<p>definition for this type.   </p>
<p>In this case the user has to provide a user header file </p>
<p>Rte_UserTypes.h</p>
<p> which </p>
<p>should contain the type definitions for the Per-Instance Memory allowing the RTE </p>
<p>generator to allocate the Per-Instance memory.  </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>95 </p>
<p>based on template version 3.5 </p>
<p><b>5.11 </b></p>
<p><b>Calibration Parameters </b></p>
<p><b>5.11.1 </b></p>
<p><b>Rte_CData </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>&lt;DataType&gt; <b>Rte_CData_&lt;cp&gt; </b>( [IN Rte_Instance instance] ) </p>
<p>&lt;DataType&gt; <b>*Rte_CData_&lt;cp&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>&lt;DataType&gt; </p>
<p>For primitive data types the return value contains the content of the </p>
<p>calibration parameter. The return value is of type &lt;DataType&gt;, which </p>
<p>is the type of the calibration element prototype. </p>
<p>&lt;DataType&gt; * </p>
<p>For composite data types and string types the return value contains </p>
<p>the reference to the calibration parameter. The return value is of type </p>
<p>&lt;DataType&gt;, which is the type of the calibration element prototype. </p>
<p><b>Existence </b></p>
<p>This API exists for each calibration element prototype specified for an AUTOSAR application SWC. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_CData_&lt;cp&gt;()</p>
<p> can be used to access SWC local calibration parameters. </p>
<p>Depending on the configuration the Rte_CData API returns a SWC type specific (</p>
<p>shared</p>
<p>) or SWC </p>
<p>instance specific (</p>
<p>perInstance</p>
<p>) calibration parameter.  </p>
<p><b>Call Context </b></p>
<p>This function can be used inside all runnable entities of the AUTOSAR software component (SWC) </p>
<p>specifying the calibration parameters. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>96 </p>
<p>based on template version 3.5 </p>
<p><b>5.11.2 </b></p>
<p><b>Rte_Prm </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>&lt;DataType&gt; <b>Rte_Prm_&lt;p&gt;_&lt;cp&gt; </b>( [IN Rte_Instance instance] ) </p>
<p>&lt;DataType&gt; <b>*Rte_Prm_&lt;p&gt;_&lt;cp&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>&lt;DataType&gt; </p>
<p>For primitive data types the return value contains the content of the </p>
<p>calibration parameter. The return value is of type &lt;DataType&gt;, which </p>
<p>is the type of the calibration element prototype. </p>
<p>&lt;DataType&gt; * </p>
<p>For composite data types and string types the return value contains </p>
<p>the reference to the calibration parameter. The return value is of type </p>
<p>&lt;DataType&gt;, which is the type of the calibration element prototype. </p>
<p><b>Existence </b></p>
<p>This API exists for each calibration element prototype specified for a calibration software </p>
<p>component. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Prm_&lt;p&gt;_&lt;cp&gt;()</p>
<p> can be used to access the instance specific calibration </p>
<p>element prototypes of a calibration component.  </p>
<p><b>Call Context </b></p>
<p>This function can be used inside all runnable entities of the AUTOSAR software component (SWC) </p>
<p>specifying access to calibration element prototypes of calibration components via calibration ports. </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>97 </p>
<p>based on template version 3.5 </p>
<p><b>5.12 </b></p>
<p><b>Client-Server Communication </b></p>
<p><b>5.12.1 </b></p>
<p><b>Rte_Call </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Rte_Call_&lt;p&gt;_&lt;o&gt; </b>( [IN Rte_Instance instance,]                  </p>
<p>{IN type </p>
<p>[*]inputparam,}* {OUT type *outputparam,}* {INOUT type *inoutputparam,}*</p>
<p> ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different </p>
<p>instances in case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the </p>
<p>configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> </p>
<p>attribute. </p>
<p>[*]inputparam, *outputparam, </p>
<p>*inoutputparam, </p>
<p>The number and type of parameters is determined by the </p>
<p>operation prototype. Input (IN) parameters are passed by value </p>
<p>(primitive types) or reference (composite and string types), </p>
<p>output (OUT) and input-output (INOUT) parameters are always </p>
<p>passed by reference. </p>
<p><b>Return code </b></p>
<p>RTE_E_OK </p>
<p>Operation executed successfully. </p>
<p>RTE_E_UNCONNECTED </p>
<p>Indicates that the client port is not connected. </p>
<p>RTE_E_LIMIT </p>
<p>The operation is invoked while a previous invocation has not yet </p>
<p>terminated. Relevant only for asynchronous calls. </p>
<p>RTE_E_COM_STOPPED </p>
<p>An infrastructure communication error was detected by the RTE. </p>
<p>Relevant only to external communication. </p>
<p>RTE_E_TIMEOUT </p>
<p>Returned by a synchronous call after the timeout has expired </p>
<p>and no other error occurred. The arguments are not changed. </p>
<p>RTE_E_&lt;interf&gt;_&lt;error&gt; </p>
<p>Server runnables may return an application error if the operation </p>
<p>execution was not successful. Application errors are defined at </p>
<p>the client/server port interface and are references by the </p>
<p>operation prototype. </p>
<p>RTE_E_SOFT_TRANSFORMER_ERROR </p>
<p>An error during transformation occurred which shall be notified </p>
<p>to the SWC but still produces valid data as output. </p>
<p>RTE_E_HARD_TRANSFORMER_ERROR </p>
<p>An error during transformation occurred which produces invalid </p>
<p>data as output. </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured access to the operation prototype in the </p>
<p>DaVinci configuration. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Call_&lt;p&gt;_&lt;o&gt;()</p>
<p> invokes the server operation &lt;o&gt; with the specified parameters. If </p>
<p>Rte_Call</p>
<p> returns with an error, the INOUT and OUT parameters are unchanged.  </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>98 </p>
<p>based on template version 3.5 </p>
<p><b>5.12.2 </b></p>
<p><b>Rte_Result </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Rte_Result_&lt;p&gt;_&lt;o&gt; </b>( [IN Rte_Instance instance,]               </p>
<p>{OUT type *outputparam,}* ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p>*outputparam </p>
<p>The number and type of parameters is determined by the operation </p>
<p>prototype. The output (OUT) parameters are always passed by </p>
<p>reference. </p>
<p><b>Return code </b></p>
<p>RTE_E_OK </p>
<p>Operation executed successfully. </p>
<p>RTE_E_UNCONNECTED </p>
<p>Indicates that the client port is not connected. </p>
<p>RTE_E_NO_DATA </p>
<p>The result of the asynchronous operation invocation is not available. </p>
<p>Relevant only for non-blocking call. </p>
<p>RTE_E_COM_STOPPED </p>
<p>An infrastructure communication error was detected by the RTE. </p>
<p>Relevant only to external communication. </p>
<p>RTE_E_TIMEOUT </p>
<p>The result of the asynchronous operation invocation is not available in </p>
<p>the specified time. Relevant only for blocking call. </p>
<p>RTE_E_&lt;interf&gt;_&lt;error&gt; </p>
<p>Server runnables may return an application error if the operation </p>
<p>execution was not successful. Application errors are defined at the </p>
<p>client/server port interface and are references by the operation </p>
<p>prototype. </p>
<p><b>Existence </b></p>
<p>This API exists, if the runnable entity of a SWC has configured polling or waiting access to an </p>
<p>asynchronous invoked operation of a C/S port interface. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Result_&lt;p&gt;_&lt;o&gt;() </p>
<p>provides the result of asynchronous C/S calls. In case of </p>
<p>a polling call, the API returns the OUT parameters if the result is already available while for </p>
<p>asynchronous calls the API waits until the server runnable has finished the execution or a timeout </p>
<p>occurs. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>99 </p>
<p>based on template version 3.5 </p>
<p><b>5.13 </b></p>
<p><b>Indirect API </b></p>
<p><b>5.13.1 </b></p>
<p><b>Rte_Ports </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Rte_PortHandle_&lt;i&gt;_&lt;R/P&gt; <b>Rte_Ports_&lt;i&gt;_&lt;P/R&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>Rte_PortHandle_&lt;i&gt;_&lt;R/P&gt; </p>
<p>The API returns a pointer to the first port data structure of the port </p>
<p>data structure array.    </p>
<p><b>Existence </b></p>
<p>This API exists, if the indirect API is configured at the Component Type. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Ports_&lt;i&gt;_&lt;R/P&gt;</p>
<p> returns an array containing the port data structures of all </p>
<p>require ports indicated by the API extension &lt;R&gt; or provide ports indicated by &lt;P&gt; of the port </p>
<p>interface specified by &lt;i&gt; in order to allow indirect access of the port APIs via the port handle (e.g. </p>
<p>iteration over all ports of the same interface). </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>100 </p>
<p>based on template version 3.5 </p>
<p><b>5.13.2 </b></p>
<p><b>Rte_NPorts </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>uint8 <b>Rte_NPorts_&lt;i&gt;_&lt;P/R&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>uint8</p>
<p> </p>
<p>The API returns the size of the port data structure array provided by </p>
<p>Rte_Ports</p>
<p>. </p>
<p><b>Existence </b></p>
<p>This API exists, if the indirect API is configured at the component type. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_NPorts_&lt;i&gt;_&lt;R/P&gt;</p>
<p> returns the number of array entries (port data structures) </p>
<p>of all require ports indicated by the API extension &lt;R&gt; or provide ports indicated by &lt;P&gt; of the port </p>
<p>interface specified by &lt;i&gt;.  </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>101 </p>
<p>based on template version 3.5 </p>
<p><b>5.13.3 </b></p>
<p><b>Rte_Port </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Rte_PortHandle_&lt;i&gt;_&lt;R/P&gt; <b>Rte_Port_&lt;p&gt; </b>( [IN Rte_Instance instance] ) </p>
<p><b>Parameter </b></p>
<p>instance </p>
<p>Instance handle, used to distinguish between the different instances in </p>
<p>case of multiple instantiation. </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>Rte_PortHandle_&lt;i&gt;_&lt;R/P&gt; </p>
<p>The API returns a pointer to a port data structure.   </p>
<p><b>Existence </b></p>
<p>This API exists, if the indirect API is configured at the component type. </p>
<p><b>Functional Description </b></p>
<p>The function </p>
<p>Rte_Port_&lt;p&gt;</p>
<p> returns the port data structure of the port specified by &lt;p&gt;. It allows </p>
<p>indirect API access via the port handle. </p>
<p><b>Call Context </b></p>
<p>This function can be used inside a runnable entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>102 </p>
<p>based on template version 3.5 </p>
<p><b>5.14 </b></p>
<p><b>RTE Lifecycle API </b></p>
<p>The lifecycle API functions are declared in the RTE lifecycle header file </p>
<p>Rte_Main.h</p>
<p> </p>
<p><b>5.14.1 </b></p>
<p><b>Rte_Start </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Rte_Start </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p> </p>
<p><b>Return code </b></p>
<p>RTE_E_OK </p>
<p>RTE initialized successfully.  </p>
<p>RTE_E_LIMIT </p>
<p>An internal limit has been exceeded.  </p>
<p><b>Functional Description </b></p>
<p>The RTE lifecycle API function </p>
<p>Rte_Start</p>
<p> allocates and initializes system resources and </p>
<p>communication resources used by the RTE.  </p>
<p><b>Call Context </b></p>
<p>This function has to be called by the ECU state manager after basic software modules have been </p>
<p>initialized especially OS and COM. It has to be called on every core that is used by the RTE. The </p>
<p>call on the core that contains the BSW will start the triggering of all cyclic runnables. Therefore </p>
<p>Rte_Start on the other cores has to be executed first. </p>
<p> </p>
<p><b>5.14.2 </b></p>
<p><b>Rte_Stop </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Rte_Stop </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p> </p>
<p><b>Return code </b></p>
<p>RTE_E_OK </p>
<p>RTE initialized successfully.  </p>
<p>RTE_E_LIMIT </p>
<p>A resource could not be released.  </p>
<p><b>Functional Description </b></p>
<p>The RTE lifecycle API function </p>
<p>Rte_Stop</p>
<p> releases system resources and communication </p>
<p>resources used by the RTE and shutdowns the RTE. After </p>
<p>Rte_Stop</p>
<p> is called no runnable entity </p>
<p>must be processed. </p>
<p><b>Call Context </b></p>
<p>This function has to be called by the ECU state manager on every core that is used by the RTE. </p>
<p>The call on the core that contains the BSW will stop the triggering of the cyclic runnables. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>103 </p>
<p>based on template version 3.5 </p>
<p><b>5.14.3 </b></p>
<p><b>Rte_InitMemory </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_InitMemory </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Functional Description </b></p>
<p>The API function </p>
<p>Rte_InitMemory</p>
<p> is a MICROSAR RTE specific extension and should be used </p>
<p>to initialize RTE internal state variables if the compiler does not support initialized variables.  </p>
<p><b>Call Context </b></p>
<p>This function has to be called before the ECU state manager calls the initialization functions of </p>
<p>other BSW modules especially the AUTOSAR COM module.  It has to be called on all cores that </p>
<p>are used by the RTE. </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>Rte_InitMemory API is a Vector extension to the AUTOSAR standard and may not be </p>
<p>supported by other RTE generators. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>104 </p>
<p>based on template version 3.5 </p>
<p><b>5.15 </b></p>
<p><b>SchM Lifecycle API </b></p>
<p>The lifecycle API functions are declared in the RTE lifecycle header file </p>
<p>Rte_Main.h</p>
<p> </p>
<p><b>5.15.1 </b></p>
<p><b>SchM_Init </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>SchM_Init </b>( [IN SchM_ConfigType ConfigPtr] ) </p>
<p><b>Parameter </b></p>
<p>ConfigPtr  </p>
<p>Pointer to the Rte_Config_&lt;VariantName&gt; data structure that shall be </p>
<p>used for the RTE initialization of the active variant in case of a </p>
<p>postbuild selectable configuration. The parameter is omitted in case </p>
<p>the project contains no postbuild selectable variance. </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Functional Description </b></p>
<p>This function initializes the BSW Scheduler and resets the timers for all cyclic triggered schedulable </p>
<p>entities (main functions). Note that all main functions calls are activated upon return from this </p>
<p>function. </p>
<p><b>Call Context </b></p>
<p>This function has to be called by the ECU state manager from task context. The OS has to be </p>
<p>initialized before as well as those BSW modules for which the SchM provides triggering of </p>
<p>schedulable entities (main functions). The API has to be called on all cores that are used by the </p>
<p>RTE.  </p>
<p> </p>
<p><b>5.15.2 </b></p>
<p><b>SchM_Deinit </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>SchM_Deinit </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Functional Description </b></p>
<p>This function finalizes the BSW Scheduler and stops the timer which triggers the main functions. </p>
<p><b>Call Context </b></p>
<p>This function has to be called by the ECU state manager from task context. It has to be called on </p>
<p>all cores that are used by the RTE. </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>105 </p>
<p>based on template version 3.5 </p>
<p><b>5.15.3 </b></p>
<p><b>SchM_GetVersionInfo </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>SchM_GetVersionInfo </b>(Std_VersionInfoType *versioninfo ) </p>
<p><b>Parameter </b></p>
<p>versioninfo </p>
<p>Pointer to where to store the version information of this module. </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This API exists if </p>
<p>RteSchMVersionInfoApi</p>
<p> is enabled. </p>
<p><b>Functional Description </b></p>
<p>SchM_GetVersionInfo()</p>
<p> returns version information, vendor ID and AUTOSAR module ID of </p>
<p>the component. </p>
<p>The versions are decimal-coded. </p>
<p><b>Call Context </b></p>
<p>The function can be called on interrupt and task level. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>106 </p>
<p>based on template version 3.5 </p>
<p><b>5.16 </b></p>
<p><b>VFB Trace Hooks  </b></p>
<p>The </p>
<p>RTE’s </p>
<p>“VFB </p>
<p>tracing” </p>
<p>mechanism </p>
<p>allows </p>
<p>to </p>
<p>trace </p>
<p>interactions  of  the  AUTOSAR </p>
<p>software components with the VFB. The choice of events resides with the user and can </p>
<p>range  from  none  to  all.  The  “VFB  tracing”  functionality  is  designed  to  support  multiple </p>
<p>clients  for  each  event.  If  one  or  multiple  clients  are  specified  for  an  event,  the  trace </p>
<p>function without client prefix will be generated followed by the trace functions with client </p>
<p>prefixes in alphabetically ascending order.</p>
<p> </p>
<p> </p>
<p><b>5.16.1 </b></p>
<p><b>Rte_[&lt;client&gt;_]&lt;API&gt;Hook_&lt;cts&gt;_&lt;ap&gt;_Start </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_[&lt;client&gt;_]&lt;API&gt;Hook_&lt;cts&gt;_&lt;ap&gt;_Start </b>( [IN const Rte_CDS_&lt;cts&gt;* inst,] </p>
<p>params ) </p>
<p><b>Parameter </b></p>
<p>Rte_CDS_&lt;cts&gt;* inst </p>
<p>The instance specific pointer of type Rte_CDS_&lt;cts&gt; is used to </p>
<p>distinguish between the different instances in case of multiple </p>
<p>instantiation.  </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p>params </p>
<p>The parameters are the same as the parameters of the &lt;API&gt;. See </p>
<p>the corresponding API description for details. </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This VFB trace hook exists if the global and the hook specific configuration switches are enabled. </p>
<p><b>Functional Description </b></p>
<p>This VFB trace hook is called inside the RTE APIs directly after invocation of the API. The user has </p>
<p>to provide this hook function if it is enabled in the configuration. The placeholder &lt;API&gt; represents </p>
<p>one of the following APIs: </p>
<p>Enter, Exit, Write, Read, Send, Receive, Invalidate, SwitchAck, Switch, Call, Result, IrvWrite, </p>
<p>IrvRead  </p>
<p>The &lt;AccessPoint&gt; is defined as follows: </p>
<p></p>
<p> Enter, Exit: &lt;ExclusiveArea&gt; </p>
<p></p>
<p> Write, Read, Send, Receive, Feedback, Invalidate: </p>
<p>&lt;PortPrototype&gt;_&lt;DataElementPrototype&gt; </p>
<p></p>
<p> Switch, SwitchAck: &lt;PortPrototype&gt;_&lt;ModeDeclarationGroupPrototype&gt;        </p>
<p></p>
<p> Call, Result: &lt;PortPrototype&gt;_&lt;OperationPrototype&gt; </p>
<p></p>
<p> IrvWrite, IrvRead: &lt;InterRunnableVariable&gt; </p>
<p><b>Call Context </b></p>
<p>This function is called inside the RTE API. The call context is the context of the API itself. Since </p>
<p>APIs can only be called in runnable context, the context of the trace hooks is also the runnable </p>
<p>entity of an AUTOSAR software component (SWC). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>107 </p>
<p>based on template version 3.5 </p>
<p><b>5.16.2 </b></p>
<p><b>Rte_[&lt;client&gt;_]&lt;API&gt;Hook_&lt;cts&gt;_&lt;ap&gt;_Return </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_[&lt;client&gt;_]&lt;API&gt;Hook_&lt;cts&gt;_&lt;ap&gt;_Return </b>( [IN const Rte_CDS_&lt;cts&gt; *inst,] </p>
<p>params ) </p>
<p><b>Parameter </b></p>
<p>Rte_CDS_&lt;cts&gt;* inst </p>
<p>The instance specific pointer of type Rte_CDS_&lt;cts&gt; is used to </p>
<p>distinguish between the different instances in case of multiple </p>
<p>instantiation.  </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute.  </p>
<p>params </p>
<p>The parameters are the same as the parameters of the API. See the </p>
<p>corresponding API description for details. </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This VFB trace hook exists if the global and the hook specific configuration switches are enabled. </p>
<p><b>Functional Description </b></p>
<p>This VFB trace hook is called inside the RTE APIs directly before leaving the API. The user has to </p>
<p>provide this hook function if it is enabled in the configuration. The placeholder &lt;API&gt; represents </p>
<p>one of the following APIs: </p>
<p>Enter, Exit, Write, Read, Send, Receive, Invalidate, Feedback, Switch, SwitchAck, Call, Result, </p>
<p>IrvWrite, IrvRead </p>
<p> The &lt;AccessPoint&gt; is defined as follows: </p>
<p></p>
<p> Enter, Exit: &lt;ExclusiveArea&gt; </p>
<p></p>
<p> Write, Read, Send, Receive, Feedback, Invalidate: </p>
<p>&lt;PortPrototype&gt;_&lt;DataElementPrototype&gt; </p>
<p></p>
<p> Switch, SwitchAck: &lt;PortPrototype&gt;_&lt;ModeDeclarationGroupPrototype&gt;        </p>
<p></p>
<p> Call, Result: &lt;PortPrototype&gt;_&lt;OperationPrototype&gt; </p>
<p></p>
<p> IrvWrite, IrvRead: &lt;InterRunnableVariable&gt; </p>
<p><b>Call Context </b></p>
<p>This function is called inside the RTE API. The call context is the context of the API itself. Since </p>
<p>APIs can only be called in runnable context, the context of the trace hooks is also the runnable </p>
<p>entity of an AUTOSAR software component (SWC). </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>The RTE generator tries to prevent overhead by sometimes implementing the Rte_Call </p>
<p>API as macro that does a direct runnable invocation. If VFB trace hooks are enabled </p>
<p>for such an Rte_Call API or for the called server runnable, these optimizations are no </p>
<p>longer possible. </p>
<p>Also macro optimizations for Rte_Read, Rte_DRead, Rte_Write, Rte_IrvRead and </p>
<p>Rte_IrvWrite APIs are disabled when VFB tracing for that APIs is enabled. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>108 </p>
<p>based on template version 3.5 </p>
<p> </p>
<p><b>Caution </b></p>
<p>The RTE does not call VFB trace hooks for the following APIs because they are </p>
<p>intended to be implemented as macros. </p>
<p></p>
<p> Implicit S/R APIs: Rte_IWrite, Rte_IWriteRef, Rte_IRead, Rte_IStatus, </p>
<p>Rte_IInvalidate </p>
<p></p>
<p> Implicit Inter-Runnable Variables: Rte_IrvIWrite, Rte_IrvIRead </p>
<p></p>
<p> Per-instance Memory and calibration parameter APIs: Rte_Pim, Rte_CData, </p>
<p>Rte_Prm </p>
<p></p>
<p> Indirect APIs: Rte_Ports, Rte_Port, Rte_NPorts </p>
<p></p>
<p> RTE Life-Cycle APIs: Rte_Start, Rte_Stop </p>
<p> </p>
<p><b>5.16.3 </b></p>
<p><b>SchM_[&lt;client&gt;_]&lt;API&gt;Hook_&lt;Bsw&gt;_&lt;ap&gt;_Start </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>SchM_[&lt;client&gt;_]&lt;API&gt;Hook_&lt;bsw&gt;_&lt;ap&gt;_Start </b>( params ) </p>
<p><b>Parameter </b></p>
<p>params </p>
<p>The parameters are the same as the parameters of the &lt;API&gt;. See </p>
<p>the corresponding API description for details. </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This VFB trace hook exists if the global and the hook specific configuration switches are enabled. </p>
<p><b>Functional Description </b></p>
<p>This VFB trace hook is called inside the RTE APIs directly after invocation of the API. The user has </p>
<p>to provide this hook function if it is enabled in the configuration. The placeholder &lt;API&gt; represents </p>
<p>one of the following APIs: </p>
<p>Enter, Exit  </p>
<p>The &lt;AccessPoint&gt; is defined as follows: </p>
<p></p>
<p> Enter, Exit: &lt;ExclusiveArea&gt; </p>
<p><b>Call Context </b></p>
<p>This function is called inside the RTE API. The call context is the context of the API itself. Since </p>
<p>APIs can be called from a BSW function, the context of the trace hooks depends on the context of </p>
<p>the BSW function. </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>The SchM Hook APIs are a Vector extension to the AUTOSAR standard and may not </p>
<p>be supported by other RTE generators. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>109 </p>
<p>based on template version 3.5 </p>
<p><b>5.16.4 </b></p>
<p><b>SchM_[&lt;client&gt;_]&lt;API&gt;Hook_&lt;Bsw&gt;_&lt;ap&gt;_Return </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>SchM_[&lt;client&gt;_]&lt;API&gt;Hook_&lt;bsw&gt;_&lt;ap&gt;_Return </b>( params ) </p>
<p><b>Parameter </b></p>
<p>params </p>
<p>The parameters are the same as the parameters of the &lt;API&gt;. See </p>
<p>the corresponding API description for details. </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This VFB trace hook exists if the global and the hook specific configuration switches are enabled. </p>
<p><b>Functional Description </b></p>
<p>This VFB trace hook is called inside the RTE APIs directly before leaving the API. The user has to </p>
<p>provide this hook function if it is enabled in the configuration. The placeholder &lt;API&gt; represents </p>
<p>one of the following APIs: </p>
<p>Enter, Exit  </p>
<p>The &lt;AccessPoint&gt; is defined as follows: </p>
<p></p>
<p> Enter, Exit: &lt;ExclusiveArea&gt; </p>
<p><b>Call Context </b></p>
<p>This function is called inside the RTE API. The call context is the context of the API itself. Since </p>
<p>APIs can be called from a BSW function, the context of the trace hooks depends on the context of </p>
<p>the BSW function. </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>The SchM Hook APIs are a Vector extension to the AUTOSAR standard and may not </p>
<p>be supported by other RTE generators. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>110 </p>
<p>based on template version 3.5 </p>
<p><b>5.16.5 </b></p>
<p><b>Rte_[&lt;client&gt;_]ComHook_&lt;SignalName&gt;_SigTx </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_[&lt;client&gt;_]ComHook_&lt;SignalName&gt;_SigTx </b>( &lt;DataType&gt; *data ) </p>
<p><b>Parameter </b></p>
<p>&lt;DataType&gt;* data </p>
<p>Pointer to data to be transmitted via the COM API.  </p>
<p>Note: &lt;DataType&gt; is the application specific data type of </p>
<p>Rte_Send</p>
<p>, </p>
<p>Rte_Write</p>
<p> or </p>
<p>Rte_IWrite</p>
<p>.  </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This VFB trace hook exists, if at least one data element prototype of a port prototype has to be </p>
<p>transmitted over a network (Inter-Ecu) and the global and the hook specific configuration switches </p>
<p>are enabled.  </p>
<p><b>Functional Description </b></p>
<p>This hook is called just before the RTE invokes </p>
<p>Com_SendSignal</p>
<p> or </p>
<p>Com_UpdateShadowSignal</p>
<p>.    </p>
<p><b>Call Context </b></p>
<p>This function is called inside the RTE APIs </p>
<p>Rte_Send</p>
<p> and </p>
<p>Rte_Write</p>
<p>. The call context is the </p>
<p>context of the API itself. Since APIs can only be called in runnable context, the context of the trace </p>
<p>hooks is also the runnable entity of an AUTOSAR software component.  </p>
<p>If buffered communication (</p>
<p>Rte_IWrite</p>
<p>) is used, the call context is the task of the mapped </p>
<p>runnable.  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>111 </p>
<p>based on template version 3.5 </p>
<p><b>5.16.6 </b></p>
<p><b>Rte_[&lt;client&gt;_]ComHook_&lt;SignalName&gt;_SigIv </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_[&lt;client&gt;_]ComHook_&lt;SignalName&gt;_SigIv </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This VFB trace hook exists, if at least one data element prototype of a port prototype has to be </p>
<p>transmitted over a network (Inter-Ecu) and the global and the hook specific configuration switches </p>
<p>are enabled. In addition the </p>
<p>canInvalidate</p>
<p> attribute at the UnqueuedSenderComSpec of the </p>
<p>data element prototype must be enabled. </p>
<p><b>Functional Description </b></p>
<p>This hook is called just before the RTE invokes </p>
<p>Com_InvalidateSignal</p>
<p>.    </p>
<p><b>Call Context </b></p>
<p>This function is called inside the RTE APIs </p>
<p>Rte_Invalidate</p>
<p>. The call context is the context of the </p>
<p>API itself. Since APIs can only be called in runnable context, the context of the trace hooks is also </p>
<p>the runnable entity of an AUTOSAR software component.  </p>
<p>If buffered communication (</p>
<p>Rte_IInvalidate</p>
<p>) is used, the call context is the task of the mapped </p>
<p>runnable.  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>112 </p>
<p>based on template version 3.5 </p>
<p><b>5.16.7 </b></p>
<p><b>Rte_[&lt;client&gt;_]ComHook_&lt;SignalName&gt;_SigGroupIv </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_[&lt;client&gt;_]ComHook_&lt;SignalGroupName&gt;_SigGroupIv </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This VFB trace hook exists, if at least one data element prototype of a port prototype is composite </p>
<p>and has to be transmitted over a network (Inter-Ecu) and the global and the hook specific </p>
<p>configuration switches are enabled. In addition the </p>
<p>canInvalidate</p>
<p> attribute at the </p>
<p>UnqueuedSenderComSpec of the data element prototype must be enabled. </p>
<p><b>Functional Description </b></p>
<p>This hook is called just before the RTE invokes </p>
<p>Com_InvalidateSignalGroup</p>
<p>.    </p>
<p><b>Call Context </b></p>
<p>This function is called inside the RTE APIs </p>
<p>Rte_Invalidate</p>
<p>. The call context is the context of the </p>
<p>API itself. Since APIs can only be called in runnable context, the context of the trace hooks is also </p>
<p>the runnable entity of an AUTOSAR software component.  </p>
<p>If buffered communication (</p>
<p>Rte_IInvalidate</p>
<p>) is used, the call context is the task of the mapped </p>
<p>runnable.  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>113 </p>
<p>based on template version 3.5 </p>
<p><b>5.16.8 </b></p>
<p><b>Rte_[&lt;client&gt;_]ComHook_&lt;SignalName&gt;_SigRx </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_[&lt;client&gt;_]ComHook_&lt;SignalName&gt;_SigRx </b>( &lt;DataType&gt; *data ) </p>
<p><b>Parameter </b></p>
<p>&lt;DataType&gt;* data </p>
<p>Pointer to the data received via the COM API.  </p>
<p>Note: &lt;DataType&gt; is the application specific data type of </p>
<p>Rte_Receive</p>
<p>, </p>
<p>Rte_Read</p>
<p>, </p>
<p>Rte_DRead</p>
<p> or </p>
<p>Rte_IRead</p>
<p>.  </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This VFB trace hook exists, if at least one data element prototype of a port prototype has to be </p>
<p>received from a network and the global and hook specific configuration switches are enabled.  </p>
<p><b>Functional Description </b></p>
<p>This VFB Trace Hook is called after the RTE invokes </p>
<p>Com_ReceiveSignal</p>
<p> or </p>
<p>Com_ReceiveShadowSignal</p>
<p>. </p>
<p><b>Call Context </b></p>
<p>This function is called inside the RTE API </p>
<p>Rte_Read </p>
<p>or</p>
<p> Rte_DRead</p>
<p>. The call context is the </p>
<p>context of the API itself. Since this API can only be called in runnable context, the context of the </p>
<p>trace hooks is also the runnable entity of an AUTOSAR software component. </p>
<p>If buffered communication (</p>
<p>Rte_IRead</p>
<p>) is used, the call context is the task of the mapped </p>
<p>runnable.  </p>
<p>If queued communication is configured (</p>
<p>Rte_Receive</p>
<p>), the call of the Com API is called inside the </p>
<p>COM callback after reception. In this case, the context of the trace hook is the context of the COM </p>
<p>callback.  </p>
<p>Note: This could be the task context or the interrupt context! </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>114 </p>
<p>based on template version 3.5 </p>
<p><b>5.16.9 </b></p>
<p><b>Rte_[&lt;client&gt;_]ComHook&lt;Event&gt;_&lt;SignalName&gt; </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_[&lt;client&gt;_]ComHook&lt;Event&gt;_&lt;SignalName&gt; </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This VFB trace hook is called inside the &lt;Event&gt; specific COM callback, directly after the </p>
<p>invocation by COM and if the global and the hook specific configuration switches are enabled.  </p>
<p><b>Functional Description </b></p>
<p>This trace hook indicates the start of a COM callback. &lt;Event&gt; depends on the type of the </p>
<p>callback.  </p>
<p></p>
<p> empty string:  Rte_COMCbk_&lt;SignalName&gt; </p>
<p></p>
<p> TxTOut           Rte_COMCbkTxTOut_&lt;SignalName&gt; </p>
<p></p>
<p> RxTOut          Rte_COMCbkRxTOut_&lt;SignalName&gt; </p>
<p></p>
<p> TAck              Rte_COMCbkTAck_&lt;SignalName&gt; </p>
<p></p>
<p> TErr               Rte_COMCbkTErr_&lt;SignalName&gt; </p>
<p></p>
<p> Inv                 Rte_COMCbkInv_&lt;SignalName&gt; </p>
<p><b>Call Context </b></p>
<p>This function is called inside the context of the COM callback. </p>
<p>Note: This could be the task context or the interrupt context! </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>115 </p>
<p>based on template version 3.5 </p>
<p><b>5.16.10 Rte_[&lt;client&gt;_]Task_Activate </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_[&lt;client&gt;_]Task_Activate </b>( TaskType task ) </p>
<p><b>Parameter </b></p>
<p>task </p>
<p>The same parameter is also used to call the OS API </p>
<p>ActivateTask</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This VFB trace hook is called by the RTE immediately before the invocation of the OS API </p>
<p>ActivateTask</p>
<p> and if the global and the hook specific configuration switches are enabled.  </p>
<p><b>Functional Description </b></p>
<p>This trace hook indicates the call of </p>
<p>ActivateTask</p>
<p> of the OS. </p>
<p><b>Call Context </b></p>
<p>This function is called inside </p>
<p>Rte_Start</p>
<p> and in the context RTE API functions which trigger the </p>
<p>execution of a runnable entity where the runnable is mapped to a basic task. For API functions, the </p>
<p>call context is the runnable context.    </p>
<p> </p>
<p><b>5.16.11 Rte_[&lt;client&gt;_]Task_Dispatch </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_[&lt;client&gt;_]Task_Dispatch </b>( TaskType task ) </p>
<p><b>Parameter </b></p>
<p>task </p>
<p>The parameter indicates the task to which was started (dispatched) by </p>
<p>the OS </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This VFB trace hook exists for each configured RTE task and is called directly after the start if the </p>
<p>global and the hook specific configuration switches are enabled.  </p>
<p><b>Functional Description </b></p>
<p>This trace hook indicates the call activation of a task by the OS. </p>
<p><b>Call Context </b></p>
<p>The call context is the task. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>116 </p>
<p>based on template version 3.5 </p>
<p><b>5.16.12 Rte_[&lt;client&gt;_]Task_SetEvent </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_[&lt;client&gt;_]Task_SetEvent </b>( TaskType task, EventMaskType event ) </p>
<p><b>Parameter </b></p>
<p>task </p>
<p>The same parameter is also used to call the OS API </p>
<p>SetEvent</p>
<p> </p>
<p>event </p>
<p>The same parameter is also used to call the OS API </p>
<p>SetEvent</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This VFB trace hook is called by the RTE immediately before the invocation of the OS API </p>
<p>SetEvent</p>
<p> and if the global and the hook specific configuration switches are enabled.  </p>
<p><b>Functional Description </b></p>
<p>This trace hook indicates the call of </p>
<p>SetEvent</p>
<p>. </p>
<p><b>Call Context </b></p>
<p>This function is called inside RTE API functions and in COM callbacks. For API functions, the call </p>
<p>context is the runnable context.  </p>
<p>Note: For COM callbacks the context could be the task context or the interrupt context! </p>
<p> </p>
<p><b>5.16.13 Rte_[&lt;client&gt;_]Task_WaitEvent </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_[&lt;client&gt;_]Task_WaitEvent </b>( TaskType task, EventMaskType event ) </p>
<p><b>Parameter </b></p>
<p>task </p>
<p>The same parameter is also used to call the OS API </p>
<p>WaitEvent</p>
<p> </p>
<p>event </p>
<p>The same parameter is also used to call the OS API </p>
<p>WaitEvent</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This VFB trace hook is called by the RTE immediately before the invocation of the OS API </p>
<p>WaitEvent</p>
<p> and if the global and the hook specific configuration switches are enabled.  </p>
<p><b>Functional Description </b></p>
<p>This trace hook indicates the call of </p>
<p>WaitEvent</p>
<p>. </p>
<p><b>Call Context </b></p>
<p>This function is called inside RTE API functions and in generated task bodies. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>117 </p>
<p>based on template version 3.5 </p>
<p><b>5.16.14 Rte_[&lt;client&gt;_]Task_WaitEventRet </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_[&lt;client&gt;_]Task_WaitEventRet </b>( TaskType task, EventMaskType event ) </p>
<p><b>Parameter </b></p>
<p>task </p>
<p>The same parameter is also used to call the OS API </p>
<p>WaitEvent</p>
<p> </p>
<p>event </p>
<p>The same parameter is also used to call the OS API </p>
<p>WaitEvent</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This VFB trace hook is called by the RTE immediately after returning from the OS API </p>
<p>WaitEvent</p>
<p> </p>
<p>and if the global and the hook specific configuration switches are enabled.  </p>
<p><b>Functional Description </b></p>
<p>This trace hook indicates leaving the call of </p>
<p>WaitEvent</p>
<p>. </p>
<p><b>Call Context </b></p>
<p>This function is called inside RTE API functions and in generated task bodies. </p>
<p> </p>
<p><b>5.16.15 Rte_[&lt;client&gt;_]Runnable_&lt;cts&gt;_&lt;re&gt;_Start </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_[&lt;client&gt;_]Runnable_&lt;cts&gt;_&lt;re&gt;_Start </b>( [IN const Rte_CDS_&lt;cts&gt; *inst] ) </p>
<p><b>Parameter </b></p>
<p>Rte_CDS_&lt;cts&gt;* inst </p>
<p>The instance specific pointer of type Rte_CDS_&lt;cts&gt; is used to </p>
<p>distinguish between the different instances in case of multiple </p>
<p>instantiation.  </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This VFB trace hook is called for all mapped runnable entities if the global and the hook specific </p>
<p>configuration switches are enabled.  </p>
<p><b>Functional Description </b></p>
<p>This trace hook indicates invocation of the runnable entity. It is called just before the call of the </p>
<p>runnable entity and allows for example measurement of the execution time of a runnable together </p>
<p>with the counterpart </p>
<p>Rte_[&lt;client&gt;_]Runnable_&lt;cts&gt;_&lt;re&gt;_Return</p>
<p><i>. </i></p>
<p><b>Call Context </b></p>
<p>This function is called inside RTE generated task bodies. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>118 </p>
<p>based on template version 3.5 </p>
<p><b>5.16.16 Rte_[&lt;client&gt;_]Runnable_&lt;cts&gt;_&lt;re&gt;_Return </b></p>
<p><b> </b></p>
<p><b>Prototype </b></p>
<p>void <b>Rte_[&lt;client&gt;_]Runnable_&lt;cts&gt;_&lt;re&gt;_Return </b>( [IN const Rte_CDS_&lt;cts&gt; *inst] ) </p>
<p><b>Parameter </b></p>
<p>Rte_CDS_&lt;cts&gt;* inst </p>
<p>The instance specific pointer of type Rte_CDS_&lt;cts&gt; is used to </p>
<p>distinguish between the different instances in case of multiple </p>
<p>instantiation.  </p>
<p>Note: This is an optional parameter depending on the configuration of </p>
<p>supportsMultipleInstantiation</p>
<p> attribute. </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Existence </b></p>
<p>This VFB trace hook is called for all mapped runnable entities if the global and the hook specific </p>
<p>configuration switches are enabled.  </p>
<p><b>Functional Description </b></p>
<p>This trace hook indicates invocation of the runnable entity. It is called just after the call of the </p>
<p>runnable entity and allows for example measurement of the execution time of a runnable together </p>
<p>with the counterpart </p>
<p>Rte_[&lt;client&gt;_]Runnable_&lt;cts&gt;_&lt;re&gt;_Start</p>
<p><i>.  </i></p>
<p><b>Call Context </b></p>
<p>This function is called inside RTE generated task bodies. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>119 </p>
<p>based on template version 3.5 </p>
<p><b>5.17 </b></p>
<p><b>RTE Interfaces to BSW  </b></p>
<p>The RTE has standardized Interfaces to the following basic software modules  </p>
<p></p>
<p> COM / LDCOM </p>
<p></p>
<p> Transformer (COMXF, SOMEIPXF, E2EXF) </p>
<p></p>
<p> NVM </p>
<p></p>
<p> DET </p>
<p></p>
<p> OS </p>
<p></p>
<p> XCP </p>
<p></p>
<p> SCHM </p>
<p>The actual used API’s of these BSW modules depend on the configuration of the RTE. </p>
<p> </p>
<p><b>5.17.1 </b></p>
<p><b>Interface to COM / LDCOM </b></p>
<p><b>Used COM API </b></p>
<p>Com_SendSignal </p>
<p>Com_SendDynSignal </p>
<p>Com_SendSignalGroup </p>
<p>Com_SendSignalGroupArray </p>
<p>Com_UpdateShadowSignal </p>
<p>Com_ReceiveSignal </p>
<p>Com_ReceiveDynSignal </p>
<p>Com_ReceiveSignalGroup </p>
<p>Com_ReceiveSignalGroupArray </p>
<p>Com_ReceiveShadowSignal </p>
<p>Com_InvalidateSignal </p>
<p>Com_InvalidateSignalGroup </p>
<p> </p>
<p><b>Used LDCOM API </b></p>
<p>LdCom_IfTransmit (early versions of MICROSAR LDCOM) </p>
<p>LdCom_Transmit </p>
<p> </p>
<p>The RTE generator provides COM / LDCOM callback functions for signal notifications. The </p>
<p>generated callbacks, which are called inside the COM layer, have to be configured in the </p>
<p>COM  /  LDCOM  configuration  accordingly.  The  necessary  callbacks  are  defined  in  the </p>
<p>Rte_Cbk.h</p>
<p> header file.  </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>The RTE generator assumes that the context of COM / LDCOM callbacks is either a </p>
<p>task context or an interrupt context of category 2.  </p>
<p>It is explicitly NOT allowed that the call context of a COM / LDCOM callback is an </p>
<p>interrupt of category 1.   </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>120 </p>
<p>based on template version 3.5 </p>
<p>In </p>
<p>order </p>
<p>to </p>
<p>access </p>
<p>the </p>
<p>COM </p>
<p>/ </p>
<p>LDCOM </p>
<p>API </p>
<p>the </p>
<p>generated </p>
<p>RTE </p>
<p>includes </p>
<p>the </p>
<p>Com.h/LdCom.h</p>
<p> header file if necessary.   </p>
<p>During </p>
<p>export </p>
<p>of </p>
<p>the </p>
<p>ECU </p>
<p>configuration </p>
<p>description </p>
<p>the </p>
<p>necessary </p>
<p>COM </p>
<p>/ </p>
<p>LDCOM </p>
<p>callbacks </p>
<p>are </p>
<p>exported </p>
<p>into </p>
<p>the </p>
<p>COM </p>
<p>/ </p>
<p>LDCOM </p>
<p>section </p>
<p>of </p>
<p>the </p>
<p>ECU </p>
<p>configuration </p>
<p>description. </p>
<p> </p>
<p><b>5.17.2 </b></p>
<p><b>Interface to Transformer </b></p>
<p><b>Used Transformer API </b></p>
<p>ComXf_&lt;transformerId&gt; </p>
<p>ComXf_Inv_&lt;transformerId&gt; </p>
<p>SomeIpXf_&lt;transformerId&gt; </p>
<p>SomeIpXf_Inv_&lt;transformerId&gt; </p>
<p>E2EXf_&lt;transformerId&gt; </p>
<p>E2EXf_Inv_&lt;transformerId&gt; </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>The RTE generator does not support configurable transformer chains. Only the </p>
<p>SomeIpXf and the ComXf are supported as first transformer in the chain. The E2EXf as </p>
<p>second transformer is optional dependent on the configuration. </p>
<p>  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>121 </p>
<p>based on template version 3.5 </p>
<p><b>5.17.3 </b></p>
<p><b>Interface to OS </b></p>
<p>In </p>
<p>general, </p>
<p>the </p>
<p>RTE </p>
<p>may </p>
<p>use </p>
<p>all </p>
<p>available </p>
<p>OS  API </p>
<p>functions </p>
<p>to </p>
<p>provide </p>
<p>the </p>
<p>RTE </p>
<p>functionality  to  the  software  components. The following  table  contains  a  list of  used  OS </p>
<p>APIs of the current RTE implementation.    </p>
<p><b>Used OS API </b></p>
<p>SetRelAlarm </p>
<p>CancelAlarm </p>
<p>StartScheduleTableRel  </p>
<p>NextScheduleTable </p>
<p>StopScheduleTable </p>
<p>SetEvent </p>
<p>GetEvent </p>
<p>ClearEvent </p>
<p>WaitEvent </p>
<p>GetTaskID </p>
<p>GetCoreID </p>
<p>ActivateTask </p>
<p>Schedule </p>
<p>TerminateTask </p>
<p>ChainTask </p>
<p>GetResource </p>
<p>ReleaseResource </p>
<p>GetSpinlock </p>
<p>ReleaseSpinlock </p>
<p>DisableAllInterrupts </p>
<p>EnableAllInterrupts </p>
<p>SuspendAllInterrupts </p>
<p>ResumeAllInterrupts </p>
<p>SuspendOSInterrupts </p>
<p>ResumeOSInterrupts </p>
<p>CallTrustedFunction (MICROSAR OS specific) </p>
<p>IocWrite </p>
<p>IocRead </p>
<p>IocWriteGroup  </p>
<p>IocReadGroup </p>
<p>IocSend </p>
<p>IocReceive  </p>
<p> </p>
<p>In order to access the OS API the generated RTE includes the </p>
<p>Os.h</p>
<p> header file.   </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>122 </p>
<p>based on template version 3.5 </p>
<p>The OS configuration needed by the RTE is stored in the file </p>
<p>Rte_Needs.ecuc.arxml</p>
<p> </p>
<p>which is created during the RTE Generation Phase. </p>
<p>For  legacy  systems  the  OS  configuration  is  also  stored  in </p>
<p>Rte.oil</p>
<p>.  This  file  is  an </p>
<p>incomplete OIL file and contains only the RTE relevant configuration. It should be included </p>
<p>in an OIL file used for the OS configuration of the whole ECU. </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>The generated files </p>
<p>Rte_Needs.ecuc.arxml</p>
<p> and </p>
<p>Rte.oil</p>
<p> file must not be </p>
<p>changed! </p>
<p> </p>
<p><b>5.17.4 </b></p>
<p><b>Interface to NVM </b></p>
<p>The RTE generator provides NvM callback functions for synchronous copying of the mirror </p>
<p>buffers  to  and  from  the  NvM.  The  generated  callbacks,  which  are  called  inside  the </p>
<p>NvM_MainFunction</p>
<p>,  have  to  be  configured  in  the  NvM  configuration  accordingly.  The </p>
<p>necessary callbacks are defined in the </p>
<p>Rte_Cbk.h</p>
<p> header file.  </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>The RTE generator assumes that the call context of NvM callbacks is the task which </p>
<p>calls the </p>
<p>NvM_MainFunction</p>
<p>.   </p>
<p> </p>
<p>During  export  of  the  ECU  configuration  description  the  necessary  NVM  callbacks  are </p>
<p>exported into the NVM section of the ECU configuration description. </p>
<p><b>5.17.5 </b></p>
<p><b>Interface to XCP </b></p>
<p>In addition to the usage of the Com and the OS module as described by AUTOSAR, the </p>
<p>MICROSAR RTE  generator optionally  can  also  take advantage  of  the  MICROSAR  XCP </p>
<p>module. </p>
<p>This </p>
<p>makes </p>
<p>it </p>
<p>possible </p>
<p>to </p>
<p>configure </p>
<p>the </p>
<p>RTE </p>
<p>to </p>
<p>trigger </p>
<p>XCP </p>
<p>Events </p>
<p>when </p>
<p>certain </p>
<p>measurement points are reached. </p>
<p>This  for  example  also  allows  the  measurement  of  buffers  for  implicit  sender/receiver </p>
<p>communication when a runnable entity is terminated. </p>
<p>Measurement is described in detail in chapter 6.6 Measurement and Calibration. </p>
<p>When measurement with XCP Events is enabled, the RTE therefore includes the header </p>
<p>Xcp.h</p>
<p> and calls the Xcp_Event API to trigger the events. </p>
<p><b>Used Xcp API </b></p>
<p>Xcp_Event </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>123 </p>
<p>based on template version 3.5 </p>
<p><b>5.17.6 </b></p>
<p><b>Interface to SCHM </b></p>
<p>In </p>
<p>multicore </p>
<p>and </p>
<p>memory </p>
<p>protection </p>
<p>systems, </p>
<p>the </p>
<p>schedulable </p>
<p>entity </p>
<p>Rte_ComSendSignalProxyPeriodic</p>
<p> is provided by the RTE and is used to access the </p>
<p>COM  from  OS  Applications  without  BSW.  This  schedulable  entity  needs  to  be  called </p>
<p>periodically by the SCHM. </p>
<p>See chapter 4.8.1 for details.  </p>
<p><b>Provided Schedulable Entity </b></p>
<p>Rte_ComSendSignalProxyPeriodic </p>
<p> </p>
<p><b>5.17.7 </b></p>
<p><b>Interface to DET </b></p>
<p>The RTE generator reports development errors to the DET, if development error detection </p>
<p>is enabled. </p>
<p>See chapter 3.8.1 for details. </p>
<p><b>Used DET API </b></p>
<p>Det_ReportError </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>124 </p>
<p>based on template version 3.5 </p>
<p><b>6 </b></p>
<p><b>RTE Configuration </b></p>
<p>The RTE specific configuration in DaVinci Configurator encompasses the following parts: </p>
<p><b></b></p>
<p><b> </b></p>
<p>assignment of runnables to OS tasks </p>
<p><b></b></p>
<p><b> </b></p>
<p>assignment of OS tasks to OS applications (memory protection/multicore support) </p>
<p><b></b></p>
<p><b> </b></p>
<p>assignment of Per-Instance Memory to NV memory blocks </p>
<p><b></b></p>
<p><b> </b></p>
<p>selection of the exclusive area implementation method </p>
<p><b></b></p>
<p><b> </b></p>
<p>configuration of the periodic triggers </p>
<p><b></b></p>
<p><b> </b></p>
<p>configuration of measurement and calibration </p>
<p><b></b></p>
<p><b> </b></p>
<p>selection of the optimization mode  </p>
<p><b></b></p>
<p><b> </b></p>
<p>selection of required VFB tracing callback functions </p>
<p><b></b></p>
<p><b> </b></p>
<p>configuration of the built-in call to the RTE generator </p>
<p><b></b></p>
<p><b> </b></p>
<p>platform dependent resource calculation </p>
<p><b>6.1 </b></p>
<p><b>Configuration Variants </b></p>
<p>The RTE supports the configuration variants </p>
<p><b></b></p>
<p><b> </b></p>
<p>VARIANT-PRE-COMPILE </p>
<p><b></b></p>
<p><b> </b></p>
<p>VARIANT-POST-BUILD-SELECTABLE </p>
<p>The configuration classes of the RTE parameters depend on the supported configuration </p>
<p>variants. For their definitions please see the </p>
<p>Rte_bswmd.arxml</p>
<p> file. </p>
<p><b>6.2 </b></p>
<p><b>Task Configuration </b></p>
<p>Runnable  Entities  triggered  by  any  kind  of  RTE  Event  e.g. </p>
<p>TimingEvent</p>
<p>  have  to  be </p>
<p>mapped to tasks. Only server runnables (triggered by an </p>
<p>OperationInvokedEvent</p>
<p>) that </p>
<p>either  have  their </p>
<p>CanBeInvokedConcurrently</p>
<p>  flag  enabled  or  that  are  called  from </p>
<p>tasks  that  cannot  interrupt  each  other  do  not  need  to  be  mapped.  For  optimization </p>
<p>purposes they can be called directly and are then executed in the context of the calling </p>
<p>runnable (client). </p>
<p>The task configuration within DaVinci Configurator also contains some attributes which are </p>
<p>part of the OS configuration. The parameters are required to control RTE generation.  </p>
<p>The creation of tasks is done in OS Configuration Editor in the in the DaVinci Configurator. </p>
<p>The <b>Task Mapping Assistant </b>has to be used to assign the triggered functions (runnables </p>
<p>and schedulable entities) to the tasks.   </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>125 </p>
<p>based on template version 3.5 </p>
<p> </p>
<p> </p>
<p>Figure 6-1   Mapping of Runnables to Tasks </p>
<p> </p>
<p>The  MICROSAR  RTE  supports  the  generation  of  both </p>
<p>BASIC</p>
<p>  and </p>
<p>EXTENDED</p>
<p>  tasks. The </p>
<p>Task  Type  can  either  be  selected  or  the  selection  is  done  automatically  if </p>
<p>AUTO</p>
<p>  is </p>
<p>configured. </p>
<p> </p>
<p>A  basic  task  can  be  used  when  all  runnables  of  the  task  are  triggered  by  one  or  more </p>
<p>identical triggers. </p>
<p>A typical example for this might be several cyclic triggered runnables that share the same </p>
<p>activation offset and cycle time. </p>
<p>There  is  also  the  possibility  to  select  Task  Typ </p>
<p>BASIC </p>
<p>if  all  runnables  of  a  task  are </p>
<p>triggered cyclically but have different cycle times or different activation offsets. The RTE </p>
<p>realizes the basic task with the help of OS Schedule Tables. </p>
<p>Moreover another prerequisite for basic task usage is that the mapped runnables do not </p>
<p>use APIs that require a waitpoint, like a blocking </p>
<p>Rte_Feedback()</p>
<p>. </p>
<p>If the above described conditions are not fulfilled an  extended task has to be used. The </p>
<p>extended task can wait for different runnable trigger conditions e.g. data reception trigger, </p>
<p>cyclic triggers or mode switch trigger.  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>126 </p>
<p>based on template version 3.5 </p>
<p> </p>
<p><b>Caution </b></p>
<p>When RTE events that trigger a runnable are fired multiple times before the actual </p>
<p>runnable invocation happens and when the runnable is mapped to an extended task, </p>
<p>the runnable is invoked only once. </p>
<p>However, if the runnable is mapped to a basic task, the same circumstances will cause </p>
<p>multiple task activations and runnable invocations. Therefore, for basic tasks, the task </p>
<p>attribute Activation in the OS configuration has to be set to the maximum number of </p>
<p>queued task activations. If Activation is too small, additional task activations may result </p>
<p>in runtime OS errors. To avoid the runtime error the number of possible Task Activation </p>
<p>should be increased. </p>
<p> </p>
<p><b>6.3 </b></p>
<p><b>Memory Protection and Multicore Configuration </b></p>
<p>For  memory  protection </p>
<p>or  multicore </p>
<p>support  the  tasks  have </p>
<p>to  be  assigned  to  OS </p>
<p>applications.  The  following  figures  show  the  configuration  of  OS  applications  and  the </p>
<p>assignment of OS tasks. For multicore support also the Core ID has to be configured for </p>
<p>the OS application. When a runnable/trigger of a SWC is mapped to a task, the SWC is </p>
<p>automatically assigned to the same OS application as the task. In case the SWC contains </p>
<p>only  runnables  that  are  not  mapped  to  a  task,  the  SWC  can  be  assigned  to  an  ECUC </p>
<p>partition </p>
<p>with </p>
<p>the </p>
<p>parameter </p>
<p>EcuC/EcucPartitionCollection/EcucPartition/EcucPartitionSoftwareComponentInstanceRef. </p>
<p>For  every  OS  application,  an  ECUC  partition  can  be  created.  It  then  needs  to  be </p>
<p>referenced </p>
<p>by </p>
<p>the </p>
<p>OS </p>
<p>application </p>
<p>with </p>
<p>the </p>
<p>Os/OsApplication/OsAppEcucPartitionRef </p>
<p>parameter.  Besides  the  assignment  of  SWCs  to  OS  applications,  the  ECUC  partition </p>
<p>provides  a  parameter  to  configure  the  safety  level  of  the  partition  (QM  or  ASIL_A  to </p>
<p>ASIL_D). The RTE generator uses this parameter to enable additional task priority based </p>
<p>optimizations for QM partitions.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>127 </p>
<p>based on template version 3.5 </p>
<p> </p>
<p> </p>
<p>Figure 6-2   Assignment of a Task to an OS Application </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>Make sure that the operating system is configured with scalability class SC3 or SC4.  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>128 </p>
<p>based on template version 3.5 </p>
<p> </p>
<p>Figure 6-3   OS Application Configuration </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>129 </p>
<p>based on template version 3.5 </p>
<p><b>6.4 </b></p>
<p><b>NV Memory Mapping </b></p>
<p>Each instance of a Per-Instance Memory, which has configured <b>Needs memory mapping </b></p>
<p>can be mapped to an NV memory block of the NvM.  </p>
<p>The Per-Instance Memory (PIM) is used as mirror buffer for the NV memory block. During </p>
<p>startup, the EcuM calls </p>
<p>NvM_ReadAll</p>
<p>, which initializes the configured PIM with the value </p>
<p>of the assigned NV memory block. During shutdown, </p>
<p>NvM_WriteAll</p>
<p> stores the current </p>
<p>value of the PIM buffer in the corresponding NV memory block.  </p>
<p>The  RTE  configurator  provides  support  for  manual  mapping  of </p>
<p>already  existing  NV </p>
<p>memory  blocks  or  automatically  generation  of  NV  memory  blocks  and  mapping  for  all </p>
<p>PIMs. </p>
<p>The  RTE  has  no  direct  Interface  to  the  NvM  in  the  source  code.  There  exists  only  an </p>
<p>Interface on configuration level. The RTE configurator has to configure the following parts </p>
<p>of the NvM configuration. </p>
<p><b></b></p>
<p><b> </b></p>
<p>Address of PIM representing the RAM mirror of the NV memory block. </p>
<p><b></b></p>
<p><b> </b></p>
<p>Optionally the address of calibration parameter for default values. </p>
<p><b></b></p>
<p><b> </b></p>
<p>Optionally the size of the PIM in bytes if available during configuration time. </p>
<p> </p>
<p>The </p>
<p>following </p>
<p>figure </p>
<p>shows </p>
<p>the </p>
<p><b>Memory </b></p>
<p><b>Mapping </b></p>
<p>in </p>
<p>DaVinci </p>
<p>Configurator </p>
<p>where </p>
<p>assignment of Per-Instance Memory to NV memory blocks can be configured.  </p>
<p>   </p>
<p> </p>
<p>Figure 6-4   Mapping of Per-Instance Memory to NV Memory Blocks </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>130 </p>
<p>based on template version 3.5 </p>
<p><b>6.5 </b></p>
<p><b>RTE Generator Settings </b></p>
<p>The  following  figure  shows  how  the  MICROSAR  RTE  Generator  has  to  be  enabled  for </p>
<p>code generation within the DaVinci Configurator. </p>
<p>  </p>
<p>Figure 6-5   RTE Generator Settings </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>131 </p>
<p>based on template version 3.5 </p>
<p><b>6.6 </b></p>
<p><b>Measurement and Calibration </b></p>
<p>The </p>
<p>MICROSAR </p>
<p>RTE </p>
<p>generator </p>
<p>supports </p>
<p>the </p>
<p>generation </p>
<p>of </p>
<p>an </p>
<p>ASAM </p>
<p>MCD-2MC </p>
<p>compatible  description  of  the  generated  RTE  that  can  be  used  for  measurement  and </p>
<p>calibration  purposes.  When  measurement  or  calibration  is  enabled  the  RTE  generator </p>
<p>generates  a  file </p>
<p>Rte.a2l</p>
<p>  that  contains  measurement  objects  for  sender/receiver  ports, </p>
<p>per-instance </p>
<p>memories </p>
<p>and </p>
<p>inter-runnable </p>
<p>variables. </p>
<p>Calibration </p>
<p>parameters </p>
<p>are </p>
<p>represented as characteristic objects. </p>
<p> </p>
<p> </p>
<p>Figure 6-6   Measurement and Calibration Generation Parameters </p>
<p> </p>
<p>The switch A2L Version controls the ASAM MCD-2MC standard to which the </p>
<p>Rte.a2l</p>
<p> file </p>
<p>is compliant. Version 1.6.0 is recommended as it supports a symbol link attribute that can </p>
<p>be used by the measurement and calibration tools to automatically obtain the address of a </p>
<p>characteristic or measurement object in the compiled and linked RTE code. </p>
<p>What  measurements  and  characteristics  are  listed  in  the </p>
<p>Rte.a2l</p>
<p>  file  depends  on  the </p>
<p>measurement </p>
<p>and </p>
<p>calibration </p>
<p>settings </p>
<p>of </p>
<p>the </p>
<p>individual </p>
<p>port </p>
<p>interfaces, </p>
<p>per-instance </p>
<p>memories,  inter-runnable variables and calibration parameters and if the variable can be </p>
<p>measured </p>
<p>in </p>
<p>general. </p>
<p>For </p>
<p>example, </p>
<p>measurement </p>
<p>is </p>
<p>not </p>
<p>possible </p>
<p>for </p>
<p>queued </p>
<p>communication as described in the RTE specification. When “Calibration Access” is set to </p>
<p>“NotAccessible”, an object will not be listed in the </p>
<p>Rte.a2l</p>
<p> file. </p>
<p>Within  the </p>
<p>Rte.a2l</p>
<p>  file,  the  measurement  objects  are  grouped  by  SWCs.  When  inter-</p>
<p>ECU sender/receiver communication shall be measured, the groups will also contain links </p>
<p>to  measurement  objects  with  the  name  of the  COM  signal  handle. These  measurement </p>
<p>objects have to be provided by the COM. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>132 </p>
<p>based on template version 3.5 </p>
<p>Furthermore, the generated </p>
<p>Rte.a2l</p>
<p> is only a partial A2L file. It is meant to be included in </p>
<p>the MODULE block of a skeleton A2L file with the ASAM MCD-2MC /include command. </p>
<p>This makes  it  possible  to  specify  additional  measurement  objects,  for example from  the </p>
<p>COM, and IF_DATA blocks directly in the surrounding A2L file. </p>
<p> </p>
<p>In order to also allow the measurement of implicit buffers for inter-ECU communication, the </p>
<p>MICROSAR RTE generator supports measurement with the help of XCP Events. This is </p>
<p>controlled  by  the  flag  “Use  XCPEvents”.  When  XCP  Events  are  enabled,  the  RTE </p>
<p>generator  triggers  an  XCP  Event  that  measures  the  implicit  buffer  after a  runnable  with </p>
<p>implicit </p>
<p>inter-ECU </p>
<p>communication </p>
<p>is </p>
<p>terminated </p>
<p>and </p>
<p>before </p>
<p>the </p>
<p>data </p>
<p>is </p>
<p>sent. </p>
<p>“Use </p>
<p>XCPEvents” also enables the generation of one XCP Event at the end of every task that </p>
<p>can be used to trigger the measurement of other objects. </p>
<p> </p>
<p>The  RTE  generator automatically  adds  the XCP  Events  to  the  configuration  of the  XCP </p>
<p>module. The Event IDs are then automatically calculated by the XCP module. </p>
<p>The </p>
<p>definitions </p>
<p>for </p>
<p>the </p>
<p>Events </p>
<p>are </p>
<p>generated </p>
<p>by </p>
<p>the </p>
<p>XCP </p>
<p>module </p>
<p>into </p>
<p>the </p>
<p>file </p>
<p>XCP_events.a2l</p>
<p>.  This  file  can  be  included  in  the  DAQ  section  of  the  IF_DATA  XCP </p>
<p>section in the skeleton A2L file. </p>
<p> </p>
<p>The  MICROSAR  RTE  supports  three  different  online  calibration  methods,  which  can  be </p>
<p>selected globally for the whole ECU. They differ in their kind how the APIs </p>
<p>Rte_CData</p>
<p> and </p>
<p>Rte_Prm</p>
<p> access the calibration parameter. By default the online calibration is switched off. </p>
<p>The following configuration values can be selected: </p>
<p><b></b></p>
<p><b> </b></p>
<p>None                                                                                                                 </p>
<p><b></b></p>
<p><b> </b></p>
<p>Single Pointered                                                                                                                 </p>
<p><b></b></p>
<p><b> </b></p>
<p>Double Pointered                                                                                                                </p>
<p><b></b></p>
<p><b> </b></p>
<p>Initialized RAM </p>
<p> </p>
<p>In  addition  to  the  ECU  global  selection  of  the  method  the  online  calibration  have  to  be </p>
<p>activated for each component individually by setting the <b>Calibration Support </b>switch. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>133 </p>
<p>based on template version 3.5 </p>
<p>  </p>
<p>Figure 6-7   SWC Calibration Support Parameters </p>
<p> </p>
<p>For each component with activated Calibration Support memory segments are generated </p>
<p>into the file </p>
<p>Rte_MemSeg.a2l</p>
<p>. This file can be included in the MOD_PAR section in the </p>
<p>skeleton A2L  file.  This  makes  it  possible  to  specify  additional  memory  segments  in  the </p>
<p>surrounding A2L file. </p>
<p>If  the  method  Initialized  RAM  is  selected,  segments  for  the  Flash  data  section  and  the </p>
<p>RAM  data  section  of  each  calibration  parameter  are  generated. The  Flash  sections  are </p>
<p>mapped to the corresponding RAM sections. </p>
<p>If the Single Pointered or Double Pointered method is enabled, only memory segments for </p>
<p>the Flash data sections are listed in the </p>
<p>Rte_MemSeg.a2l</p>
<p>. In addition a segment for a </p>
<p>RAM </p>
<p>buffer </p>
<p>is </p>
<p>generated, </p>
<p>when </p>
<p>the </p>
<p>Single </p>
<p>Pointered </p>
<p>method </p>
<p>is </p>
<p>used </p>
<p>and </p>
<p>a </p>
<p>CalibrationBufferSize</p>
<p> is set. This parameter specifies the size of the RAM buffer in </p>
<p>byte. If it is set to 0, no RAM buffer will be created. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>134 </p>
<p>based on template version 3.5 </p>
<p> </p>
<p>Figure 6-8  </p>
<p>CalibrationBufferSize Parameter </p>
<p>The following figure shows a possible include structure of an A2L file. In addition to the </p>
<p>fragment A2L files that are generated by the RTE generator other parts (e.g. generated by </p>
<p>the BSW) can be included in the skeleton A2L file. </p>
<p> </p>
<p> </p>
<p>Figure 6-9  </p>
<p>A2L Include Structure </p>
<p> </p>
<p>For more details about the creation of a complete A2L file see [24]. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>135 </p>
<p>based on template version 3.5 </p>
<p><b>6.7 </b></p>
<p><b>Optimization Mode Configuration </b></p>
<p>A  general  requirement  to  the  RTE  generator  is  production  of  optimized  RTE  code.  If </p>
<p>possible  the  MICROSAR  RTE  Generator optimizes  in  different optimization directions at </p>
<p>the same time. Nevertheless, sometimes it isn’t possible to do that. In that case the default </p>
<p>optimization direction is “Minimum RAM Consumption”. The user can change this behavior </p>
<p>by manually selection of the optimization mode.   </p>
<p><b></b></p>
<p><b> </b></p>
<p>Minimum RAM Consumption (</p>
<p>MEMORY</p>
<p>) </p>
<p><b></b></p>
<p><b> </b></p>
<p>Minimum Execution Time (</p>
<p>RUNTIME</p>
<p>) </p>
<p> </p>
<p>The  following  figure  shows  the <b> Optimization  Mode </b> Configuration  in  DaVinci  Configurator.  </p>
<p> </p>
<p>Figure 6-10  Optimization Mode Configuration </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>136 </p>
<p>based on template version 3.5 </p>
<p><b>6.8 </b></p>
<p><b>VFB Tracing Configuration </b></p>
<p>The  VFB  Tracing  feature </p>
<p>of  the  MICROSAR  RTE  may  be  enabled  in </p>
<p>the  DaVinci </p>
<p>Configrator as shown in the following picture. </p>
<p> </p>
<p> </p>
<p>Figure 6-11   VFB Tracing Configuration </p>
<p> </p>
<p>You may open an already generated </p>
<p>Rte_Hook.h</p>
<p> header file from within this dialog. This </p>
<p>header file contains the complete list of all available trace hook functions, which can be </p>
<p>activated independently. You can select and copy the names and insert these names into </p>
<p>the trace function list of this dialog manually or you can import a complete list from a file. If </p>
<p>you want to enable all trace functions you can import the trace functions from an already </p>
<p>generated </p>
<p>Rte_Hook.h.</p>
<p> The VFB Trace Client Prefix defines an additional prefix for all </p>
<p>VFB trace functions to be generated. With this approach it is for example possible to </p>
<p>enable additionally trace functions for debugging (Dbg) and diagnostic log and trace (Dlt) </p>
<p>at the same time. </p>
<p> </p>
<p> </p>
<p><b>Info</b> </p>
<p>All enabled trace functions have to be provided by the user. Section 4.3.4 describes </p>
<p>how a template for VFB trace hooks can be generated initially or updated after </p>
<p>configuration changes. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>137 </p>
<p>based on template version 3.5 </p>
<p><b>6.9 </b></p>
<p><b>Exclusive Area Implementation </b></p>
<p>The implementation method for exclusive areas can be set in the DaVinci Configurator as </p>
<p>shown in the following picture. </p>
<p> </p>
<p> </p>
<p>Figure 6-12  Exclusive Area Implementation Configuration </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>138 </p>
<p>based on template version 3.5 </p>
<p><b>6.10 </b></p>
<p><b>Periodic Trigger Implementation </b></p>
<p>The  runnable  activation  offset  and  the  trigger implementation for  cyclic  runnable  entities </p>
<p>may be set in the ECU project editor as shown in the following picture. </p>
<p> </p>
<p> </p>
<p>Figure 6-13  Periodic Trigger Implementation Configuration </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>Currently it is not supported to define an activation offset and a trigger implementation </p>
<p>per trigger. The settings can only be made for the complete runnable with potential </p>
<p>several cyclic triggers.  </p>
<p> </p>
<p>The activation offset specifies at what time relative to the start of the RTE the runnable / </p>
<p>main function is triggered for the first time. </p>
<p>Trigger implementation can either be set to </p>
<p>Auto</p>
<p> or </p>
<p>None</p>
<p>. When it is set to the default </p>
<p>setting </p>
<p>Auto</p>
<p>, the RTE generator will automatically generate and set OS alarms that will </p>
<p>then trigger the runnables / main functions. When trigger implementation is set to </p>
<p>None</p>
<p>, </p>
<p>the RTE generator only creates the tasks and events for triggering the runnables / main </p>
<p>functions. It is then the responsibility of the user to periodically activate the basic task to </p>
<p>which a runnable / main function is mapped or to send an event when the runnable / main </p>
<p>function is mapped to an extended task.  </p>
<p>This feature  can  also  be  used  to  trigger  cyclic  runnable  entities  /  main  functions  with  a </p>
<p>schedule table. This allows the synchronization with FlexRay. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>139 </p>
<p>based on template version 3.5 </p>
<p>To ease the creation of such a schedule table, the generated report </p>
<p>Rte.html</p>
<p> contains a </p>
<p>trigger listing. The listing contains the triggered runnables / main functions, their tasks and </p>
<p>the used events and alarms. </p>
<p> </p>
<p>Figure 6-14  HTML Report </p>
<p> </p>
<p>If the OS alarm column for a trigger is empty, the runnable / main function needs to be </p>
<p>triggered  manually.  In  the  example  above,  this  is  the  case  for  all  runnables  except  for </p>
<p>RunnableCyclic. </p>
<p>The row for Runnable2 does not contain an event because this runnable is mapped to a </p>
<p>basic task. </p>
<p>To  manually  implement  the  cyclic  triggers,  one  could  for  example  create  a  repeating </p>
<p>schedule table in the OS configuration with duration 10 that uses a counter with a tick time </p>
<p>of  one  millisecond.  An  expiry  point  at  offset  0  would  then  need  to  contain </p>
<p>SETEVENT</p>
<p> </p>
<p>actions  for  the  runnables  Runnable1  and  Runnable3  and  an </p>
<p>ACTIVATETASK</p>
<p>  action  for </p>
<p>Runnable2. </p>
<p>Moreover further expiry points with the offsets 2, 4, 6, 8 are needed to activate Runnable1 </p>
<p>and Runnable2 and another expiry point with offset 5 is needed to activate Runnable3. </p>
<p> </p>
<p> </p>
<p><b>Caution </b></p>
<p>When the trigger implementation is set to none, the settings for the cycle time and the </p>
<p>activation offset are no longer taken into account by the RTE. It is then the </p>
<p>responsibility of the user to periodically trigger the runnables / main functions at the </p>
<p>configured times. Moreover the user also has to make sure that this triggering does not </p>
<p>happen before the RTE is completely started. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>140 </p>
<p>based on template version 3.5 </p>
<p><b>6.11 </b></p>
<p><b>Resource Calculation </b></p>
<p>The RTE generator generates the file Rte.html containing the RAM and CONST usage of </p>
<p>the generated RTE. The RTE generator makes the following assumptions. </p>
<p><b></b></p>
<p><b> </b></p>
<p>Size of a pointer: 2 bytes. The default value of the RTE generator can be changed with </p>
<p>the parameter </p>
<p>Size Of RAM Pointer</p>
<p> in the EcuC module. </p>
<p><b></b></p>
<p><b> </b></p>
<p>Size of the OS dependent data type </p>
<p>TaskType</p>
<p>: 1 byte </p>
<p><b></b></p>
<p><b> </b></p>
<p>Size of the OS dependent data type </p>
<p>EventMaskType</p>
<p>: 1 byte </p>
<p><b></b></p>
<p><b> </b></p>
<p>Padding bytes in structures and arrays are considered according to the configured </p>
<p>parameters </p>
<p>Struct Alignment</p>
<p> and </p>
<p>Struct In Array Alignment</p>
<p> in the EcuC </p>
<p>module for NvM blocks. </p>
<p><b></b></p>
<p><b> </b></p>
<p>Size of a </p>
<p>boolean</p>
<p> data type: 1 byte (defined in </p>
<p>PlatformTypes.h</p>
<p>)  </p>
<p> </p>
<p>The </p>
<p>pointer </p>
<p>size </p>
<p>and </p>
<p>the </p>
<p>alignment </p>
<p>parameters </p>
<p>can </p>
<p>be </p>
<p>found </p>
<p>in </p>
<p>the </p>
<p>container </p>
<p>EcuC/EcucGeneral in the Basic Editor of DaVinci Configurator. </p>
<p> </p>
<p>Figure 6-15  Configuration of platform settings </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>141 </p>
<p>based on template version 3.5 </p>
<p><b>7 </b></p>
<p><b>Glossary and Abbreviations </b></p>
<p><b>7.1 </b></p>
<p><b>Glossary </b></p>
<p><b>Term </b></p>
<p><b>Description </b></p>
<p>DaVinci DEV </p>
<p>DaVinci Developer: The SWC Configuration Editor. </p>
<p>DaVinci CFG </p>
<p>DaVinci Configurator: The BSW and RTE Configuration Editor. </p>
<p>Table 7-1  </p>
<p>Glossary </p>
<p>The AUTOSAR Glossary [14] also describes a lot of important terms, which are used in </p>
<p>this document. </p>
<p><b>7.2 </b></p>
<p><b>Abbreviations </b></p>
<p><b>Abbreviation </b></p>
<p><b>Description </b></p>
<p>API </p>
<p>Application Programming Interface </p>
<p> </p>
<p>AUTOSAR </p>
<p>Automotive Open System Architecture </p>
<p>BSW </p>
<p>Basis Software </p>
<p>Com </p>
<p>Communication Layer </p>
<p>ComXf </p>
<p>Com based Transformer </p>
<p>C/S </p>
<p>Client-Server </p>
<p>E2E </p>
<p>End-to-End Communication Protection </p>
<p>E2EXf </p>
<p>End-to-End Transformer </p>
<p>EA </p>
<p>Exclusive Area </p>
<p>ECU </p>
<p>Electronic Control Unit </p>
<p>EcuM </p>
<p>ECU State Manager </p>
<p>FOSS </p>
<p>Free and Open Source Software </p>
<p>HIS </p>
<p>Hersteller Initiative Software </p>
<p>IOC </p>
<p>Inter OS-Application Communicator </p>
<p>ISR </p>
<p>Interrupt Service Routine </p>
<p>MICROSAR </p>
<p>Microcontroller Open System Architecture (Vector’s  AUTOSAR solution) </p>
<p>NvM </p>
<p>Non-volatile Memory Manager </p>
<p>PIM </p>
<p>Per-Instance Memory </p>
<p>OIL </p>
<p>OSEK Implementation Language </p>
<p>OSEK </p>
<p>Open Systems and their corresponding Interfaces for Electronics in </p>
<p>Automotive  </p>
<p>RE </p>
<p>Runnable Entity </p>
<p>SE </p>
<p>Schedulable Entity </p>
<p>RTE </p>
<p>Runtime Environment </p>
<p>SchM </p>
<p>Schedule Manager </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>142 </p>
<p>based on template version 3.5 </p>
<p>SOME/IP </p>
<p>Scalable service-oriented middleware over IP </p>
<p>SomeIpXf </p>
<p>SOME/IP Transformer </p>
<p>S/R </p>
<p>Sender-Receiver </p>
<p>SWC </p>
<p>Software Component </p>
<p>SWS </p>
<p>Software Specification </p>
<p>VFB </p>
<p>Virtual Functional Bus </p>
<p>Table 7-2  </p>
<p>Abbreviations </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>143 </p>
<p>based on template version 3.5 </p>
<p><b>8 </b></p>
<p><b>Additional Copyrights </b></p>
<p>The MICROSAR RTE Generator contains <i>Free and Open Source Software </i>(FOSS). The </p>
<p>following table lists the files which contain this software, the kind and version of the FOSS, </p>
<p>the license under which this FOSS is distributed and a reference to a license file which </p>
<p>contains the original text of the license terms and conditions. The referenced license files </p>
<p>can be found in the directory of the RTE Generator. </p>
<p> </p>
<p><b>File </b></p>
<p><b>FOSS </b></p>
<p><b>License </b></p>
<p><b>License Reference </b></p>
<p>MicrosarRteGen.exe </p>
<p>Perl 5.20.2 </p>
<p>Artistic License </p>
<p>License_Artistic.txt </p>
<p> </p>
<p>Newtonsoft.Json.dll </p>
<p>Json.NET 6.0.4 </p>
<p>MIT License </p>
<p>License_JamesNewton-King.txt </p>
<p>Rte.jar </p>
<p>flexjson 2.1 </p>
<p>Apache License V2.0 </p>
<p>License_Apache-2.0.txt </p>
<p>Table 8-1  </p>
<p>Free and Open Source Software Licenses </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR RTE </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 4.12.0 </p>
<p>144 </p>
<p>based on template version 3.5 </p>
<p><b>9 </b></p>
<p><b>Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>News </p>
<p><b></b></p>
<p><b> </b></p>
<p>Products </p>
<p><b></b></p>
<p><b> </b></p>
<p>Demo software </p>
<p><b></b></p>
<p><b> </b></p>
<p>Support </p>
<p><b></b></p>
<p><b> </b></p>
<p>Training data </p>
<p><b></b></p>
<p><b> </b></p>
<p>Addresses </p>
<p> </p>
<p><b>www.vector.com </b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
</body>
</html>
{% endraw %}